{
    "settings": [
        {
            "con": {
                "smart": "newPersistentVolumeSourceAzureDisk",
                "name": "PersistentVolumeSourceAzureDisk'"
            },
            "arguments": [
                {
                    "default": "_cachingMode",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Host Caching mode: None, Read Only, Read Write."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"caching_mode\" <$> TF.attribute",
                    "name": "_cachingMode",
                    "method": "cachingMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCachingMode",
                    "validate": false,
                    "optional": false,
                    "original": "caching_mode"
                },
                {
                    "default": "_dataDiskUri",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The URI the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data_disk_uri\" <$> TF.attribute",
                    "name": "_dataDiskUri",
                    "method": "dataDiskUri",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDataDiskUri",
                    "validate": false,
                    "optional": false,
                    "original": "data_disk_uri"
                },
                {
                    "default": "_diskName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Name of the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disk_name\" <$> TF.attribute",
                    "name": "_diskName",
                    "method": "diskName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDiskName",
                    "validate": false,
                    "optional": false,
                    "original": "disk_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "name": "PersistentVolumeSourceAzureDisk",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_cachingMode",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Host Caching mode: None, Read Only, Read Write."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"caching_mode\" <$> TF.attribute",
                    "name": "_cachingMode",
                    "method": "cachingMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCachingMode",
                    "validate": false,
                    "optional": false,
                    "original": "caching_mode"
                },
                {
                    "default": "_dataDiskUri",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The URI the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data_disk_uri\" <$> TF.attribute",
                    "name": "_dataDiskUri",
                    "method": "dataDiskUri",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDataDiskUri",
                    "validate": false,
                    "optional": false,
                    "original": "data_disk_uri"
                },
                {
                    "default": "_diskName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Name of the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disk_name\" <$> TF.attribute",
                    "name": "_diskName",
                    "method": "diskName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDiskName",
                    "validate": false,
                    "optional": false,
                    "original": "disk_name"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSourceAzureDisk s",
            "original": "persistent_volume_source_azure_disk"
        },
        {
            "con": {
                "smart": "newVolumeAzureDisk",
                "name": "VolumeAzureDisk'"
            },
            "arguments": [
                {
                    "default": "_cachingMode",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Host Caching mode: None, Read Only, Read Write."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"caching_mode\" <$> TF.attribute",
                    "name": "_cachingMode",
                    "method": "cachingMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCachingMode",
                    "validate": false,
                    "optional": false,
                    "original": "caching_mode"
                },
                {
                    "default": "_dataDiskUri",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The URI the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data_disk_uri\" <$> TF.attribute",
                    "name": "_dataDiskUri",
                    "method": "dataDiskUri",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDataDiskUri",
                    "validate": false,
                    "optional": false,
                    "original": "data_disk_uri"
                },
                {
                    "default": "_diskName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Name of the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disk_name\" <$> TF.attribute",
                    "name": "_diskName",
                    "method": "diskName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDiskName",
                    "validate": false,
                    "optional": false,
                    "original": "disk_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "name": "VolumeAzureDisk",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_cachingMode",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Host Caching mode: None, Read Only, Read Write."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"caching_mode\" <$> TF.attribute",
                    "name": "_cachingMode",
                    "method": "cachingMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCachingMode",
                    "validate": false,
                    "optional": false,
                    "original": "caching_mode"
                },
                {
                    "default": "_dataDiskUri",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The URI the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data_disk_uri\" <$> TF.attribute",
                    "name": "_dataDiskUri",
                    "method": "dataDiskUri",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDataDiskUri",
                    "validate": false,
                    "optional": false,
                    "original": "data_disk_uri"
                },
                {
                    "default": "_diskName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Name of the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disk_name\" <$> TF.attribute",
                    "name": "_diskName",
                    "method": "diskName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDiskName",
                    "validate": false,
                    "optional": false,
                    "original": "disk_name"
                }
            ],
            "conflicts": [],
            "type": "VolumeAzureDisk s",
            "original": "volume_azure_disk"
        },
        {
            "con": {
                "smart": "newLivenessProbeExec",
                "name": "LivenessProbeExec'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Command is the command line to execute inside the container, the working",
                        "directory for the command is root ('/') in the container's filesystem. The",
                        "command is simply exec'd, it is not run inside a shell, so traditional shell",
                        "instructions. To use a shell, you need to explicitly call out to that shell.",
                        "Exit status of 0 is treated as live/healthy and non-zero is unhealthy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                }
            ],
            "name": "LivenessProbeExec",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "LivenessProbeExec s",
            "original": "liveness_probe_exec"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSourceGlusterfs",
                "name": "PersistentVolumeSourceGlusterfs'"
            },
            "arguments": [
                {
                    "default": "_endpointsName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The endpoint name that details Glusterfs topology. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"endpoints_name\" <$> TF.attribute",
                    "name": "_endpointsName",
                    "method": "endpointsName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasEndpointsName",
                    "validate": false,
                    "optional": false,
                    "original": "endpoints_name"
                },
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Glusterfs volume path. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the Glusterfs volume to be mounted with read-only",
                        "permissions. Defaults to false. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "name": "PersistentVolumeSourceGlusterfs",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_endpointsName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The endpoint name that details Glusterfs topology. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"endpoints_name\" <$> TF.attribute",
                    "name": "_endpointsName",
                    "method": "endpointsName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasEndpointsName",
                    "validate": false,
                    "optional": false,
                    "original": "endpoints_name"
                },
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Glusterfs volume path. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSourceGlusterfs s",
            "original": "persistent_volume_source_glusterfs"
        },
        {
            "con": {
                "smart": "newPreStopExec",
                "name": "PreStopExec'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Command is the command line to execute inside the container, the working",
                        "directory for the command is root ('/') in the container's filesystem. The",
                        "command is simply exec'd, it is not run inside a shell, so traditional shell",
                        "instructions. To use a shell, you need to explicitly call out to that shell.",
                        "Exit status of 0 is treated as live/healthy and non-zero is unhealthy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                }
            ],
            "name": "PreStopExec",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PreStopExec s",
            "original": "pre_stop_exec"
        },
        {
            "con": {
                "smart": "newVolumeNfs",
                "name": "VolumeNfs'"
            },
            "arguments": [
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that is exported by the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the NFS export to be mounted with read-only permissions.",
                        "Defaults to false. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_server",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Server is the hostname or IP address of the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"server\" <$> TF.attribute",
                    "name": "_server",
                    "method": "server",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasServer",
                    "validate": false,
                    "optional": false,
                    "original": "server"
                }
            ],
            "name": "VolumeNfs",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that is exported by the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "_server",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Server is the hostname or IP address of the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"server\" <$> TF.attribute",
                    "name": "_server",
                    "method": "server",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasServer",
                    "validate": false,
                    "optional": false,
                    "original": "server"
                }
            ],
            "conflicts": [],
            "type": "VolumeNfs s",
            "original": "volume_nfs"
        },
        {
            "con": {
                "smart": "newValueFromResourceFieldRef",
                "name": "ValueFromResourceFieldRef'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_name\" <$> TF.attribute",
                    "name": "_containerName",
                    "method": "containerName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasContainerName",
                    "validate": false,
                    "optional": true,
                    "original": "container_name"
                },
                {
                    "default": "_resource",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Resource to select"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource\" <$> TF.attribute",
                    "name": "_resource",
                    "method": "resource",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResource",
                    "validate": false,
                    "optional": false,
                    "original": "resource"
                }
            ],
            "name": "ValueFromResourceFieldRef",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_resource",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Resource to select"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource\" <$> TF.attribute",
                    "name": "_resource",
                    "method": "resource",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResource",
                    "validate": false,
                    "optional": false,
                    "original": "resource"
                }
            ],
            "conflicts": [],
            "type": "ValueFromResourceFieldRef s",
            "original": "value_from_resource_field_ref"
        },
        {
            "con": {
                "smart": "newVolumeGlusterfs",
                "name": "VolumeGlusterfs'"
            },
            "arguments": [
                {
                    "default": "_endpointsName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The endpoint name that details Glusterfs topology. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"endpoints_name\" <$> TF.attribute",
                    "name": "_endpointsName",
                    "method": "endpointsName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasEndpointsName",
                    "validate": false,
                    "optional": false,
                    "original": "endpoints_name"
                },
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Glusterfs volume path. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the Glusterfs volume to be mounted with read-only",
                        "permissions. Defaults to false. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "name": "VolumeGlusterfs",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_endpointsName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The endpoint name that details Glusterfs topology. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"endpoints_name\" <$> TF.attribute",
                    "name": "_endpointsName",
                    "method": "endpointsName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasEndpointsName",
                    "validate": false,
                    "optional": false,
                    "original": "endpoints_name"
                },
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Glusterfs volume path. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                }
            ],
            "conflicts": [],
            "type": "VolumeGlusterfs s",
            "original": "volume_glusterfs"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSourceNfs",
                "name": "PersistentVolumeSourceNfs'"
            },
            "arguments": [
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that is exported by the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the NFS export to be mounted with read-only permissions.",
                        "Defaults to false. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_server",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Server is the hostname or IP address of the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"server\" <$> TF.attribute",
                    "name": "_server",
                    "method": "server",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasServer",
                    "validate": false,
                    "optional": false,
                    "original": "server"
                }
            ],
            "name": "PersistentVolumeSourceNfs",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that is exported by the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "_server",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Server is the hostname or IP address of the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"server\" <$> TF.attribute",
                    "name": "_server",
                    "method": "server",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasServer",
                    "validate": false,
                    "optional": false,
                    "original": "server"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSourceNfs s",
            "original": "persistent_volume_source_nfs"
        },
        {
            "con": {
                "smart": "newTemplateVolume",
                "name": "TemplateVolume'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an AWS Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"aws_elastic_block_store\" <$> TF.attribute",
                    "name": "_awsElasticBlockStore",
                    "method": "awsElasticBlockStore",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeAwsElasticBlockStore s)",
                    "class": "HasAwsElasticBlockStore",
                    "validate": true,
                    "optional": true,
                    "original": "aws_elastic_block_store"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure Data Disk mount on the host and bind mount to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_disk\" <$> TF.attribute",
                    "name": "_azureDisk",
                    "method": "azureDisk",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeAzureDisk s)",
                    "class": "HasAzureDisk",
                    "validate": true,
                    "optional": true,
                    "original": "azure_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure File Service mount on the host and bind mount to the",
                        "pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_file\" <$> TF.attribute",
                    "name": "_azureFile",
                    "method": "azureFile",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeAzureFile s)",
                    "class": "HasAzureFile",
                    "validate": true,
                    "optional": true,
                    "original": "azure_file"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Ceph FS mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_fs\" <$> TF.attribute",
                    "name": "_cephFs",
                    "method": "cephFs",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeCephFs s)",
                    "class": "HasCephFs",
                    "validate": true,
                    "optional": true,
                    "original": "ceph_fs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a cinder volume attached and mounted on kubelets host machine.",
                        "More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cinder\" <$> TF.attribute",
                    "name": "_cinder",
                    "method": "cinder",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeCinder s)",
                    "class": "HasCinder",
                    "validate": true,
                    "optional": true,
                    "original": "cinder"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ConfigMap represents a configMap that should populate this volume"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"config_map\" <$> TF.attribute",
                    "name": "_configMap",
                    "method": "configMap",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeConfigMap s)",
                    "class": "HasConfigMap",
                    "validate": true,
                    "optional": true,
                    "original": "config_map"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "DownwardAPI represents downward API about the pod that should populate this",
                        "volume"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"downward_api\" <$> TF.attribute",
                    "name": "_downwardApi",
                    "method": "downwardApi",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeDownwardApi s)",
                    "class": "HasDownwardApi",
                    "validate": true,
                    "optional": true,
                    "original": "downward_api"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "EmptyDir represents a temporary directory that shares a pod's lifetime. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#emptydir"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"empty_dir\" <$> TF.attribute",
                    "name": "_emptyDir",
                    "method": "emptyDir",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeEmptyDir s)",
                    "class": "HasEmptyDir",
                    "validate": true,
                    "optional": true,
                    "original": "empty_dir"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Fibre Channel resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fc\" <$> TF.attribute",
                    "name": "_fc",
                    "method": "fc",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeFc s)",
                    "class": "HasFc",
                    "validate": true,
                    "optional": true,
                    "original": "fc"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a generic volume resource that is provisioned/attached using an",
                        "exec based plugin. This is an alpha feature and may change in future."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flex_volume\" <$> TF.attribute",
                    "name": "_flexVolume",
                    "method": "flexVolume",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeFlexVolume s)",
                    "class": "HasFlexVolume",
                    "validate": true,
                    "optional": true,
                    "original": "flex_volume"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Flocker volume attached to a kubelet's host machine and exposed",
                        "to the pod for its usage. This depends on the Flocker control service being",
                        "running"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flocker\" <$> TF.attribute",
                    "name": "_flocker",
                    "method": "flocker",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeFlocker s)",
                    "class": "HasFlocker",
                    "validate": true,
                    "optional": true,
                    "original": "flocker"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a GCE Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"gce_persistent_disk\" <$> TF.attribute",
                    "name": "_gcePersistentDisk",
                    "method": "gcePersistentDisk",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeGcePersistentDisk s)",
                    "class": "HasGcePersistentDisk",
                    "validate": true,
                    "optional": true,
                    "original": "gce_persistent_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "GitRepo represents a git repository at a particular revision."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"git_repo\" <$> TF.attribute",
                    "name": "_gitRepo",
                    "method": "gitRepo",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeGitRepo s)",
                    "class": "HasGitRepo",
                    "validate": true,
                    "optional": true,
                    "original": "git_repo"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Glusterfs volume that is attached to a host and exposed to the",
                        "pod. Provisioned by an admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"glusterfs\" <$> TF.attribute",
                    "name": "_glusterfs",
                    "method": "glusterfs",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeGlusterfs s)",
                    "class": "HasGlusterfs",
                    "validate": true,
                    "optional": true,
                    "original": "glusterfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a directory on the host. Provisioned by a developer or tester.",
                        "This is useful for single-node development and testing only! On-host storage",
                        "is not supported in any way and WILL NOT WORK in a multi-node cluster. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#hostpath"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_path\" <$> TF.attribute",
                    "name": "_hostPath",
                    "method": "hostPath",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeHostPath s)",
                    "class": "HasHostPath",
                    "validate": true,
                    "optional": true,
                    "original": "host_path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an ISCSI Disk resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod. Provisioned by an admin."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi\" <$> TF.attribute",
                    "name": "_iscsi",
                    "method": "iscsi",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeIscsi s)",
                    "class": "HasIscsi",
                    "validate": true,
                    "optional": true,
                    "original": "iscsi"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Volume's name. Must be a DNS_LABEL and unique within the pod. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an NFS mount on the host. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"nfs\" <$> TF.attribute",
                    "name": "_nfs",
                    "method": "nfs",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeNfs s)",
                    "class": "HasNfs",
                    "validate": true,
                    "optional": true,
                    "original": "nfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The specification of a persistent volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"persistent_volume_claim\" <$> TF.attribute",
                    "name": "_persistentVolumeClaim",
                    "method": "persistentVolumeClaim",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumePersistentVolumeClaim s)",
                    "class": "HasPersistentVolumeClaim",
                    "validate": true,
                    "optional": true,
                    "original": "persistent_volume_claim"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a PhotonController persistent disk attached and mounted on",
                        "kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"photon_persistent_disk\" <$> TF.attribute",
                    "name": "_photonPersistentDisk",
                    "method": "photonPersistentDisk",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumePhotonPersistentDisk s)",
                    "class": "HasPhotonPersistentDisk",
                    "validate": true,
                    "optional": true,
                    "original": "photon_persistent_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Quobyte represents a Quobyte mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"quobyte\" <$> TF.attribute",
                    "name": "_quobyte",
                    "method": "quobyte",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeQuobyte s)",
                    "class": "HasQuobyte",
                    "validate": true,
                    "optional": true,
                    "original": "quobyte"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Rados Block Device mount on the host that shares a pod's",
                        "lifetime. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd\" <$> TF.attribute",
                    "name": "_rbd",
                    "method": "rbd",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeRbd s)",
                    "class": "HasRbd",
                    "validate": true,
                    "optional": true,
                    "original": "rbd"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Secret represents a secret that should populate this volume. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#secrets"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret\" <$> TF.attribute",
                    "name": "_secret",
                    "method": "secret",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeSecret s)",
                    "class": "HasSecret",
                    "validate": true,
                    "optional": true,
                    "original": "secret"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a vSphere volume attached and mounted on kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vsphere_volume\" <$> TF.attribute",
                    "name": "_vsphereVolume",
                    "method": "vsphereVolume",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeVsphereVolume s)",
                    "class": "HasVsphereVolume",
                    "validate": true,
                    "optional": true,
                    "original": "vsphere_volume"
                }
            ],
            "name": "TemplateVolume",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "TemplateVolume s",
            "original": "template_volume"
        },
        {
            "con": {
                "smart": "newSpecLimit",
                "name": "SpecLimit'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Default resource requirement limit value by resource name if resource limit",
                        "is omitted."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default\" <$> TF.attribute",
                    "name": "_default'",
                    "method": "default'",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasDefault'",
                    "validate": false,
                    "optional": true,
                    "original": "default"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Max usage constraints on this kind by resource name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"max\" <$> TF.attribute",
                    "name": "_max",
                    "method": "max",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasMax",
                    "validate": false,
                    "optional": true,
                    "original": "max"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The named resource must have a request and limit that are both non-zero",
                        "where limit divided by request is less than or equal to the enumerated",
                        "value; this represents the max burst for the named resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"max_limit_request_ratio\" <$> TF.attribute",
                    "name": "_maxLimitRequestRatio",
                    "method": "maxLimitRequestRatio",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasMaxLimitRequestRatio",
                    "validate": false,
                    "optional": true,
                    "original": "max_limit_request_ratio"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Min usage constraints on this kind by resource name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"min\" <$> TF.attribute",
                    "name": "_min",
                    "method": "min",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasMin",
                    "validate": false,
                    "optional": true,
                    "original": "min"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Type of resource that this limit applies to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": true,
                    "original": "type"
                }
            ],
            "name": "SpecLimit",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The default resource requirement request value by resource name if resource",
                        "request is omitted."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_request\" <$> TF.attribute",
                    "name": "_computedDefaultRequest",
                    "method": "computedDefaultRequest",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasComputedDefaultRequest",
                    "validate": false,
                    "optional": true,
                    "original": "default_request"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "SpecLimit s",
            "original": "spec_limit"
        },
        {
            "con": {
                "smart": "newSecretItems",
                "name": "SecretItems'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key to project."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on this file, must be a value between 0 and 0777.",
                        "If not specified, the volume defaultMode will be used. This might be in",
                        "conflict with other options that affect the file mode, like fsGroup, and the",
                        "result can be other mode bits set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mode\" <$> TF.attribute",
                    "name": "_mode",
                    "method": "mode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasMode",
                    "validate": false,
                    "optional": true,
                    "original": "mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The relative path of the file to map the key to. May not be an absolute",
                        "path. May not contain the path element '..'. May not start with the string",
                        "'..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                }
            ],
            "name": "SecretItems",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "SecretItems s",
            "original": "secret_items"
        },
        {
            "con": {
                "smart": "newFlexVolumeSecretRef",
                "name": "FlexVolumeSecretRef'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "name": "FlexVolumeSecretRef",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "FlexVolumeSecretRef s",
            "original": "flex_volume_secret_ref"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSourceAzureFile",
                "name": "PersistentVolumeSourceAzureFile'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_secretName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of secret that contains Azure Storage Account Name and Key"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_name\" <$> TF.attribute",
                    "name": "_secretName",
                    "method": "secretName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretName",
                    "validate": false,
                    "optional": false,
                    "original": "secret_name"
                },
                {
                    "default": "_shareName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Share Name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"share_name\" <$> TF.attribute",
                    "name": "_shareName",
                    "method": "shareName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasShareName",
                    "validate": false,
                    "optional": false,
                    "original": "share_name"
                }
            ],
            "name": "PersistentVolumeSourceAzureFile",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_secretName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of secret that contains Azure Storage Account Name and Key"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_name\" <$> TF.attribute",
                    "name": "_secretName",
                    "method": "secretName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretName",
                    "validate": false,
                    "optional": false,
                    "original": "secret_name"
                },
                {
                    "default": "_shareName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Share Name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"share_name\" <$> TF.attribute",
                    "name": "_shareName",
                    "method": "shareName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasShareName",
                    "validate": false,
                    "optional": false,
                    "original": "share_name"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSourceAzureFile s",
            "original": "persistent_volume_source_azure_file"
        },
        {
            "con": {
                "smart": "newVolumeAzureFile",
                "name": "VolumeAzureFile'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_secretName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of secret that contains Azure Storage Account Name and Key"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_name\" <$> TF.attribute",
                    "name": "_secretName",
                    "method": "secretName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretName",
                    "validate": false,
                    "optional": false,
                    "original": "secret_name"
                },
                {
                    "default": "_shareName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Share Name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"share_name\" <$> TF.attribute",
                    "name": "_shareName",
                    "method": "shareName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasShareName",
                    "validate": false,
                    "optional": false,
                    "original": "share_name"
                }
            ],
            "name": "VolumeAzureFile",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_secretName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of secret that contains Azure Storage Account Name and Key"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_name\" <$> TF.attribute",
                    "name": "_secretName",
                    "method": "secretName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretName",
                    "validate": false,
                    "optional": false,
                    "original": "secret_name"
                },
                {
                    "default": "_shareName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Share Name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"share_name\" <$> TF.attribute",
                    "name": "_shareName",
                    "method": "shareName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasShareName",
                    "validate": false,
                    "optional": false,
                    "original": "share_name"
                }
            ],
            "conflicts": [],
            "type": "VolumeAzureFile s",
            "original": "volume_azure_file"
        },
        {
            "con": {
                "smart": "newStorageClassMetadata",
                "name": "StorageClassMetadata'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the storage class that may be used",
                        "to store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the storage class. May match selectors of replication",
                        "controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the storage class that may be used",
                        "to store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the storage class. May match selectors of replication",
                        "controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                }
            ],
            "name": "StorageClassMetadata",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the storage class, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "conflicts": [
                        "_generateName"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this storage class",
                        "that can be used by clients to determine when storage class has changed.",
                        "Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this storage class."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this storage class. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the storage class, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this storage class",
                        "that can be used by clients to determine when storage class has changed.",
                        "Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this storage class."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this storage class. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "StorageClassMetadata s",
            "original": "storage_class_metadata"
        },
        {
            "con": {
                "smart": "newContainerVolumeMount",
                "name": "ContainerVolumeMount'"
            },
            "arguments": [
                {
                    "default": "_mountPath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path within the container at which the volume should be mounted. Must not",
                        "contain ':'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mount_path\" <$> TF.attribute",
                    "name": "_mountPath",
                    "method": "mountPath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMountPath",
                    "validate": false,
                    "optional": false,
                    "original": "mount_path"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "This must match the Name of a Volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Mounted read-only if true, read-write otherwise (false or unspecified).",
                        "Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path within the volume from which the container's volume should be mounted.",
                        "Defaults to \"\" (volume's root)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sub_path\" <$> TF.attribute",
                    "name": "_subPath",
                    "method": "subPath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSubPath",
                    "validate": false,
                    "optional": true,
                    "original": "sub_path"
                }
            ],
            "name": "ContainerVolumeMount",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_mountPath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path within the container at which the volume should be mounted. Must not",
                        "contain ':'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mount_path\" <$> TF.attribute",
                    "name": "_mountPath",
                    "method": "mountPath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMountPath",
                    "validate": false,
                    "optional": false,
                    "original": "mount_path"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "This must match the Name of a Volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "ContainerVolumeMount s",
            "original": "container_volume_mount"
        },
        {
            "con": {
                "smart": "newVolumeEmptyDir",
                "name": "VolumeEmptyDir'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "What type of storage medium should back this directory. The default is \"\"",
                        "which means to use the node's default medium. Must be an empty string",
                        "(default) or Memory. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#emptydir"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"medium\" <$> TF.attribute",
                    "name": "_medium",
                    "method": "medium",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMedium",
                    "validate": false,
                    "optional": true,
                    "original": "medium"
                }
            ],
            "name": "VolumeEmptyDir",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "VolumeEmptyDir s",
            "original": "volume_empty_dir"
        },
        {
            "con": {
                "smart": "newSpecTemplate",
                "name": "SpecTemplate'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional duration in seconds the pod may be active on the node relative to",
                        "StartTime before the system will actively try to mark it failed and kill",
                        "associated containers. Value must be a positive integer."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"active_deadline_seconds\" <$> TF.attribute",
                    "name": "_activeDeadlineSeconds",
                    "method": "activeDeadlineSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasActiveDeadlineSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "active_deadline_seconds"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of containers belonging to the pod. Containers cannot currently be",
                        "added or removed. There must be at least one container in a Pod. Cannot be",
                        "updated. More info: http://kubernetes.io/docs/user-guide/containers"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"container\" <$> TF.attribute",
                    "name": "_container",
                    "method": "container",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TemplateContainer s)]",
                    "class": "HasContainer",
                    "validate": true,
                    "optional": true,
                    "original": "container"
                },
                {
                    "default": "TF.value \"ClusterFirst\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Set DNS policy for containers within the pod. One of 'ClusterFirst' or",
                        "'Default'. Defaults to 'ClusterFirst'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dns_policy\" <$> TF.attribute",
                    "name": "_dnsPolicy",
                    "method": "dnsPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDnsPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "dns_policy"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Use the host's ipc namespace. Optional: Default to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_ipc\" <$> TF.attribute",
                    "name": "_hostIpc",
                    "method": "hostIpc",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostIpc",
                    "validate": false,
                    "optional": true,
                    "original": "host_ipc"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host networking requested for this pod. Use the host's network namespace. If",
                        "this option is set, the ports that will be used must be specified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_network\" <$> TF.attribute",
                    "name": "_hostNetwork",
                    "method": "hostNetwork",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostNetwork",
                    "validate": false,
                    "optional": true,
                    "original": "host_network"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Use the host's pid namespace."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_pid\" <$> TF.attribute",
                    "name": "_hostPid",
                    "method": "hostPid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostPid",
                    "validate": false,
                    "optional": true,
                    "original": "host_pid"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of init containers belonging to the pod. Init containers always run to",
                        "completion and each must complete succesfully before the next is started.",
                        "More info:",
                        "https://kubernetes.io/docs/concepts/workloads/pods/init-containers/"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"init_container\" <$> TF.attribute",
                    "name": "_initContainer",
                    "method": "initContainer",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TemplateInitContainer s)]",
                    "class": "HasInitContainer",
                    "validate": true,
                    "optional": true,
                    "original": "init_container"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "NodeSelector is a selector which must be true for the pod to fit on a node.",
                        "Selector which must match a node's labels for the pod to be scheduled on",
                        "that node. More info: http://kubernetes.io/docs/user-guide/node-selection."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"node_selector\" <$> TF.attribute",
                    "name": "_nodeSelector",
                    "method": "nodeSelector",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasNodeSelector",
                    "validate": false,
                    "optional": true,
                    "original": "node_selector"
                },
                {
                    "default": "TF.value \"Always\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Restart policy for all containers within the pod. One of Always, OnFailure,",
                        "Never. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#restartpolicy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"restart_policy\" <$> TF.attribute",
                    "name": "_restartPolicy",
                    "method": "restartPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRestartPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "restart_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "SecurityContext holds pod-level security attributes and common container",
                        "settings. Optional: Defaults to empty"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"security_context\" <$> TF.attribute",
                    "name": "_securityContext",
                    "method": "securityContext",
                    "conflicts": [],
                    "type": "TF.Attr s (TemplateSecurityContext s)",
                    "class": "HasSecurityContext",
                    "validate": true,
                    "optional": true,
                    "original": "security_context"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If specified, the fully qualified Pod hostname will be \"...svc.\". If not",
                        "specified, the pod will not have a domainname at all.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"subdomain\" <$> TF.attribute",
                    "name": "_subdomain",
                    "method": "subdomain",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSubdomain",
                    "validate": false,
                    "optional": true,
                    "original": "subdomain"
                },
                {
                    "default": "TF.value 30",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional duration in seconds the pod needs to terminate gracefully. May be",
                        "decreased in delete request. Value must be non-negative integer. The value",
                        "zero indicates delete immediately. If this value is nil, the default grace",
                        "period will be used instead. The grace period is the duration in seconds",
                        "after the processes running in the pod are sent a termination signal and the",
                        "time when the processes are forcibly halted with a kill signal. Set this",
                        "value longer than the expected cleanup time for your process."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"termination_grace_period_seconds\" <$> TF.attribute",
                    "name": "_terminationGracePeriodSeconds",
                    "method": "terminationGracePeriodSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasTerminationGracePeriodSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "termination_grace_period_seconds"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of volumes that can be mounted by containers belonging to the pod. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "_volume",
                    "method": "volume",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TemplateVolume s)]",
                    "class": "HasVolume",
                    "validate": true,
                    "optional": true,
                    "original": "volume"
                }
            ],
            "name": "SpecTemplate",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Specifies the hostname of the Pod If not specified, the pod's hostname will",
                        "be set to a system-defined value."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"hostname\" <$> TF.attribute",
                    "name": "_computedHostname",
                    "method": "computedHostname",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedHostname",
                    "validate": false,
                    "optional": true,
                    "original": "hostname"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "ImagePullSecrets is an optional list of references to secrets in the same",
                        "namespace to use for pulling any of the images used by this PodSpec. If",
                        "specified, these secrets will be passed to individual puller implementations",
                        "for them to use. For example, in the case of docker, only DockerConfig type",
                        "secrets are honored. More info:",
                        "http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image_pull_secrets\" <$> TF.attribute",
                    "name": "_computedImagePullSecrets",
                    "method": "computedImagePullSecrets",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TemplateImagePullSecrets s)]",
                    "class": "HasComputedImagePullSecrets",
                    "validate": true,
                    "optional": true,
                    "original": "image_pull_secrets"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "NodeName is a request to schedule this pod onto a specific node. If it is",
                        "non-empty, the scheduler simply schedules this pod onto that node, assuming",
                        "that it fits resource requirements."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"node_name\" <$> TF.attribute",
                    "name": "_computedNodeName",
                    "method": "computedNodeName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedNodeName",
                    "validate": false,
                    "optional": true,
                    "original": "node_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "ServiceAccountName is the name of the ServiceAccount to use to run this pod.",
                        "More info: http://releases.k8s.io/HEAD/docs/design/service_accounts.md."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"service_account_name\" <$> TF.attribute",
                    "name": "_computedServiceAccountName",
                    "method": "computedServiceAccountName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedServiceAccountName",
                    "validate": false,
                    "optional": true,
                    "original": "service_account_name"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "SpecTemplate s",
            "original": "spec_template"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSourceFc",
                "name": "PersistentVolumeSourceFc'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_lun",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target lun number"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "_lun",
                    "method": "lun",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasLun",
                    "validate": false,
                    "optional": false,
                    "original": "lun"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_targetWwNs",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target worldwide names (WWNs)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_ww_ns\" <$> TF.attribute",
                    "name": "_targetWwNs",
                    "method": "targetWwNs",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTargetWwNs",
                    "validate": false,
                    "optional": false,
                    "original": "target_ww_ns"
                }
            ],
            "name": "PersistentVolumeSourceFc",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_lun",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target lun number"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "_lun",
                    "method": "lun",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasLun",
                    "validate": false,
                    "optional": false,
                    "original": "lun"
                },
                {
                    "default": "_targetWwNs",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target worldwide names (WWNs)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_ww_ns\" <$> TF.attribute",
                    "name": "_targetWwNs",
                    "method": "targetWwNs",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTargetWwNs",
                    "validate": false,
                    "optional": false,
                    "original": "target_ww_ns"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSourceFc s",
            "original": "persistent_volume_source_fc"
        },
        {
            "con": {
                "smart": "newVolumeGitRepo",
                "name": "VolumeGitRepo'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Target directory name. Must not contain or start with '..'. If '.' is",
                        "supplied, the volume directory will be the git repository. Otherwise, if",
                        "specified, the volume will contain the git repository in the subdirectory",
                        "with the given name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"directory\" <$> TF.attribute",
                    "name": "_directory",
                    "method": "directory",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDirectory",
                    "validate": false,
                    "optional": true,
                    "original": "directory"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Repository URL"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"repository\" <$> TF.attribute",
                    "name": "_repository",
                    "method": "repository",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRepository",
                    "validate": false,
                    "optional": true,
                    "original": "repository"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Commit hash for the specified revision."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"revision\" <$> TF.attribute",
                    "name": "_revision",
                    "method": "revision",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRevision",
                    "validate": false,
                    "optional": true,
                    "original": "revision"
                }
            ],
            "name": "VolumeGitRepo",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "VolumeGitRepo s",
            "original": "volume_git_repo"
        },
        {
            "con": {
                "smart": "newSpecScaleTargetRef",
                "name": "SpecScaleTargetRef'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "API version of the referent"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"api_version\" <$> TF.attribute",
                    "name": "_apiVersion",
                    "method": "apiVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasApiVersion",
                    "validate": false,
                    "optional": true,
                    "original": "api_version"
                },
                {
                    "default": "_kind",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Kind of the referent. e.g. `ReplicationController`. More info:",
                        "http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#types-kinds"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"kind\" <$> TF.attribute",
                    "name": "_kind",
                    "method": "kind",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKind",
                    "validate": false,
                    "optional": false,
                    "original": "kind"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "name": "SpecScaleTargetRef",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_kind",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Kind of the referent. e.g. `ReplicationController`. More info:",
                        "http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#types-kinds"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"kind\" <$> TF.attribute",
                    "name": "_kind",
                    "method": "kind",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKind",
                    "validate": false,
                    "optional": false,
                    "original": "kind"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "SpecScaleTargetRef s",
            "original": "spec_scale_target_ref"
        },
        {
            "con": {
                "smart": "newVolumeFc",
                "name": "VolumeFc'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_lun",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target lun number"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "_lun",
                    "method": "lun",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasLun",
                    "validate": false,
                    "optional": false,
                    "original": "lun"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_targetWwNs",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target worldwide names (WWNs)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_ww_ns\" <$> TF.attribute",
                    "name": "_targetWwNs",
                    "method": "targetWwNs",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTargetWwNs",
                    "validate": false,
                    "optional": false,
                    "original": "target_ww_ns"
                }
            ],
            "name": "VolumeFc",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_lun",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target lun number"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "_lun",
                    "method": "lun",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasLun",
                    "validate": false,
                    "optional": false,
                    "original": "lun"
                },
                {
                    "default": "_targetWwNs",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target worldwide names (WWNs)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_ww_ns\" <$> TF.attribute",
                    "name": "_targetWwNs",
                    "method": "targetWwNs",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTargetWwNs",
                    "validate": false,
                    "optional": false,
                    "original": "target_ww_ns"
                }
            ],
            "conflicts": [],
            "type": "VolumeFc s",
            "original": "volume_fc"
        },
        {
            "con": {
                "smart": "newVolumeHostPath",
                "name": "VolumeHostPath'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path of the directory on the host. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#hostpath"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                }
            ],
            "name": "VolumeHostPath",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "VolumeHostPath s",
            "original": "volume_host_path"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSourceFlocker",
                "name": "PersistentVolumeSourceFlocker'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the dataset stored as metadata -> name on the dataset for Flocker",
                        "should be considered as deprecated"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dataset_name\" <$> TF.attribute",
                    "name": "_datasetName",
                    "method": "datasetName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatasetName",
                    "validate": false,
                    "optional": true,
                    "original": "dataset_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "UUID of the dataset. This is unique identifier of a Flocker dataset"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dataset_uuid\" <$> TF.attribute",
                    "name": "_datasetUuid",
                    "method": "datasetUuid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatasetUuid",
                    "validate": false,
                    "optional": true,
                    "original": "dataset_uuid"
                }
            ],
            "name": "PersistentVolumeSourceFlocker",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PersistentVolumeSourceFlocker s",
            "original": "persistent_volume_source_flocker"
        },
        {
            "con": {
                "smart": "newPersistentVolumeClaimSpec",
                "name": "PersistentVolumeClaimSpec'"
            },
            "arguments": [
                {
                    "default": "_accessModes",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A set of the desired access modes the volume should have. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes-1"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"access_modes\" <$> TF.attribute",
                    "name": "_accessModes",
                    "method": "accessModes",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasAccessModes",
                    "validate": false,
                    "optional": false,
                    "original": "access_modes"
                },
                {
                    "default": "_resources",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A list of the minimum resources the volume should have. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_resources",
                    "method": "resources",
                    "conflicts": [],
                    "type": "TF.Attr s (SpecResources s)",
                    "class": "HasResources",
                    "validate": true,
                    "optional": false,
                    "original": "resources"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A label query over volumes to consider for binding."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"selector\" <$> TF.attribute",
                    "name": "_selector",
                    "method": "selector",
                    "conflicts": [],
                    "type": "TF.Attr s (SpecSelector s)",
                    "class": "HasSelector",
                    "validate": true,
                    "optional": true,
                    "original": "selector"
                }
            ],
            "name": "PersistentVolumeClaimSpec",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the storage class requested by the claim"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"storage_class_name\" <$> TF.attribute",
                    "name": "_computedStorageClassName",
                    "method": "computedStorageClassName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedStorageClassName",
                    "validate": false,
                    "optional": true,
                    "original": "storage_class_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The binding reference to the PersistentVolume backing this claim."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"volume_name\" <$> TF.attribute",
                    "name": "_computedVolumeName",
                    "method": "computedVolumeName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedVolumeName",
                    "validate": false,
                    "optional": true,
                    "original": "volume_name"
                }
            ],
            "parameters": [
                {
                    "default": "_accessModes",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A set of the desired access modes the volume should have. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes-1"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"access_modes\" <$> TF.attribute",
                    "name": "_accessModes",
                    "method": "accessModes",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasAccessModes",
                    "validate": false,
                    "optional": false,
                    "original": "access_modes"
                },
                {
                    "default": "_resources",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A list of the minimum resources the volume should have. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_resources",
                    "method": "resources",
                    "conflicts": [],
                    "type": "TF.Attr s (SpecResources s)",
                    "class": "HasResources",
                    "validate": true,
                    "optional": false,
                    "original": "resources"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeClaimSpec s",
            "original": "persistent_volume_claim_spec"
        },
        {
            "con": {
                "smart": "newItemsFieldRef",
                "name": "ItemsFieldRef'"
            },
            "arguments": [
                {
                    "default": "TF.value \"v1\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Version of the schema the FieldPath is written in terms of, defaults to",
                        "\"v1\"."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"api_version\" <$> TF.attribute",
                    "name": "_apiVersion",
                    "method": "apiVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasApiVersion",
                    "validate": false,
                    "optional": true,
                    "original": "api_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path of the field to select in the specified API version"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_path\" <$> TF.attribute",
                    "name": "_fieldPath",
                    "method": "fieldPath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFieldPath",
                    "validate": false,
                    "optional": true,
                    "original": "field_path"
                }
            ],
            "name": "ItemsFieldRef",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ItemsFieldRef s",
            "original": "items_field_ref"
        },
        {
            "con": {
                "smart": "newVolumePhotonPersistentDisk",
                "name": "VolumePhotonPersistentDisk'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_pdId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ID that identifies Photon Controller persistent disk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_id\" <$> TF.attribute",
                    "name": "_pdId",
                    "method": "pdId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdId",
                    "validate": false,
                    "optional": false,
                    "original": "pd_id"
                }
            ],
            "name": "VolumePhotonPersistentDisk",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_pdId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ID that identifies Photon Controller persistent disk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_id\" <$> TF.attribute",
                    "name": "_pdId",
                    "method": "pdId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdId",
                    "validate": false,
                    "optional": false,
                    "original": "pd_id"
                }
            ],
            "conflicts": [],
            "type": "VolumePhotonPersistentDisk s",
            "original": "volume_photon_persistent_disk"
        },
        {
            "con": {
                "smart": "newSpecImagePullSecrets",
                "name": "SpecImagePullSecrets'"
            },
            "arguments": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "name": "SpecImagePullSecrets",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "SpecImagePullSecrets s",
            "original": "spec_image_pull_secrets"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSourcePhotonPersistentDisk",
                "name": "PersistentVolumeSourcePhotonPersistentDisk'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_pdId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ID that identifies Photon Controller persistent disk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_id\" <$> TF.attribute",
                    "name": "_pdId",
                    "method": "pdId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdId",
                    "validate": false,
                    "optional": false,
                    "original": "pd_id"
                }
            ],
            "name": "PersistentVolumeSourcePhotonPersistentDisk",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_pdId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ID that identifies Photon Controller persistent disk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_id\" <$> TF.attribute",
                    "name": "_pdId",
                    "method": "pdId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdId",
                    "validate": false,
                    "optional": false,
                    "original": "pd_id"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSourcePhotonPersistentDisk s",
            "original": "persistent_volume_source_photon_persistent_disk"
        },
        {
            "con": {
                "smart": "newVolumeFlocker",
                "name": "VolumeFlocker'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the dataset stored as metadata -> name on the dataset for Flocker",
                        "should be considered as deprecated"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dataset_name\" <$> TF.attribute",
                    "name": "_datasetName",
                    "method": "datasetName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatasetName",
                    "validate": false,
                    "optional": true,
                    "original": "dataset_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "UUID of the dataset. This is unique identifier of a Flocker dataset"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dataset_uuid\" <$> TF.attribute",
                    "name": "_datasetUuid",
                    "method": "datasetUuid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatasetUuid",
                    "validate": false,
                    "optional": true,
                    "original": "dataset_uuid"
                }
            ],
            "name": "VolumeFlocker",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "VolumeFlocker s",
            "original": "volume_flocker"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSourceHostPath",
                "name": "PersistentVolumeSourceHostPath'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path of the directory on the host. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#hostpath"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                }
            ],
            "name": "PersistentVolumeSourceHostPath",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PersistentVolumeSourceHostPath s",
            "original": "persistent_volume_source_host_path"
        },
        {
            "con": {
                "smart": "newPersistentVolumeClaimMetadata",
                "name": "PersistentVolumeClaimMetadata'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the persistent volume claim that",
                        "may be used to store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the persistent volume claim. May match selectors of",
                        "replication controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Namespace defines the space within which name of the persistent volume claim",
                        "must be unique."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"namespace\" <$> TF.attribute",
                    "name": "_namespace",
                    "method": "namespace",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNamespace",
                    "validate": false,
                    "optional": true,
                    "original": "namespace"
                }
            ],
            "name": "PersistentVolumeClaimMetadata",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the persistent volume claim, must be unique. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "conflicts": [
                        "_generateName"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this persistent",
                        "volume claim that can be used by clients to determine when persistent volume",
                        "claim has changed. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this persistent volume claim."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this persistent volume claim. More",
                        "info: http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "PersistentVolumeClaimMetadata s",
            "original": "persistent_volume_claim_metadata"
        },
        {
            "con": {
                "smart": "newSpecContainer",
                "name": "SpecContainer'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Arguments to the entrypoint. The docker image's CMD is used if this is not",
                        "provided. Variable references $(VAR_NAME) are expanded using the container's",
                        "environment. If a variable cannot be resolved, the reference in the input",
                        "string will be unchanged. The $(VAR_NAME) syntax can be escaped with a",
                        "double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,",
                        "regardless of whether the variable exists or not. Cannot be updated. More",
                        "info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"args\" <$> TF.attribute",
                    "name": "_args",
                    "method": "args",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasArgs",
                    "validate": false,
                    "optional": true,
                    "original": "args"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT",
                        "is used if this is not provided. Variable references $(VAR_NAME) are",
                        "expanded using the container's environment. If a variable cannot be",
                        "resolved, the reference in the input string will be unchanged. The",
                        "$(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).",
                        "Escaped references will never be expanded, regardless of whether the",
                        "variable exists or not. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of environment variables to set in the container. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"env\" <$> TF.attribute",
                    "name": "_env",
                    "method": "env",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ContainerEnv s)]",
                    "class": "HasEnv",
                    "validate": true,
                    "optional": true,
                    "original": "env"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Docker image name. More info: http://kubernetes.io/docs/user-guide/images"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image\" <$> TF.attribute",
                    "name": "_image",
                    "method": "image",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasImage",
                    "validate": false,
                    "optional": true,
                    "original": "image"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Actions that the management system should take in response to container",
                        "lifecycle events"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"lifecycle\" <$> TF.attribute",
                    "name": "_lifecycle",
                    "method": "lifecycle",
                    "conflicts": [],
                    "type": "TF.Attr s (ContainerLifecycle s)",
                    "class": "HasLifecycle",
                    "validate": true,
                    "optional": true,
                    "original": "lifecycle"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container liveness. Container will be restarted if the",
                        "probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"liveness_probe\" <$> TF.attribute",
                    "name": "_livenessProbe",
                    "method": "livenessProbe",
                    "conflicts": [],
                    "type": "TF.Attr s (ContainerLivenessProbe s)",
                    "class": "HasLivenessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "liveness_probe"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of ports to expose from the container. Exposing a port here gives the",
                        "system additional information about the network connections a container",
                        "uses, but is primarily informational. Not specifying a port here DOES NOT",
                        "prevent that port from being exposed. Any port which is listening on the",
                        "default \"0.0.0.0\" address inside a container will be accessible from the",
                        "network. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ContainerPort s)]",
                    "class": "HasPort",
                    "validate": true,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container service readiness. Container will be removed",
                        "from service endpoints if the probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"readiness_probe\" <$> TF.attribute",
                    "name": "_readinessProbe",
                    "method": "readinessProbe",
                    "conflicts": [],
                    "type": "TF.Attr s (ContainerReadinessProbe s)",
                    "class": "HasReadinessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "readiness_probe"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Security options the pod should run with. More info:",
                        "http://releases.k8s.io/HEAD/docs/design/security_context.md"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"security_context\" <$> TF.attribute",
                    "name": "_securityContext",
                    "method": "securityContext",
                    "conflicts": [],
                    "type": "TF.Attr s (ContainerSecurityContext s)",
                    "class": "HasSecurityContext",
                    "validate": true,
                    "optional": true,
                    "original": "security_context"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a buffer for stdin in the container",
                        "runtime. If this is not set, reads from stdin in the container will always",
                        "result in EOF."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"stdin\" <$> TF.attribute",
                    "name": "_stdin",
                    "method": "stdin",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdin",
                    "validate": false,
                    "optional": true,
                    "original": "stdin"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether the container runtime should close the stdin channel after it has",
                        "been opened by a single attach. When stdin is true the stdin stream will",
                        "remain open across multiple attach sessions. If stdinOnce is set to true,",
                        "stdin is opened on container start, is empty until the first client attaches",
                        "to stdin, and then remains open and accepts data until the client",
                        "disconnects, at which time stdin is closed and remains closed until the",
                        "container is restarted. If this flag is false, a container processes that",
                        "reads from stdin will never receive an EOF."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"stdin_once\" <$> TF.attribute",
                    "name": "_stdinOnce",
                    "method": "stdinOnce",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdinOnce",
                    "validate": false,
                    "optional": true,
                    "original": "stdin_once"
                },
                {
                    "default": "TF.value \"/dev/termination-log\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: Path at which the file to which the container's termination",
                        "message will be written is mounted into the container's filesystem. Message",
                        "written is intended to be brief final status, such as an assertion failure",
                        "message. Defaults to /dev/termination-log. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"termination_message_path\" <$> TF.attribute",
                    "name": "_terminationMessagePath",
                    "method": "terminationMessagePath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTerminationMessagePath",
                    "validate": false,
                    "optional": true,
                    "original": "termination_message_path"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a TTY for itself"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"tty\" <$> TF.attribute",
                    "name": "_tty",
                    "method": "tty",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasTty",
                    "validate": false,
                    "optional": true,
                    "original": "tty"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Pod volumes to mount into the container's filesystem. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"volume_mount\" <$> TF.attribute",
                    "name": "_volumeMount",
                    "method": "volumeMount",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ContainerVolumeMount s)]",
                    "class": "HasVolumeMount",
                    "validate": true,
                    "optional": true,
                    "original": "volume_mount"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Container's working directory. If not specified, the container runtime's",
                        "default will be used, which might be configured in the container image.",
                        "Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"working_dir\" <$> TF.attribute",
                    "name": "_workingDir",
                    "method": "workingDir",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasWorkingDir",
                    "validate": false,
                    "optional": true,
                    "original": "working_dir"
                }
            ],
            "name": "SpecContainer",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if",
                        ":latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/images#updating-images"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"image_pull_policy\" <$> TF.attribute",
                    "name": "_computedImagePullPolicy",
                    "method": "computedImagePullPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedImagePullPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "image_pull_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Compute Resources required by this container. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_computedResources",
                    "method": "computedResources",
                    "conflicts": [],
                    "type": "TF.Attr s (ContainerResources s)",
                    "class": "HasComputedResources",
                    "validate": true,
                    "optional": true,
                    "original": "resources"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "SpecContainer s",
            "original": "spec_container"
        },
        {
            "con": {
                "smart": "newServiceAccountImagePullSecret",
                "name": "ServiceAccountImagePullSecret'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "name": "ServiceAccountImagePullSecret",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ServiceAccountImagePullSecret s",
            "original": "service_account_image_pull_secret"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSpec",
                "name": "PersistentVolumeSpec'"
            },
            "arguments": [
                {
                    "default": "_accessModes",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Contains all ways the volume can be mounted. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"access_modes\" <$> TF.attribute",
                    "name": "_accessModes",
                    "method": "accessModes",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasAccessModes",
                    "validate": false,
                    "optional": false,
                    "original": "access_modes"
                },
                {
                    "default": "_capacity",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A description of the persistent volume's resources and capacity. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#capacity"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"capacity\" <$> TF.attribute",
                    "name": "_capacity",
                    "method": "capacity",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasCapacity",
                    "validate": false,
                    "optional": false,
                    "original": "capacity"
                },
                {
                    "default": "TF.value \"Retain\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "What happens to a persistent volume when released from its claim. Valid",
                        "options are Retain (default) and Recycle. Recycling must be supported by the",
                        "volume plugin underlying this persistent volume. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#recycling-policy"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"persistent_volume_reclaim_policy\" <$> TF.attribute",
                    "name": "_persistentVolumeReclaimPolicy",
                    "method": "persistentVolumeReclaimPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPersistentVolumeReclaimPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "persistent_volume_reclaim_policy"
                },
                {
                    "default": "_persistentVolumeSource",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The specification of a persistent volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"persistent_volume_source\" <$> TF.attribute",
                    "name": "_persistentVolumeSource",
                    "method": "persistentVolumeSource",
                    "conflicts": [],
                    "type": "TF.Attr s (SpecPersistentVolumeSource s)",
                    "class": "HasPersistentVolumeSource",
                    "validate": true,
                    "optional": false,
                    "original": "persistent_volume_source"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A description of the persistent volume's class. More info:",
                        "https://kubernetes.io/docs/concepts/storage/persistent-volumes/#class"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"storage_class_name\" <$> TF.attribute",
                    "name": "_storageClassName",
                    "method": "storageClassName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasStorageClassName",
                    "validate": false,
                    "optional": true,
                    "original": "storage_class_name"
                }
            ],
            "name": "PersistentVolumeSpec",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_accessModes",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Contains all ways the volume can be mounted. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"access_modes\" <$> TF.attribute",
                    "name": "_accessModes",
                    "method": "accessModes",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasAccessModes",
                    "validate": false,
                    "optional": false,
                    "original": "access_modes"
                },
                {
                    "default": "_capacity",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A description of the persistent volume's resources and capacity. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#capacity"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"capacity\" <$> TF.attribute",
                    "name": "_capacity",
                    "method": "capacity",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasCapacity",
                    "validate": false,
                    "optional": false,
                    "original": "capacity"
                },
                {
                    "default": "_persistentVolumeSource",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The specification of a persistent volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"persistent_volume_source\" <$> TF.attribute",
                    "name": "_persistentVolumeSource",
                    "method": "persistentVolumeSource",
                    "conflicts": [],
                    "type": "TF.Attr s (SpecPersistentVolumeSource s)",
                    "class": "HasPersistentVolumeSource",
                    "validate": true,
                    "optional": false,
                    "original": "persistent_volume_source"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSpec s",
            "original": "persistent_volume_spec"
        },
        {
            "con": {
                "smart": "newContainerLivenessProbe",
                "name": "ContainerLivenessProbe'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "conflicts": [],
                    "type": "TF.Attr s (LivenessProbeExec s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive failures for the probe to be considered failed after",
                        "having succeeded."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failure_threshold\" <$> TF.attribute",
                    "name": "_failureThreshold",
                    "method": "failureThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasFailureThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "failure_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "conflicts": [],
                    "type": "TF.Attr s (LivenessProbeHttpGet s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after the container has started before liveness probes are",
                        "initiated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"initial_delay_seconds\" <$> TF.attribute",
                    "name": "_initialDelaySeconds",
                    "method": "initialDelaySeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasInitialDelaySeconds",
                    "validate": false,
                    "optional": true,
                    "original": "initial_delay_seconds"
                },
                {
                    "default": "TF.value 10",
                    "computed": false,
                    "required": false,
                    "help": [
                        "How often (in seconds) to perform the probe"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"period_seconds\" <$> TF.attribute",
                    "name": "_periodSeconds",
                    "method": "periodSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasPeriodSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "period_seconds"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive successes for the probe to be considered successful",
                        "after having failed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"success_threshold\" <$> TF.attribute",
                    "name": "_successThreshold",
                    "method": "successThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasSuccessThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "success_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (LivenessProbeTcpSocket s)]",
                    "class": "HasTcpSocket",
                    "validate": true,
                    "optional": true,
                    "original": "tcp_socket"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after which the probe times out. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"timeout_seconds\" <$> TF.attribute",
                    "name": "_timeoutSeconds",
                    "method": "timeoutSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasTimeoutSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "timeout_seconds"
                }
            ],
            "name": "ContainerLivenessProbe",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ContainerLivenessProbe s",
            "original": "container_liveness_probe"
        },
        {
            "con": {
                "smart": "newConfigMapItems",
                "name": "ConfigMapItems'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key to project."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on this file, must be a value between 0 and 0777.",
                        "If not specified, the volume defaultMode will be used. This might be in",
                        "conflict with other options that affect the file mode, like fsGroup, and the",
                        "result can be other mode bits set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mode\" <$> TF.attribute",
                    "name": "_mode",
                    "method": "mode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasMode",
                    "validate": false,
                    "optional": true,
                    "original": "mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The relative path of the file to map the key to. May not be an absolute",
                        "path. May not contain the path element '..'. May not start with the string",
                        "'..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                }
            ],
            "name": "ConfigMapItems",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ConfigMapItems s",
            "original": "config_map_items"
        },
        {
            "con": {
                "smart": "newItemsResourceFieldRef",
                "name": "ItemsResourceFieldRef'"
            },
            "arguments": [
                {
                    "default": "_containerName",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_name\" <$> TF.attribute",
                    "name": "_containerName",
                    "method": "containerName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasContainerName",
                    "validate": false,
                    "optional": false,
                    "original": "container_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"quantity\" <$> TF.attribute",
                    "name": "_quantity",
                    "method": "quantity",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasQuantity",
                    "validate": false,
                    "optional": true,
                    "original": "quantity"
                },
                {
                    "default": "_resource",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Resource to select"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource\" <$> TF.attribute",
                    "name": "_resource",
                    "method": "resource",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResource",
                    "validate": false,
                    "optional": false,
                    "original": "resource"
                }
            ],
            "name": "ItemsResourceFieldRef",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_containerName",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_name\" <$> TF.attribute",
                    "name": "_containerName",
                    "method": "containerName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasContainerName",
                    "validate": false,
                    "optional": false,
                    "original": "container_name"
                },
                {
                    "default": "_resource",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Resource to select"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource\" <$> TF.attribute",
                    "name": "_resource",
                    "method": "resource",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResource",
                    "validate": false,
                    "optional": false,
                    "original": "resource"
                }
            ],
            "conflicts": [],
            "type": "ItemsResourceFieldRef s",
            "original": "items_resource_field_ref"
        },
        {
            "con": {
                "smart": "newTemplateContainer",
                "name": "TemplateContainer'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Arguments to the entrypoint. The docker image's CMD is used if this is not",
                        "provided. Variable references $(VAR_NAME) are expanded using the container's",
                        "environment. If a variable cannot be resolved, the reference in the input",
                        "string will be unchanged. The $(VAR_NAME) syntax can be escaped with a",
                        "double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,",
                        "regardless of whether the variable exists or not. Cannot be updated. More",
                        "info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"args\" <$> TF.attribute",
                    "name": "_args",
                    "method": "args",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasArgs",
                    "validate": false,
                    "optional": true,
                    "original": "args"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT",
                        "is used if this is not provided. Variable references $(VAR_NAME) are",
                        "expanded using the container's environment. If a variable cannot be",
                        "resolved, the reference in the input string will be unchanged. The",
                        "$(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).",
                        "Escaped references will never be expanded, regardless of whether the",
                        "variable exists or not. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of environment variables to set in the container. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"env\" <$> TF.attribute",
                    "name": "_env",
                    "method": "env",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ContainerEnv s)]",
                    "class": "HasEnv",
                    "validate": true,
                    "optional": true,
                    "original": "env"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Docker image name. More info: http://kubernetes.io/docs/user-guide/images"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image\" <$> TF.attribute",
                    "name": "_image",
                    "method": "image",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasImage",
                    "validate": false,
                    "optional": true,
                    "original": "image"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Actions that the management system should take in response to container",
                        "lifecycle events"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"lifecycle\" <$> TF.attribute",
                    "name": "_lifecycle",
                    "method": "lifecycle",
                    "conflicts": [],
                    "type": "TF.Attr s (ContainerLifecycle s)",
                    "class": "HasLifecycle",
                    "validate": true,
                    "optional": true,
                    "original": "lifecycle"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container liveness. Container will be restarted if the",
                        "probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"liveness_probe\" <$> TF.attribute",
                    "name": "_livenessProbe",
                    "method": "livenessProbe",
                    "conflicts": [],
                    "type": "TF.Attr s (ContainerLivenessProbe s)",
                    "class": "HasLivenessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "liveness_probe"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of ports to expose from the container. Exposing a port here gives the",
                        "system additional information about the network connections a container",
                        "uses, but is primarily informational. Not specifying a port here DOES NOT",
                        "prevent that port from being exposed. Any port which is listening on the",
                        "default \"0.0.0.0\" address inside a container will be accessible from the",
                        "network. Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ContainerPort s)]",
                    "class": "HasPort",
                    "validate": true,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container service readiness. Container will be removed",
                        "from service endpoints if the probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"readiness_probe\" <$> TF.attribute",
                    "name": "_readinessProbe",
                    "method": "readinessProbe",
                    "conflicts": [],
                    "type": "TF.Attr s (ContainerReadinessProbe s)",
                    "class": "HasReadinessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "readiness_probe"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Security options the pod should run with. More info:",
                        "http://releases.k8s.io/HEAD/docs/design/security_context.md"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"security_context\" <$> TF.attribute",
                    "name": "_securityContext",
                    "method": "securityContext",
                    "conflicts": [],
                    "type": "TF.Attr s (ContainerSecurityContext s)",
                    "class": "HasSecurityContext",
                    "validate": true,
                    "optional": true,
                    "original": "security_context"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a buffer for stdin in the container",
                        "runtime. If this is not set, reads from stdin in the container will always",
                        "result in EOF."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"stdin\" <$> TF.attribute",
                    "name": "_stdin",
                    "method": "stdin",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdin",
                    "validate": false,
                    "optional": true,
                    "original": "stdin"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether the container runtime should close the stdin channel after it has",
                        "been opened by a single attach. When stdin is true the stdin stream will",
                        "remain open across multiple attach sessions. If stdinOnce is set to true,",
                        "stdin is opened on container start, is empty until the first client attaches",
                        "to stdin, and then remains open and accepts data until the client",
                        "disconnects, at which time stdin is closed and remains closed until the",
                        "container is restarted. If this flag is false, a container processes that",
                        "reads from stdin will never receive an EOF."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"stdin_once\" <$> TF.attribute",
                    "name": "_stdinOnce",
                    "method": "stdinOnce",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdinOnce",
                    "validate": false,
                    "optional": true,
                    "original": "stdin_once"
                },
                {
                    "default": "TF.value \"/dev/termination-log\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: Path at which the file to which the container's termination",
                        "message will be written is mounted into the container's filesystem. Message",
                        "written is intended to be brief final status, such as an assertion failure",
                        "message. Defaults to /dev/termination-log. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"termination_message_path\" <$> TF.attribute",
                    "name": "_terminationMessagePath",
                    "method": "terminationMessagePath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTerminationMessagePath",
                    "validate": false,
                    "optional": true,
                    "original": "termination_message_path"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a TTY for itself"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tty\" <$> TF.attribute",
                    "name": "_tty",
                    "method": "tty",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasTty",
                    "validate": false,
                    "optional": true,
                    "original": "tty"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Pod volumes to mount into the container's filesystem. Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_mount\" <$> TF.attribute",
                    "name": "_volumeMount",
                    "method": "volumeMount",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ContainerVolumeMount s)]",
                    "class": "HasVolumeMount",
                    "validate": true,
                    "optional": true,
                    "original": "volume_mount"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Container's working directory. If not specified, the container runtime's",
                        "default will be used, which might be configured in the container image.",
                        "Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"working_dir\" <$> TF.attribute",
                    "name": "_workingDir",
                    "method": "workingDir",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasWorkingDir",
                    "validate": false,
                    "optional": true,
                    "original": "working_dir"
                }
            ],
            "name": "TemplateContainer",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if",
                        ":latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/images#updating-images"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image_pull_policy\" <$> TF.attribute",
                    "name": "_computedImagePullPolicy",
                    "method": "computedImagePullPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedImagePullPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "image_pull_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Compute Resources required by this container. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_computedResources",
                    "method": "computedResources",
                    "conflicts": [],
                    "type": "TF.Attr s (ContainerResources s)",
                    "class": "HasComputedResources",
                    "validate": true,
                    "optional": true,
                    "original": "resources"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "TemplateContainer s",
            "original": "template_container"
        },
        {
            "con": {
                "smart": "newPersistentVolumeMetadata",
                "name": "PersistentVolumeMetadata'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the persistent volume that may be",
                        "used to store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the persistent volume. May match selectors of replication",
                        "controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                }
            ],
            "name": "PersistentVolumeMetadata",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the persistent volume, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this persistent",
                        "volume that can be used by clients to determine when persistent volume has",
                        "changed. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this persistent volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this persistent volume. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "PersistentVolumeMetadata s",
            "original": "persistent_volume_metadata"
        },
        {
            "con": {
                "smart": "newSpecInitContainer",
                "name": "SpecInitContainer'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Arguments to the entrypoint. The docker image's CMD is used if this is not",
                        "provided. Variable references $(VAR_NAME) are expanded using the container's",
                        "environment. If a variable cannot be resolved, the reference in the input",
                        "string will be unchanged. The $(VAR_NAME) syntax can be escaped with a",
                        "double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,",
                        "regardless of whether the variable exists or not. Cannot be updated. More",
                        "info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"args\" <$> TF.attribute",
                    "name": "_args",
                    "method": "args",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasArgs",
                    "validate": false,
                    "optional": true,
                    "original": "args"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT",
                        "is used if this is not provided. Variable references $(VAR_NAME) are",
                        "expanded using the container's environment. If a variable cannot be",
                        "resolved, the reference in the input string will be unchanged. The",
                        "$(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).",
                        "Escaped references will never be expanded, regardless of whether the",
                        "variable exists or not. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of environment variables to set in the container. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"env\" <$> TF.attribute",
                    "name": "_env",
                    "method": "env",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (InitContainerEnv s)]",
                    "class": "HasEnv",
                    "validate": true,
                    "optional": true,
                    "original": "env"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Docker image name. More info: http://kubernetes.io/docs/user-guide/images"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"image\" <$> TF.attribute",
                    "name": "_image",
                    "method": "image",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasImage",
                    "validate": false,
                    "optional": true,
                    "original": "image"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Actions that the management system should take in response to container",
                        "lifecycle events"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"lifecycle\" <$> TF.attribute",
                    "name": "_lifecycle",
                    "method": "lifecycle",
                    "conflicts": [],
                    "type": "TF.Attr s (InitContainerLifecycle s)",
                    "class": "HasLifecycle",
                    "validate": true,
                    "optional": true,
                    "original": "lifecycle"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container liveness. Container will be restarted if the",
                        "probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"liveness_probe\" <$> TF.attribute",
                    "name": "_livenessProbe",
                    "method": "livenessProbe",
                    "conflicts": [],
                    "type": "TF.Attr s (InitContainerLivenessProbe s)",
                    "class": "HasLivenessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "liveness_probe"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of ports to expose from the container. Exposing a port here gives the",
                        "system additional information about the network connections a container",
                        "uses, but is primarily informational. Not specifying a port here DOES NOT",
                        "prevent that port from being exposed. Any port which is listening on the",
                        "default \"0.0.0.0\" address inside a container will be accessible from the",
                        "network. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (InitContainerPort s)]",
                    "class": "HasPort",
                    "validate": true,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container service readiness. Container will be removed",
                        "from service endpoints if the probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"readiness_probe\" <$> TF.attribute",
                    "name": "_readinessProbe",
                    "method": "readinessProbe",
                    "conflicts": [],
                    "type": "TF.Attr s (InitContainerReadinessProbe s)",
                    "class": "HasReadinessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "readiness_probe"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Security options the pod should run with. More info:",
                        "http://releases.k8s.io/HEAD/docs/design/security_context.md"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"security_context\" <$> TF.attribute",
                    "name": "_securityContext",
                    "method": "securityContext",
                    "conflicts": [],
                    "type": "TF.Attr s (InitContainerSecurityContext s)",
                    "class": "HasSecurityContext",
                    "validate": true,
                    "optional": true,
                    "original": "security_context"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a buffer for stdin in the container",
                        "runtime. If this is not set, reads from stdin in the container will always",
                        "result in EOF."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"stdin\" <$> TF.attribute",
                    "name": "_stdin",
                    "method": "stdin",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdin",
                    "validate": false,
                    "optional": true,
                    "original": "stdin"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether the container runtime should close the stdin channel after it has",
                        "been opened by a single attach. When stdin is true the stdin stream will",
                        "remain open across multiple attach sessions. If stdinOnce is set to true,",
                        "stdin is opened on container start, is empty until the first client attaches",
                        "to stdin, and then remains open and accepts data until the client",
                        "disconnects, at which time stdin is closed and remains closed until the",
                        "container is restarted. If this flag is false, a container processes that",
                        "reads from stdin will never receive an EOF."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"stdin_once\" <$> TF.attribute",
                    "name": "_stdinOnce",
                    "method": "stdinOnce",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdinOnce",
                    "validate": false,
                    "optional": true,
                    "original": "stdin_once"
                },
                {
                    "default": "TF.value \"/dev/termination-log\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: Path at which the file to which the container's termination",
                        "message will be written is mounted into the container's filesystem. Message",
                        "written is intended to be brief final status, such as an assertion failure",
                        "message. Defaults to /dev/termination-log. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"termination_message_path\" <$> TF.attribute",
                    "name": "_terminationMessagePath",
                    "method": "terminationMessagePath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTerminationMessagePath",
                    "validate": false,
                    "optional": true,
                    "original": "termination_message_path"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a TTY for itself"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"tty\" <$> TF.attribute",
                    "name": "_tty",
                    "method": "tty",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasTty",
                    "validate": false,
                    "optional": true,
                    "original": "tty"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Pod volumes to mount into the container's filesystem. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"volume_mount\" <$> TF.attribute",
                    "name": "_volumeMount",
                    "method": "volumeMount",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (InitContainerVolumeMount s)]",
                    "class": "HasVolumeMount",
                    "validate": true,
                    "optional": true,
                    "original": "volume_mount"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Container's working directory. If not specified, the container runtime's",
                        "default will be used, which might be configured in the container image.",
                        "Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"working_dir\" <$> TF.attribute",
                    "name": "_workingDir",
                    "method": "workingDir",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasWorkingDir",
                    "validate": false,
                    "optional": true,
                    "original": "working_dir"
                }
            ],
            "name": "SpecInitContainer",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if",
                        ":latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/images#updating-images"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"image_pull_policy\" <$> TF.attribute",
                    "name": "_computedImagePullPolicy",
                    "method": "computedImagePullPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedImagePullPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "image_pull_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Compute Resources required by this container. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_computedResources",
                    "method": "computedResources",
                    "conflicts": [],
                    "type": "TF.Attr s (InitContainerResources s)",
                    "class": "HasComputedResources",
                    "validate": true,
                    "optional": true,
                    "original": "resources"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "SpecInitContainer s",
            "original": "spec_init_container"
        },
        {
            "con": {
                "smart": "newInitContainerLifecycle",
                "name": "InitContainerLifecycle'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Post_start is called immediately after a container is created. If the",
                        "handler fails, the container is terminated and restarted according to its",
                        "restart policy. Other management of the container blocks until the hook",
                        "completes. More info:",
                        "http://kubernetes.io/docs/user-guide/container-environment#hook-details"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"post_start\" <$> TF.attribute",
                    "name": "_postStart",
                    "method": "postStart",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (LifecyclePostStart s)]",
                    "class": "HasPostStart",
                    "validate": true,
                    "optional": true,
                    "original": "post_start"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Pre_stop is called immediately before a container is terminated. The",
                        "container is terminated after the handler completes. The reason for",
                        "termination is passed to the handler. Regardless of the outcome of the",
                        "handler, the container is eventually terminated. Other management of the",
                        "container blocks until the hook completes. More info:",
                        "http://kubernetes.io/docs/user-guide/container-environment#hook-details"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pre_stop\" <$> TF.attribute",
                    "name": "_preStop",
                    "method": "preStop",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (LifecyclePreStop s)]",
                    "class": "HasPreStop",
                    "validate": true,
                    "optional": true,
                    "original": "pre_stop"
                }
            ],
            "name": "InitContainerLifecycle",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "InitContainerLifecycle s",
            "original": "init_container_lifecycle"
        },
        {
            "con": {
                "smart": "newVolumeCephFs",
                "name": "VolumeCephFs'"
            },
            "arguments": [
                {
                    "default": "_monitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Monitors is a collection of Ceph monitors More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"monitors\" <$> TF.attribute",
                    "name": "_monitors",
                    "method": "monitors",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "monitors"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Used as the mounted root, rather than the full Ceph tree, default is /"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to `false`",
                        "(read/write). More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The path to key ring for User, default is /etc/ceph/user.secret More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_file\" <$> TF.attribute",
                    "name": "_secretFile",
                    "method": "secretFile",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretFile",
                    "validate": false,
                    "optional": true,
                    "original": "secret_file"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Reference to the authentication secret for User, default is empty. More",
                        "info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "_secretRef",
                    "method": "secretRef",
                    "conflicts": [],
                    "type": "TF.Attr s (CephFsSecretRef s)",
                    "class": "HasSecretRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User is the rados user name, default is admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "_user",
                    "method": "user",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "validate": false,
                    "optional": true,
                    "original": "user"
                }
            ],
            "name": "VolumeCephFs",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_monitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Monitors is a collection of Ceph monitors More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"monitors\" <$> TF.attribute",
                    "name": "_monitors",
                    "method": "monitors",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "monitors"
                }
            ],
            "conflicts": [],
            "type": "VolumeCephFs s",
            "original": "volume_ceph_fs"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSourceCephFs",
                "name": "PersistentVolumeSourceCephFs'"
            },
            "arguments": [
                {
                    "default": "_monitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Monitors is a collection of Ceph monitors More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"monitors\" <$> TF.attribute",
                    "name": "_monitors",
                    "method": "monitors",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "monitors"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Used as the mounted root, rather than the full Ceph tree, default is /"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to `false`",
                        "(read/write). More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The path to key ring for User, default is /etc/ceph/user.secret More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_file\" <$> TF.attribute",
                    "name": "_secretFile",
                    "method": "secretFile",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretFile",
                    "validate": false,
                    "optional": true,
                    "original": "secret_file"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Reference to the authentication secret for User, default is empty. More",
                        "info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "_secretRef",
                    "method": "secretRef",
                    "conflicts": [],
                    "type": "TF.Attr s (CephFsSecretRef s)",
                    "class": "HasSecretRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User is the rados user name, default is admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "_user",
                    "method": "user",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "validate": false,
                    "optional": true,
                    "original": "user"
                }
            ],
            "name": "PersistentVolumeSourceCephFs",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_monitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Monitors is a collection of Ceph monitors More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"monitors\" <$> TF.attribute",
                    "name": "_monitors",
                    "method": "monitors",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "monitors"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSourceCephFs s",
            "original": "persistent_volume_source_ceph_fs"
        },
        {
            "con": {
                "smart": "newReadinessProbeHttpGet",
                "name": "ReadinessProbeHttpGet'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host name to connect to, defaults to the pod IP. You probably want to set",
                        "\"Host\" in httpHeaders instead."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "_host",
                    "method": "host",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHost",
                    "validate": false,
                    "optional": true,
                    "original": "host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_header\" <$> TF.attribute",
                    "name": "_httpHeader",
                    "method": "httpHeader",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (HttpGetHttpHeader s)]",
                    "class": "HasHttpHeader",
                    "validate": true,
                    "optional": true,
                    "original": "http_header"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path to access on the HTTP server."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name or number of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.value \"HTTP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scheme\" <$> TF.attribute",
                    "name": "_scheme",
                    "method": "scheme",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScheme",
                    "validate": false,
                    "optional": true,
                    "original": "scheme"
                }
            ],
            "name": "ReadinessProbeHttpGet",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReadinessProbeHttpGet s",
            "original": "readiness_probe_http_get"
        },
        {
            "con": {
                "smart": "newSpecPort",
                "name": "SpecPort'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The name of this port within the service. All ports within the service must",
                        "have unique names. Optional if only one ServicePort is defined on this",
                        "service."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The port that will be exposed by this service."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                },
                {
                    "default": "TF.value \"TCP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The IP protocol for this port. Supports `TCP` and `UDP`. Default is `TCP`."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"protocol\" <$> TF.attribute",
                    "name": "_protocol",
                    "method": "protocol",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasProtocol",
                    "validate": false,
                    "optional": true,
                    "original": "protocol"
                }
            ],
            "name": "SpecPort",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The port on each node on which this service is exposed when `type` is",
                        "`NodePort` or `LoadBalancer`. Usually assigned by the system. If specified,",
                        "it will be allocated to the service if unused or else creation of the",
                        "service will fail. Default is to auto-allocate a port if the `type` of this",
                        "service requires one. More info:",
                        "http://kubernetes.io/docs/user-guide/services#type--nodeport"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"node_port\" <$> TF.attribute",
                    "name": "_computedNodePort",
                    "method": "computedNodePort",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedNodePort",
                    "validate": false,
                    "optional": true,
                    "original": "node_port"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Number or name of the port to access on the pods targeted by the service.",
                        "Number must be in the range 1 to 65535. This field is ignored for services",
                        "with `cluster_ip = \"None\"`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#defining-a-service"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_port\" <$> TF.attribute",
                    "name": "_computedTargetPort",
                    "method": "computedTargetPort",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedTargetPort",
                    "validate": false,
                    "optional": true,
                    "original": "target_port"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The name of this port within the service. All ports within the service must",
                        "have unique names. Optional if only one ServicePort is defined on this",
                        "service."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The port on each node on which this service is exposed when `type` is",
                        "`NodePort` or `LoadBalancer`. Usually assigned by the system. If specified,",
                        "it will be allocated to the service if unused or else creation of the",
                        "service will fail. Default is to auto-allocate a port if the `type` of this",
                        "service requires one. More info:",
                        "http://kubernetes.io/docs/user-guide/services#type--nodeport"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"node_port\" <$> TF.attribute",
                    "name": "_computedNodePort",
                    "method": "computedNodePort",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedNodePort",
                    "validate": false,
                    "optional": false,
                    "original": "node_port"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The port that will be exposed by this service."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_computedPort",
                    "method": "computedPort",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The IP protocol for this port. Supports `TCP` and `UDP`. Default is `TCP`."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"protocol\" <$> TF.attribute",
                    "name": "_computedProtocol",
                    "method": "computedProtocol",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedProtocol",
                    "validate": false,
                    "optional": false,
                    "original": "protocol"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Number or name of the port to access on the pods targeted by the service.",
                        "Number must be in the range 1 to 65535. This field is ignored for services",
                        "with `cluster_ip = \"None\"`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#defining-a-service"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_port\" <$> TF.attribute",
                    "name": "_computedTargetPort",
                    "method": "computedTargetPort",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedTargetPort",
                    "validate": false,
                    "optional": false,
                    "original": "target_port"
                }
            ],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The port that will be exposed by this service."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "SpecPort s",
            "original": "spec_port"
        },
        {
            "con": {
                "smart": "newRbdSecretRef",
                "name": "RbdSecretRef'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "name": "RbdSecretRef",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "RbdSecretRef s",
            "original": "rbd_secret_ref"
        },
        {
            "con": {
                "smart": "newConfigMapMetadata",
                "name": "ConfigMapMetadata'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the config map that may be used to",
                        "store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the config map. May match selectors of replication",
                        "controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Namespace defines the space within which name of the config map must be",
                        "unique."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"namespace\" <$> TF.attribute",
                    "name": "_namespace",
                    "method": "namespace",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNamespace",
                    "validate": false,
                    "optional": true,
                    "original": "namespace"
                }
            ],
            "name": "ConfigMapMetadata",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the config map, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "conflicts": [
                        "_generateName"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this config map that",
                        "can be used by clients to determine when config map has changed. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this config map."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this config map. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "ConfigMapMetadata s",
            "original": "config_map_metadata"
        },
        {
            "con": {
                "smart": "newInitContainerSecurityContext",
                "name": "InitContainerSecurityContext'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The capabilities to add/drop when running containers. Defaults to the",
                        "default set of capabilities granted by the container runtime."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"capabilities\" <$> TF.attribute",
                    "name": "_capabilities",
                    "method": "capabilities",
                    "conflicts": [],
                    "type": "TF.Attr s (SecurityContextCapabilities s)",
                    "class": "HasCapabilities",
                    "validate": true,
                    "optional": true,
                    "original": "capabilities"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Run container in privileged mode. Processes in privileged containers are",
                        "essentially equivalent to root on the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"privileged\" <$> TF.attribute",
                    "name": "_privileged",
                    "method": "privileged",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasPrivileged",
                    "validate": false,
                    "optional": true,
                    "original": "privileged"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container has a read-only root filesystem."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only_root_filesystem\" <$> TF.attribute",
                    "name": "_readOnlyRootFilesystem",
                    "method": "readOnlyRootFilesystem",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnlyRootFilesystem",
                    "validate": false,
                    "optional": true,
                    "original": "read_only_root_filesystem"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Indicates that the container must run as a non-root user. If true, the",
                        "Kubelet will validate the image at runtime to ensure that it does not run as",
                        "UID 0 (root) and fail to start the container if it does."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_non_root\" <$> TF.attribute",
                    "name": "_runAsNonRoot",
                    "method": "runAsNonRoot",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRunAsNonRoot",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_non_root"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The UID to run the entrypoint of the container process. Defaults to user",
                        "specified in image metadata if unspecified"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_user\" <$> TF.attribute",
                    "name": "_runAsUser",
                    "method": "runAsUser",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasRunAsUser",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_user"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ImagePullSecrets is an optional list of references to secrets in the same",
                        "namespace to use for pulling any of the images used by this PodSpec. If",
                        "specified, these secrets will be passed to individual puller implementations",
                        "for them to use. For example, in the case of docker, only DockerConfig type",
                        "secrets are honored. More info:",
                        "http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"se_linux_options\" <$> TF.attribute",
                    "name": "_seLinuxOptions",
                    "method": "seLinuxOptions",
                    "conflicts": [],
                    "type": "TF.Attr s (SecurityContextSeLinuxOptions s)",
                    "class": "HasSeLinuxOptions",
                    "validate": true,
                    "optional": true,
                    "original": "se_linux_options"
                }
            ],
            "name": "InitContainerSecurityContext",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "InitContainerSecurityContext s",
            "original": "init_container_security_context"
        },
        {
            "con": {
                "smart": "newPostStartExec",
                "name": "PostStartExec'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Command is the command line to execute inside the container, the working",
                        "directory for the command is root ('/') in the container's filesystem. The",
                        "command is simply exec'd, it is not run inside a shell, so traditional shell",
                        "instructions. To use a shell, you need to explicitly call out to that shell.",
                        "Exit status of 0 is treated as live/healthy and non-zero is unhealthy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                }
            ],
            "name": "PostStartExec",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PostStartExec s",
            "original": "post_start_exec"
        },
        {
            "con": {
                "smart": "newVolumeGcePersistentDisk",
                "name": "VolumeGcePersistentDisk'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The partition in the volume that you want to mount. If omitted, the default",
                        "is to mount by volume name. Examples: For volume /dev/sda1, you specify the",
                        "partition as \"1\". Similarly, the volume partition for /dev/sda is \"0\" (or",
                        "you can leave the property empty). More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"partition\" <$> TF.attribute",
                    "name": "_partition",
                    "method": "partition",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasPartition",
                    "validate": false,
                    "optional": true,
                    "original": "partition"
                },
                {
                    "default": "_pdName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique name of the PD resource in GCE. Used to identify the disk in GCE.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_name\" <$> TF.attribute",
                    "name": "_pdName",
                    "method": "pdName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdName",
                    "validate": false,
                    "optional": false,
                    "original": "pd_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the ReadOnly setting in VolumeMounts. Defaults to false.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "name": "VolumeGcePersistentDisk",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_pdName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique name of the PD resource in GCE. Used to identify the disk in GCE.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_name\" <$> TF.attribute",
                    "name": "_pdName",
                    "method": "pdName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdName",
                    "validate": false,
                    "optional": false,
                    "original": "pd_name"
                }
            ],
            "conflicts": [],
            "type": "VolumeGcePersistentDisk s",
            "original": "volume_gce_persistent_disk"
        },
        {
            "con": {
                "smart": "newContainerSecurityContext",
                "name": "ContainerSecurityContext'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The capabilities to add/drop when running containers. Defaults to the",
                        "default set of capabilities granted by the container runtime."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"capabilities\" <$> TF.attribute",
                    "name": "_capabilities",
                    "method": "capabilities",
                    "conflicts": [],
                    "type": "TF.Attr s (SecurityContextCapabilities s)",
                    "class": "HasCapabilities",
                    "validate": true,
                    "optional": true,
                    "original": "capabilities"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Run container in privileged mode. Processes in privileged containers are",
                        "essentially equivalent to root on the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"privileged\" <$> TF.attribute",
                    "name": "_privileged",
                    "method": "privileged",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasPrivileged",
                    "validate": false,
                    "optional": true,
                    "original": "privileged"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container has a read-only root filesystem."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only_root_filesystem\" <$> TF.attribute",
                    "name": "_readOnlyRootFilesystem",
                    "method": "readOnlyRootFilesystem",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnlyRootFilesystem",
                    "validate": false,
                    "optional": true,
                    "original": "read_only_root_filesystem"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Indicates that the container must run as a non-root user. If true, the",
                        "Kubelet will validate the image at runtime to ensure that it does not run as",
                        "UID 0 (root) and fail to start the container if it does."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_non_root\" <$> TF.attribute",
                    "name": "_runAsNonRoot",
                    "method": "runAsNonRoot",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRunAsNonRoot",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_non_root"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The UID to run the entrypoint of the container process. Defaults to user",
                        "specified in image metadata if unspecified"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_user\" <$> TF.attribute",
                    "name": "_runAsUser",
                    "method": "runAsUser",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasRunAsUser",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_user"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ImagePullSecrets is an optional list of references to secrets in the same",
                        "namespace to use for pulling any of the images used by this PodSpec. If",
                        "specified, these secrets will be passed to individual puller implementations",
                        "for them to use. For example, in the case of docker, only DockerConfig type",
                        "secrets are honored. More info:",
                        "http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"se_linux_options\" <$> TF.attribute",
                    "name": "_seLinuxOptions",
                    "method": "seLinuxOptions",
                    "conflicts": [],
                    "type": "TF.Attr s (SecurityContextSeLinuxOptions s)",
                    "class": "HasSeLinuxOptions",
                    "validate": true,
                    "optional": true,
                    "original": "se_linux_options"
                }
            ],
            "name": "ContainerSecurityContext",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ContainerSecurityContext s",
            "original": "container_security_context"
        },
        {
            "con": {
                "smart": "newHttpGetHttpHeader",
                "name": "HttpGetHttpHeader'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                }
            ],
            "name": "HttpGetHttpHeader",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "HttpGetHttpHeader s",
            "original": "http_get_http_header"
        },
        {
            "con": {
                "smart": "newVolumeQuobyte",
                "name": "VolumeQuobyte'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Group to map volume access to Default is no group"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"group\" <$> TF.attribute",
                    "name": "_group",
                    "method": "group",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGroup",
                    "validate": false,
                    "optional": true,
                    "original": "group"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the Quobyte volume to be mounted with read-only",
                        "permissions. Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_registry",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Registry represents a single or multiple Quobyte Registry services specified",
                        "as a string as host:port pair (multiple entries are separated with commas)",
                        "which acts as the central registry for volumes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"registry\" <$> TF.attribute",
                    "name": "_registry",
                    "method": "registry",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRegistry",
                    "validate": false,
                    "optional": false,
                    "original": "registry"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User to map volume access to Defaults to serivceaccount user"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "_user",
                    "method": "user",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "validate": false,
                    "optional": true,
                    "original": "user"
                },
                {
                    "default": "_volume",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume is a string that references an already created Quobyte volume by",
                        "name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "_volume",
                    "method": "volume",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolume",
                    "validate": false,
                    "optional": false,
                    "original": "volume"
                }
            ],
            "name": "VolumeQuobyte",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_registry",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Registry represents a single or multiple Quobyte Registry services specified",
                        "as a string as host:port pair (multiple entries are separated with commas)",
                        "which acts as the central registry for volumes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"registry\" <$> TF.attribute",
                    "name": "_registry",
                    "method": "registry",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRegistry",
                    "validate": false,
                    "optional": false,
                    "original": "registry"
                },
                {
                    "default": "_volume",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume is a string that references an already created Quobyte volume by",
                        "name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "_volume",
                    "method": "volume",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolume",
                    "validate": false,
                    "optional": false,
                    "original": "volume"
                }
            ],
            "conflicts": [],
            "type": "VolumeQuobyte s",
            "original": "volume_quobyte"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSourceGcePersistentDisk",
                "name": "PersistentVolumeSourceGcePersistentDisk'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The partition in the volume that you want to mount. If omitted, the default",
                        "is to mount by volume name. Examples: For volume /dev/sda1, you specify the",
                        "partition as \"1\". Similarly, the volume partition for /dev/sda is \"0\" (or",
                        "you can leave the property empty). More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"partition\" <$> TF.attribute",
                    "name": "_partition",
                    "method": "partition",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasPartition",
                    "validate": false,
                    "optional": true,
                    "original": "partition"
                },
                {
                    "default": "_pdName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique name of the PD resource in GCE. Used to identify the disk in GCE.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_name\" <$> TF.attribute",
                    "name": "_pdName",
                    "method": "pdName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdName",
                    "validate": false,
                    "optional": false,
                    "original": "pd_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the ReadOnly setting in VolumeMounts. Defaults to false.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "name": "PersistentVolumeSourceGcePersistentDisk",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_pdName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique name of the PD resource in GCE. Used to identify the disk in GCE.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_name\" <$> TF.attribute",
                    "name": "_pdName",
                    "method": "pdName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdName",
                    "validate": false,
                    "optional": false,
                    "original": "pd_name"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSourceGcePersistentDisk s",
            "original": "persistent_volume_source_gce_persistent_disk"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSourceQuobyte",
                "name": "PersistentVolumeSourceQuobyte'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Group to map volume access to Default is no group"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"group\" <$> TF.attribute",
                    "name": "_group",
                    "method": "group",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGroup",
                    "validate": false,
                    "optional": true,
                    "original": "group"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the Quobyte volume to be mounted with read-only",
                        "permissions. Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_registry",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Registry represents a single or multiple Quobyte Registry services specified",
                        "as a string as host:port pair (multiple entries are separated with commas)",
                        "which acts as the central registry for volumes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"registry\" <$> TF.attribute",
                    "name": "_registry",
                    "method": "registry",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRegistry",
                    "validate": false,
                    "optional": false,
                    "original": "registry"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User to map volume access to Defaults to serivceaccount user"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "_user",
                    "method": "user",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "validate": false,
                    "optional": true,
                    "original": "user"
                },
                {
                    "default": "_volume",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume is a string that references an already created Quobyte volume by",
                        "name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "_volume",
                    "method": "volume",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolume",
                    "validate": false,
                    "optional": false,
                    "original": "volume"
                }
            ],
            "name": "PersistentVolumeSourceQuobyte",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_registry",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Registry represents a single or multiple Quobyte Registry services specified",
                        "as a string as host:port pair (multiple entries are separated with commas)",
                        "which acts as the central registry for volumes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"registry\" <$> TF.attribute",
                    "name": "_registry",
                    "method": "registry",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRegistry",
                    "validate": false,
                    "optional": false,
                    "original": "registry"
                },
                {
                    "default": "_volume",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume is a string that references an already created Quobyte volume by",
                        "name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "_volume",
                    "method": "volume",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolume",
                    "validate": false,
                    "optional": false,
                    "original": "volume"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSourceQuobyte s",
            "original": "persistent_volume_source_quobyte"
        },
        {
            "con": {
                "smart": "newResourceQuotaMetadata",
                "name": "ResourceQuotaMetadata'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the resource quota that may be",
                        "used to store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the resource quota. May match selectors of replication",
                        "controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Namespace defines the space within which name of the resource quota must be",
                        "unique."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"namespace\" <$> TF.attribute",
                    "name": "_namespace",
                    "method": "namespace",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNamespace",
                    "validate": false,
                    "optional": true,
                    "original": "namespace"
                }
            ],
            "name": "ResourceQuotaMetadata",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the resource quota, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "conflicts": [
                        "_generateName"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this resource quota",
                        "that can be used by clients to determine when resource quota has changed.",
                        "Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this resource quota."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this resource quota. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "ResourceQuotaMetadata s",
            "original": "resource_quota_metadata"
        },
        {
            "con": {
                "smart": "newVolumeSecret",
                "name": "VolumeSecret'"
            },
            "arguments": [
                {
                    "default": "TF.value 420",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on created files by default. Must be a value",
                        "between 0 and 0777. Defaults to 0644. Directories within the path are not",
                        "affected by this setting. This might be in conflict with other options that",
                        "affect the file mode, like fsGroup, and the result can be other mode bits",
                        "set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_mode\" <$> TF.attribute",
                    "name": "_defaultMode",
                    "method": "defaultMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasDefaultMode",
                    "validate": false,
                    "optional": true,
                    "original": "default_mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If unspecified, each key-value pair in the Data field of the referenced",
                        "Secret will be projected into the volume as a file whose name is the key and",
                        "content is the value. If specified, the listed keys will be projected into",
                        "the specified paths, and unlisted keys will not be present. If a key is",
                        "specified which is not present in the Secret, the volume setup will error",
                        "unless it is marked optional. Paths must be relative and may not contain the",
                        "'..' path or start with '..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"items\" <$> TF.attribute",
                    "name": "_items",
                    "method": "items",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (SecretItems s)]",
                    "class": "HasItems",
                    "validate": true,
                    "optional": true,
                    "original": "items"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: Specify whether the Secret or it's keys must be defined."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"optional\" <$> TF.attribute",
                    "name": "_optional",
                    "method": "optional",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasOptional",
                    "validate": false,
                    "optional": true,
                    "original": "optional"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the secret in the pod's namespace to use. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#secrets"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_name\" <$> TF.attribute",
                    "name": "_secretName",
                    "method": "secretName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretName",
                    "validate": false,
                    "optional": true,
                    "original": "secret_name"
                }
            ],
            "name": "VolumeSecret",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "VolumeSecret s",
            "original": "volume_secret"
        },
        {
            "con": {
                "smart": "newPodMetadata",
                "name": "PodMetadata'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the pod that may be used to store",
                        "arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the pod. May match selectors of replication controllers",
                        "and services. More info: http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Namespace defines the space within which name of the pod must be unique."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"namespace\" <$> TF.attribute",
                    "name": "_namespace",
                    "method": "namespace",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNamespace",
                    "validate": false,
                    "optional": true,
                    "original": "namespace"
                }
            ],
            "name": "PodMetadata",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the pod, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "conflicts": [
                        "_generateName"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this pod that can be",
                        "used by clients to determine when pod has changed. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this pod. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "PodMetadata s",
            "original": "pod_metadata"
        },
        {
            "con": {
                "smart": "newContainerPort",
                "name": "ContainerPort'"
            },
            "arguments": [
                {
                    "default": "_containerPort",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number of port to expose on the pod's IP address. This must be a valid port",
                        "number, 0 < x < 65536."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_port\" <$> TF.attribute",
                    "name": "_containerPort",
                    "method": "containerPort",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasContainerPort",
                    "validate": false,
                    "optional": false,
                    "original": "container_port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "What host IP to bind the external port to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_ip\" <$> TF.attribute",
                    "name": "_hostIp",
                    "method": "hostIp",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostIp",
                    "validate": false,
                    "optional": true,
                    "original": "host_ip"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of port to expose on the host. If specified, this must be a valid",
                        "port number, 0 < x < 65536. If HostNetwork is specified, this must match",
                        "ContainerPort. Most containers do not need this."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_port\" <$> TF.attribute",
                    "name": "_hostPort",
                    "method": "hostPort",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasHostPort",
                    "validate": false,
                    "optional": true,
                    "original": "host_port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If specified, this must be an IANA_SVC_NAME and unique within the pod. Each",
                        "named port in a pod must have a unique name. Name for the port that can be",
                        "referred to by services"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.value \"TCP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Protocol for port. Must be UDP or TCP. Defaults to \"TCP\"."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"protocol\" <$> TF.attribute",
                    "name": "_protocol",
                    "method": "protocol",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasProtocol",
                    "validate": false,
                    "optional": true,
                    "original": "protocol"
                }
            ],
            "name": "ContainerPort",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_containerPort",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number of port to expose on the pod's IP address. This must be a valid port",
                        "number, 0 < x < 65536."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_port\" <$> TF.attribute",
                    "name": "_containerPort",
                    "method": "containerPort",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasContainerPort",
                    "validate": false,
                    "optional": false,
                    "original": "container_port"
                }
            ],
            "conflicts": [],
            "type": "ContainerPort s",
            "original": "container_port"
        },
        {
            "con": {
                "smart": "newPodSpec",
                "name": "PodSpec'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional duration in seconds the pod may be active on the node relative to",
                        "StartTime before the system will actively try to mark it failed and kill",
                        "associated containers. Value must be a positive integer."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"active_deadline_seconds\" <$> TF.attribute",
                    "name": "_activeDeadlineSeconds",
                    "method": "activeDeadlineSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasActiveDeadlineSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "active_deadline_seconds"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of containers belonging to the pod. Containers cannot currently be",
                        "added or removed. There must be at least one container in a Pod. Cannot be",
                        "updated. More info: http://kubernetes.io/docs/user-guide/containers"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"container\" <$> TF.attribute",
                    "name": "_container",
                    "method": "container",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (SpecContainer s)]",
                    "class": "HasContainer",
                    "validate": true,
                    "optional": true,
                    "original": "container"
                },
                {
                    "default": "TF.value \"ClusterFirst\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Set DNS policy for containers within the pod. One of 'ClusterFirst' or",
                        "'Default'. Defaults to 'ClusterFirst'."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"dns_policy\" <$> TF.attribute",
                    "name": "_dnsPolicy",
                    "method": "dnsPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDnsPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "dns_policy"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Use the host's ipc namespace. Optional: Default to false."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_ipc\" <$> TF.attribute",
                    "name": "_hostIpc",
                    "method": "hostIpc",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostIpc",
                    "validate": false,
                    "optional": true,
                    "original": "host_ipc"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host networking requested for this pod. Use the host's network namespace. If",
                        "this option is set, the ports that will be used must be specified."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_network\" <$> TF.attribute",
                    "name": "_hostNetwork",
                    "method": "hostNetwork",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostNetwork",
                    "validate": false,
                    "optional": true,
                    "original": "host_network"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Use the host's pid namespace."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_pid\" <$> TF.attribute",
                    "name": "_hostPid",
                    "method": "hostPid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostPid",
                    "validate": false,
                    "optional": true,
                    "original": "host_pid"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of init containers belonging to the pod. Init containers always run to",
                        "completion and each must complete succesfully before the next is started.",
                        "More info:",
                        "https://kubernetes.io/docs/concepts/workloads/pods/init-containers/"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"init_container\" <$> TF.attribute",
                    "name": "_initContainer",
                    "method": "initContainer",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (SpecInitContainer s)]",
                    "class": "HasInitContainer",
                    "validate": true,
                    "optional": true,
                    "original": "init_container"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "NodeSelector is a selector which must be true for the pod to fit on a node.",
                        "Selector which must match a node's labels for the pod to be scheduled on",
                        "that node. More info: http://kubernetes.io/docs/user-guide/node-selection."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"node_selector\" <$> TF.attribute",
                    "name": "_nodeSelector",
                    "method": "nodeSelector",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasNodeSelector",
                    "validate": false,
                    "optional": true,
                    "original": "node_selector"
                },
                {
                    "default": "TF.value \"Always\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Restart policy for all containers within the pod. One of Always, OnFailure,",
                        "Never. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#restartpolicy."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"restart_policy\" <$> TF.attribute",
                    "name": "_restartPolicy",
                    "method": "restartPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRestartPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "restart_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "SecurityContext holds pod-level security attributes and common container",
                        "settings. Optional: Defaults to empty"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"security_context\" <$> TF.attribute",
                    "name": "_securityContext",
                    "method": "securityContext",
                    "conflicts": [],
                    "type": "TF.Attr s (SpecSecurityContext s)",
                    "class": "HasSecurityContext",
                    "validate": true,
                    "optional": true,
                    "original": "security_context"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If specified, the fully qualified Pod hostname will be \"...svc.\". If not",
                        "specified, the pod will not have a domainname at all.."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"subdomain\" <$> TF.attribute",
                    "name": "_subdomain",
                    "method": "subdomain",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSubdomain",
                    "validate": false,
                    "optional": true,
                    "original": "subdomain"
                },
                {
                    "default": "TF.value 30",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional duration in seconds the pod needs to terminate gracefully. May be",
                        "decreased in delete request. Value must be non-negative integer. The value",
                        "zero indicates delete immediately. If this value is nil, the default grace",
                        "period will be used instead. The grace period is the duration in seconds",
                        "after the processes running in the pod are sent a termination signal and the",
                        "time when the processes are forcibly halted with a kill signal. Set this",
                        "value longer than the expected cleanup time for your process."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"termination_grace_period_seconds\" <$> TF.attribute",
                    "name": "_terminationGracePeriodSeconds",
                    "method": "terminationGracePeriodSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasTerminationGracePeriodSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "termination_grace_period_seconds"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of volumes that can be mounted by containers belonging to the pod. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "_volume",
                    "method": "volume",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (SpecVolume s)]",
                    "class": "HasVolume",
                    "validate": true,
                    "optional": true,
                    "original": "volume"
                }
            ],
            "name": "PodSpec",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Specifies the hostname of the Pod If not specified, the pod's hostname will",
                        "be set to a system-defined value."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"hostname\" <$> TF.attribute",
                    "name": "_computedHostname",
                    "method": "computedHostname",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedHostname",
                    "validate": false,
                    "optional": true,
                    "original": "hostname"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "ImagePullSecrets is an optional list of references to secrets in the same",
                        "namespace to use for pulling any of the images used by this PodSpec. If",
                        "specified, these secrets will be passed to individual puller implementations",
                        "for them to use. For example, in the case of docker, only DockerConfig type",
                        "secrets are honored. More info:",
                        "http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"image_pull_secrets\" <$> TF.attribute",
                    "name": "_computedImagePullSecrets",
                    "method": "computedImagePullSecrets",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (SpecImagePullSecrets s)]",
                    "class": "HasComputedImagePullSecrets",
                    "validate": true,
                    "optional": true,
                    "original": "image_pull_secrets"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "NodeName is a request to schedule this pod onto a specific node. If it is",
                        "non-empty, the scheduler simply schedules this pod onto that node, assuming",
                        "that it fits resource requirements."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"node_name\" <$> TF.attribute",
                    "name": "_computedNodeName",
                    "method": "computedNodeName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedNodeName",
                    "validate": false,
                    "optional": true,
                    "original": "node_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "ServiceAccountName is the name of the ServiceAccount to use to run this pod.",
                        "More info: http://releases.k8s.io/HEAD/docs/design/service_accounts.md."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"service_account_name\" <$> TF.attribute",
                    "name": "_computedServiceAccountName",
                    "method": "computedServiceAccountName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedServiceAccountName",
                    "validate": false,
                    "optional": true,
                    "original": "service_account_name"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "PodSpec s",
            "original": "pod_spec"
        },
        {
            "con": {
                "smart": "newReadinessProbeExec",
                "name": "ReadinessProbeExec'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Command is the command line to execute inside the container, the working",
                        "directory for the command is root ('/') in the container's filesystem. The",
                        "command is simply exec'd, it is not run inside a shell, so traditional shell",
                        "instructions. To use a shell, you need to explicitly call out to that shell.",
                        "Exit status of 0 is treated as live/healthy and non-zero is unhealthy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                }
            ],
            "name": "ReadinessProbeExec",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReadinessProbeExec s",
            "original": "readiness_probe_exec"
        },
        {
            "con": {
                "smart": "newValueFromFieldRef",
                "name": "ValueFromFieldRef'"
            },
            "arguments": [
                {
                    "default": "TF.value \"v1\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Version of the schema the FieldPath is written in terms of, defaults to",
                        "\"v1\"."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"api_version\" <$> TF.attribute",
                    "name": "_apiVersion",
                    "method": "apiVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasApiVersion",
                    "validate": false,
                    "optional": true,
                    "original": "api_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path of the field to select in the specified API version"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_path\" <$> TF.attribute",
                    "name": "_fieldPath",
                    "method": "fieldPath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFieldPath",
                    "validate": false,
                    "optional": true,
                    "original": "field_path"
                }
            ],
            "name": "ValueFromFieldRef",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ValueFromFieldRef s",
            "original": "value_from_field_ref"
        },
        {
            "con": {
                "smart": "newTemplateSecurityContext",
                "name": "TemplateSecurityContext'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A special supplemental group that applies to all containers in a pod. Some",
                        "volume types allow the Kubelet to change the ownership of that volume to be",
                        "owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is",
                        "set (new files created in the volume will be owned by FSGroup) 3. The",
                        "permission bits are OR'd with rw-rw---- If unset, the Kubelet will not",
                        "modify the ownership and permissions of any volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_group\" <$> TF.attribute",
                    "name": "_fsGroup",
                    "method": "fsGroup",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasFsGroup",
                    "validate": false,
                    "optional": true,
                    "original": "fs_group"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Indicates that the container must run as a non-root user. If true, the",
                        "Kubelet will validate the image at runtime to ensure that it does not run as",
                        "UID 0 (root) and fail to start the container if it does."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_non_root\" <$> TF.attribute",
                    "name": "_runAsNonRoot",
                    "method": "runAsNonRoot",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRunAsNonRoot",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_non_root"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The UID to run the entrypoint of the container process. Defaults to user",
                        "specified in image metadata if unspecified"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_user\" <$> TF.attribute",
                    "name": "_runAsUser",
                    "method": "runAsUser",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasRunAsUser",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_user"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The SELinux context to be applied to all containers. If unspecified, the",
                        "container runtime will allocate a random SELinux context for each container.",
                        "May also be set in SecurityContext. If set in both SecurityContext and",
                        "PodSecurityContext, the value specified in SecurityContext takes precedence",
                        "for that container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"se_linux_options\" <$> TF.attribute",
                    "name": "_seLinuxOptions",
                    "method": "seLinuxOptions",
                    "conflicts": [],
                    "type": "TF.Attr s (SecurityContextSeLinuxOptions s)",
                    "class": "HasSeLinuxOptions",
                    "validate": true,
                    "optional": true,
                    "original": "se_linux_options"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of groups applied to the first process run in each container, in",
                        "addition to the container's primary GID. If unspecified, no groups will be",
                        "added to any container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"supplemental_groups\" <$> TF.attribute",
                    "name": "_supplementalGroups",
                    "method": "supplementalGroups",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Integer]",
                    "class": "HasSupplementalGroups",
                    "validate": false,
                    "optional": true,
                    "original": "supplemental_groups"
                }
            ],
            "name": "TemplateSecurityContext",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "TemplateSecurityContext s",
            "original": "template_security_context"
        },
        {
            "con": {
                "smart": "newPostStartHttpGet",
                "name": "PostStartHttpGet'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host name to connect to, defaults to the pod IP. You probably want to set",
                        "\"Host\" in httpHeaders instead."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "_host",
                    "method": "host",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHost",
                    "validate": false,
                    "optional": true,
                    "original": "host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_header\" <$> TF.attribute",
                    "name": "_httpHeader",
                    "method": "httpHeader",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (HttpGetHttpHeader s)]",
                    "class": "HasHttpHeader",
                    "validate": true,
                    "optional": true,
                    "original": "http_header"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path to access on the HTTP server."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name or number of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.value \"HTTP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scheme\" <$> TF.attribute",
                    "name": "_scheme",
                    "method": "scheme",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScheme",
                    "validate": false,
                    "optional": true,
                    "original": "scheme"
                }
            ],
            "name": "PostStartHttpGet",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PostStartHttpGet s",
            "original": "post_start_http_get"
        },
        {
            "con": {
                "smart": "newResourceQuotaSpec",
                "name": "ResourceQuotaSpec'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The set of desired hard limits for each named resource. More info:",
                        "http://releases.k8s.io/HEAD/docs/design/admission_control_resource_quota.md#admissioncontrol-plugin-resourcequota"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"hard\" <$> TF.attribute",
                    "name": "_hard",
                    "method": "hard",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasHard",
                    "validate": false,
                    "optional": true,
                    "original": "hard"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A collection of filters that must match each object tracked by a quota. If",
                        "not specified, the quota matches all objects."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"scopes\" <$> TF.attribute",
                    "name": "_scopes",
                    "method": "scopes",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasScopes",
                    "validate": false,
                    "optional": true,
                    "original": "scopes"
                }
            ],
            "name": "ResourceQuotaSpec",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ResourceQuotaSpec s",
            "original": "resource_quota_spec"
        },
        {
            "con": {
                "smart": "newInitContainerResources",
                "name": "InitContainerResources'"
            },
            "arguments": [],
            "name": "InitContainerResources",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Describes the maximum amount of compute resources allowed. More info:",
                        "http://kubernetes.io/docs/user-guide/compute-resources/"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"limits\" <$> TF.attribute",
                    "name": "_computedLimits",
                    "method": "computedLimits",
                    "conflicts": [],
                    "type": "TF.Attr s (ResourcesLimits s)",
                    "class": "HasComputedLimits",
                    "validate": true,
                    "optional": true,
                    "original": "limits"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"requests\" <$> TF.attribute",
                    "name": "_computedRequests",
                    "method": "computedRequests",
                    "conflicts": [],
                    "type": "TF.Attr s (ResourcesRequests s)",
                    "class": "HasComputedRequests",
                    "validate": true,
                    "optional": true,
                    "original": "requests"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "InitContainerResources s",
            "original": "init_container_resources"
        },
        {
            "con": {
                "smart": "newInitContainerPort",
                "name": "InitContainerPort'"
            },
            "arguments": [
                {
                    "default": "_containerPort",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number of port to expose on the pod's IP address. This must be a valid port",
                        "number, 0 < x < 65536."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_port\" <$> TF.attribute",
                    "name": "_containerPort",
                    "method": "containerPort",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasContainerPort",
                    "validate": false,
                    "optional": false,
                    "original": "container_port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "What host IP to bind the external port to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_ip\" <$> TF.attribute",
                    "name": "_hostIp",
                    "method": "hostIp",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostIp",
                    "validate": false,
                    "optional": true,
                    "original": "host_ip"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of port to expose on the host. If specified, this must be a valid",
                        "port number, 0 < x < 65536. If HostNetwork is specified, this must match",
                        "ContainerPort. Most containers do not need this."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_port\" <$> TF.attribute",
                    "name": "_hostPort",
                    "method": "hostPort",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasHostPort",
                    "validate": false,
                    "optional": true,
                    "original": "host_port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If specified, this must be an IANA_SVC_NAME and unique within the pod. Each",
                        "named port in a pod must have a unique name. Name for the port that can be",
                        "referred to by services"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.value \"TCP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Protocol for port. Must be UDP or TCP. Defaults to \"TCP\"."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"protocol\" <$> TF.attribute",
                    "name": "_protocol",
                    "method": "protocol",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasProtocol",
                    "validate": false,
                    "optional": true,
                    "original": "protocol"
                }
            ],
            "name": "InitContainerPort",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_containerPort",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number of port to expose on the pod's IP address. This must be a valid port",
                        "number, 0 < x < 65536."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_port\" <$> TF.attribute",
                    "name": "_containerPort",
                    "method": "containerPort",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasContainerPort",
                    "validate": false,
                    "optional": false,
                    "original": "container_port"
                }
            ],
            "conflicts": [],
            "type": "InitContainerPort s",
            "original": "init_container_port"
        },
        {
            "con": {
                "smart": "newDownwardApiItems",
                "name": "DownwardApiItems'"
            },
            "arguments": [
                {
                    "default": "_fieldRef",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Required: Selects a field of the pod: only annotations, labels, name and",
                        "namespace are supported."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_ref\" <$> TF.attribute",
                    "name": "_fieldRef",
                    "method": "fieldRef",
                    "conflicts": [],
                    "type": "TF.Attr s (ItemsFieldRef s)",
                    "class": "HasFieldRef",
                    "validate": true,
                    "optional": false,
                    "original": "field_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on this file, must be a value between 0 and 0777.",
                        "If not specified, the volume defaultMode will be used. This might be in",
                        "conflict with other options that affect the file mode, like fsGroup, and the",
                        "result can be other mode bits set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mode\" <$> TF.attribute",
                    "name": "_mode",
                    "method": "mode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasMode",
                    "validate": false,
                    "optional": true,
                    "original": "mode"
                },
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path is the relative path name of the file to be created. Must not be",
                        "absolute or contain the '..' path. Must be utf-8 encoded. The first item of",
                        "the relative path must not start with '..'"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a resource of the container: only resources limits and requests",
                        "(limits.cpu, limits.memory, requests.cpu and requests.memory) are currently",
                        "supported."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_field_ref\" <$> TF.attribute",
                    "name": "_resourceFieldRef",
                    "method": "resourceFieldRef",
                    "conflicts": [],
                    "type": "TF.Attr s (ItemsResourceFieldRef s)",
                    "class": "HasResourceFieldRef",
                    "validate": true,
                    "optional": true,
                    "original": "resource_field_ref"
                }
            ],
            "name": "DownwardApiItems",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_fieldRef",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Required: Selects a field of the pod: only annotations, labels, name and",
                        "namespace are supported."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_ref\" <$> TF.attribute",
                    "name": "_fieldRef",
                    "method": "fieldRef",
                    "conflicts": [],
                    "type": "TF.Attr s (ItemsFieldRef s)",
                    "class": "HasFieldRef",
                    "validate": true,
                    "optional": false,
                    "original": "field_ref"
                },
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path is the relative path name of the file to be created. Must not be",
                        "absolute or contain the '..' path. Must be utf-8 encoded. The first item of",
                        "the relative path must not start with '..'"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                }
            ],
            "conflicts": [],
            "type": "DownwardApiItems s",
            "original": "downward_api_items"
        },
        {
            "con": {
                "smart": "newVolumeIscsi",
                "name": "VolumeIscsi'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#iscsi"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_iqn",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Target iSCSI Qualified Name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iqn\" <$> TF.attribute",
                    "name": "_iqn",
                    "method": "iqn",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIqn",
                    "validate": false,
                    "optional": false,
                    "original": "iqn"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ISCSI interface name that uses an iSCSI transport. Defaults to 'default'",
                        "(tcp)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi_interface\" <$> TF.attribute",
                    "name": "_iscsiInterface",
                    "method": "iscsiInterface",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIscsiInterface",
                    "validate": false,
                    "optional": true,
                    "original": "iscsi_interface"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ISCSI target lun number."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "_lun",
                    "method": "lun",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasLun",
                    "validate": false,
                    "optional": true,
                    "original": "lun"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_targetPortal",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ISCSI target portal. The portal is either an IP or ip_addr:port if the port",
                        "is other than default (typically TCP ports 860 and 3260)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_portal\" <$> TF.attribute",
                    "name": "_targetPortal",
                    "method": "targetPortal",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTargetPortal",
                    "validate": false,
                    "optional": false,
                    "original": "target_portal"
                }
            ],
            "name": "VolumeIscsi",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_iqn",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Target iSCSI Qualified Name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iqn\" <$> TF.attribute",
                    "name": "_iqn",
                    "method": "iqn",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIqn",
                    "validate": false,
                    "optional": false,
                    "original": "iqn"
                },
                {
                    "default": "_targetPortal",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ISCSI target portal. The portal is either an IP or ip_addr:port if the port",
                        "is other than default (typically TCP ports 860 and 3260)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_portal\" <$> TF.attribute",
                    "name": "_targetPortal",
                    "method": "targetPortal",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTargetPortal",
                    "validate": false,
                    "optional": false,
                    "original": "target_portal"
                }
            ],
            "conflicts": [],
            "type": "VolumeIscsi s",
            "original": "volume_iscsi"
        },
        {
            "con": {
                "smart": "newSpecSecurityContext",
                "name": "SpecSecurityContext'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A special supplemental group that applies to all containers in a pod. Some",
                        "volume types allow the Kubelet to change the ownership of that volume to be",
                        "owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is",
                        "set (new files created in the volume will be owned by FSGroup) 3. The",
                        "permission bits are OR'd with rw-rw---- If unset, the Kubelet will not",
                        "modify the ownership and permissions of any volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_group\" <$> TF.attribute",
                    "name": "_fsGroup",
                    "method": "fsGroup",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasFsGroup",
                    "validate": false,
                    "optional": true,
                    "original": "fs_group"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Indicates that the container must run as a non-root user. If true, the",
                        "Kubelet will validate the image at runtime to ensure that it does not run as",
                        "UID 0 (root) and fail to start the container if it does."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_non_root\" <$> TF.attribute",
                    "name": "_runAsNonRoot",
                    "method": "runAsNonRoot",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRunAsNonRoot",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_non_root"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The UID to run the entrypoint of the container process. Defaults to user",
                        "specified in image metadata if unspecified"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_user\" <$> TF.attribute",
                    "name": "_runAsUser",
                    "method": "runAsUser",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasRunAsUser",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_user"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The SELinux context to be applied to all containers. If unspecified, the",
                        "container runtime will allocate a random SELinux context for each container.",
                        "May also be set in SecurityContext. If set in both SecurityContext and",
                        "PodSecurityContext, the value specified in SecurityContext takes precedence",
                        "for that container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"se_linux_options\" <$> TF.attribute",
                    "name": "_seLinuxOptions",
                    "method": "seLinuxOptions",
                    "conflicts": [],
                    "type": "TF.Attr s (SecurityContextSeLinuxOptions s)",
                    "class": "HasSeLinuxOptions",
                    "validate": true,
                    "optional": true,
                    "original": "se_linux_options"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of groups applied to the first process run in each container, in",
                        "addition to the container's primary GID. If unspecified, no groups will be",
                        "added to any container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"supplemental_groups\" <$> TF.attribute",
                    "name": "_supplementalGroups",
                    "method": "supplementalGroups",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Integer]",
                    "class": "HasSupplementalGroups",
                    "validate": false,
                    "optional": true,
                    "original": "supplemental_groups"
                }
            ],
            "name": "SpecSecurityContext",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "SpecSecurityContext s",
            "original": "spec_security_context"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSourceIscsi",
                "name": "PersistentVolumeSourceIscsi'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#iscsi"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_iqn",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Target iSCSI Qualified Name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iqn\" <$> TF.attribute",
                    "name": "_iqn",
                    "method": "iqn",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIqn",
                    "validate": false,
                    "optional": false,
                    "original": "iqn"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ISCSI interface name that uses an iSCSI transport. Defaults to 'default'",
                        "(tcp)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi_interface\" <$> TF.attribute",
                    "name": "_iscsiInterface",
                    "method": "iscsiInterface",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIscsiInterface",
                    "validate": false,
                    "optional": true,
                    "original": "iscsi_interface"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ISCSI target lun number."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "_lun",
                    "method": "lun",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasLun",
                    "validate": false,
                    "optional": true,
                    "original": "lun"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_targetPortal",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ISCSI target portal. The portal is either an IP or ip_addr:port if the port",
                        "is other than default (typically TCP ports 860 and 3260)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_portal\" <$> TF.attribute",
                    "name": "_targetPortal",
                    "method": "targetPortal",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTargetPortal",
                    "validate": false,
                    "optional": false,
                    "original": "target_portal"
                }
            ],
            "name": "PersistentVolumeSourceIscsi",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_iqn",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Target iSCSI Qualified Name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iqn\" <$> TF.attribute",
                    "name": "_iqn",
                    "method": "iqn",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIqn",
                    "validate": false,
                    "optional": false,
                    "original": "iqn"
                },
                {
                    "default": "_targetPortal",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ISCSI target portal. The portal is either an IP or ip_addr:port if the port",
                        "is other than default (typically TCP ports 860 and 3260)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_portal\" <$> TF.attribute",
                    "name": "_targetPortal",
                    "method": "targetPortal",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTargetPortal",
                    "validate": false,
                    "optional": false,
                    "original": "target_portal"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSourceIscsi s",
            "original": "persistent_volume_source_iscsi"
        },
        {
            "con": {
                "smart": "newSecretMetadata",
                "name": "SecretMetadata'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the secret that may be used to",
                        "store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the secret. May match selectors of replication",
                        "controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Namespace defines the space within which name of the secret must be unique."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"namespace\" <$> TF.attribute",
                    "name": "_namespace",
                    "method": "namespace",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNamespace",
                    "validate": false,
                    "optional": true,
                    "original": "namespace"
                }
            ],
            "name": "SecretMetadata",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the secret, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "conflicts": [
                        "_generateName"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this secret that can",
                        "be used by clients to determine when secret has changed. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this secret."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this secret. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "SecretMetadata s",
            "original": "secret_metadata"
        },
        {
            "con": {
                "smart": "newResourcesRequests",
                "name": "ResourcesRequests'"
            },
            "arguments": [],
            "name": "ResourcesRequests",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_computedCpu",
                    "method": "computedCpu",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedCpu",
                    "validate": false,
                    "optional": true,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_computedMemory",
                    "method": "computedMemory",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMemory",
                    "validate": false,
                    "optional": true,
                    "original": "memory"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "ResourcesRequests s",
            "original": "resources_requests"
        },
        {
            "con": {
                "smart": "newInitContainerVolumeMount",
                "name": "InitContainerVolumeMount'"
            },
            "arguments": [
                {
                    "default": "_mountPath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path within the container at which the volume should be mounted. Must not",
                        "contain ':'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mount_path\" <$> TF.attribute",
                    "name": "_mountPath",
                    "method": "mountPath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMountPath",
                    "validate": false,
                    "optional": false,
                    "original": "mount_path"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "This must match the Name of a Volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Mounted read-only if true, read-write otherwise (false or unspecified).",
                        "Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path within the volume from which the container's volume should be mounted.",
                        "Defaults to \"\" (volume's root)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sub_path\" <$> TF.attribute",
                    "name": "_subPath",
                    "method": "subPath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSubPath",
                    "validate": false,
                    "optional": true,
                    "original": "sub_path"
                }
            ],
            "name": "InitContainerVolumeMount",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_mountPath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path within the container at which the volume should be mounted. Must not",
                        "contain ':'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mount_path\" <$> TF.attribute",
                    "name": "_mountPath",
                    "method": "mountPath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMountPath",
                    "validate": false,
                    "optional": false,
                    "original": "mount_path"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "This must match the Name of a Volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "InitContainerVolumeMount s",
            "original": "init_container_volume_mount"
        },
        {
            "con": {
                "smart": "newReadinessProbeTcpSocket",
                "name": "ReadinessProbeTcpSocket'"
            },
            "arguments": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "name": "ReadinessProbeTcpSocket",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "ReadinessProbeTcpSocket s",
            "original": "readiness_probe_tcp_socket"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSourceFlexVolume",
                "name": "PersistentVolumeSourceFlexVolume'"
            },
            "arguments": [
                {
                    "default": "_driver",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Driver is the name of the driver to use for this volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"driver\" <$> TF.attribute",
                    "name": "_driver",
                    "method": "driver",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDriver",
                    "validate": false,
                    "optional": false,
                    "original": "driver"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". The default filesystem depends",
                        "on FlexVolume script."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Extra command options if any."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"options\" <$> TF.attribute",
                    "name": "_options",
                    "method": "options",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasOptions",
                    "validate": false,
                    "optional": true,
                    "original": "options"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the ReadOnly setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Reference to the secret object containing sensitive information to pass to",
                        "the plugin scripts. This may be empty if no secret object is specified. If",
                        "the secret object contains more than one secret, all secrets are passed to",
                        "the plugin scripts."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "_secretRef",
                    "method": "secretRef",
                    "conflicts": [],
                    "type": "TF.Attr s (FlexVolumeSecretRef s)",
                    "class": "HasSecretRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_ref"
                }
            ],
            "name": "PersistentVolumeSourceFlexVolume",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_driver",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Driver is the name of the driver to use for this volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"driver\" <$> TF.attribute",
                    "name": "_driver",
                    "method": "driver",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDriver",
                    "validate": false,
                    "optional": false,
                    "original": "driver"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSourceFlexVolume s",
            "original": "persistent_volume_source_flex_volume"
        },
        {
            "con": {
                "smart": "newVolumeVsphereVolume",
                "name": "VolumeVsphereVolume'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_volumePath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that identifies vSphere volume vmdk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_path\" <$> TF.attribute",
                    "name": "_volumePath",
                    "method": "volumePath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumePath",
                    "validate": false,
                    "optional": false,
                    "original": "volume_path"
                }
            ],
            "name": "VolumeVsphereVolume",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumePath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that identifies vSphere volume vmdk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_path\" <$> TF.attribute",
                    "name": "_volumePath",
                    "method": "volumePath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumePath",
                    "validate": false,
                    "optional": false,
                    "original": "volume_path"
                }
            ],
            "conflicts": [],
            "type": "VolumeVsphereVolume s",
            "original": "volume_vsphere_volume"
        },
        {
            "con": {
                "smart": "newServiceSpec",
                "name": "ServiceSpec'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of IP addresses for which nodes in the cluster will also accept",
                        "traffic for this service. These IPs are not managed by Kubernetes. The user",
                        "is responsible for ensuring that traffic arrives at a node with this IP.  A",
                        "common example is external load-balancers that are not part of the",
                        "Kubernetes system."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"external_ips\" <$> TF.attribute",
                    "name": "_externalIps",
                    "method": "externalIps",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasExternalIps",
                    "validate": false,
                    "optional": true,
                    "original": "external_ips"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The external reference that kubedns or equivalent will return as a CNAME",
                        "record for this service. No proxying will be involved. Must be a valid DNS",
                        "name and requires `type` to be `ExternalName`."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"external_name\" <$> TF.attribute",
                    "name": "_externalName",
                    "method": "externalName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasExternalName",
                    "validate": false,
                    "optional": true,
                    "original": "external_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Only applies to `type = LoadBalancer`. LoadBalancer will get created with",
                        "the IP specified in this field. This feature depends on whether the",
                        "underlying cloud-provider supports specifying this field when a load",
                        "balancer is created. This field will be ignored if the cloud-provider does",
                        "not support the feature."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_ip\" <$> TF.attribute",
                    "name": "_loadBalancerIp",
                    "method": "loadBalancerIp",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLoadBalancerIp",
                    "validate": false,
                    "optional": true,
                    "original": "load_balancer_ip"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If specified and supported by the platform, this will restrict traffic",
                        "through the cloud-provider load-balancer will be restricted to the specified",
                        "client IPs. This field will be ignored if the cloud-provider does not",
                        "support the feature. More info:",
                        "http://kubernetes.io/docs/user-guide/services-firewalls"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_source_ranges\" <$> TF.attribute",
                    "name": "_loadBalancerSourceRanges",
                    "method": "loadBalancerSourceRanges",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasLoadBalancerSourceRanges",
                    "validate": false,
                    "optional": true,
                    "original": "load_balancer_source_ranges"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The list of ports that are exposed by this service. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (TF.Attr s (SpecPort s)))",
                    "class": "HasPort",
                    "validate": true,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Route service traffic to pods with label keys and values matching this",
                        "selector. Only applies to types `ClusterIP`, `NodePort`, and `LoadBalancer`.",
                        "More info: http://kubernetes.io/docs/user-guide/services#overview"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"selector\" <$> TF.attribute",
                    "name": "_selector",
                    "method": "selector",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasSelector",
                    "validate": false,
                    "optional": true,
                    "original": "selector"
                },
                {
                    "default": "TF.value \"None\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Used to maintain session affinity. Supports `ClientIP` and `None`. Defaults",
                        "to `None`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"session_affinity\" <$> TF.attribute",
                    "name": "_sessionAffinity",
                    "method": "sessionAffinity",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSessionAffinity",
                    "validate": false,
                    "optional": true,
                    "original": "session_affinity"
                },
                {
                    "default": "TF.value \"ClusterIP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Determines how the service is exposed. Defaults to `ClusterIP`. Valid",
                        "options are `ExternalName`, `ClusterIP`, `NodePort`, and `LoadBalancer`.",
                        "`ExternalName` maps to the specified `external_name`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#overview"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": true,
                    "original": "type"
                }
            ],
            "name": "ServiceSpec",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The IP address of the service. It is usually assigned randomly by the",
                        "master. If an address is specified manually and is not in use by others, it",
                        "will be allocated to the service; otherwise, creation of the service will",
                        "fail. `None` can be specified for headless services when proxying is not",
                        "required. Ignored if type is `ExternalName`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"cluster_ip\" <$> TF.attribute",
                    "name": "_computedClusterIp",
                    "method": "computedClusterIp",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedClusterIp",
                    "validate": false,
                    "optional": true,
                    "original": "cluster_ip"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The IP address of the service. It is usually assigned randomly by the",
                        "master. If an address is specified manually and is not in use by others, it",
                        "will be allocated to the service; otherwise, creation of the service will",
                        "fail. `None` can be specified for headless services when proxying is not",
                        "required. Ignored if type is `ExternalName`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cluster_ip\" <$> TF.attribute",
                    "name": "_computedClusterIp",
                    "method": "computedClusterIp",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedClusterIp",
                    "validate": false,
                    "optional": false,
                    "original": "cluster_ip"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A list of IP addresses for which nodes in the cluster will also accept",
                        "traffic for this service. These IPs are not managed by Kubernetes. The user",
                        "is responsible for ensuring that traffic arrives at a node with this IP.  A",
                        "common example is external load-balancers that are not part of the",
                        "Kubernetes system."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"external_ips\" <$> TF.attribute",
                    "name": "_computedExternalIps",
                    "method": "computedExternalIps",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedExternalIps",
                    "validate": false,
                    "optional": false,
                    "original": "external_ips"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The external reference that kubedns or equivalent will return as a CNAME",
                        "record for this service. No proxying will be involved. Must be a valid DNS",
                        "name and requires `type` to be `ExternalName`."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"external_name\" <$> TF.attribute",
                    "name": "_computedExternalName",
                    "method": "computedExternalName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedExternalName",
                    "validate": false,
                    "optional": false,
                    "original": "external_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Only applies to `type = LoadBalancer`. LoadBalancer will get created with",
                        "the IP specified in this field. This feature depends on whether the",
                        "underlying cloud-provider supports specifying this field when a load",
                        "balancer is created. This field will be ignored if the cloud-provider does",
                        "not support the feature."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_ip\" <$> TF.attribute",
                    "name": "_computedLoadBalancerIp",
                    "method": "computedLoadBalancerIp",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedLoadBalancerIp",
                    "validate": false,
                    "optional": false,
                    "original": "load_balancer_ip"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "If specified and supported by the platform, this will restrict traffic",
                        "through the cloud-provider load-balancer will be restricted to the specified",
                        "client IPs. This field will be ignored if the cloud-provider does not",
                        "support the feature. More info:",
                        "http://kubernetes.io/docs/user-guide/services-firewalls"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_source_ranges\" <$> TF.attribute",
                    "name": "_computedLoadBalancerSourceRanges",
                    "method": "computedLoadBalancerSourceRanges",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedLoadBalancerSourceRanges",
                    "validate": false,
                    "optional": false,
                    "original": "load_balancer_source_ranges"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The list of ports that are exposed by this service. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_computedPort",
                    "method": "computedPort",
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (TF.Attr s (SpecPort s)))",
                    "class": "HasComputedPort",
                    "validate": true,
                    "optional": false,
                    "original": "port"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Route service traffic to pods with label keys and values matching this",
                        "selector. Only applies to types `ClusterIP`, `NodePort`, and `LoadBalancer`.",
                        "More info: http://kubernetes.io/docs/user-guide/services#overview"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"selector\" <$> TF.attribute",
                    "name": "_computedSelector",
                    "method": "computedSelector",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasComputedSelector",
                    "validate": false,
                    "optional": false,
                    "original": "selector"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Used to maintain session affinity. Supports `ClientIP` and `None`. Defaults",
                        "to `None`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"session_affinity\" <$> TF.attribute",
                    "name": "_computedSessionAffinity",
                    "method": "computedSessionAffinity",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSessionAffinity",
                    "validate": false,
                    "optional": false,
                    "original": "session_affinity"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Determines how the service is exposed. Defaults to `ClusterIP`. Valid",
                        "options are `ExternalName`, `ClusterIP`, `NodePort`, and `LoadBalancer`.",
                        "`ExternalName` maps to the specified `external_name`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#overview"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_computedType",
                    "method": "computedType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedType",
                    "validate": false,
                    "optional": false,
                    "original": "type"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "ServiceSpec s",
            "original": "service_spec"
        },
        {
            "con": {
                "smart": "newSpecSelector",
                "name": "SpecSelector'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of label selector requirements. The requirements are ANDed."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"match_expressions\" <$> TF.attribute",
                    "name": "_matchExpressions",
                    "method": "matchExpressions",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (SelectorMatchExpressions s)]",
                    "class": "HasMatchExpressions",
                    "validate": true,
                    "optional": true,
                    "original": "match_expressions"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A map of {key,value} pairs. A single {key,value} in the matchLabels map is",
                        "equivalent to an element of `match_expressions`, whose key field is \"key\",",
                        "the operator is \"In\", and the values array contains only \"value\". The",
                        "requirements are ANDed."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"match_labels\" <$> TF.attribute",
                    "name": "_matchLabels",
                    "method": "matchLabels",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasMatchLabels",
                    "validate": false,
                    "optional": true,
                    "original": "match_labels"
                }
            ],
            "name": "SpecSelector",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "SpecSelector s",
            "original": "spec_selector"
        },
        {
            "con": {
                "smart": "newSelectorMatchExpressions",
                "name": "SelectorMatchExpressions'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The label key that the selector applies to."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A key's relationship to a set of values. Valid operators ard `In`, `NotIn`,",
                        "`Exists` and `DoesNotExist`."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"operator\" <$> TF.attribute",
                    "name": "_operator",
                    "method": "operator",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasOperator",
                    "validate": false,
                    "optional": true,
                    "original": "operator"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An array of string values. If the operator is `In` or `NotIn`, the values",
                        "array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the",
                        "values array must be empty. This array is replaced during a strategic merge",
                        "patch."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"values\" <$> TF.attribute",
                    "name": "_values",
                    "method": "values",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasValues",
                    "validate": false,
                    "optional": true,
                    "original": "values"
                }
            ],
            "name": "SelectorMatchExpressions",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "SelectorMatchExpressions s",
            "original": "selector_match_expressions"
        },
        {
            "con": {
                "smart": "newServiceLoadBalancerIngress",
                "name": "ServiceLoadBalancerIngress'"
            },
            "arguments": [],
            "name": "ServiceLoadBalancerIngress",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"hostname\" <$> TF.attribute",
                    "name": "_computedHostname",
                    "method": "computedHostname",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedHostname",
                    "validate": false,
                    "optional": false,
                    "original": "hostname"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"ip\" <$> TF.attribute",
                    "name": "_computedIp",
                    "method": "computedIp",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedIp",
                    "validate": false,
                    "optional": false,
                    "original": "ip"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "ServiceLoadBalancerIngress s",
            "original": "service_load_balancer_ingress"
        },
        {
            "con": {
                "smart": "newVolumeFlexVolume",
                "name": "VolumeFlexVolume'"
            },
            "arguments": [
                {
                    "default": "_driver",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Driver is the name of the driver to use for this volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"driver\" <$> TF.attribute",
                    "name": "_driver",
                    "method": "driver",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDriver",
                    "validate": false,
                    "optional": false,
                    "original": "driver"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". The default filesystem depends",
                        "on FlexVolume script."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Extra command options if any."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"options\" <$> TF.attribute",
                    "name": "_options",
                    "method": "options",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasOptions",
                    "validate": false,
                    "optional": true,
                    "original": "options"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the ReadOnly setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Reference to the secret object containing sensitive information to pass to",
                        "the plugin scripts. This may be empty if no secret object is specified. If",
                        "the secret object contains more than one secret, all secrets are passed to",
                        "the plugin scripts."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "_secretRef",
                    "method": "secretRef",
                    "conflicts": [],
                    "type": "TF.Attr s (FlexVolumeSecretRef s)",
                    "class": "HasSecretRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_ref"
                }
            ],
            "name": "VolumeFlexVolume",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_driver",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Driver is the name of the driver to use for this volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"driver\" <$> TF.attribute",
                    "name": "_driver",
                    "method": "driver",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDriver",
                    "validate": false,
                    "optional": false,
                    "original": "driver"
                }
            ],
            "conflicts": [],
            "type": "VolumeFlexVolume s",
            "original": "volume_flex_volume"
        },
        {
            "con": {
                "smart": "newLimitRangeMetadata",
                "name": "LimitRangeMetadata'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the limit range that may be used",
                        "to store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the limit range. May match selectors of replication",
                        "controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Namespace defines the space within which name of the limit range must be",
                        "unique."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"namespace\" <$> TF.attribute",
                    "name": "_namespace",
                    "method": "namespace",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNamespace",
                    "validate": false,
                    "optional": true,
                    "original": "namespace"
                }
            ],
            "name": "LimitRangeMetadata",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the limit range, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "conflicts": [
                        "_generateName"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this limit range",
                        "that can be used by clients to determine when limit range has changed. Read",
                        "more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this limit range."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this limit range. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "LimitRangeMetadata s",
            "original": "limit_range_metadata"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSourceVsphereVolume",
                "name": "PersistentVolumeSourceVsphereVolume'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_volumePath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that identifies vSphere volume vmdk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_path\" <$> TF.attribute",
                    "name": "_volumePath",
                    "method": "volumePath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumePath",
                    "validate": false,
                    "optional": false,
                    "original": "volume_path"
                }
            ],
            "name": "PersistentVolumeSourceVsphereVolume",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumePath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that identifies vSphere volume vmdk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_path\" <$> TF.attribute",
                    "name": "_volumePath",
                    "method": "volumePath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumePath",
                    "validate": false,
                    "optional": false,
                    "original": "volume_path"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSourceVsphereVolume s",
            "original": "persistent_volume_source_vsphere_volume"
        },
        {
            "con": {
                "smart": "newServiceMetadata",
                "name": "ServiceMetadata'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the service that may be used to",
                        "store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the service. May match selectors of replication",
                        "controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Namespace defines the space within which name of the service must be unique."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"namespace\" <$> TF.attribute",
                    "name": "_namespace",
                    "method": "namespace",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNamespace",
                    "validate": false,
                    "optional": true,
                    "original": "namespace"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the service that may be used to",
                        "store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the service. May match selectors of replication",
                        "controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Namespace defines the space within which name of the service must be unique."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"namespace\" <$> TF.attribute",
                    "name": "_namespace",
                    "method": "namespace",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNamespace",
                    "validate": false,
                    "optional": true,
                    "original": "namespace"
                }
            ],
            "name": "ServiceMetadata",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the service, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "conflicts": [
                        "_generateName"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this service that",
                        "can be used by clients to determine when service has changed. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this service."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this service. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the service, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this service that",
                        "can be used by clients to determine when service has changed. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this service."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this service. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "ServiceMetadata s",
            "original": "service_metadata"
        },
        {
            "con": {
                "smart": "newSecurityContextCapabilities",
                "name": "SecurityContextCapabilities'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Added capabilities"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"add\" <$> TF.attribute",
                    "name": "_add",
                    "method": "add",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasAdd",
                    "validate": false,
                    "optional": true,
                    "original": "add"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Removed capabilities"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drop\" <$> TF.attribute",
                    "name": "_drop",
                    "method": "drop",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasDrop",
                    "validate": false,
                    "optional": true,
                    "original": "drop"
                }
            ],
            "name": "SecurityContextCapabilities",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "SecurityContextCapabilities s",
            "original": "security_context_capabilities"
        },
        {
            "con": {
                "smart": "newLimitRangeSpec",
                "name": "LimitRangeSpec'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Limits is the list of objects that are enforced."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"limit\" <$> TF.attribute",
                    "name": "_limit",
                    "method": "limit",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (SpecLimit s)]",
                    "class": "HasLimit",
                    "validate": true,
                    "optional": true,
                    "original": "limit"
                }
            ],
            "name": "LimitRangeSpec",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "LimitRangeSpec s",
            "original": "limit_range_spec"
        },
        {
            "con": {
                "smart": "newValueFromConfigMapKeyRef",
                "name": "ValueFromConfigMapKeyRef'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key to select."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "name": "ValueFromConfigMapKeyRef",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ValueFromConfigMapKeyRef s",
            "original": "value_from_config_map_key_ref"
        },
        {
            "con": {
                "smart": "newPreStopTcpSocket",
                "name": "PreStopTcpSocket'"
            },
            "arguments": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "name": "PreStopTcpSocket",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "PreStopTcpSocket s",
            "original": "pre_stop_tcp_socket"
        },
        {
            "con": {
                "smart": "newLivenessProbeTcpSocket",
                "name": "LivenessProbeTcpSocket'"
            },
            "arguments": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "name": "LivenessProbeTcpSocket",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "LivenessProbeTcpSocket s",
            "original": "liveness_probe_tcp_socket"
        },
        {
            "con": {
                "smart": "newHorizontalPodAutoscalerSpec",
                "name": "HorizontalPodAutoscalerSpec'"
            },
            "arguments": [
                {
                    "default": "_maxReplicas",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Upper limit for the number of pods that can be set by the autoscaler."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"max_replicas\" <$> TF.attribute",
                    "name": "_maxReplicas",
                    "method": "maxReplicas",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasMaxReplicas",
                    "validate": false,
                    "optional": false,
                    "original": "max_replicas"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Lower limit for the number of pods that can be set by the autoscaler,",
                        "defaults to `1`."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"min_replicas\" <$> TF.attribute",
                    "name": "_minReplicas",
                    "method": "minReplicas",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasMinReplicas",
                    "validate": false,
                    "optional": true,
                    "original": "min_replicas"
                },
                {
                    "default": "_scaleTargetRef",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Reference to scaled resource. e.g. Replication Controller"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scale_target_ref\" <$> TF.attribute",
                    "name": "_scaleTargetRef",
                    "method": "scaleTargetRef",
                    "conflicts": [],
                    "type": "TF.Attr s (SpecScaleTargetRef s)",
                    "class": "HasScaleTargetRef",
                    "validate": true,
                    "optional": false,
                    "original": "scale_target_ref"
                }
            ],
            "name": "HorizontalPodAutoscalerSpec",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Target average CPU utilization (represented as a percentage of requested",
                        "CPU) over all the pods. If not specified the default autoscaling policy will",
                        "be used."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_cpu_utilization_percentage\" <$> TF.attribute",
                    "name": "_computedTargetCpuUtilizationPercentage",
                    "method": "computedTargetCpuUtilizationPercentage",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedTargetCpuUtilizationPercentage",
                    "validate": false,
                    "optional": true,
                    "original": "target_cpu_utilization_percentage"
                }
            ],
            "parameters": [
                {
                    "default": "_maxReplicas",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Upper limit for the number of pods that can be set by the autoscaler."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"max_replicas\" <$> TF.attribute",
                    "name": "_maxReplicas",
                    "method": "maxReplicas",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasMaxReplicas",
                    "validate": false,
                    "optional": false,
                    "original": "max_replicas"
                },
                {
                    "default": "_scaleTargetRef",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Reference to scaled resource. e.g. Replication Controller"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scale_target_ref\" <$> TF.attribute",
                    "name": "_scaleTargetRef",
                    "method": "scaleTargetRef",
                    "conflicts": [],
                    "type": "TF.Attr s (SpecScaleTargetRef s)",
                    "class": "HasScaleTargetRef",
                    "validate": true,
                    "optional": false,
                    "original": "scale_target_ref"
                }
            ],
            "conflicts": [],
            "type": "HorizontalPodAutoscalerSpec s",
            "original": "horizontal_pod_autoscaler_spec"
        },
        {
            "con": {
                "smart": "newHorizontalPodAutoscalerMetadata",
                "name": "HorizontalPodAutoscalerMetadata'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the horizontal pod autoscaler that",
                        "may be used to store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the horizontal pod autoscaler. May match selectors of",
                        "replication controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Namespace defines the space within which name of the horizontal pod",
                        "autoscaler must be unique."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"namespace\" <$> TF.attribute",
                    "name": "_namespace",
                    "method": "namespace",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNamespace",
                    "validate": false,
                    "optional": true,
                    "original": "namespace"
                }
            ],
            "name": "HorizontalPodAutoscalerMetadata",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the horizontal pod autoscaler, must be unique. Cannot be updated.",
                        "More info: http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "conflicts": [
                        "_generateName"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this horizontal pod",
                        "autoscaler that can be used by clients to determine when horizontal pod",
                        "autoscaler has changed. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this horizontal pod autoscaler."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this horizontal pod autoscaler. More",
                        "info: http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "HorizontalPodAutoscalerMetadata s",
            "original": "horizontal_pod_autoscaler_metadata"
        },
        {
            "con": {
                "smart": "newServiceAccountSecret",
                "name": "ServiceAccountSecret'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "name": "ServiceAccountSecret",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ServiceAccountSecret s",
            "original": "service_account_secret"
        },
        {
            "con": {
                "smart": "newSpecVolume",
                "name": "SpecVolume'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an AWS Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"aws_elastic_block_store\" <$> TF.attribute",
                    "name": "_awsElasticBlockStore",
                    "method": "awsElasticBlockStore",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeAwsElasticBlockStore s)",
                    "class": "HasAwsElasticBlockStore",
                    "validate": true,
                    "optional": true,
                    "original": "aws_elastic_block_store"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure Data Disk mount on the host and bind mount to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_disk\" <$> TF.attribute",
                    "name": "_azureDisk",
                    "method": "azureDisk",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeAzureDisk s)",
                    "class": "HasAzureDisk",
                    "validate": true,
                    "optional": true,
                    "original": "azure_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure File Service mount on the host and bind mount to the",
                        "pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_file\" <$> TF.attribute",
                    "name": "_azureFile",
                    "method": "azureFile",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeAzureFile s)",
                    "class": "HasAzureFile",
                    "validate": true,
                    "optional": true,
                    "original": "azure_file"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Ceph FS mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_fs\" <$> TF.attribute",
                    "name": "_cephFs",
                    "method": "cephFs",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeCephFs s)",
                    "class": "HasCephFs",
                    "validate": true,
                    "optional": true,
                    "original": "ceph_fs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a cinder volume attached and mounted on kubelets host machine.",
                        "More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cinder\" <$> TF.attribute",
                    "name": "_cinder",
                    "method": "cinder",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeCinder s)",
                    "class": "HasCinder",
                    "validate": true,
                    "optional": true,
                    "original": "cinder"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ConfigMap represents a configMap that should populate this volume"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"config_map\" <$> TF.attribute",
                    "name": "_configMap",
                    "method": "configMap",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeConfigMap s)",
                    "class": "HasConfigMap",
                    "validate": true,
                    "optional": true,
                    "original": "config_map"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "DownwardAPI represents downward API about the pod that should populate this",
                        "volume"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"downward_api\" <$> TF.attribute",
                    "name": "_downwardApi",
                    "method": "downwardApi",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeDownwardApi s)",
                    "class": "HasDownwardApi",
                    "validate": true,
                    "optional": true,
                    "original": "downward_api"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "EmptyDir represents a temporary directory that shares a pod's lifetime. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#emptydir"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"empty_dir\" <$> TF.attribute",
                    "name": "_emptyDir",
                    "method": "emptyDir",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeEmptyDir s)",
                    "class": "HasEmptyDir",
                    "validate": true,
                    "optional": true,
                    "original": "empty_dir"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Fibre Channel resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fc\" <$> TF.attribute",
                    "name": "_fc",
                    "method": "fc",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeFc s)",
                    "class": "HasFc",
                    "validate": true,
                    "optional": true,
                    "original": "fc"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a generic volume resource that is provisioned/attached using an",
                        "exec based plugin. This is an alpha feature and may change in future."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flex_volume\" <$> TF.attribute",
                    "name": "_flexVolume",
                    "method": "flexVolume",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeFlexVolume s)",
                    "class": "HasFlexVolume",
                    "validate": true,
                    "optional": true,
                    "original": "flex_volume"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Flocker volume attached to a kubelet's host machine and exposed",
                        "to the pod for its usage. This depends on the Flocker control service being",
                        "running"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flocker\" <$> TF.attribute",
                    "name": "_flocker",
                    "method": "flocker",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeFlocker s)",
                    "class": "HasFlocker",
                    "validate": true,
                    "optional": true,
                    "original": "flocker"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a GCE Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"gce_persistent_disk\" <$> TF.attribute",
                    "name": "_gcePersistentDisk",
                    "method": "gcePersistentDisk",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeGcePersistentDisk s)",
                    "class": "HasGcePersistentDisk",
                    "validate": true,
                    "optional": true,
                    "original": "gce_persistent_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "GitRepo represents a git repository at a particular revision."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"git_repo\" <$> TF.attribute",
                    "name": "_gitRepo",
                    "method": "gitRepo",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeGitRepo s)",
                    "class": "HasGitRepo",
                    "validate": true,
                    "optional": true,
                    "original": "git_repo"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Glusterfs volume that is attached to a host and exposed to the",
                        "pod. Provisioned by an admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"glusterfs\" <$> TF.attribute",
                    "name": "_glusterfs",
                    "method": "glusterfs",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeGlusterfs s)",
                    "class": "HasGlusterfs",
                    "validate": true,
                    "optional": true,
                    "original": "glusterfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a directory on the host. Provisioned by a developer or tester.",
                        "This is useful for single-node development and testing only! On-host storage",
                        "is not supported in any way and WILL NOT WORK in a multi-node cluster. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#hostpath"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_path\" <$> TF.attribute",
                    "name": "_hostPath",
                    "method": "hostPath",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeHostPath s)",
                    "class": "HasHostPath",
                    "validate": true,
                    "optional": true,
                    "original": "host_path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an ISCSI Disk resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod. Provisioned by an admin."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi\" <$> TF.attribute",
                    "name": "_iscsi",
                    "method": "iscsi",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeIscsi s)",
                    "class": "HasIscsi",
                    "validate": true,
                    "optional": true,
                    "original": "iscsi"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Volume's name. Must be a DNS_LABEL and unique within the pod. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an NFS mount on the host. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"nfs\" <$> TF.attribute",
                    "name": "_nfs",
                    "method": "nfs",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeNfs s)",
                    "class": "HasNfs",
                    "validate": true,
                    "optional": true,
                    "original": "nfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The specification of a persistent volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"persistent_volume_claim\" <$> TF.attribute",
                    "name": "_persistentVolumeClaim",
                    "method": "persistentVolumeClaim",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumePersistentVolumeClaim s)",
                    "class": "HasPersistentVolumeClaim",
                    "validate": true,
                    "optional": true,
                    "original": "persistent_volume_claim"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a PhotonController persistent disk attached and mounted on",
                        "kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"photon_persistent_disk\" <$> TF.attribute",
                    "name": "_photonPersistentDisk",
                    "method": "photonPersistentDisk",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumePhotonPersistentDisk s)",
                    "class": "HasPhotonPersistentDisk",
                    "validate": true,
                    "optional": true,
                    "original": "photon_persistent_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Quobyte represents a Quobyte mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"quobyte\" <$> TF.attribute",
                    "name": "_quobyte",
                    "method": "quobyte",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeQuobyte s)",
                    "class": "HasQuobyte",
                    "validate": true,
                    "optional": true,
                    "original": "quobyte"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Rados Block Device mount on the host that shares a pod's",
                        "lifetime. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd\" <$> TF.attribute",
                    "name": "_rbd",
                    "method": "rbd",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeRbd s)",
                    "class": "HasRbd",
                    "validate": true,
                    "optional": true,
                    "original": "rbd"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Secret represents a secret that should populate this volume. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#secrets"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret\" <$> TF.attribute",
                    "name": "_secret",
                    "method": "secret",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeSecret s)",
                    "class": "HasSecret",
                    "validate": true,
                    "optional": true,
                    "original": "secret"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a vSphere volume attached and mounted on kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vsphere_volume\" <$> TF.attribute",
                    "name": "_vsphereVolume",
                    "method": "vsphereVolume",
                    "conflicts": [],
                    "type": "TF.Attr s (VolumeVsphereVolume s)",
                    "class": "HasVsphereVolume",
                    "validate": true,
                    "optional": true,
                    "original": "vsphere_volume"
                }
            ],
            "name": "SpecVolume",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "SpecVolume s",
            "original": "spec_volume"
        },
        {
            "con": {
                "smart": "newVolumeDownwardApi",
                "name": "VolumeDownwardApi'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on created files by default. Must be a value",
                        "between 0 and 0777. Defaults to 0644. Directories within the path are not",
                        "affected by this setting. This might be in conflict with other options that",
                        "affect the file mode, like fsGroup, and the result can be other mode bits",
                        "set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_mode\" <$> TF.attribute",
                    "name": "_defaultMode",
                    "method": "defaultMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasDefaultMode",
                    "validate": false,
                    "optional": true,
                    "original": "default_mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If unspecified, each key-value pair in the Data field of the referenced",
                        "ConfigMap will be projected into the volume as a file whose name is the key",
                        "and content is the value. If specified, the listed keys will be projected",
                        "into the specified paths, and unlisted keys will not be present. If a key is",
                        "specified which is not present in the ConfigMap, the volume setup will",
                        "error. Paths must be relative and may not contain the '..' path or start",
                        "with '..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"items\" <$> TF.attribute",
                    "name": "_items",
                    "method": "items",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (DownwardApiItems s)]",
                    "class": "HasItems",
                    "validate": true,
                    "optional": true,
                    "original": "items"
                }
            ],
            "name": "VolumeDownwardApi",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "VolumeDownwardApi s",
            "original": "volume_downward_api"
        },
        {
            "con": {
                "smart": "newSpecPersistentVolumeSource",
                "name": "SpecPersistentVolumeSource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an AWS Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"aws_elastic_block_store\" <$> TF.attribute",
                    "name": "_awsElasticBlockStore",
                    "method": "awsElasticBlockStore",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSourceAwsElasticBlockStore s)",
                    "class": "HasAwsElasticBlockStore",
                    "validate": true,
                    "optional": true,
                    "original": "aws_elastic_block_store"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure Data Disk mount on the host and bind mount to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_disk\" <$> TF.attribute",
                    "name": "_azureDisk",
                    "method": "azureDisk",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSourceAzureDisk s)",
                    "class": "HasAzureDisk",
                    "validate": true,
                    "optional": true,
                    "original": "azure_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure File Service mount on the host and bind mount to the",
                        "pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_file\" <$> TF.attribute",
                    "name": "_azureFile",
                    "method": "azureFile",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSourceAzureFile s)",
                    "class": "HasAzureFile",
                    "validate": true,
                    "optional": true,
                    "original": "azure_file"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Ceph FS mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_fs\" <$> TF.attribute",
                    "name": "_cephFs",
                    "method": "cephFs",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSourceCephFs s)",
                    "class": "HasCephFs",
                    "validate": true,
                    "optional": true,
                    "original": "ceph_fs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a cinder volume attached and mounted on kubelets host machine.",
                        "More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cinder\" <$> TF.attribute",
                    "name": "_cinder",
                    "method": "cinder",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSourceCinder s)",
                    "class": "HasCinder",
                    "validate": true,
                    "optional": true,
                    "original": "cinder"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Fibre Channel resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fc\" <$> TF.attribute",
                    "name": "_fc",
                    "method": "fc",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSourceFc s)",
                    "class": "HasFc",
                    "validate": true,
                    "optional": true,
                    "original": "fc"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a generic volume resource that is provisioned/attached using an",
                        "exec based plugin. This is an alpha feature and may change in future."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flex_volume\" <$> TF.attribute",
                    "name": "_flexVolume",
                    "method": "flexVolume",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSourceFlexVolume s)",
                    "class": "HasFlexVolume",
                    "validate": true,
                    "optional": true,
                    "original": "flex_volume"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Flocker volume attached to a kubelet's host machine and exposed",
                        "to the pod for its usage. This depends on the Flocker control service being",
                        "running"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flocker\" <$> TF.attribute",
                    "name": "_flocker",
                    "method": "flocker",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSourceFlocker s)",
                    "class": "HasFlocker",
                    "validate": true,
                    "optional": true,
                    "original": "flocker"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a GCE Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"gce_persistent_disk\" <$> TF.attribute",
                    "name": "_gcePersistentDisk",
                    "method": "gcePersistentDisk",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSourceGcePersistentDisk s)",
                    "class": "HasGcePersistentDisk",
                    "validate": true,
                    "optional": true,
                    "original": "gce_persistent_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Glusterfs volume that is attached to a host and exposed to the",
                        "pod. Provisioned by an admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"glusterfs\" <$> TF.attribute",
                    "name": "_glusterfs",
                    "method": "glusterfs",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSourceGlusterfs s)",
                    "class": "HasGlusterfs",
                    "validate": true,
                    "optional": true,
                    "original": "glusterfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a directory on the host. Provisioned by a developer or tester.",
                        "This is useful for single-node development and testing only! On-host storage",
                        "is not supported in any way and WILL NOT WORK in a multi-node cluster. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#hostpath"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_path\" <$> TF.attribute",
                    "name": "_hostPath",
                    "method": "hostPath",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSourceHostPath s)",
                    "class": "HasHostPath",
                    "validate": true,
                    "optional": true,
                    "original": "host_path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an ISCSI Disk resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod. Provisioned by an admin."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi\" <$> TF.attribute",
                    "name": "_iscsi",
                    "method": "iscsi",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSourceIscsi s)",
                    "class": "HasIscsi",
                    "validate": true,
                    "optional": true,
                    "original": "iscsi"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an NFS mount on the host. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"nfs\" <$> TF.attribute",
                    "name": "_nfs",
                    "method": "nfs",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSourceNfs s)",
                    "class": "HasNfs",
                    "validate": true,
                    "optional": true,
                    "original": "nfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a PhotonController persistent disk attached and mounted on",
                        "kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"photon_persistent_disk\" <$> TF.attribute",
                    "name": "_photonPersistentDisk",
                    "method": "photonPersistentDisk",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSourcePhotonPersistentDisk s)",
                    "class": "HasPhotonPersistentDisk",
                    "validate": true,
                    "optional": true,
                    "original": "photon_persistent_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Quobyte represents a Quobyte mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"quobyte\" <$> TF.attribute",
                    "name": "_quobyte",
                    "method": "quobyte",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSourceQuobyte s)",
                    "class": "HasQuobyte",
                    "validate": true,
                    "optional": true,
                    "original": "quobyte"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Rados Block Device mount on the host that shares a pod's",
                        "lifetime. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd\" <$> TF.attribute",
                    "name": "_rbd",
                    "method": "rbd",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSourceRbd s)",
                    "class": "HasRbd",
                    "validate": true,
                    "optional": true,
                    "original": "rbd"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a vSphere volume attached and mounted on kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vsphere_volume\" <$> TF.attribute",
                    "name": "_vsphereVolume",
                    "method": "vsphereVolume",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSourceVsphereVolume s)",
                    "class": "HasVsphereVolume",
                    "validate": true,
                    "optional": true,
                    "original": "vsphere_volume"
                }
            ],
            "name": "SpecPersistentVolumeSource",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "SpecPersistentVolumeSource s",
            "original": "spec_persistent_volume_source"
        },
        {
            "con": {
                "smart": "newReplicationControllerMetadata",
                "name": "ReplicationControllerMetadata'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the replication controller that",
                        "may be used to store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the replication controller. May match selectors of",
                        "replication controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Namespace defines the space within which name of the replication controller",
                        "must be unique."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"namespace\" <$> TF.attribute",
                    "name": "_namespace",
                    "method": "namespace",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNamespace",
                    "validate": false,
                    "optional": true,
                    "original": "namespace"
                }
            ],
            "name": "ReplicationControllerMetadata",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the replication controller, must be unique. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "conflicts": [
                        "_generateName"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this replication",
                        "controller that can be used by clients to determine when replication",
                        "controller has changed. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this replication controller."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this replication controller. More",
                        "info: http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "ReplicationControllerMetadata s",
            "original": "replication_controller_metadata"
        },
        {
            "con": {
                "smart": "newPostStartTcpSocket",
                "name": "PostStartTcpSocket'"
            },
            "arguments": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "name": "PostStartTcpSocket",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "PostStartTcpSocket s",
            "original": "post_start_tcp_socket"
        },
        {
            "con": {
                "smart": "newContainerReadinessProbe",
                "name": "ContainerReadinessProbe'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "conflicts": [],
                    "type": "TF.Attr s (ReadinessProbeExec s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive failures for the probe to be considered failed after",
                        "having succeeded."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failure_threshold\" <$> TF.attribute",
                    "name": "_failureThreshold",
                    "method": "failureThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasFailureThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "failure_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "conflicts": [],
                    "type": "TF.Attr s (ReadinessProbeHttpGet s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after the container has started before liveness probes are",
                        "initiated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"initial_delay_seconds\" <$> TF.attribute",
                    "name": "_initialDelaySeconds",
                    "method": "initialDelaySeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasInitialDelaySeconds",
                    "validate": false,
                    "optional": true,
                    "original": "initial_delay_seconds"
                },
                {
                    "default": "TF.value 10",
                    "computed": false,
                    "required": false,
                    "help": [
                        "How often (in seconds) to perform the probe"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"period_seconds\" <$> TF.attribute",
                    "name": "_periodSeconds",
                    "method": "periodSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasPeriodSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "period_seconds"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive successes for the probe to be considered successful",
                        "after having failed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"success_threshold\" <$> TF.attribute",
                    "name": "_successThreshold",
                    "method": "successThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasSuccessThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "success_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReadinessProbeTcpSocket s)]",
                    "class": "HasTcpSocket",
                    "validate": true,
                    "optional": true,
                    "original": "tcp_socket"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after which the probe times out. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"timeout_seconds\" <$> TF.attribute",
                    "name": "_timeoutSeconds",
                    "method": "timeoutSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasTimeoutSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "timeout_seconds"
                }
            ],
            "name": "ContainerReadinessProbe",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ContainerReadinessProbe s",
            "original": "container_readiness_probe"
        },
        {
            "con": {
                "smart": "newInitContainerLivenessProbe",
                "name": "InitContainerLivenessProbe'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "conflicts": [],
                    "type": "TF.Attr s (LivenessProbeExec s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive failures for the probe to be considered failed after",
                        "having succeeded."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failure_threshold\" <$> TF.attribute",
                    "name": "_failureThreshold",
                    "method": "failureThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasFailureThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "failure_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "conflicts": [],
                    "type": "TF.Attr s (LivenessProbeHttpGet s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after the container has started before liveness probes are",
                        "initiated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"initial_delay_seconds\" <$> TF.attribute",
                    "name": "_initialDelaySeconds",
                    "method": "initialDelaySeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasInitialDelaySeconds",
                    "validate": false,
                    "optional": true,
                    "original": "initial_delay_seconds"
                },
                {
                    "default": "TF.value 10",
                    "computed": false,
                    "required": false,
                    "help": [
                        "How often (in seconds) to perform the probe"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"period_seconds\" <$> TF.attribute",
                    "name": "_periodSeconds",
                    "method": "periodSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasPeriodSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "period_seconds"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive successes for the probe to be considered successful",
                        "after having failed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"success_threshold\" <$> TF.attribute",
                    "name": "_successThreshold",
                    "method": "successThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasSuccessThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "success_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (LivenessProbeTcpSocket s)]",
                    "class": "HasTcpSocket",
                    "validate": true,
                    "optional": true,
                    "original": "tcp_socket"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after which the probe times out. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"timeout_seconds\" <$> TF.attribute",
                    "name": "_timeoutSeconds",
                    "method": "timeoutSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasTimeoutSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "timeout_seconds"
                }
            ],
            "name": "InitContainerLivenessProbe",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "InitContainerLivenessProbe s",
            "original": "init_container_liveness_probe"
        },
        {
            "con": {
                "smart": "newReplicationControllerSpec",
                "name": "ReplicationControllerSpec'"
            },
            "arguments": [
                {
                    "default": "TF.value 0",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum number of seconds for which a newly created pod should be ready",
                        "without any of its container crashing, for it to be considered available.",
                        "Defaults to 0 (pod will be considered available as soon as it is ready)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"min_ready_seconds\" <$> TF.attribute",
                    "name": "_minReadySeconds",
                    "method": "minReadySeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasMinReadySeconds",
                    "validate": false,
                    "optional": true,
                    "original": "min_ready_seconds"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The number of desired replicas. Defaults to 1. More info:",
                        "http://kubernetes.io/docs/user-guide/replication-controller#what-is-a-replication-controller"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"replicas\" <$> TF.attribute",
                    "name": "_replicas",
                    "method": "replicas",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasReplicas",
                    "validate": false,
                    "optional": true,
                    "original": "replicas"
                },
                {
                    "default": "_selector",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A label query over pods that should match the Replicas count. If Selector is",
                        "empty, it is defaulted to the labels present on the Pod template. Label keys",
                        "and values that must match in order to be controlled by this replication",
                        "controller, if empty defaulted to labels on Pod template. More info:",
                        "http://kubernetes.io/docs/user-guide/labels#label-selectors"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"selector\" <$> TF.attribute",
                    "name": "_selector",
                    "method": "selector",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasSelector",
                    "validate": false,
                    "optional": false,
                    "original": "selector"
                },
                {
                    "default": "_template",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Describes the pod that will be created if insufficient replicas are",
                        "detected. This takes precedence over a TemplateRef. More info:",
                        "http://kubernetes.io/docs/user-guide/replication-controller#pod-template"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"template\" <$> TF.attribute",
                    "name": "_template",
                    "method": "template",
                    "conflicts": [],
                    "type": "TF.Attr s (SpecTemplate s)",
                    "class": "HasTemplate",
                    "validate": true,
                    "optional": false,
                    "original": "template"
                }
            ],
            "name": "ReplicationControllerSpec",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_selector",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A label query over pods that should match the Replicas count. If Selector is",
                        "empty, it is defaulted to the labels present on the Pod template. Label keys",
                        "and values that must match in order to be controlled by this replication",
                        "controller, if empty defaulted to labels on Pod template. More info:",
                        "http://kubernetes.io/docs/user-guide/labels#label-selectors"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"selector\" <$> TF.attribute",
                    "name": "_selector",
                    "method": "selector",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasSelector",
                    "validate": false,
                    "optional": false,
                    "original": "selector"
                },
                {
                    "default": "_template",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Describes the pod that will be created if insufficient replicas are",
                        "detected. This takes precedence over a TemplateRef. More info:",
                        "http://kubernetes.io/docs/user-guide/replication-controller#pod-template"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"template\" <$> TF.attribute",
                    "name": "_template",
                    "method": "template",
                    "conflicts": [],
                    "type": "TF.Attr s (SpecTemplate s)",
                    "class": "HasTemplate",
                    "validate": true,
                    "optional": false,
                    "original": "template"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerSpec s",
            "original": "replication_controller_spec"
        },
        {
            "con": {
                "smart": "newTemplateInitContainer",
                "name": "TemplateInitContainer'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Arguments to the entrypoint. The docker image's CMD is used if this is not",
                        "provided. Variable references $(VAR_NAME) are expanded using the container's",
                        "environment. If a variable cannot be resolved, the reference in the input",
                        "string will be unchanged. The $(VAR_NAME) syntax can be escaped with a",
                        "double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,",
                        "regardless of whether the variable exists or not. Cannot be updated. More",
                        "info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"args\" <$> TF.attribute",
                    "name": "_args",
                    "method": "args",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasArgs",
                    "validate": false,
                    "optional": true,
                    "original": "args"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT",
                        "is used if this is not provided. Variable references $(VAR_NAME) are",
                        "expanded using the container's environment. If a variable cannot be",
                        "resolved, the reference in the input string will be unchanged. The",
                        "$(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).",
                        "Escaped references will never be expanded, regardless of whether the",
                        "variable exists or not. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of environment variables to set in the container. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"env\" <$> TF.attribute",
                    "name": "_env",
                    "method": "env",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (InitContainerEnv s)]",
                    "class": "HasEnv",
                    "validate": true,
                    "optional": true,
                    "original": "env"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Docker image name. More info: http://kubernetes.io/docs/user-guide/images"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image\" <$> TF.attribute",
                    "name": "_image",
                    "method": "image",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasImage",
                    "validate": false,
                    "optional": true,
                    "original": "image"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Actions that the management system should take in response to container",
                        "lifecycle events"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"lifecycle\" <$> TF.attribute",
                    "name": "_lifecycle",
                    "method": "lifecycle",
                    "conflicts": [],
                    "type": "TF.Attr s (InitContainerLifecycle s)",
                    "class": "HasLifecycle",
                    "validate": true,
                    "optional": true,
                    "original": "lifecycle"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container liveness. Container will be restarted if the",
                        "probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"liveness_probe\" <$> TF.attribute",
                    "name": "_livenessProbe",
                    "method": "livenessProbe",
                    "conflicts": [],
                    "type": "TF.Attr s (InitContainerLivenessProbe s)",
                    "class": "HasLivenessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "liveness_probe"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of ports to expose from the container. Exposing a port here gives the",
                        "system additional information about the network connections a container",
                        "uses, but is primarily informational. Not specifying a port here DOES NOT",
                        "prevent that port from being exposed. Any port which is listening on the",
                        "default \"0.0.0.0\" address inside a container will be accessible from the",
                        "network. Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (InitContainerPort s)]",
                    "class": "HasPort",
                    "validate": true,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container service readiness. Container will be removed",
                        "from service endpoints if the probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"readiness_probe\" <$> TF.attribute",
                    "name": "_readinessProbe",
                    "method": "readinessProbe",
                    "conflicts": [],
                    "type": "TF.Attr s (InitContainerReadinessProbe s)",
                    "class": "HasReadinessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "readiness_probe"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Security options the pod should run with. More info:",
                        "http://releases.k8s.io/HEAD/docs/design/security_context.md"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"security_context\" <$> TF.attribute",
                    "name": "_securityContext",
                    "method": "securityContext",
                    "conflicts": [],
                    "type": "TF.Attr s (InitContainerSecurityContext s)",
                    "class": "HasSecurityContext",
                    "validate": true,
                    "optional": true,
                    "original": "security_context"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a buffer for stdin in the container",
                        "runtime. If this is not set, reads from stdin in the container will always",
                        "result in EOF."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"stdin\" <$> TF.attribute",
                    "name": "_stdin",
                    "method": "stdin",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdin",
                    "validate": false,
                    "optional": true,
                    "original": "stdin"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether the container runtime should close the stdin channel after it has",
                        "been opened by a single attach. When stdin is true the stdin stream will",
                        "remain open across multiple attach sessions. If stdinOnce is set to true,",
                        "stdin is opened on container start, is empty until the first client attaches",
                        "to stdin, and then remains open and accepts data until the client",
                        "disconnects, at which time stdin is closed and remains closed until the",
                        "container is restarted. If this flag is false, a container processes that",
                        "reads from stdin will never receive an EOF."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"stdin_once\" <$> TF.attribute",
                    "name": "_stdinOnce",
                    "method": "stdinOnce",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdinOnce",
                    "validate": false,
                    "optional": true,
                    "original": "stdin_once"
                },
                {
                    "default": "TF.value \"/dev/termination-log\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: Path at which the file to which the container's termination",
                        "message will be written is mounted into the container's filesystem. Message",
                        "written is intended to be brief final status, such as an assertion failure",
                        "message. Defaults to /dev/termination-log. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"termination_message_path\" <$> TF.attribute",
                    "name": "_terminationMessagePath",
                    "method": "terminationMessagePath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTerminationMessagePath",
                    "validate": false,
                    "optional": true,
                    "original": "termination_message_path"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a TTY for itself"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tty\" <$> TF.attribute",
                    "name": "_tty",
                    "method": "tty",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasTty",
                    "validate": false,
                    "optional": true,
                    "original": "tty"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Pod volumes to mount into the container's filesystem. Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_mount\" <$> TF.attribute",
                    "name": "_volumeMount",
                    "method": "volumeMount",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (InitContainerVolumeMount s)]",
                    "class": "HasVolumeMount",
                    "validate": true,
                    "optional": true,
                    "original": "volume_mount"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Container's working directory. If not specified, the container runtime's",
                        "default will be used, which might be configured in the container image.",
                        "Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"working_dir\" <$> TF.attribute",
                    "name": "_workingDir",
                    "method": "workingDir",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasWorkingDir",
                    "validate": false,
                    "optional": true,
                    "original": "working_dir"
                }
            ],
            "name": "TemplateInitContainer",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if",
                        ":latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/images#updating-images"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image_pull_policy\" <$> TF.attribute",
                    "name": "_computedImagePullPolicy",
                    "method": "computedImagePullPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedImagePullPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "image_pull_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Compute Resources required by this container. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_computedResources",
                    "method": "computedResources",
                    "conflicts": [],
                    "type": "TF.Attr s (InitContainerResources s)",
                    "class": "HasComputedResources",
                    "validate": true,
                    "optional": true,
                    "original": "resources"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "TemplateInitContainer s",
            "original": "template_init_container"
        },
        {
            "con": {
                "smart": "newValueFromSecretKeyRef",
                "name": "ValueFromSecretKeyRef'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key of the secret to select from. Must be a valid secret key."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "name": "ValueFromSecretKeyRef",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ValueFromSecretKeyRef s",
            "original": "value_from_secret_key_ref"
        },
        {
            "con": {
                "smart": "newContainerEnv",
                "name": "ContainerEnv'"
            },
            "arguments": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the environment variable. Must be a C_IDENTIFIER"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Variable references $(VAR_NAME) are expanded using the previous defined",
                        "environment variables in the container and any service environment",
                        "variables. If a variable cannot be resolved, the reference in the input",
                        "string will be unchanged. The $(VAR_NAME) syntax can be escaped with a",
                        "double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,",
                        "regardless of whether the variable exists or not. Defaults to \"\"."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Source for the environment variable's value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value_from\" <$> TF.attribute",
                    "name": "_valueFrom",
                    "method": "valueFrom",
                    "conflicts": [],
                    "type": "TF.Attr s (EnvValueFrom s)",
                    "class": "HasValueFrom",
                    "validate": true,
                    "optional": true,
                    "original": "value_from"
                }
            ],
            "name": "ContainerEnv",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the environment variable. Must be a C_IDENTIFIER"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "ContainerEnv s",
            "original": "container_env"
        },
        {
            "con": {
                "smart": "newVolumeCinder",
                "name": "VolumeCinder'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write). More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume ID used to identify the volume in Cinder. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "name": "VolumeCinder",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume ID used to identify the volume in Cinder. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "conflicts": [],
            "type": "VolumeCinder s",
            "original": "volume_cinder"
        },
        {
            "con": {
                "smart": "newTemplateImagePullSecrets",
                "name": "TemplateImagePullSecrets'"
            },
            "arguments": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "name": "TemplateImagePullSecrets",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "TemplateImagePullSecrets s",
            "original": "template_image_pull_secrets"
        },
        {
            "con": {
                "smart": "newEnvValueFrom",
                "name": "EnvValueFrom'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a key of a ConfigMap."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"config_map_key_ref\" <$> TF.attribute",
                    "name": "_configMapKeyRef",
                    "method": "configMapKeyRef",
                    "conflicts": [],
                    "type": "TF.Attr s (ValueFromConfigMapKeyRef s)",
                    "class": "HasConfigMapKeyRef",
                    "validate": true,
                    "optional": true,
                    "original": "config_map_key_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_ref\" <$> TF.attribute",
                    "name": "_fieldRef",
                    "method": "fieldRef",
                    "conflicts": [],
                    "type": "TF.Attr s (ValueFromFieldRef s)",
                    "class": "HasFieldRef",
                    "validate": true,
                    "optional": true,
                    "original": "field_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_field_ref\" <$> TF.attribute",
                    "name": "_resourceFieldRef",
                    "method": "resourceFieldRef",
                    "conflicts": [],
                    "type": "TF.Attr s (ValueFromResourceFieldRef s)",
                    "class": "HasResourceFieldRef",
                    "validate": true,
                    "optional": true,
                    "original": "resource_field_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_key_ref\" <$> TF.attribute",
                    "name": "_secretKeyRef",
                    "method": "secretKeyRef",
                    "conflicts": [],
                    "type": "TF.Attr s (ValueFromSecretKeyRef s)",
                    "class": "HasSecretKeyRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_key_ref"
                }
            ],
            "name": "EnvValueFrom",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "EnvValueFrom s",
            "original": "env_value_from"
        },
        {
            "con": {
                "smart": "newInitContainerReadinessProbe",
                "name": "InitContainerReadinessProbe'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "conflicts": [],
                    "type": "TF.Attr s (ReadinessProbeExec s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive failures for the probe to be considered failed after",
                        "having succeeded."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failure_threshold\" <$> TF.attribute",
                    "name": "_failureThreshold",
                    "method": "failureThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasFailureThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "failure_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "conflicts": [],
                    "type": "TF.Attr s (ReadinessProbeHttpGet s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after the container has started before liveness probes are",
                        "initiated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"initial_delay_seconds\" <$> TF.attribute",
                    "name": "_initialDelaySeconds",
                    "method": "initialDelaySeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasInitialDelaySeconds",
                    "validate": false,
                    "optional": true,
                    "original": "initial_delay_seconds"
                },
                {
                    "default": "TF.value 10",
                    "computed": false,
                    "required": false,
                    "help": [
                        "How often (in seconds) to perform the probe"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"period_seconds\" <$> TF.attribute",
                    "name": "_periodSeconds",
                    "method": "periodSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasPeriodSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "period_seconds"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive successes for the probe to be considered successful",
                        "after having failed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"success_threshold\" <$> TF.attribute",
                    "name": "_successThreshold",
                    "method": "successThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasSuccessThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "success_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ReadinessProbeTcpSocket s)]",
                    "class": "HasTcpSocket",
                    "validate": true,
                    "optional": true,
                    "original": "tcp_socket"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after which the probe times out. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"timeout_seconds\" <$> TF.attribute",
                    "name": "_timeoutSeconds",
                    "method": "timeoutSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasTimeoutSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "timeout_seconds"
                }
            ],
            "name": "InitContainerReadinessProbe",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "InitContainerReadinessProbe s",
            "original": "init_container_readiness_probe"
        },
        {
            "con": {
                "smart": "newVolumePersistentVolumeClaim",
                "name": "VolumePersistentVolumeClaim'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ClaimName is the name of a PersistentVolumeClaim in the same"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"claim_name\" <$> TF.attribute",
                    "name": "_claimName",
                    "method": "claimName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasClaimName",
                    "validate": false,
                    "optional": true,
                    "original": "claim_name"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Will force the ReadOnly setting in VolumeMounts."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "name": "VolumePersistentVolumeClaim",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "VolumePersistentVolumeClaim s",
            "original": "volume_persistent_volume_claim"
        },
        {
            "con": {
                "smart": "newResourcesLimits",
                "name": "ResourcesLimits'"
            },
            "arguments": [],
            "name": "ResourcesLimits",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_computedCpu",
                    "method": "computedCpu",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedCpu",
                    "validate": false,
                    "optional": true,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_computedMemory",
                    "method": "computedMemory",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMemory",
                    "validate": false,
                    "optional": true,
                    "original": "memory"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "ResourcesLimits s",
            "original": "resources_limits"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSourceCinder",
                "name": "PersistentVolumeSourceCinder'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write). More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume ID used to identify the volume in Cinder. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "name": "PersistentVolumeSourceCinder",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume ID used to identify the volume in Cinder. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSourceCinder s",
            "original": "persistent_volume_source_cinder"
        },
        {
            "con": {
                "smart": "newInitContainerEnv",
                "name": "InitContainerEnv'"
            },
            "arguments": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the environment variable. Must be a C_IDENTIFIER"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Variable references $(VAR_NAME) are expanded using the previous defined",
                        "environment variables in the container and any service environment",
                        "variables. If a variable cannot be resolved, the reference in the input",
                        "string will be unchanged. The $(VAR_NAME) syntax can be escaped with a",
                        "double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,",
                        "regardless of whether the variable exists or not. Defaults to \"\"."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Source for the environment variable's value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value_from\" <$> TF.attribute",
                    "name": "_valueFrom",
                    "method": "valueFrom",
                    "conflicts": [],
                    "type": "TF.Attr s (EnvValueFrom s)",
                    "class": "HasValueFrom",
                    "validate": true,
                    "optional": true,
                    "original": "value_from"
                }
            ],
            "name": "InitContainerEnv",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the environment variable. Must be a C_IDENTIFIER"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "InitContainerEnv s",
            "original": "init_container_env"
        },
        {
            "con": {
                "smart": "newVolumeRbd",
                "name": "VolumeRbd'"
            },
            "arguments": [
                {
                    "default": "_cephMonitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A collection of Ceph monitors. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_monitors\" <$> TF.attribute",
                    "name": "_cephMonitors",
                    "method": "cephMonitors",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCephMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "ceph_monitors"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#rbd"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.value \"admin\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The rados user name. Default is admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rados_user\" <$> TF.attribute",
                    "name": "_radosUser",
                    "method": "radosUser",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRadosUser",
                    "validate": false,
                    "optional": true,
                    "original": "rados_user"
                },
                {
                    "default": "_rbdImage",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The rados image name. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_image\" <$> TF.attribute",
                    "name": "_rbdImage",
                    "method": "rbdImage",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdImage",
                    "validate": false,
                    "optional": false,
                    "original": "rbd_image"
                },
                {
                    "default": "TF.value \"rbd\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The rados pool name. Default is rbd. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_pool\" <$> TF.attribute",
                    "name": "_rbdPool",
                    "method": "rbdPool",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdPool",
                    "validate": false,
                    "optional": true,
                    "original": "rbd_pool"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false.",
                        "More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the authentication secret for RBDUser. If provided overrides",
                        "keyring. Default is nil. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "_secretRef",
                    "method": "secretRef",
                    "conflicts": [],
                    "type": "TF.Attr s (RbdSecretRef s)",
                    "class": "HasSecretRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_ref"
                }
            ],
            "name": "VolumeRbd",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring.",
                        "More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"keyring\" <$> TF.attribute",
                    "name": "_computedKeyring",
                    "method": "computedKeyring",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedKeyring",
                    "validate": false,
                    "optional": true,
                    "original": "keyring"
                }
            ],
            "parameters": [
                {
                    "default": "_cephMonitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A collection of Ceph monitors. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_monitors\" <$> TF.attribute",
                    "name": "_cephMonitors",
                    "method": "cephMonitors",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCephMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "ceph_monitors"
                },
                {
                    "default": "_rbdImage",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The rados image name. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_image\" <$> TF.attribute",
                    "name": "_rbdImage",
                    "method": "rbdImage",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdImage",
                    "validate": false,
                    "optional": false,
                    "original": "rbd_image"
                }
            ],
            "conflicts": [],
            "type": "VolumeRbd s",
            "original": "volume_rbd"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSourceRbd",
                "name": "PersistentVolumeSourceRbd'"
            },
            "arguments": [
                {
                    "default": "_cephMonitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A collection of Ceph monitors. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_monitors\" <$> TF.attribute",
                    "name": "_cephMonitors",
                    "method": "cephMonitors",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCephMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "ceph_monitors"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#rbd"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.value \"admin\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The rados user name. Default is admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rados_user\" <$> TF.attribute",
                    "name": "_radosUser",
                    "method": "radosUser",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRadosUser",
                    "validate": false,
                    "optional": true,
                    "original": "rados_user"
                },
                {
                    "default": "_rbdImage",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The rados image name. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_image\" <$> TF.attribute",
                    "name": "_rbdImage",
                    "method": "rbdImage",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdImage",
                    "validate": false,
                    "optional": false,
                    "original": "rbd_image"
                },
                {
                    "default": "TF.value \"rbd\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The rados pool name. Default is rbd. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_pool\" <$> TF.attribute",
                    "name": "_rbdPool",
                    "method": "rbdPool",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdPool",
                    "validate": false,
                    "optional": true,
                    "original": "rbd_pool"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false.",
                        "More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the authentication secret for RBDUser. If provided overrides",
                        "keyring. Default is nil. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "_secretRef",
                    "method": "secretRef",
                    "conflicts": [],
                    "type": "TF.Attr s (RbdSecretRef s)",
                    "class": "HasSecretRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_ref"
                }
            ],
            "name": "PersistentVolumeSourceRbd",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring.",
                        "More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"keyring\" <$> TF.attribute",
                    "name": "_computedKeyring",
                    "method": "computedKeyring",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedKeyring",
                    "validate": false,
                    "optional": true,
                    "original": "keyring"
                }
            ],
            "parameters": [
                {
                    "default": "_cephMonitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A collection of Ceph monitors. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_monitors\" <$> TF.attribute",
                    "name": "_cephMonitors",
                    "method": "cephMonitors",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCephMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "ceph_monitors"
                },
                {
                    "default": "_rbdImage",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The rados image name. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_image\" <$> TF.attribute",
                    "name": "_rbdImage",
                    "method": "rbdImage",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdImage",
                    "validate": false,
                    "optional": false,
                    "original": "rbd_image"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSourceRbd s",
            "original": "persistent_volume_source_rbd"
        },
        {
            "con": {
                "smart": "newCephFsSecretRef",
                "name": "CephFsSecretRef'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "name": "CephFsSecretRef",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "CephFsSecretRef s",
            "original": "ceph_fs_secret_ref"
        },
        {
            "con": {
                "smart": "newSpecResources",
                "name": "SpecResources'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map describing the maximum amount of compute resources allowed. More info:",
                        "http://kubernetes.io/docs/user-guide/compute-resources/"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"limits\" <$> TF.attribute",
                    "name": "_limits",
                    "method": "limits",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasLimits",
                    "validate": false,
                    "optional": true,
                    "original": "limits"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map describing the minimum amount of compute resources required. If this is",
                        "omitted for a container, it defaults to `limits` if that is explicitly",
                        "specified, otherwise to an implementation-defined value. More info:",
                        "http://kubernetes.io/docs/user-guide/compute-resources/"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"requests\" <$> TF.attribute",
                    "name": "_requests",
                    "method": "requests",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasRequests",
                    "validate": false,
                    "optional": true,
                    "original": "requests"
                }
            ],
            "name": "SpecResources",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "SpecResources s",
            "original": "spec_resources"
        },
        {
            "con": {
                "smart": "newContainerLifecycle",
                "name": "ContainerLifecycle'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Post_start is called immediately after a container is created. If the",
                        "handler fails, the container is terminated and restarted according to its",
                        "restart policy. Other management of the container blocks until the hook",
                        "completes. More info:",
                        "http://kubernetes.io/docs/user-guide/container-environment#hook-details"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"post_start\" <$> TF.attribute",
                    "name": "_postStart",
                    "method": "postStart",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (LifecyclePostStart s)]",
                    "class": "HasPostStart",
                    "validate": true,
                    "optional": true,
                    "original": "post_start"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Pre_stop is called immediately before a container is terminated. The",
                        "container is terminated after the handler completes. The reason for",
                        "termination is passed to the handler. Regardless of the outcome of the",
                        "handler, the container is eventually terminated. Other management of the",
                        "container blocks until the hook completes. More info:",
                        "http://kubernetes.io/docs/user-guide/container-environment#hook-details"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pre_stop\" <$> TF.attribute",
                    "name": "_preStop",
                    "method": "preStop",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (LifecyclePreStop s)]",
                    "class": "HasPreStop",
                    "validate": true,
                    "optional": true,
                    "original": "pre_stop"
                }
            ],
            "name": "ContainerLifecycle",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ContainerLifecycle s",
            "original": "container_lifecycle"
        },
        {
            "con": {
                "smart": "newVolumeAwsElasticBlockStore",
                "name": "VolumeAwsElasticBlockStore'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The partition in the volume that you want to mount. If omitted, the default",
                        "is to mount by volume name. Examples: For volume /dev/sda1, you specify the",
                        "partition as \"1\". Similarly, the volume partition for /dev/sda is \"0\" (or",
                        "you can leave the property empty)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"partition\" <$> TF.attribute",
                    "name": "_partition",
                    "method": "partition",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasPartition",
                    "validate": false,
                    "optional": true,
                    "original": "partition"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to set the read-only property in VolumeMounts to \"true\". If omitted,",
                        "the default is \"false\". More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "name": "VolumeAwsElasticBlockStore",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "conflicts": [],
            "type": "VolumeAwsElasticBlockStore s",
            "original": "volume_aws_elastic_block_store"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSourceAwsElasticBlockStore",
                "name": "PersistentVolumeSourceAwsElasticBlockStore'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The partition in the volume that you want to mount. If omitted, the default",
                        "is to mount by volume name. Examples: For volume /dev/sda1, you specify the",
                        "partition as \"1\". Similarly, the volume partition for /dev/sda is \"0\" (or",
                        "you can leave the property empty)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"partition\" <$> TF.attribute",
                    "name": "_partition",
                    "method": "partition",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasPartition",
                    "validate": false,
                    "optional": true,
                    "original": "partition"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to set the read-only property in VolumeMounts to \"true\". If omitted,",
                        "the default is \"false\". More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "name": "PersistentVolumeSourceAwsElasticBlockStore",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeSourceAwsElasticBlockStore s",
            "original": "persistent_volume_source_aws_elastic_block_store"
        },
        {
            "con": {
                "smart": "newLivenessProbeHttpGet",
                "name": "LivenessProbeHttpGet'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host name to connect to, defaults to the pod IP. You probably want to set",
                        "\"Host\" in httpHeaders instead."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "_host",
                    "method": "host",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHost",
                    "validate": false,
                    "optional": true,
                    "original": "host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_header\" <$> TF.attribute",
                    "name": "_httpHeader",
                    "method": "httpHeader",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (HttpGetHttpHeader s)]",
                    "class": "HasHttpHeader",
                    "validate": true,
                    "optional": true,
                    "original": "http_header"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path to access on the HTTP server."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name or number of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.value \"HTTP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scheme\" <$> TF.attribute",
                    "name": "_scheme",
                    "method": "scheme",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScheme",
                    "validate": false,
                    "optional": true,
                    "original": "scheme"
                }
            ],
            "name": "LivenessProbeHttpGet",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "LivenessProbeHttpGet s",
            "original": "liveness_probe_http_get"
        },
        {
            "con": {
                "smart": "newVolumeConfigMap",
                "name": "VolumeConfigMap'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on created files by default. Must be a value",
                        "between 0 and 0777. Defaults to 0644. Directories within the path are not",
                        "affected by this setting. This might be in conflict with other options that",
                        "affect the file mode, like fsGroup, and the result can be other mode bits",
                        "set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_mode\" <$> TF.attribute",
                    "name": "_defaultMode",
                    "method": "defaultMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasDefaultMode",
                    "validate": false,
                    "optional": true,
                    "original": "default_mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If unspecified, each key-value pair in the Data field of the referenced",
                        "ConfigMap will be projected into the volume as a file whose name is the key",
                        "and content is the value. If specified, the listed keys will be projected",
                        "into the specified paths, and unlisted keys will not be present. If a key is",
                        "specified which is not present in the ConfigMap, the volume setup will",
                        "error. Paths must be relative and may not contain the '..' path or start",
                        "with '..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"items\" <$> TF.attribute",
                    "name": "_items",
                    "method": "items",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ConfigMapItems s)]",
                    "class": "HasItems",
                    "validate": true,
                    "optional": true,
                    "original": "items"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "name": "VolumeConfigMap",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "VolumeConfigMap s",
            "original": "volume_config_map"
        },
        {
            "con": {
                "smart": "newPreStopHttpGet",
                "name": "PreStopHttpGet'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host name to connect to, defaults to the pod IP. You probably want to set",
                        "\"Host\" in httpHeaders instead."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "_host",
                    "method": "host",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHost",
                    "validate": false,
                    "optional": true,
                    "original": "host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_header\" <$> TF.attribute",
                    "name": "_httpHeader",
                    "method": "httpHeader",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (HttpGetHttpHeader s)]",
                    "class": "HasHttpHeader",
                    "validate": true,
                    "optional": true,
                    "original": "http_header"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path to access on the HTTP server."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name or number of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.value \"HTTP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scheme\" <$> TF.attribute",
                    "name": "_scheme",
                    "method": "scheme",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScheme",
                    "validate": false,
                    "optional": true,
                    "original": "scheme"
                }
            ],
            "name": "PreStopHttpGet",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PreStopHttpGet s",
            "original": "pre_stop_http_get"
        },
        {
            "con": {
                "smart": "newLifecyclePostStart",
                "name": "LifecyclePostStart'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "conflicts": [],
                    "type": "TF.Attr s (PostStartExec s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "conflicts": [],
                    "type": "TF.Attr s (PostStartHttpGet s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PostStartTcpSocket s)]",
                    "class": "HasTcpSocket",
                    "validate": true,
                    "optional": true,
                    "original": "tcp_socket"
                }
            ],
            "name": "LifecyclePostStart",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "LifecyclePostStart s",
            "original": "lifecycle_post_start"
        },
        {
            "con": {
                "smart": "newSecurityContextSeLinuxOptions",
                "name": "SecurityContextSeLinuxOptions'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Level is SELinux level label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"level\" <$> TF.attribute",
                    "name": "_level",
                    "method": "level",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLevel",
                    "validate": false,
                    "optional": true,
                    "original": "level"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Role is a SELinux role label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"role\" <$> TF.attribute",
                    "name": "_role",
                    "method": "role",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRole",
                    "validate": false,
                    "optional": true,
                    "original": "role"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Type is a SELinux type label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": true,
                    "original": "type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User is a SELinux user label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "_user",
                    "method": "user",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "validate": false,
                    "optional": true,
                    "original": "user"
                }
            ],
            "name": "SecurityContextSeLinuxOptions",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "SecurityContextSeLinuxOptions s",
            "original": "security_context_se_linux_options"
        },
        {
            "con": {
                "smart": "newContainerResources",
                "name": "ContainerResources'"
            },
            "arguments": [],
            "name": "ContainerResources",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Describes the maximum amount of compute resources allowed. More info:",
                        "http://kubernetes.io/docs/user-guide/compute-resources/"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"limits\" <$> TF.attribute",
                    "name": "_computedLimits",
                    "method": "computedLimits",
                    "conflicts": [],
                    "type": "TF.Attr s (ResourcesLimits s)",
                    "class": "HasComputedLimits",
                    "validate": true,
                    "optional": true,
                    "original": "limits"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"requests\" <$> TF.attribute",
                    "name": "_computedRequests",
                    "method": "computedRequests",
                    "conflicts": [],
                    "type": "TF.Attr s (ResourcesRequests s)",
                    "class": "HasComputedRequests",
                    "validate": true,
                    "optional": true,
                    "original": "requests"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "ContainerResources s",
            "original": "container_resources"
        },
        {
            "con": {
                "smart": "newServiceAccountMetadata",
                "name": "ServiceAccountMetadata'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the service account that may be",
                        "used to store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the service account. May match selectors of replication",
                        "controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Namespace defines the space within which name of the service account must be",
                        "unique."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"namespace\" <$> TF.attribute",
                    "name": "_namespace",
                    "method": "namespace",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNamespace",
                    "validate": false,
                    "optional": true,
                    "original": "namespace"
                }
            ],
            "name": "ServiceAccountMetadata",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the service account, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "conflicts": [
                        "_generateName"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this service account",
                        "that can be used by clients to determine when service account has changed.",
                        "Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this service account."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this service account. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "ServiceAccountMetadata s",
            "original": "service_account_metadata"
        },
        {
            "con": {
                "smart": "newNamespaceMetadata",
                "name": "NamespaceMetadata'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the namespace that may be used to",
                        "store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the namespace. May match selectors of replication",
                        "controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                }
            ],
            "name": "NamespaceMetadata",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the namespace, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "conflicts": [
                        "_generateName"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this namespace that",
                        "can be used by clients to determine when namespace has changed. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this namespace."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this namespace. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "NamespaceMetadata s",
            "original": "namespace_metadata"
        },
        {
            "con": {
                "smart": "newLifecyclePreStop",
                "name": "LifecyclePreStop'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "conflicts": [],
                    "type": "TF.Attr s (PreStopExec s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "conflicts": [],
                    "type": "TF.Attr s (PreStopHttpGet s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PreStopTcpSocket s)]",
                    "class": "HasTcpSocket",
                    "validate": true,
                    "optional": true,
                    "original": "tcp_socket"
                }
            ],
            "name": "LifecyclePreStop",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "LifecyclePreStop s",
            "original": "lifecycle_pre_stop"
        }
    ],
    "url": "https://www.terraform.io/docs/providers/kubernetes/index.html",
    "dataSources": [
        {
            "con": {
                "smart": "serviceData",
                "name": "ServiceData'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (ServiceMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/d/service.html",
            "name": "ServiceData",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_ingress\" <$> TF.attribute",
                    "name": "_computedLoadBalancerIngress",
                    "method": "computedLoadBalancerIngress",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ServiceLoadBalancerIngress s)]",
                    "class": "HasComputedLoadBalancerIngress",
                    "validate": true,
                    "optional": false,
                    "original": "load_balancer_ingress"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Spec defines the behavior of a service.",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_computedSpec",
                    "method": "computedSpec",
                    "conflicts": [],
                    "type": "TF.Attr s (ServiceSpec s)",
                    "class": "HasComputedSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (ServiceMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "ServiceData s",
            "original": "kubernetes_service"
        },
        {
            "con": {
                "smart": "storageClassData",
                "name": "StorageClassData'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard storage class's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (StorageClassMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/d/storage_class.html",
            "name": "StorageClassData",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The parameters for the provisioner that should create volumes of this",
                        "storage class"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"parameters\" <$> TF.attribute",
                    "name": "_computedParameters",
                    "method": "computedParameters",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasComputedParameters",
                    "validate": false,
                    "optional": false,
                    "original": "parameters"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Indicates the type of the provisioner"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"storage_provisioner\" <$> TF.attribute",
                    "name": "_computedStorageProvisioner",
                    "method": "computedStorageProvisioner",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedStorageProvisioner",
                    "validate": false,
                    "optional": false,
                    "original": "storage_provisioner"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard storage class's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (StorageClassMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "StorageClassData s",
            "original": "kubernetes_storage_class"
        }
    ],
    "resources": [
        {
            "con": {
                "smart": "configMapResource",
                "name": "ConfigMapResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A map of the configuration data."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data\" <$> TF.attribute",
                    "name": "_data'",
                    "method": "data'",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasData'",
                    "validate": false,
                    "optional": true,
                    "original": "data"
                },
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard config map's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (ConfigMapMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/config_map.html",
            "name": "ConfigMapResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard config map's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (ConfigMapMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "ConfigMapResource s",
            "original": "kubernetes_config_map"
        },
        {
            "con": {
                "smart": "horizontalPodAutoscalerResource",
                "name": "HorizontalPodAutoscalerResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard horizontal pod autoscaler's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (HorizontalPodAutoscalerMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Behaviour of the autoscaler. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (HorizontalPodAutoscalerSpec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/horizontal_pod_autoscaler.html",
            "name": "HorizontalPodAutoscalerResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard horizontal pod autoscaler's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (HorizontalPodAutoscalerMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Behaviour of the autoscaler. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (HorizontalPodAutoscalerSpec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "HorizontalPodAutoscalerResource s",
            "original": "kubernetes_horizontal_pod_autoscaler"
        },
        {
            "con": {
                "smart": "limitRangeResource",
                "name": "LimitRangeResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard limit range's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (LimitRangeMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Spec defines the limits enforced. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (LimitRangeSpec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": true,
                    "original": "spec"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/limit_range.html",
            "name": "LimitRangeResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard limit range's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (LimitRangeMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "LimitRangeResource s",
            "original": "kubernetes_limit_range"
        },
        {
            "con": {
                "smart": "namespaceResource",
                "name": "NamespaceResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard namespace's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (NamespaceMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/namespace.html",
            "name": "NamespaceResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard namespace's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (NamespaceMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "NamespaceResource s",
            "original": "kubernetes_namespace"
        },
        {
            "con": {
                "smart": "persistentVolumeResource",
                "name": "PersistentVolumeResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard persistent volume's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec of the persistent volume owned by the cluster"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PersistentVolumeSpec s)]",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/persistent_volume.html",
            "name": "PersistentVolumeResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard persistent volume's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec of the persistent volume owned by the cluster"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PersistentVolumeSpec s)]",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeResource s",
            "original": "kubernetes_persistent_volume"
        },
        {
            "con": {
                "smart": "persistentVolumeClaimResource",
                "name": "PersistentVolumeClaimResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard persistent volume claim's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeClaimMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the desired characteristics of a volume requested by a pod",
                        "author. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#persistentvolumeclaims"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeClaimSpec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to wait for the claim to reach `Bound` state (to find volume in",
                        "which to claim the space)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"wait_until_bound\" <$> TF.attribute",
                    "name": "_waitUntilBound",
                    "method": "waitUntilBound",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasWaitUntilBound",
                    "validate": false,
                    "optional": true,
                    "original": "wait_until_bound"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/persistent_volume_claim.html",
            "name": "PersistentVolumeClaimResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard persistent volume claim's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeClaimMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the desired characteristics of a volume requested by a pod",
                        "author. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#persistentvolumeclaims"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeClaimSpec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeClaimResource s",
            "original": "kubernetes_persistent_volume_claim"
        },
        {
            "con": {
                "smart": "podResource",
                "name": "PodResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard pod's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (PodMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec of the pod owned by the cluster"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/pod.html",
            "name": "PodResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard pod's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (PodMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec of the pod owned by the cluster"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (PodSpec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "PodResource s",
            "original": "kubernetes_pod"
        },
        {
            "con": {
                "smart": "replicationControllerResource",
                "name": "ReplicationControllerResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard replication controller's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the specification of the desired behavior of the replication",
                        "controller. More info:",
                        "http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/replication_controller.html",
            "name": "ReplicationControllerResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard replication controller's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the specification of the desired behavior of the replication",
                        "controller. More info:",
                        "http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (ReplicationControllerSpec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerResource s",
            "original": "kubernetes_replication_controller"
        },
        {
            "con": {
                "smart": "resourceQuotaResource",
                "name": "ResourceQuotaResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard resource quota's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (ResourceQuotaMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Spec defines the desired quota.",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (ResourceQuotaSpec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": true,
                    "original": "spec"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/resource_quota.html",
            "name": "ResourceQuotaResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard resource quota's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (ResourceQuotaMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "ResourceQuotaResource s",
            "original": "kubernetes_resource_quota"
        },
        {
            "con": {
                "smart": "secretResource",
                "name": "SecretResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A map of the secret data."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data\" <$> TF.attribute",
                    "name": "_data'",
                    "method": "data'",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasData'",
                    "validate": false,
                    "optional": true,
                    "original": "data"
                },
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard secret's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (SecretMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "TF.value \"Opaque\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Type of secret"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": true,
                    "original": "type"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/secret.html",
            "name": "SecretResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard secret's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (SecretMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "SecretResource s",
            "original": "kubernetes_secret"
        },
        {
            "con": {
                "smart": "serviceResource",
                "name": "ServiceResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (ServiceMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the behavior of a service.",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (ServiceSpec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/service.html",
            "name": "ServiceResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_ingress\" <$> TF.attribute",
                    "name": "_computedLoadBalancerIngress",
                    "method": "computedLoadBalancerIngress",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ServiceLoadBalancerIngress s)]",
                    "class": "HasComputedLoadBalancerIngress",
                    "validate": true,
                    "optional": false,
                    "original": "load_balancer_ingress"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (ServiceMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the behavior of a service.",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (ServiceSpec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "ServiceResource s",
            "original": "kubernetes_service"
        },
        {
            "con": {
                "smart": "serviceAccountResource",
                "name": "ServiceAccountResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of references to secrets in the same namespace to use for pulling any",
                        "images in pods that reference this Service Account. More info:",
                        "http://kubernetes.io/docs/user-guide/secrets#manually-specifying-an-imagepullsecret"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image_pull_secret\" <$> TF.attribute",
                    "name": "_imagePullSecret",
                    "method": "imagePullSecret",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ServiceAccountImagePullSecret s)]",
                    "class": "HasImagePullSecret",
                    "validate": true,
                    "optional": true,
                    "original": "image_pull_secret"
                },
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service account's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (ServiceAccountMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of secrets allowed to be used by pods running using this Service",
                        "Account. More info: http://kubernetes.io/docs/user-guide/secrets"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret\" <$> TF.attribute",
                    "name": "_secret",
                    "method": "secret",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ServiceAccountSecret s)]",
                    "class": "HasSecret",
                    "validate": true,
                    "optional": true,
                    "original": "secret"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/service_account.html",
            "name": "ServiceAccountResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_secret_name\" <$> TF.attribute",
                    "name": "_computedDefaultSecretName",
                    "method": "computedDefaultSecretName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedDefaultSecretName",
                    "validate": false,
                    "optional": false,
                    "original": "default_secret_name"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service account's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (ServiceAccountMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "ServiceAccountResource s",
            "original": "kubernetes_service_account"
        },
        {
            "con": {
                "smart": "storageClassResource",
                "name": "StorageClassResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard storage class's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (StorageClassMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The parameters for the provisioner that should create volumes of this",
                        "storage class"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"parameters\" <$> TF.attribute",
                    "name": "_parameters",
                    "method": "parameters",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasParameters",
                    "validate": false,
                    "optional": true,
                    "original": "parameters"
                },
                {
                    "default": "_storageProvisioner",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Indicates the type of the provisioner"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"storage_provisioner\" <$> TF.attribute",
                    "name": "_storageProvisioner",
                    "method": "storageProvisioner",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasStorageProvisioner",
                    "validate": false,
                    "optional": false,
                    "original": "storage_provisioner"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/storage_class.html",
            "name": "StorageClassResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard storage class's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (StorageClassMetadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_storageProvisioner",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Indicates the type of the provisioner"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"storage_provisioner\" <$> TF.attribute",
                    "name": "_storageProvisioner",
                    "method": "storageProvisioner",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasStorageProvisioner",
                    "validate": false,
                    "optional": false,
                    "original": "storage_provisioner"
                }
            ],
            "conflicts": [],
            "type": "StorageClassResource s",
            "original": "kubernetes_storage_class"
        }
    ],
    "schema": {
        "con": {
            "smart": "newProvider",
            "name": "Provider'"
        },
        "arguments": [
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "PEM-encoded client certificate for TLS authentication."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"client_certificate\" <$>",
                "name": "_clientCertificate",
                "method": "clientCertificate",
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasClientCertificate",
                "validate": false,
                "optional": true,
                "original": "client_certificate"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "PEM-encoded client certificate key for TLS authentication."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"client_key\" <$>",
                "name": "_clientKey",
                "method": "clientKey",
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasClientKey",
                "validate": false,
                "optional": true,
                "original": "client_key"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "PEM-encoded root certificates bundle for TLS authentication."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"cluster_ca_certificate\" <$>",
                "name": "_clusterCaCertificate",
                "method": "clusterCaCertificate",
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasClusterCaCertificate",
                "validate": false,
                "optional": true,
                "original": "cluster_ca_certificate"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [],
                "forceNew": false,
                "encoder": "TF.assign \"config_context\" <$>",
                "name": "_configContext",
                "method": "configContext",
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasConfigContext",
                "validate": false,
                "optional": true,
                "original": "config_context"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [],
                "forceNew": false,
                "encoder": "TF.assign \"config_context_auth_info\" <$>",
                "name": "_configContextAuthInfo",
                "method": "configContextAuthInfo",
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasConfigContextAuthInfo",
                "validate": false,
                "optional": true,
                "original": "config_context_auth_info"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [],
                "forceNew": false,
                "encoder": "TF.assign \"config_context_cluster\" <$>",
                "name": "_configContextCluster",
                "method": "configContextCluster",
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasConfigContextCluster",
                "validate": false,
                "optional": true,
                "original": "config_context_cluster"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "Path to the kube config file, defaults to ~/.kube/config"
                ],
                "forceNew": false,
                "encoder": "TF.assign \"config_path\" <$>",
                "name": "_configPath",
                "method": "configPath",
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasConfigPath",
                "validate": false,
                "optional": true,
                "original": "config_path"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "The hostname (in form of URI) of Kubernetes master."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"host\" <$>",
                "name": "_host",
                "method": "host",
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasHost",
                "validate": false,
                "optional": true,
                "original": "host"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "Whether server should be accessed without verifying the TLS certificate."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"insecure\" <$>",
                "name": "_insecure",
                "method": "insecure",
                "conflicts": [],
                "type": "P.Maybe P.Bool",
                "class": "HasInsecure",
                "validate": false,
                "optional": true,
                "original": "insecure"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "Load local kubeconfig."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"load_config_file\" <$>",
                "name": "_loadConfigFile",
                "method": "loadConfigFile",
                "conflicts": [],
                "type": "P.Maybe P.Bool",
                "class": "HasLoadConfigFile",
                "validate": false,
                "optional": true,
                "original": "load_config_file"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "The password to use for HTTP basic authentication when accessing the",
                    "Kubernetes master endpoint."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"password\" <$>",
                "name": "_password",
                "method": "password",
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasPassword",
                "validate": false,
                "optional": true,
                "original": "password"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "Token to authentifcate an service account"
                ],
                "forceNew": false,
                "encoder": "TF.assign \"token\" <$>",
                "name": "_token",
                "method": "token",
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasToken",
                "validate": false,
                "optional": true,
                "original": "token"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "The username to use for HTTP basic authentication when accessing the",
                    "Kubernetes master endpoint."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"username\" <$>",
                "name": "_username",
                "method": "username",
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasUsername",
                "validate": false,
                "optional": true,
                "original": "username"
            }
        ],
        "name": "Provider",
        "threaded": false,
        "attributes": [],
        "parameters": [],
        "conflicts": [],
        "type": "Provider",
        "original": "provider"
    },
    "dependencies": [
        "base",
        "unordered-containers",
        "text",
        "terrafomo",
        "hashable",
        "microlens"
    ],
    "name": "Kubernetes",
    "package": "terrafomo-kubernetes",
    "original": "kubernetes"
}