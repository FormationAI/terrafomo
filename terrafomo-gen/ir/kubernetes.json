{
    "settings": [
        {
            "arguments": [
                {
                    "default": "_monitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Monitors is a collection of Ceph monitors More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"monitors\" <$> TF.attribute",
                    "name": "monitors",
                    "method": "monitors",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasMonitors",
                    "optional": false,
                    "label": "_monitors"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Used as the mounted root, rather than the full Ceph tree, default is /"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "optional": true,
                    "label": "_path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to `false`",
                        "(read/write). More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "read_only",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "optional": true,
                    "label": "_readOnly"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The path to key ring for User, default is /etc/ceph/user.secret More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_file\" <$> TF.attribute",
                    "name": "secret_file",
                    "method": "secretFile",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretFile",
                    "optional": true,
                    "label": "_secretFile"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Reference to the authentication secret for User, default is empty. More",
                        "info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "secret_ref",
                    "method": "secretRef",
                    "conflicts": [],
                    "type": "TF.Attr s [SecretRef s]",
                    "class": "HasSecretRef",
                    "optional": true,
                    "label": "_secretRef"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User is the rados user name, default is admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "user",
                    "method": "user",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "optional": true,
                    "label": "_user"
                }
            ],
            "name": "CephFs",
            "attributes": [],
            "parameters": [
                {
                    "default": "_monitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Monitors is a collection of Ceph monitors More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"monitors\" <$> TF.attribute",
                    "name": "monitors",
                    "method": "monitors",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasMonitors",
                    "optional": false,
                    "label": "_monitors"
                }
            ],
            "hashable": false,
            "type": "CephFs s",
            "original": "ceph_fs"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": true,
                    "label": "_name"
                }
            ],
            "name": "ImagePullSecret",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "ImagePullSecret s",
            "original": "image_pull_secret"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "fs_type",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "optional": true,
                    "label": "_fsType"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write). More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "read_only",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "optional": true,
                    "label": "_readOnly"
                },
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume ID used to identify the volume in Cinder. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "volume_id",
                    "method": "volumeId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "optional": false,
                    "label": "_volumeId"
                }
            ],
            "name": "Cinder",
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume ID used to identify the volume in Cinder. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "volume_id",
                    "method": "volumeId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "optional": false,
                    "label": "_volumeId"
                }
            ],
            "hashable": false,
            "type": "Cinder s",
            "original": "cinder"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "exec",
                    "method": "exec",
                    "conflicts": [],
                    "type": "TF.Attr s [Exec s]",
                    "class": "HasExec",
                    "optional": true,
                    "label": "_exec"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "http_get",
                    "method": "httpGet",
                    "conflicts": [],
                    "type": "TF.Attr s [HttpGet s]",
                    "class": "HasHttpGet",
                    "optional": true,
                    "label": "_httpGet"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "tcp_socket",
                    "method": "tcpSocket",
                    "conflicts": [],
                    "type": "TF.Attr s [TcpSocket s]",
                    "class": "HasTcpSocket",
                    "optional": true,
                    "label": "_tcpSocket"
                }
            ],
            "name": "PostStart",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "PostStart s",
            "original": "post_start"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path of the directory on the host. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#hostpath"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "optional": true,
                    "label": "_path"
                }
            ],
            "name": "HostPath",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "HostPath s",
            "original": "host_path"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the dataset stored as metadata -> name on the dataset for Flocker",
                        "should be considered as deprecated"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dataset_name\" <$> TF.attribute",
                    "name": "dataset_name",
                    "method": "datasetName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatasetName",
                    "optional": true,
                    "label": "_datasetName"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "UUID of the dataset. This is unique identifier of a Flocker dataset"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dataset_uuid\" <$> TF.attribute",
                    "name": "dataset_uuid",
                    "method": "datasetUuid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatasetUuid",
                    "optional": true,
                    "label": "_datasetUuid"
                }
            ],
            "name": "Flocker",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "Flocker s",
            "original": "flocker"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "exec",
                    "method": "exec",
                    "conflicts": [],
                    "type": "TF.Attr s [Exec s]",
                    "class": "HasExec",
                    "optional": true,
                    "label": "_exec"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive failures for the probe to be considered failed after",
                        "having succeeded."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failure_threshold\" <$> TF.attribute",
                    "name": "failure_threshold",
                    "method": "failureThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasFailureThreshold",
                    "optional": true,
                    "label": "_failureThreshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "http_get",
                    "method": "httpGet",
                    "conflicts": [],
                    "type": "TF.Attr s [HttpGet s]",
                    "class": "HasHttpGet",
                    "optional": true,
                    "label": "_httpGet"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after the container has started before liveness probes are",
                        "initiated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"initial_delay_seconds\" <$> TF.attribute",
                    "name": "initial_delay_seconds",
                    "method": "initialDelaySeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasInitialDelaySeconds",
                    "optional": true,
                    "label": "_initialDelaySeconds"
                },
                {
                    "default": "TF.value 10",
                    "computed": false,
                    "required": false,
                    "help": [
                        "How often (in seconds) to perform the probe"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"period_seconds\" <$> TF.attribute",
                    "name": "period_seconds",
                    "method": "periodSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasPeriodSeconds",
                    "optional": true,
                    "label": "_periodSeconds"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive successes for the probe to be considered successful",
                        "after having failed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"success_threshold\" <$> TF.attribute",
                    "name": "success_threshold",
                    "method": "successThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasSuccessThreshold",
                    "optional": true,
                    "label": "_successThreshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "tcp_socket",
                    "method": "tcpSocket",
                    "conflicts": [],
                    "type": "TF.Attr s [TcpSocket s]",
                    "class": "HasTcpSocket",
                    "optional": true,
                    "label": "_tcpSocket"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after which the probe times out. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"timeout_seconds\" <$> TF.attribute",
                    "name": "timeout_seconds",
                    "method": "timeoutSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasTimeoutSeconds",
                    "optional": true,
                    "label": "_timeoutSeconds"
                }
            ],
            "name": "ReadinessProbe",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "ReadinessProbe s",
            "original": "readiness_probe"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "What type of storage medium should back this directory. The default is \"\"",
                        "which means to use the node's default medium. Must be an empty string",
                        "(default) or Memory. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#emptydir"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"medium\" <$> TF.attribute",
                    "name": "medium",
                    "method": "medium",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMedium",
                    "optional": true,
                    "label": "_medium"
                }
            ],
            "name": "EmptyDir",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "EmptyDir s",
            "original": "empty_dir"
        },
        {
            "arguments": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the environment variable. Must be a C_IDENTIFIER"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Variable references $(VAR_NAME) are expanded using the previous defined",
                        "environment variables in the container and any service environment",
                        "variables. If a variable cannot be resolved, the reference in the input",
                        "string will be unchanged. The $(VAR_NAME) syntax can be escaped with a",
                        "double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,",
                        "regardless of whether the variable exists or not. Defaults to \"\"."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "value",
                    "method": "value",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "optional": true,
                    "label": "_value"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Source for the environment variable's value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value_from\" <$> TF.attribute",
                    "name": "value_from",
                    "method": "valueFrom",
                    "conflicts": [],
                    "type": "TF.Attr s [ValueFrom s]",
                    "class": "HasValueFrom",
                    "optional": true,
                    "label": "_valueFrom"
                }
            ],
            "name": "Env",
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the environment variable. Must be a C_IDENTIFIER"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "hashable": false,
            "type": "Env s",
            "original": "env"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of label selector requirements. The requirements are ANDed."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"match_expressions\" <$> TF.attribute",
                    "name": "match_expressions",
                    "method": "matchExpressions",
                    "conflicts": [],
                    "type": "TF.Attr s [MatchExpressions s]",
                    "class": "HasMatchExpressions",
                    "optional": true,
                    "label": "_matchExpressions"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A map of {key,value} pairs. A single {key,value} in the matchLabels map is",
                        "equivalent to an element of `match_expressions`, whose key field is \"key\",",
                        "the operator is \"In\", and the values array contains only \"value\". The",
                        "requirements are ANDed."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"match_labels\" <$> TF.attribute",
                    "name": "match_labels",
                    "method": "matchLabels",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasMatchLabels",
                    "optional": true,
                    "label": "_matchLabels"
                }
            ],
            "name": "Selector",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "Selector s",
            "original": "selector"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on created files by default. Must be a value",
                        "between 0 and 0777. Defaults to 0644. Directories within the path are not",
                        "affected by this setting. This might be in conflict with other options that",
                        "affect the file mode, like fsGroup, and the result can be other mode bits",
                        "set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_mode\" <$> TF.attribute",
                    "name": "default_mode",
                    "method": "defaultMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasDefaultMode",
                    "optional": true,
                    "label": "_defaultMode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If unspecified, each key-value pair in the Data field of the referenced",
                        "ConfigMap will be projected into the volume as a file whose name is the key",
                        "and content is the value. If specified, the listed keys will be projected",
                        "into the specified paths, and unlisted keys will not be present. If a key is",
                        "specified which is not present in the ConfigMap, the volume setup will",
                        "error. Paths must be relative and may not contain the '..' path or start",
                        "with '..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"items\" <$> TF.attribute",
                    "name": "items",
                    "method": "items",
                    "conflicts": [],
                    "type": "TF.Attr s [Items s]",
                    "class": "HasItems",
                    "optional": true,
                    "label": "_items"
                }
            ],
            "name": "DownwardApi",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "DownwardApi s",
            "original": "downward_api"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an AWS Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"aws_elastic_block_store\" <$> TF.attribute",
                    "name": "aws_elastic_block_store",
                    "method": "awsElasticBlockStore",
                    "conflicts": [],
                    "type": "TF.Attr s [AwsElasticBlockStore s]",
                    "class": "HasAwsElasticBlockStore",
                    "optional": true,
                    "label": "_awsElasticBlockStore"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure Data Disk mount on the host and bind mount to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_disk\" <$> TF.attribute",
                    "name": "azure_disk",
                    "method": "azureDisk",
                    "conflicts": [],
                    "type": "TF.Attr s [AzureDisk s]",
                    "class": "HasAzureDisk",
                    "optional": true,
                    "label": "_azureDisk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure File Service mount on the host and bind mount to the",
                        "pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_file\" <$> TF.attribute",
                    "name": "azure_file",
                    "method": "azureFile",
                    "conflicts": [],
                    "type": "TF.Attr s [AzureFile s]",
                    "class": "HasAzureFile",
                    "optional": true,
                    "label": "_azureFile"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Ceph FS mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_fs\" <$> TF.attribute",
                    "name": "ceph_fs",
                    "method": "cephFs",
                    "conflicts": [],
                    "type": "TF.Attr s [CephFs s]",
                    "class": "HasCephFs",
                    "optional": true,
                    "label": "_cephFs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a cinder volume attached and mounted on kubelets host machine.",
                        "More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cinder\" <$> TF.attribute",
                    "name": "cinder",
                    "method": "cinder",
                    "conflicts": [],
                    "type": "TF.Attr s [Cinder s]",
                    "class": "HasCinder",
                    "optional": true,
                    "label": "_cinder"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Fibre Channel resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fc\" <$> TF.attribute",
                    "name": "fc",
                    "method": "fc",
                    "conflicts": [],
                    "type": "TF.Attr s [Fc s]",
                    "class": "HasFc",
                    "optional": true,
                    "label": "_fc"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a generic volume resource that is provisioned/attached using an",
                        "exec based plugin. This is an alpha feature and may change in future."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flex_volume\" <$> TF.attribute",
                    "name": "flex_volume",
                    "method": "flexVolume",
                    "conflicts": [],
                    "type": "TF.Attr s [FlexVolume s]",
                    "class": "HasFlexVolume",
                    "optional": true,
                    "label": "_flexVolume"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Flocker volume attached to a kubelet's host machine and exposed",
                        "to the pod for its usage. This depends on the Flocker control service being",
                        "running"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flocker\" <$> TF.attribute",
                    "name": "flocker",
                    "method": "flocker",
                    "conflicts": [],
                    "type": "TF.Attr s [Flocker s]",
                    "class": "HasFlocker",
                    "optional": true,
                    "label": "_flocker"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a GCE Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"gce_persistent_disk\" <$> TF.attribute",
                    "name": "gce_persistent_disk",
                    "method": "gcePersistentDisk",
                    "conflicts": [],
                    "type": "TF.Attr s [GcePersistentDisk s]",
                    "class": "HasGcePersistentDisk",
                    "optional": true,
                    "label": "_gcePersistentDisk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Glusterfs volume that is attached to a host and exposed to the",
                        "pod. Provisioned by an admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"glusterfs\" <$> TF.attribute",
                    "name": "glusterfs",
                    "method": "glusterfs",
                    "conflicts": [],
                    "type": "TF.Attr s [Glusterfs s]",
                    "class": "HasGlusterfs",
                    "optional": true,
                    "label": "_glusterfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a directory on the host. Provisioned by a developer or tester.",
                        "This is useful for single-node development and testing only! On-host storage",
                        "is not supported in any way and WILL NOT WORK in a multi-node cluster. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#hostpath"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_path\" <$> TF.attribute",
                    "name": "host_path",
                    "method": "hostPath",
                    "conflicts": [],
                    "type": "TF.Attr s [HostPath s]",
                    "class": "HasHostPath",
                    "optional": true,
                    "label": "_hostPath"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an ISCSI Disk resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod. Provisioned by an admin."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi\" <$> TF.attribute",
                    "name": "iscsi",
                    "method": "iscsi",
                    "conflicts": [],
                    "type": "TF.Attr s [Iscsi s]",
                    "class": "HasIscsi",
                    "optional": true,
                    "label": "_iscsi"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an NFS mount on the host. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"nfs\" <$> TF.attribute",
                    "name": "nfs",
                    "method": "nfs",
                    "conflicts": [],
                    "type": "TF.Attr s [Nfs s]",
                    "class": "HasNfs",
                    "optional": true,
                    "label": "_nfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a PhotonController persistent disk attached and mounted on",
                        "kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"photon_persistent_disk\" <$> TF.attribute",
                    "name": "photon_persistent_disk",
                    "method": "photonPersistentDisk",
                    "conflicts": [],
                    "type": "TF.Attr s [PhotonPersistentDisk s]",
                    "class": "HasPhotonPersistentDisk",
                    "optional": true,
                    "label": "_photonPersistentDisk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Quobyte represents a Quobyte mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"quobyte\" <$> TF.attribute",
                    "name": "quobyte",
                    "method": "quobyte",
                    "conflicts": [],
                    "type": "TF.Attr s [Quobyte s]",
                    "class": "HasQuobyte",
                    "optional": true,
                    "label": "_quobyte"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Rados Block Device mount on the host that shares a pod's",
                        "lifetime. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd\" <$> TF.attribute",
                    "name": "rbd",
                    "method": "rbd",
                    "conflicts": [],
                    "type": "TF.Attr s [Rbd s]",
                    "class": "HasRbd",
                    "optional": true,
                    "label": "_rbd"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a vSphere volume attached and mounted on kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vsphere_volume\" <$> TF.attribute",
                    "name": "vsphere_volume",
                    "method": "vsphereVolume",
                    "conflicts": [],
                    "type": "TF.Attr s [VsphereVolume s]",
                    "class": "HasVsphereVolume",
                    "optional": true,
                    "label": "_vsphereVolume"
                }
            ],
            "name": "PersistentVolumeSource",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "PersistentVolumeSource s",
            "original": "persistent_volume_source"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "fs_type",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "optional": true,
                    "label": "_fsType"
                },
                {
                    "default": "_volumePath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that identifies vSphere volume vmdk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_path\" <$> TF.attribute",
                    "name": "volume_path",
                    "method": "volumePath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumePath",
                    "optional": false,
                    "label": "_volumePath"
                }
            ],
            "name": "VsphereVolume",
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumePath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that identifies vSphere volume vmdk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_path\" <$> TF.attribute",
                    "name": "volume_path",
                    "method": "volumePath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumePath",
                    "optional": false,
                    "label": "_volumePath"
                }
            ],
            "hashable": false,
            "type": "VsphereVolume s",
            "original": "vsphere_volume"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": true,
                    "label": "_name"
                }
            ],
            "name": "SecretRef",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "SecretRef s",
            "original": "secret_ref"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an AWS Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"aws_elastic_block_store\" <$> TF.attribute",
                    "name": "aws_elastic_block_store",
                    "method": "awsElasticBlockStore",
                    "conflicts": [],
                    "type": "TF.Attr s [AwsElasticBlockStore s]",
                    "class": "HasAwsElasticBlockStore",
                    "optional": true,
                    "label": "_awsElasticBlockStore"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure Data Disk mount on the host and bind mount to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_disk\" <$> TF.attribute",
                    "name": "azure_disk",
                    "method": "azureDisk",
                    "conflicts": [],
                    "type": "TF.Attr s [AzureDisk s]",
                    "class": "HasAzureDisk",
                    "optional": true,
                    "label": "_azureDisk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure File Service mount on the host and bind mount to the",
                        "pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_file\" <$> TF.attribute",
                    "name": "azure_file",
                    "method": "azureFile",
                    "conflicts": [],
                    "type": "TF.Attr s [AzureFile s]",
                    "class": "HasAzureFile",
                    "optional": true,
                    "label": "_azureFile"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Ceph FS mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_fs\" <$> TF.attribute",
                    "name": "ceph_fs",
                    "method": "cephFs",
                    "conflicts": [],
                    "type": "TF.Attr s [CephFs s]",
                    "class": "HasCephFs",
                    "optional": true,
                    "label": "_cephFs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a cinder volume attached and mounted on kubelets host machine.",
                        "More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cinder\" <$> TF.attribute",
                    "name": "cinder",
                    "method": "cinder",
                    "conflicts": [],
                    "type": "TF.Attr s [Cinder s]",
                    "class": "HasCinder",
                    "optional": true,
                    "label": "_cinder"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ConfigMap represents a configMap that should populate this volume"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"config_map\" <$> TF.attribute",
                    "name": "config_map",
                    "method": "configMap",
                    "conflicts": [],
                    "type": "TF.Attr s [ConfigMap s]",
                    "class": "HasConfigMap",
                    "optional": true,
                    "label": "_configMap"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "DownwardAPI represents downward API about the pod that should populate this",
                        "volume"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"downward_api\" <$> TF.attribute",
                    "name": "downward_api",
                    "method": "downwardApi",
                    "conflicts": [],
                    "type": "TF.Attr s [DownwardApi s]",
                    "class": "HasDownwardApi",
                    "optional": true,
                    "label": "_downwardApi"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "EmptyDir represents a temporary directory that shares a pod's lifetime. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#emptydir"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"empty_dir\" <$> TF.attribute",
                    "name": "empty_dir",
                    "method": "emptyDir",
                    "conflicts": [],
                    "type": "TF.Attr s [EmptyDir s]",
                    "class": "HasEmptyDir",
                    "optional": true,
                    "label": "_emptyDir"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Fibre Channel resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fc\" <$> TF.attribute",
                    "name": "fc",
                    "method": "fc",
                    "conflicts": [],
                    "type": "TF.Attr s [Fc s]",
                    "class": "HasFc",
                    "optional": true,
                    "label": "_fc"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a generic volume resource that is provisioned/attached using an",
                        "exec based plugin. This is an alpha feature and may change in future."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flex_volume\" <$> TF.attribute",
                    "name": "flex_volume",
                    "method": "flexVolume",
                    "conflicts": [],
                    "type": "TF.Attr s [FlexVolume s]",
                    "class": "HasFlexVolume",
                    "optional": true,
                    "label": "_flexVolume"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Flocker volume attached to a kubelet's host machine and exposed",
                        "to the pod for its usage. This depends on the Flocker control service being",
                        "running"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flocker\" <$> TF.attribute",
                    "name": "flocker",
                    "method": "flocker",
                    "conflicts": [],
                    "type": "TF.Attr s [Flocker s]",
                    "class": "HasFlocker",
                    "optional": true,
                    "label": "_flocker"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a GCE Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"gce_persistent_disk\" <$> TF.attribute",
                    "name": "gce_persistent_disk",
                    "method": "gcePersistentDisk",
                    "conflicts": [],
                    "type": "TF.Attr s [GcePersistentDisk s]",
                    "class": "HasGcePersistentDisk",
                    "optional": true,
                    "label": "_gcePersistentDisk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "GitRepo represents a git repository at a particular revision."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"git_repo\" <$> TF.attribute",
                    "name": "git_repo",
                    "method": "gitRepo",
                    "conflicts": [],
                    "type": "TF.Attr s [GitRepo s]",
                    "class": "HasGitRepo",
                    "optional": true,
                    "label": "_gitRepo"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Glusterfs volume that is attached to a host and exposed to the",
                        "pod. Provisioned by an admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"glusterfs\" <$> TF.attribute",
                    "name": "glusterfs",
                    "method": "glusterfs",
                    "conflicts": [],
                    "type": "TF.Attr s [Glusterfs s]",
                    "class": "HasGlusterfs",
                    "optional": true,
                    "label": "_glusterfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a directory on the host. Provisioned by a developer or tester.",
                        "This is useful for single-node development and testing only! On-host storage",
                        "is not supported in any way and WILL NOT WORK in a multi-node cluster. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#hostpath"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_path\" <$> TF.attribute",
                    "name": "host_path",
                    "method": "hostPath",
                    "conflicts": [],
                    "type": "TF.Attr s [HostPath s]",
                    "class": "HasHostPath",
                    "optional": true,
                    "label": "_hostPath"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an ISCSI Disk resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod. Provisioned by an admin."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi\" <$> TF.attribute",
                    "name": "iscsi",
                    "method": "iscsi",
                    "conflicts": [],
                    "type": "TF.Attr s [Iscsi s]",
                    "class": "HasIscsi",
                    "optional": true,
                    "label": "_iscsi"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Volume's name. Must be a DNS_LABEL and unique within the pod. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": true,
                    "label": "_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an NFS mount on the host. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"nfs\" <$> TF.attribute",
                    "name": "nfs",
                    "method": "nfs",
                    "conflicts": [],
                    "type": "TF.Attr s [Nfs s]",
                    "class": "HasNfs",
                    "optional": true,
                    "label": "_nfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The specification of a persistent volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"persistent_volume_claim\" <$> TF.attribute",
                    "name": "persistent_volume_claim",
                    "method": "persistentVolumeClaim",
                    "conflicts": [],
                    "type": "TF.Attr s [PersistentVolumeClaim s]",
                    "class": "HasPersistentVolumeClaim",
                    "optional": true,
                    "label": "_persistentVolumeClaim"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a PhotonController persistent disk attached and mounted on",
                        "kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"photon_persistent_disk\" <$> TF.attribute",
                    "name": "photon_persistent_disk",
                    "method": "photonPersistentDisk",
                    "conflicts": [],
                    "type": "TF.Attr s [PhotonPersistentDisk s]",
                    "class": "HasPhotonPersistentDisk",
                    "optional": true,
                    "label": "_photonPersistentDisk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Quobyte represents a Quobyte mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"quobyte\" <$> TF.attribute",
                    "name": "quobyte",
                    "method": "quobyte",
                    "conflicts": [],
                    "type": "TF.Attr s [Quobyte s]",
                    "class": "HasQuobyte",
                    "optional": true,
                    "label": "_quobyte"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Rados Block Device mount on the host that shares a pod's",
                        "lifetime. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd\" <$> TF.attribute",
                    "name": "rbd",
                    "method": "rbd",
                    "conflicts": [],
                    "type": "TF.Attr s [Rbd s]",
                    "class": "HasRbd",
                    "optional": true,
                    "label": "_rbd"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Secret represents a secret that should populate this volume. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#secrets"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret\" <$> TF.attribute",
                    "name": "secret",
                    "method": "secret",
                    "conflicts": [],
                    "type": "TF.Attr s [Secret s]",
                    "class": "HasSecret",
                    "optional": true,
                    "label": "_secret"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a vSphere volume attached and mounted on kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vsphere_volume\" <$> TF.attribute",
                    "name": "vsphere_volume",
                    "method": "vsphereVolume",
                    "conflicts": [],
                    "type": "TF.Attr s [VsphereVolume s]",
                    "class": "HasVsphereVolume",
                    "optional": true,
                    "label": "_vsphereVolume"
                }
            ],
            "name": "Volume",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "Volume s",
            "original": "volume"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Level is SELinux level label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"level\" <$> TF.attribute",
                    "name": "level",
                    "method": "level",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLevel",
                    "optional": true,
                    "label": "_level"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Role is a SELinux role label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"role\" <$> TF.attribute",
                    "name": "role",
                    "method": "role",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRole",
                    "optional": true,
                    "label": "_role"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Type is a SELinux type label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "type",
                    "method": "type'",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "optional": true,
                    "label": "_type'"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User is a SELinux user label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "user",
                    "method": "user",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "optional": true,
                    "label": "_user"
                }
            ],
            "name": "SeLinuxOptions",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "SeLinuxOptions s",
            "original": "se_linux_options"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Command is the command line to execute inside the container, the working",
                        "directory for the command is root ('/') in the container's filesystem. The",
                        "command is simply exec'd, it is not run inside a shell, so traditional shell",
                        "instructions. To use a shell, you need to explicitly call out to that shell.",
                        "Exit status of 0 is treated as live/healthy and non-zero is unhealthy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "command",
                    "method": "command",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "optional": true,
                    "label": "_command"
                }
            ],
            "name": "Exec",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "Exec s",
            "original": "exec"
        },
        {
            "arguments": [
                {
                    "default": "_endpointsName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The endpoint name that details Glusterfs topology. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"endpoints_name\" <$> TF.attribute",
                    "name": "endpoints_name",
                    "method": "endpointsName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasEndpointsName",
                    "optional": false,
                    "label": "_endpointsName"
                },
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Glusterfs volume path. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "optional": false,
                    "label": "_path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the Glusterfs volume to be mounted with read-only",
                        "permissions. Defaults to false. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "read_only",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "optional": true,
                    "label": "_readOnly"
                }
            ],
            "name": "Glusterfs",
            "attributes": [],
            "parameters": [
                {
                    "default": "_endpointsName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The endpoint name that details Glusterfs topology. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"endpoints_name\" <$> TF.attribute",
                    "name": "endpoints_name",
                    "method": "endpointsName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasEndpointsName",
                    "optional": false,
                    "label": "_endpointsName"
                },
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Glusterfs volume path. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "optional": false,
                    "label": "_path"
                }
            ],
            "hashable": false,
            "type": "Glusterfs s",
            "original": "glusterfs"
        },
        {
            "arguments": [
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that is exported by the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "optional": false,
                    "label": "_path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the NFS export to be mounted with read-only permissions.",
                        "Defaults to false. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "read_only",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "optional": true,
                    "label": "_readOnly"
                },
                {
                    "default": "_server",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Server is the hostname or IP address of the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"server\" <$> TF.attribute",
                    "name": "server",
                    "method": "server",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasServer",
                    "optional": false,
                    "label": "_server"
                }
            ],
            "name": "Nfs",
            "attributes": [],
            "parameters": [
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that is exported by the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "optional": false,
                    "label": "_path"
                },
                {
                    "default": "_server",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Server is the hostname or IP address of the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"server\" <$> TF.attribute",
                    "name": "server",
                    "method": "server",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasServer",
                    "optional": false,
                    "label": "_server"
                }
            ],
            "hashable": false,
            "type": "Nfs s",
            "original": "nfs"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key to project."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "key",
                    "method": "key",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "optional": true,
                    "label": "_key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on this file, must be a value between 0 and 0777.",
                        "If not specified, the volume defaultMode will be used. This might be in",
                        "conflict with other options that affect the file mode, like fsGroup, and the",
                        "result can be other mode bits set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mode\" <$> TF.attribute",
                    "name": "mode",
                    "method": "mode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasMode",
                    "optional": true,
                    "label": "_mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The relative path of the file to map the key to. May not be an absolute",
                        "path. May not contain the path element '..'. May not start with the string",
                        "'..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "optional": true,
                    "label": "_path"
                }
            ],
            "name": "Items",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "Items s",
            "original": "items"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": true,
                    "label": "_name"
                }
            ],
            "name": "Secret",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "Secret s",
            "original": "secret"
        },
        {
            "arguments": [],
            "name": "Limits",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "cpu",
                    "method": "computedCpu",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedCpu",
                    "optional": true,
                    "label": "_computedCpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "memory",
                    "method": "computedMemory",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMemory",
                    "optional": true,
                    "label": "_computedMemory"
                }
            ],
            "parameters": [],
            "hashable": false,
            "type": "Limits s",
            "original": "limits"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Post_start is called immediately after a container is created. If the",
                        "handler fails, the container is terminated and restarted according to its",
                        "restart policy. Other management of the container blocks until the hook",
                        "completes. More info:",
                        "http://kubernetes.io/docs/user-guide/container-environment#hook-details"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"post_start\" <$> TF.attribute",
                    "name": "post_start",
                    "method": "postStart",
                    "conflicts": [],
                    "type": "TF.Attr s [PostStart s]",
                    "class": "HasPostStart",
                    "optional": true,
                    "label": "_postStart"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Pre_stop is called immediately before a container is terminated. The",
                        "container is terminated after the handler completes. The reason for",
                        "termination is passed to the handler. Regardless of the outcome of the",
                        "handler, the container is eventually terminated. Other management of the",
                        "container blocks until the hook completes. More info:",
                        "http://kubernetes.io/docs/user-guide/container-environment#hook-details"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pre_stop\" <$> TF.attribute",
                    "name": "pre_stop",
                    "method": "preStop",
                    "conflicts": [],
                    "type": "TF.Attr s [PreStop s]",
                    "class": "HasPreStop",
                    "optional": true,
                    "label": "_preStop"
                }
            ],
            "name": "Lifecycle",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "Lifecycle s",
            "original": "lifecycle"
        },
        {
            "arguments": [
                {
                    "default": "_containerName",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_name\" <$> TF.attribute",
                    "name": "container_name",
                    "method": "containerName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasContainerName",
                    "optional": false,
                    "label": "_containerName"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"quantity\" <$> TF.attribute",
                    "name": "quantity",
                    "method": "quantity",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasQuantity",
                    "optional": true,
                    "label": "_quantity"
                },
                {
                    "default": "_resource",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Resource to select"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource\" <$> TF.attribute",
                    "name": "resource",
                    "method": "resource",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResource",
                    "optional": false,
                    "label": "_resource"
                }
            ],
            "name": "ResourceFieldRef",
            "attributes": [],
            "parameters": [
                {
                    "default": "_containerName",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_name\" <$> TF.attribute",
                    "name": "container_name",
                    "method": "containerName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasContainerName",
                    "optional": false,
                    "label": "_containerName"
                },
                {
                    "default": "_resource",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Resource to select"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource\" <$> TF.attribute",
                    "name": "resource",
                    "method": "resource",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResource",
                    "optional": false,
                    "label": "_resource"
                }
            ],
            "hashable": false,
            "type": "ResourceFieldRef s",
            "original": "resource_field_ref"
        },
        {
            "arguments": [],
            "name": "Resources",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Describes the maximum amount of compute resources allowed. More info:",
                        "http://kubernetes.io/docs/user-guide/compute-resources/"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"limits\" <$> TF.attribute",
                    "name": "limits",
                    "method": "computedLimits",
                    "conflicts": [],
                    "type": "TF.Attr s [Limits s]",
                    "class": "HasComputedLimits",
                    "optional": true,
                    "label": "_computedLimits"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"requests\" <$> TF.attribute",
                    "name": "requests",
                    "method": "computedRequests",
                    "conflicts": [],
                    "type": "TF.Attr s [Requests s]",
                    "class": "HasComputedRequests",
                    "optional": true,
                    "label": "_computedRequests"
                }
            ],
            "parameters": [],
            "hashable": false,
            "type": "Resources s",
            "original": "resources"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host name to connect to, defaults to the pod IP. You probably want to set",
                        "\"Host\" in httpHeaders instead."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "host",
                    "method": "host",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHost",
                    "optional": true,
                    "label": "_host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_header\" <$> TF.attribute",
                    "name": "http_header",
                    "method": "httpHeader",
                    "conflicts": [],
                    "type": "TF.Attr s [HttpHeader s]",
                    "class": "HasHttpHeader",
                    "optional": true,
                    "label": "_httpHeader"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path to access on the HTTP server."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "optional": true,
                    "label": "_path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name or number of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "optional": true,
                    "label": "_port"
                },
                {
                    "default": "TF.value \"HTTP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scheme\" <$> TF.attribute",
                    "name": "scheme",
                    "method": "scheme",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScheme",
                    "optional": true,
                    "label": "_scheme"
                }
            ],
            "name": "HttpGet",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "HttpGet s",
            "original": "http_get"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "fs_type",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "optional": true,
                    "label": "_fsType"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The partition in the volume that you want to mount. If omitted, the default",
                        "is to mount by volume name. Examples: For volume /dev/sda1, you specify the",
                        "partition as \"1\". Similarly, the volume partition for /dev/sda is \"0\" (or",
                        "you can leave the property empty)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"partition\" <$> TF.attribute",
                    "name": "partition",
                    "method": "partition",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasPartition",
                    "optional": true,
                    "label": "_partition"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to set the read-only property in VolumeMounts to \"true\". If omitted,",
                        "the default is \"false\". More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "read_only",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "optional": true,
                    "label": "_readOnly"
                },
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "volume_id",
                    "method": "volumeId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "optional": false,
                    "label": "_volumeId"
                }
            ],
            "name": "AwsElasticBlockStore",
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "volume_id",
                    "method": "volumeId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "optional": false,
                    "label": "_volumeId"
                }
            ],
            "hashable": false,
            "type": "AwsElasticBlockStore s",
            "original": "aws_elastic_block_store"
        },
        {
            "arguments": [
                {
                    "default": "TF.value \"v1\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Version of the schema the FieldPath is written in terms of, defaults to",
                        "\"v1\"."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"api_version\" <$> TF.attribute",
                    "name": "api_version",
                    "method": "apiVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasApiVersion",
                    "optional": true,
                    "label": "_apiVersion"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path of the field to select in the specified API version"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_path\" <$> TF.attribute",
                    "name": "field_path",
                    "method": "fieldPath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFieldPath",
                    "optional": true,
                    "label": "_fieldPath"
                }
            ],
            "name": "FieldRef",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "FieldRef s",
            "original": "field_ref"
        },
        {
            "arguments": [
                {
                    "default": "_cephMonitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A collection of Ceph monitors. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_monitors\" <$> TF.attribute",
                    "name": "ceph_monitors",
                    "method": "cephMonitors",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasCephMonitors",
                    "optional": false,
                    "label": "_cephMonitors"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#rbd"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "fs_type",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "optional": true,
                    "label": "_fsType"
                },
                {
                    "default": "TF.value \"admin\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The rados user name. Default is admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rados_user\" <$> TF.attribute",
                    "name": "rados_user",
                    "method": "radosUser",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRadosUser",
                    "optional": true,
                    "label": "_radosUser"
                },
                {
                    "default": "_rbdImage",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The rados image name. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_image\" <$> TF.attribute",
                    "name": "rbd_image",
                    "method": "rbdImage",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdImage",
                    "optional": false,
                    "label": "_rbdImage"
                },
                {
                    "default": "TF.value \"rbd\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The rados pool name. Default is rbd. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_pool\" <$> TF.attribute",
                    "name": "rbd_pool",
                    "method": "rbdPool",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdPool",
                    "optional": true,
                    "label": "_rbdPool"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false.",
                        "More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "read_only",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "optional": true,
                    "label": "_readOnly"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the authentication secret for RBDUser. If provided overrides",
                        "keyring. Default is nil. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "secret_ref",
                    "method": "secretRef",
                    "conflicts": [],
                    "type": "TF.Attr s [SecretRef s]",
                    "class": "HasSecretRef",
                    "optional": true,
                    "label": "_secretRef"
                }
            ],
            "name": "Rbd",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring.",
                        "More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"keyring\" <$> TF.attribute",
                    "name": "keyring",
                    "method": "computedKeyring",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedKeyring",
                    "optional": true,
                    "label": "_computedKeyring"
                }
            ],
            "parameters": [
                {
                    "default": "_cephMonitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A collection of Ceph monitors. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_monitors\" <$> TF.attribute",
                    "name": "ceph_monitors",
                    "method": "cephMonitors",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasCephMonitors",
                    "optional": false,
                    "label": "_cephMonitors"
                },
                {
                    "default": "_rbdImage",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The rados image name. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_image\" <$> TF.attribute",
                    "name": "rbd_image",
                    "method": "rbdImage",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdImage",
                    "optional": false,
                    "label": "_rbdImage"
                }
            ],
            "hashable": false,
            "type": "Rbd s",
            "original": "rbd"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Arguments to the entrypoint. The docker image's CMD is used if this is not",
                        "provided. Variable references $(VAR_NAME) are expanded using the container's",
                        "environment. If a variable cannot be resolved, the reference in the input",
                        "string will be unchanged. The $(VAR_NAME) syntax can be escaped with a",
                        "double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,",
                        "regardless of whether the variable exists or not. Cannot be updated. More",
                        "info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"args\" <$> TF.attribute",
                    "name": "args",
                    "method": "args",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasArgs",
                    "optional": true,
                    "label": "_args"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT",
                        "is used if this is not provided. Variable references $(VAR_NAME) are",
                        "expanded using the container's environment. If a variable cannot be",
                        "resolved, the reference in the input string will be unchanged. The",
                        "$(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).",
                        "Escaped references will never be expanded, regardless of whether the",
                        "variable exists or not. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "command",
                    "method": "command",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "optional": true,
                    "label": "_command"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of environment variables to set in the container. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"env\" <$> TF.attribute",
                    "name": "env",
                    "method": "env",
                    "conflicts": [],
                    "type": "TF.Attr s [Env s]",
                    "class": "HasEnv",
                    "optional": true,
                    "label": "_env"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Docker image name. More info: http://kubernetes.io/docs/user-guide/images"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image\" <$> TF.attribute",
                    "name": "image",
                    "method": "image",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasImage",
                    "optional": true,
                    "label": "_image"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Actions that the management system should take in response to container",
                        "lifecycle events"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"lifecycle\" <$> TF.attribute",
                    "name": "lifecycle",
                    "method": "lifecycle",
                    "conflicts": [],
                    "type": "TF.Attr s [Lifecycle s]",
                    "class": "HasLifecycle",
                    "optional": true,
                    "label": "_lifecycle"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container liveness. Container will be restarted if the",
                        "probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"liveness_probe\" <$> TF.attribute",
                    "name": "liveness_probe",
                    "method": "livenessProbe",
                    "conflicts": [],
                    "type": "TF.Attr s [LivenessProbe s]",
                    "class": "HasLivenessProbe",
                    "optional": true,
                    "label": "_livenessProbe"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of ports to expose from the container. Exposing a port here gives the",
                        "system additional information about the network connections a container",
                        "uses, but is primarily informational. Not specifying a port here DOES NOT",
                        "prevent that port from being exposed. Any port which is listening on the",
                        "default \"0.0.0.0\" address inside a container will be accessible from the",
                        "network. Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s [Port s]",
                    "class": "HasPort",
                    "optional": true,
                    "label": "_port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container service readiness. Container will be removed",
                        "from service endpoints if the probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"readiness_probe\" <$> TF.attribute",
                    "name": "readiness_probe",
                    "method": "readinessProbe",
                    "conflicts": [],
                    "type": "TF.Attr s [ReadinessProbe s]",
                    "class": "HasReadinessProbe",
                    "optional": true,
                    "label": "_readinessProbe"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Security options the pod should run with. More info:",
                        "http://releases.k8s.io/HEAD/docs/design/security_context.md"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"security_context\" <$> TF.attribute",
                    "name": "security_context",
                    "method": "securityContext",
                    "conflicts": [],
                    "type": "TF.Attr s [SecurityContext s]",
                    "class": "HasSecurityContext",
                    "optional": true,
                    "label": "_securityContext"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a buffer for stdin in the container",
                        "runtime. If this is not set, reads from stdin in the container will always",
                        "result in EOF."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"stdin\" <$> TF.attribute",
                    "name": "stdin",
                    "method": "stdin",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdin",
                    "optional": true,
                    "label": "_stdin"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether the container runtime should close the stdin channel after it has",
                        "been opened by a single attach. When stdin is true the stdin stream will",
                        "remain open across multiple attach sessions. If stdinOnce is set to true,",
                        "stdin is opened on container start, is empty until the first client attaches",
                        "to stdin, and then remains open and accepts data until the client",
                        "disconnects, at which time stdin is closed and remains closed until the",
                        "container is restarted. If this flag is false, a container processes that",
                        "reads from stdin will never receive an EOF."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"stdin_once\" <$> TF.attribute",
                    "name": "stdin_once",
                    "method": "stdinOnce",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdinOnce",
                    "optional": true,
                    "label": "_stdinOnce"
                },
                {
                    "default": "TF.value \"/dev/termination-log\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: Path at which the file to which the container's termination",
                        "message will be written is mounted into the container's filesystem. Message",
                        "written is intended to be brief final status, such as an assertion failure",
                        "message. Defaults to /dev/termination-log. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"termination_message_path\" <$> TF.attribute",
                    "name": "termination_message_path",
                    "method": "terminationMessagePath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTerminationMessagePath",
                    "optional": true,
                    "label": "_terminationMessagePath"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a TTY for itself"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tty\" <$> TF.attribute",
                    "name": "tty",
                    "method": "tty",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasTty",
                    "optional": true,
                    "label": "_tty"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Pod volumes to mount into the container's filesystem. Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_mount\" <$> TF.attribute",
                    "name": "volume_mount",
                    "method": "volumeMount",
                    "conflicts": [],
                    "type": "TF.Attr s [VolumeMount s]",
                    "class": "HasVolumeMount",
                    "optional": true,
                    "label": "_volumeMount"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Container's working directory. If not specified, the container runtime's",
                        "default will be used, which might be configured in the container image.",
                        "Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"working_dir\" <$> TF.attribute",
                    "name": "working_dir",
                    "method": "workingDir",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasWorkingDir",
                    "optional": true,
                    "label": "_workingDir"
                }
            ],
            "name": "Container",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if",
                        ":latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/images#updating-images"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image_pull_policy\" <$> TF.attribute",
                    "name": "image_pull_policy",
                    "method": "computedImagePullPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedImagePullPolicy",
                    "optional": true,
                    "label": "_computedImagePullPolicy"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Compute Resources required by this container. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "resources",
                    "method": "computedResources",
                    "conflicts": [],
                    "type": "TF.Attr s [Resources s]",
                    "class": "HasComputedResources",
                    "optional": true,
                    "label": "_computedResources"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "hashable": false,
            "type": "Container s",
            "original": "container"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ClaimName is the name of a PersistentVolumeClaim in the same"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"claim_name\" <$> TF.attribute",
                    "name": "claim_name",
                    "method": "claimName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasClaimName",
                    "optional": true,
                    "label": "_claimName"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Will force the ReadOnly setting in VolumeMounts."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "read_only",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "optional": true,
                    "label": "_readOnly"
                }
            ],
            "name": "PersistentVolumeClaim",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "PersistentVolumeClaim s",
            "original": "persistent_volume_claim"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key to select."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "key",
                    "method": "key",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "optional": true,
                    "label": "_key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": true,
                    "label": "_name"
                }
            ],
            "name": "ConfigMapKeyRef",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "ConfigMapKeyRef s",
            "original": "config_map_key_ref"
        },
        {
            "arguments": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "name": "ImagePullSecrets",
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "hashable": false,
            "type": "ImagePullSecrets s",
            "original": "image_pull_secrets"
        },
        {
            "arguments": [
                {
                    "default": "_mountPath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path within the container at which the volume should be mounted. Must not",
                        "contain ':'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mount_path\" <$> TF.attribute",
                    "name": "mount_path",
                    "method": "mountPath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMountPath",
                    "optional": false,
                    "label": "_mountPath"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "This must match the Name of a Volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Mounted read-only if true, read-write otherwise (false or unspecified).",
                        "Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "read_only",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "optional": true,
                    "label": "_readOnly"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path within the volume from which the container's volume should be mounted.",
                        "Defaults to \"\" (volume's root)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sub_path\" <$> TF.attribute",
                    "name": "sub_path",
                    "method": "subPath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSubPath",
                    "optional": true,
                    "label": "_subPath"
                }
            ],
            "name": "VolumeMount",
            "attributes": [],
            "parameters": [
                {
                    "default": "_mountPath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path within the container at which the volume should be mounted. Must not",
                        "contain ':'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mount_path\" <$> TF.attribute",
                    "name": "mount_path",
                    "method": "mountPath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMountPath",
                    "optional": false,
                    "label": "_mountPath"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "This must match the Name of a Volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "hashable": false,
            "type": "VolumeMount s",
            "original": "volume_mount"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a key of a ConfigMap."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"config_map_key_ref\" <$> TF.attribute",
                    "name": "config_map_key_ref",
                    "method": "configMapKeyRef",
                    "conflicts": [],
                    "type": "TF.Attr s [ConfigMapKeyRef s]",
                    "class": "HasConfigMapKeyRef",
                    "optional": true,
                    "label": "_configMapKeyRef"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_ref\" <$> TF.attribute",
                    "name": "field_ref",
                    "method": "fieldRef",
                    "conflicts": [],
                    "type": "TF.Attr s [FieldRef s]",
                    "class": "HasFieldRef",
                    "optional": true,
                    "label": "_fieldRef"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_field_ref\" <$> TF.attribute",
                    "name": "resource_field_ref",
                    "method": "resourceFieldRef",
                    "conflicts": [],
                    "type": "TF.Attr s [ResourceFieldRef s]",
                    "class": "HasResourceFieldRef",
                    "optional": true,
                    "label": "_resourceFieldRef"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_key_ref\" <$> TF.attribute",
                    "name": "secret_key_ref",
                    "method": "secretKeyRef",
                    "conflicts": [],
                    "type": "TF.Attr s [SecretKeyRef s]",
                    "class": "HasSecretKeyRef",
                    "optional": true,
                    "label": "_secretKeyRef"
                }
            ],
            "name": "ValueFrom",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "ValueFrom s",
            "original": "value_from"
        },
        {
            "arguments": [],
            "name": "Requests",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "cpu",
                    "method": "computedCpu",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedCpu",
                    "optional": true,
                    "label": "_computedCpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "memory",
                    "method": "computedMemory",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMemory",
                    "optional": true,
                    "label": "_computedMemory"
                }
            ],
            "parameters": [],
            "hashable": false,
            "type": "Requests s",
            "original": "requests"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "fs_type",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "optional": true,
                    "label": "_fsType"
                },
                {
                    "default": "_pdId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ID that identifies Photon Controller persistent disk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_id\" <$> TF.attribute",
                    "name": "pd_id",
                    "method": "pdId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdId",
                    "optional": false,
                    "label": "_pdId"
                }
            ],
            "name": "PhotonPersistentDisk",
            "attributes": [],
            "parameters": [
                {
                    "default": "_pdId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ID that identifies Photon Controller persistent disk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_id\" <$> TF.attribute",
                    "name": "pd_id",
                    "method": "pdId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdId",
                    "optional": false,
                    "label": "_pdId"
                }
            ],
            "hashable": false,
            "type": "PhotonPersistentDisk s",
            "original": "photon_persistent_disk"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Arguments to the entrypoint. The docker image's CMD is used if this is not",
                        "provided. Variable references $(VAR_NAME) are expanded using the container's",
                        "environment. If a variable cannot be resolved, the reference in the input",
                        "string will be unchanged. The $(VAR_NAME) syntax can be escaped with a",
                        "double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,",
                        "regardless of whether the variable exists or not. Cannot be updated. More",
                        "info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"args\" <$> TF.attribute",
                    "name": "args",
                    "method": "args",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasArgs",
                    "optional": true,
                    "label": "_args"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT",
                        "is used if this is not provided. Variable references $(VAR_NAME) are",
                        "expanded using the container's environment. If a variable cannot be",
                        "resolved, the reference in the input string will be unchanged. The",
                        "$(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).",
                        "Escaped references will never be expanded, regardless of whether the",
                        "variable exists or not. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "command",
                    "method": "command",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "optional": true,
                    "label": "_command"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of environment variables to set in the container. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"env\" <$> TF.attribute",
                    "name": "env",
                    "method": "env",
                    "conflicts": [],
                    "type": "TF.Attr s [Env s]",
                    "class": "HasEnv",
                    "optional": true,
                    "label": "_env"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Docker image name. More info: http://kubernetes.io/docs/user-guide/images"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image\" <$> TF.attribute",
                    "name": "image",
                    "method": "image",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasImage",
                    "optional": true,
                    "label": "_image"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Actions that the management system should take in response to container",
                        "lifecycle events"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"lifecycle\" <$> TF.attribute",
                    "name": "lifecycle",
                    "method": "lifecycle",
                    "conflicts": [],
                    "type": "TF.Attr s [Lifecycle s]",
                    "class": "HasLifecycle",
                    "optional": true,
                    "label": "_lifecycle"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container liveness. Container will be restarted if the",
                        "probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"liveness_probe\" <$> TF.attribute",
                    "name": "liveness_probe",
                    "method": "livenessProbe",
                    "conflicts": [],
                    "type": "TF.Attr s [LivenessProbe s]",
                    "class": "HasLivenessProbe",
                    "optional": true,
                    "label": "_livenessProbe"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of ports to expose from the container. Exposing a port here gives the",
                        "system additional information about the network connections a container",
                        "uses, but is primarily informational. Not specifying a port here DOES NOT",
                        "prevent that port from being exposed. Any port which is listening on the",
                        "default \"0.0.0.0\" address inside a container will be accessible from the",
                        "network. Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s [Port s]",
                    "class": "HasPort",
                    "optional": true,
                    "label": "_port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container service readiness. Container will be removed",
                        "from service endpoints if the probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"readiness_probe\" <$> TF.attribute",
                    "name": "readiness_probe",
                    "method": "readinessProbe",
                    "conflicts": [],
                    "type": "TF.Attr s [ReadinessProbe s]",
                    "class": "HasReadinessProbe",
                    "optional": true,
                    "label": "_readinessProbe"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Security options the pod should run with. More info:",
                        "http://releases.k8s.io/HEAD/docs/design/security_context.md"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"security_context\" <$> TF.attribute",
                    "name": "security_context",
                    "method": "securityContext",
                    "conflicts": [],
                    "type": "TF.Attr s [SecurityContext s]",
                    "class": "HasSecurityContext",
                    "optional": true,
                    "label": "_securityContext"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a buffer for stdin in the container",
                        "runtime. If this is not set, reads from stdin in the container will always",
                        "result in EOF."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"stdin\" <$> TF.attribute",
                    "name": "stdin",
                    "method": "stdin",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdin",
                    "optional": true,
                    "label": "_stdin"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether the container runtime should close the stdin channel after it has",
                        "been opened by a single attach. When stdin is true the stdin stream will",
                        "remain open across multiple attach sessions. If stdinOnce is set to true,",
                        "stdin is opened on container start, is empty until the first client attaches",
                        "to stdin, and then remains open and accepts data until the client",
                        "disconnects, at which time stdin is closed and remains closed until the",
                        "container is restarted. If this flag is false, a container processes that",
                        "reads from stdin will never receive an EOF."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"stdin_once\" <$> TF.attribute",
                    "name": "stdin_once",
                    "method": "stdinOnce",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdinOnce",
                    "optional": true,
                    "label": "_stdinOnce"
                },
                {
                    "default": "TF.value \"/dev/termination-log\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: Path at which the file to which the container's termination",
                        "message will be written is mounted into the container's filesystem. Message",
                        "written is intended to be brief final status, such as an assertion failure",
                        "message. Defaults to /dev/termination-log. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"termination_message_path\" <$> TF.attribute",
                    "name": "termination_message_path",
                    "method": "terminationMessagePath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTerminationMessagePath",
                    "optional": true,
                    "label": "_terminationMessagePath"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a TTY for itself"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tty\" <$> TF.attribute",
                    "name": "tty",
                    "method": "tty",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasTty",
                    "optional": true,
                    "label": "_tty"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Pod volumes to mount into the container's filesystem. Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_mount\" <$> TF.attribute",
                    "name": "volume_mount",
                    "method": "volumeMount",
                    "conflicts": [],
                    "type": "TF.Attr s [VolumeMount s]",
                    "class": "HasVolumeMount",
                    "optional": true,
                    "label": "_volumeMount"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Container's working directory. If not specified, the container runtime's",
                        "default will be used, which might be configured in the container image.",
                        "Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"working_dir\" <$> TF.attribute",
                    "name": "working_dir",
                    "method": "workingDir",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasWorkingDir",
                    "optional": true,
                    "label": "_workingDir"
                }
            ],
            "name": "InitContainer",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if",
                        ":latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/images#updating-images"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image_pull_policy\" <$> TF.attribute",
                    "name": "image_pull_policy",
                    "method": "computedImagePullPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedImagePullPolicy",
                    "optional": true,
                    "label": "_computedImagePullPolicy"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Compute Resources required by this container. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "resources",
                    "method": "computedResources",
                    "conflicts": [],
                    "type": "TF.Attr s [Resources s]",
                    "class": "HasComputedResources",
                    "optional": true,
                    "label": "_computedResources"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "hashable": false,
            "type": "InitContainer s",
            "original": "init_container"
        },
        {
            "arguments": [],
            "name": "Spec",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The IP address of the service. It is usually assigned randomly by the",
                        "master. If an address is specified manually and is not in use by others, it",
                        "will be allocated to the service; otherwise, creation of the service will",
                        "fail. `None` can be specified for headless services when proxying is not",
                        "required. Ignored if type is `ExternalName`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cluster_ip\" <$> TF.attribute",
                    "name": "cluster_ip",
                    "method": "computedClusterIp",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedClusterIp",
                    "optional": false,
                    "label": "_computedClusterIp"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A list of IP addresses for which nodes in the cluster will also accept",
                        "traffic for this service. These IPs are not managed by Kubernetes. The user",
                        "is responsible for ensuring that traffic arrives at a node with this IP.  A",
                        "common example is external load-balancers that are not part of the",
                        "Kubernetes system."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"external_ips\" <$> TF.attribute",
                    "name": "external_ips",
                    "method": "computedExternalIps",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasComputedExternalIps",
                    "optional": false,
                    "label": "_computedExternalIps"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The external reference that kubedns or equivalent will return as a CNAME",
                        "record for this service. No proxying will be involved. Must be a valid DNS",
                        "name and requires `type` to be `ExternalName`."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"external_name\" <$> TF.attribute",
                    "name": "external_name",
                    "method": "computedExternalName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedExternalName",
                    "optional": false,
                    "label": "_computedExternalName"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Only applies to `type = LoadBalancer`. LoadBalancer will get created with",
                        "the IP specified in this field. This feature depends on whether the",
                        "underlying cloud-provider supports specifying this field when a load",
                        "balancer is created. This field will be ignored if the cloud-provider does",
                        "not support the feature."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_ip\" <$> TF.attribute",
                    "name": "load_balancer_ip",
                    "method": "computedLoadBalancerIp",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedLoadBalancerIp",
                    "optional": false,
                    "label": "_computedLoadBalancerIp"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "If specified and supported by the platform, this will restrict traffic",
                        "through the cloud-provider load-balancer will be restricted to the specified",
                        "client IPs. This field will be ignored if the cloud-provider does not",
                        "support the feature. More info:",
                        "http://kubernetes.io/docs/user-guide/services-firewalls"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_source_ranges\" <$> TF.attribute",
                    "name": "load_balancer_source_ranges",
                    "method": "computedLoadBalancerSourceRanges",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasComputedLoadBalancerSourceRanges",
                    "optional": false,
                    "label": "_computedLoadBalancerSourceRanges"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The list of ports that are exposed by this service. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "port",
                    "method": "computedPort",
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (Port s))",
                    "class": "HasComputedPort",
                    "optional": false,
                    "label": "_computedPort"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Route service traffic to pods with label keys and values matching this",
                        "selector. Only applies to types `ClusterIP`, `NodePort`, and `LoadBalancer`.",
                        "More info: http://kubernetes.io/docs/user-guide/services#overview"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"selector\" <$> TF.attribute",
                    "name": "selector",
                    "method": "computedSelector",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasComputedSelector",
                    "optional": false,
                    "label": "_computedSelector"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Used to maintain session affinity. Supports `ClientIP` and `None`. Defaults",
                        "to `None`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"session_affinity\" <$> TF.attribute",
                    "name": "session_affinity",
                    "method": "computedSessionAffinity",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSessionAffinity",
                    "optional": false,
                    "label": "_computedSessionAffinity"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Determines how the service is exposed. Defaults to `ClusterIP`. Valid",
                        "options are `ExternalName`, `ClusterIP`, `NodePort`, and `LoadBalancer`.",
                        "`ExternalName` maps to the specified `external_name`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#overview"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "type",
                    "method": "computedType'",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedType'",
                    "optional": false,
                    "label": "_computedType'"
                }
            ],
            "parameters": [],
            "hashable": false,
            "type": "Spec s",
            "original": "spec"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the storage class that may be used",
                        "to store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "annotations",
                    "method": "annotations",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "optional": true,
                    "label": "_annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the storage class. May match selectors of replication",
                        "controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "labels",
                    "method": "labels",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "optional": true,
                    "label": "_labels"
                }
            ],
            "name": "Metadata",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "generation",
                    "method": "computedGeneration",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedGeneration",
                    "optional": false,
                    "label": "_computedGeneration"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the storage class, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "computedName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "optional": true,
                    "label": "_computedName"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this storage class",
                        "that can be used by clients to determine when storage class has changed.",
                        "Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "resource_version",
                    "method": "computedResourceVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "optional": false,
                    "label": "_computedResourceVersion"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this storage class."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "self_link",
                    "method": "computedSelfLink",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "optional": false,
                    "label": "_computedSelfLink"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this storage class. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "uid",
                    "method": "computedUid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "optional": false,
                    "label": "_computedUid"
                }
            ],
            "parameters": [],
            "hashable": false,
            "type": "Metadata s",
            "original": "metadata"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The label key that the selector applies to."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "key",
                    "method": "key",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "optional": true,
                    "label": "_key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A key's relationship to a set of values. Valid operators ard `In`, `NotIn`,",
                        "`Exists` and `DoesNotExist`."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"operator\" <$> TF.attribute",
                    "name": "operator",
                    "method": "operator",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasOperator",
                    "optional": true,
                    "label": "_operator"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An array of string values. If the operator is `In` or `NotIn`, the values",
                        "array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the",
                        "values array must be empty. This array is replaced during a strategic merge",
                        "patch."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"values\" <$> TF.attribute",
                    "name": "values",
                    "method": "values",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasValues",
                    "optional": true,
                    "label": "_values"
                }
            ],
            "name": "MatchExpressions",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "MatchExpressions s",
            "original": "match_expressions"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Target directory name. Must not contain or start with '..'. If '.' is",
                        "supplied, the volume directory will be the git repository. Otherwise, if",
                        "specified, the volume will contain the git repository in the subdirectory",
                        "with the given name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"directory\" <$> TF.attribute",
                    "name": "directory",
                    "method": "directory",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDirectory",
                    "optional": true,
                    "label": "_directory"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Repository URL"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"repository\" <$> TF.attribute",
                    "name": "repository",
                    "method": "repository",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRepository",
                    "optional": true,
                    "label": "_repository"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Commit hash for the specified revision."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"revision\" <$> TF.attribute",
                    "name": "revision",
                    "method": "revision",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRevision",
                    "optional": true,
                    "label": "_revision"
                }
            ],
            "name": "GitRepo",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "GitRepo s",
            "original": "git_repo"
        },
        {
            "arguments": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "optional": false,
                    "label": "_port"
                }
            ],
            "name": "TcpSocket",
            "attributes": [],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "optional": false,
                    "label": "_port"
                }
            ],
            "hashable": false,
            "type": "TcpSocket s",
            "original": "tcp_socket"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Default resource requirement limit value by resource name if resource limit",
                        "is omitted."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default\" <$> TF.attribute",
                    "name": "default",
                    "method": "default'",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasDefault'",
                    "optional": true,
                    "label": "_default'"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Max usage constraints on this kind by resource name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"max\" <$> TF.attribute",
                    "name": "max",
                    "method": "max",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasMax",
                    "optional": true,
                    "label": "_max"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The named resource must have a request and limit that are both non-zero",
                        "where limit divided by request is less than or equal to the enumerated",
                        "value; this represents the max burst for the named resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"max_limit_request_ratio\" <$> TF.attribute",
                    "name": "max_limit_request_ratio",
                    "method": "maxLimitRequestRatio",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasMaxLimitRequestRatio",
                    "optional": true,
                    "label": "_maxLimitRequestRatio"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Min usage constraints on this kind by resource name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"min\" <$> TF.attribute",
                    "name": "min",
                    "method": "min",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasMin",
                    "optional": true,
                    "label": "_min"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Type of resource that this limit applies to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "type",
                    "method": "type'",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "optional": true,
                    "label": "_type'"
                }
            ],
            "name": "Limit",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The default resource requirement request value by resource name if resource",
                        "request is omitted."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_request\" <$> TF.attribute",
                    "name": "default_request",
                    "method": "computedDefaultRequest",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasComputedDefaultRequest",
                    "optional": true,
                    "label": "_computedDefaultRequest"
                }
            ],
            "parameters": [],
            "hashable": false,
            "type": "Limit s",
            "original": "limit"
        },
        {
            "arguments": [],
            "name": "LoadBalancerIngress",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"hostname\" <$> TF.attribute",
                    "name": "hostname",
                    "method": "computedHostname",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedHostname",
                    "optional": false,
                    "label": "_computedHostname"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"ip\" <$> TF.attribute",
                    "name": "ip",
                    "method": "computedIp",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedIp",
                    "optional": false,
                    "label": "_computedIp"
                }
            ],
            "parameters": [],
            "hashable": false,
            "type": "LoadBalancerIngress s",
            "original": "load_balancer_ingress"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "fs_type",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "optional": true,
                    "label": "_fsType"
                },
                {
                    "default": "_lun",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target lun number"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "lun",
                    "method": "lun",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasLun",
                    "optional": false,
                    "label": "_lun"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "read_only",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "optional": true,
                    "label": "_readOnly"
                },
                {
                    "default": "_targetWwNs",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target worldwide names (WWNs)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_ww_ns\" <$> TF.attribute",
                    "name": "target_ww_ns",
                    "method": "targetWwNs",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasTargetWwNs",
                    "optional": false,
                    "label": "_targetWwNs"
                }
            ],
            "name": "Fc",
            "attributes": [],
            "parameters": [
                {
                    "default": "_lun",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target lun number"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "lun",
                    "method": "lun",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasLun",
                    "optional": false,
                    "label": "_lun"
                },
                {
                    "default": "_targetWwNs",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target worldwide names (WWNs)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_ww_ns\" <$> TF.attribute",
                    "name": "target_ww_ns",
                    "method": "targetWwNs",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasTargetWwNs",
                    "optional": false,
                    "label": "_targetWwNs"
                }
            ],
            "hashable": false,
            "type": "Fc s",
            "original": "fc"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "exec",
                    "method": "exec",
                    "conflicts": [],
                    "type": "TF.Attr s [Exec s]",
                    "class": "HasExec",
                    "optional": true,
                    "label": "_exec"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive failures for the probe to be considered failed after",
                        "having succeeded."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failure_threshold\" <$> TF.attribute",
                    "name": "failure_threshold",
                    "method": "failureThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasFailureThreshold",
                    "optional": true,
                    "label": "_failureThreshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "http_get",
                    "method": "httpGet",
                    "conflicts": [],
                    "type": "TF.Attr s [HttpGet s]",
                    "class": "HasHttpGet",
                    "optional": true,
                    "label": "_httpGet"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after the container has started before liveness probes are",
                        "initiated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"initial_delay_seconds\" <$> TF.attribute",
                    "name": "initial_delay_seconds",
                    "method": "initialDelaySeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasInitialDelaySeconds",
                    "optional": true,
                    "label": "_initialDelaySeconds"
                },
                {
                    "default": "TF.value 10",
                    "computed": false,
                    "required": false,
                    "help": [
                        "How often (in seconds) to perform the probe"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"period_seconds\" <$> TF.attribute",
                    "name": "period_seconds",
                    "method": "periodSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasPeriodSeconds",
                    "optional": true,
                    "label": "_periodSeconds"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive successes for the probe to be considered successful",
                        "after having failed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"success_threshold\" <$> TF.attribute",
                    "name": "success_threshold",
                    "method": "successThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasSuccessThreshold",
                    "optional": true,
                    "label": "_successThreshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "tcp_socket",
                    "method": "tcpSocket",
                    "conflicts": [],
                    "type": "TF.Attr s [TcpSocket s]",
                    "class": "HasTcpSocket",
                    "optional": true,
                    "label": "_tcpSocket"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after which the probe times out. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"timeout_seconds\" <$> TF.attribute",
                    "name": "timeout_seconds",
                    "method": "timeoutSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasTimeoutSeconds",
                    "optional": true,
                    "label": "_timeoutSeconds"
                }
            ],
            "name": "LivenessProbe",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "LivenessProbe s",
            "original": "liveness_probe"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "read_only",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "optional": true,
                    "label": "_readOnly"
                },
                {
                    "default": "_secretName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of secret that contains Azure Storage Account Name and Key"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_name\" <$> TF.attribute",
                    "name": "secret_name",
                    "method": "secretName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretName",
                    "optional": false,
                    "label": "_secretName"
                },
                {
                    "default": "_shareName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Share Name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"share_name\" <$> TF.attribute",
                    "name": "share_name",
                    "method": "shareName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasShareName",
                    "optional": false,
                    "label": "_shareName"
                }
            ],
            "name": "AzureFile",
            "attributes": [],
            "parameters": [
                {
                    "default": "_secretName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of secret that contains Azure Storage Account Name and Key"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_name\" <$> TF.attribute",
                    "name": "secret_name",
                    "method": "secretName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretName",
                    "optional": false,
                    "label": "_secretName"
                },
                {
                    "default": "_shareName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Share Name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"share_name\" <$> TF.attribute",
                    "name": "share_name",
                    "method": "shareName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasShareName",
                    "optional": false,
                    "label": "_shareName"
                }
            ],
            "hashable": false,
            "type": "AzureFile s",
            "original": "azure_file"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "API version of the referent"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"api_version\" <$> TF.attribute",
                    "name": "api_version",
                    "method": "apiVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasApiVersion",
                    "optional": true,
                    "label": "_apiVersion"
                },
                {
                    "default": "_kind",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Kind of the referent. e.g. `ReplicationController`. More info:",
                        "http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#types-kinds"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"kind\" <$> TF.attribute",
                    "name": "kind",
                    "method": "kind",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKind",
                    "optional": false,
                    "label": "_kind"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "name": "ScaleTargetRef",
            "attributes": [],
            "parameters": [
                {
                    "default": "_kind",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Kind of the referent. e.g. `ReplicationController`. More info:",
                        "http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#types-kinds"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"kind\" <$> TF.attribute",
                    "name": "kind",
                    "method": "kind",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKind",
                    "optional": false,
                    "label": "_kind"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "hashable": false,
            "type": "ScaleTargetRef s",
            "original": "scale_target_ref"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "exec",
                    "method": "exec",
                    "conflicts": [],
                    "type": "TF.Attr s [Exec s]",
                    "class": "HasExec",
                    "optional": true,
                    "label": "_exec"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "http_get",
                    "method": "httpGet",
                    "conflicts": [],
                    "type": "TF.Attr s [HttpGet s]",
                    "class": "HasHttpGet",
                    "optional": true,
                    "label": "_httpGet"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "tcp_socket",
                    "method": "tcpSocket",
                    "conflicts": [],
                    "type": "TF.Attr s [TcpSocket s]",
                    "class": "HasTcpSocket",
                    "optional": true,
                    "label": "_tcpSocket"
                }
            ],
            "name": "PreStop",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "PreStop s",
            "original": "pre_stop"
        },
        {
            "arguments": [
                {
                    "default": "_driver",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Driver is the name of the driver to use for this volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"driver\" <$> TF.attribute",
                    "name": "driver",
                    "method": "driver",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDriver",
                    "optional": false,
                    "label": "_driver"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". The default filesystem depends",
                        "on FlexVolume script."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "fs_type",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "optional": true,
                    "label": "_fsType"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Extra command options if any."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"options\" <$> TF.attribute",
                    "name": "options",
                    "method": "options",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasOptions",
                    "optional": true,
                    "label": "_options"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the ReadOnly setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "read_only",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "optional": true,
                    "label": "_readOnly"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Reference to the secret object containing sensitive information to pass to",
                        "the plugin scripts. This may be empty if no secret object is specified. If",
                        "the secret object contains more than one secret, all secrets are passed to",
                        "the plugin scripts."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "secret_ref",
                    "method": "secretRef",
                    "conflicts": [],
                    "type": "TF.Attr s [SecretRef s]",
                    "class": "HasSecretRef",
                    "optional": true,
                    "label": "_secretRef"
                }
            ],
            "name": "FlexVolume",
            "attributes": [],
            "parameters": [
                {
                    "default": "_driver",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Driver is the name of the driver to use for this volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"driver\" <$> TF.attribute",
                    "name": "driver",
                    "method": "driver",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDriver",
                    "optional": false,
                    "label": "_driver"
                }
            ],
            "hashable": false,
            "type": "FlexVolume s",
            "original": "flex_volume"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key of the secret to select from. Must be a valid secret key."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "key",
                    "method": "key",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "optional": true,
                    "label": "_key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": true,
                    "label": "_name"
                }
            ],
            "name": "SecretKeyRef",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "SecretKeyRef s",
            "original": "secret_key_ref"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": true,
                    "label": "_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "value",
                    "method": "value",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "optional": true,
                    "label": "_value"
                }
            ],
            "name": "HttpHeader",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "HttpHeader s",
            "original": "http_header"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional duration in seconds the pod may be active on the node relative to",
                        "StartTime before the system will actively try to mark it failed and kill",
                        "associated containers. Value must be a positive integer."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"active_deadline_seconds\" <$> TF.attribute",
                    "name": "active_deadline_seconds",
                    "method": "activeDeadlineSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasActiveDeadlineSeconds",
                    "optional": true,
                    "label": "_activeDeadlineSeconds"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of containers belonging to the pod. Containers cannot currently be",
                        "added or removed. There must be at least one container in a Pod. Cannot be",
                        "updated. More info: http://kubernetes.io/docs/user-guide/containers"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"container\" <$> TF.attribute",
                    "name": "container",
                    "method": "container",
                    "conflicts": [],
                    "type": "TF.Attr s [Container s]",
                    "class": "HasContainer",
                    "optional": true,
                    "label": "_container"
                },
                {
                    "default": "TF.value \"ClusterFirst\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Set DNS policy for containers within the pod. One of 'ClusterFirst' or",
                        "'Default'. Defaults to 'ClusterFirst'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dns_policy\" <$> TF.attribute",
                    "name": "dns_policy",
                    "method": "dnsPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDnsPolicy",
                    "optional": true,
                    "label": "_dnsPolicy"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Use the host's ipc namespace. Optional: Default to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_ipc\" <$> TF.attribute",
                    "name": "host_ipc",
                    "method": "hostIpc",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostIpc",
                    "optional": true,
                    "label": "_hostIpc"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host networking requested for this pod. Use the host's network namespace. If",
                        "this option is set, the ports that will be used must be specified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_network\" <$> TF.attribute",
                    "name": "host_network",
                    "method": "hostNetwork",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostNetwork",
                    "optional": true,
                    "label": "_hostNetwork"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Use the host's pid namespace."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_pid\" <$> TF.attribute",
                    "name": "host_pid",
                    "method": "hostPid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostPid",
                    "optional": true,
                    "label": "_hostPid"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of init containers belonging to the pod. Init containers always run to",
                        "completion and each must complete succesfully before the next is started.",
                        "More info:",
                        "https://kubernetes.io/docs/concepts/workloads/pods/init-containers/"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"init_container\" <$> TF.attribute",
                    "name": "init_container",
                    "method": "initContainer",
                    "conflicts": [],
                    "type": "TF.Attr s [InitContainer s]",
                    "class": "HasInitContainer",
                    "optional": true,
                    "label": "_initContainer"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "NodeSelector is a selector which must be true for the pod to fit on a node.",
                        "Selector which must match a node's labels for the pod to be scheduled on",
                        "that node. More info: http://kubernetes.io/docs/user-guide/node-selection."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"node_selector\" <$> TF.attribute",
                    "name": "node_selector",
                    "method": "nodeSelector",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasNodeSelector",
                    "optional": true,
                    "label": "_nodeSelector"
                },
                {
                    "default": "TF.value \"Always\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Restart policy for all containers within the pod. One of Always, OnFailure,",
                        "Never. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#restartpolicy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"restart_policy\" <$> TF.attribute",
                    "name": "restart_policy",
                    "method": "restartPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRestartPolicy",
                    "optional": true,
                    "label": "_restartPolicy"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "SecurityContext holds pod-level security attributes and common container",
                        "settings. Optional: Defaults to empty"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"security_context\" <$> TF.attribute",
                    "name": "security_context",
                    "method": "securityContext",
                    "conflicts": [],
                    "type": "TF.Attr s [SecurityContext s]",
                    "class": "HasSecurityContext",
                    "optional": true,
                    "label": "_securityContext"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If specified, the fully qualified Pod hostname will be \"...svc.\". If not",
                        "specified, the pod will not have a domainname at all.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"subdomain\" <$> TF.attribute",
                    "name": "subdomain",
                    "method": "subdomain",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSubdomain",
                    "optional": true,
                    "label": "_subdomain"
                },
                {
                    "default": "TF.value 30",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional duration in seconds the pod needs to terminate gracefully. May be",
                        "decreased in delete request. Value must be non-negative integer. The value",
                        "zero indicates delete immediately. If this value is nil, the default grace",
                        "period will be used instead. The grace period is the duration in seconds",
                        "after the processes running in the pod are sent a termination signal and the",
                        "time when the processes are forcibly halted with a kill signal. Set this",
                        "value longer than the expected cleanup time for your process."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"termination_grace_period_seconds\" <$> TF.attribute",
                    "name": "termination_grace_period_seconds",
                    "method": "terminationGracePeriodSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasTerminationGracePeriodSeconds",
                    "optional": true,
                    "label": "_terminationGracePeriodSeconds"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of volumes that can be mounted by containers belonging to the pod. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "volume",
                    "method": "volume",
                    "conflicts": [],
                    "type": "TF.Attr s [Volume s]",
                    "class": "HasVolume",
                    "optional": true,
                    "label": "_volume"
                }
            ],
            "name": "Template",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Specifies the hostname of the Pod If not specified, the pod's hostname will",
                        "be set to a system-defined value."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"hostname\" <$> TF.attribute",
                    "name": "hostname",
                    "method": "computedHostname",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedHostname",
                    "optional": true,
                    "label": "_computedHostname"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "ImagePullSecrets is an optional list of references to secrets in the same",
                        "namespace to use for pulling any of the images used by this PodSpec. If",
                        "specified, these secrets will be passed to individual puller implementations",
                        "for them to use. For example, in the case of docker, only DockerConfig type",
                        "secrets are honored. More info:",
                        "http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image_pull_secrets\" <$> TF.attribute",
                    "name": "image_pull_secrets",
                    "method": "computedImagePullSecrets",
                    "conflicts": [],
                    "type": "TF.Attr s [ImagePullSecrets s]",
                    "class": "HasComputedImagePullSecrets",
                    "optional": true,
                    "label": "_computedImagePullSecrets"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "NodeName is a request to schedule this pod onto a specific node. If it is",
                        "non-empty, the scheduler simply schedules this pod onto that node, assuming",
                        "that it fits resource requirements."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"node_name\" <$> TF.attribute",
                    "name": "node_name",
                    "method": "computedNodeName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedNodeName",
                    "optional": true,
                    "label": "_computedNodeName"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "ServiceAccountName is the name of the ServiceAccount to use to run this pod.",
                        "More info: http://releases.k8s.io/HEAD/docs/design/service_accounts.md."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"service_account_name\" <$> TF.attribute",
                    "name": "service_account_name",
                    "method": "computedServiceAccountName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedServiceAccountName",
                    "optional": true,
                    "label": "_computedServiceAccountName"
                }
            ],
            "parameters": [],
            "hashable": false,
            "type": "Template s",
            "original": "template"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#iscsi"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "fs_type",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "optional": true,
                    "label": "_fsType"
                },
                {
                    "default": "_iqn",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Target iSCSI Qualified Name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iqn\" <$> TF.attribute",
                    "name": "iqn",
                    "method": "iqn",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIqn",
                    "optional": false,
                    "label": "_iqn"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ISCSI interface name that uses an iSCSI transport. Defaults to 'default'",
                        "(tcp)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi_interface\" <$> TF.attribute",
                    "name": "iscsi_interface",
                    "method": "iscsiInterface",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIscsiInterface",
                    "optional": true,
                    "label": "_iscsiInterface"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ISCSI target lun number."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "lun",
                    "method": "lun",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasLun",
                    "optional": true,
                    "label": "_lun"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "read_only",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "optional": true,
                    "label": "_readOnly"
                },
                {
                    "default": "_targetPortal",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ISCSI target portal. The portal is either an IP or ip_addr:port if the port",
                        "is other than default (typically TCP ports 860 and 3260)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_portal\" <$> TF.attribute",
                    "name": "target_portal",
                    "method": "targetPortal",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTargetPortal",
                    "optional": false,
                    "label": "_targetPortal"
                }
            ],
            "name": "Iscsi",
            "attributes": [],
            "parameters": [
                {
                    "default": "_iqn",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Target iSCSI Qualified Name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iqn\" <$> TF.attribute",
                    "name": "iqn",
                    "method": "iqn",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIqn",
                    "optional": false,
                    "label": "_iqn"
                },
                {
                    "default": "_targetPortal",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ISCSI target portal. The portal is either an IP or ip_addr:port if the port",
                        "is other than default (typically TCP ports 860 and 3260)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_portal\" <$> TF.attribute",
                    "name": "target_portal",
                    "method": "targetPortal",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTargetPortal",
                    "optional": false,
                    "label": "_targetPortal"
                }
            ],
            "hashable": false,
            "type": "Iscsi s",
            "original": "iscsi"
        },
        {
            "arguments": [
                {
                    "default": "_cachingMode",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Host Caching mode: None, Read Only, Read Write."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"caching_mode\" <$> TF.attribute",
                    "name": "caching_mode",
                    "method": "cachingMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCachingMode",
                    "optional": false,
                    "label": "_cachingMode"
                },
                {
                    "default": "_dataDiskUri",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The URI the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data_disk_uri\" <$> TF.attribute",
                    "name": "data_disk_uri",
                    "method": "dataDiskUri",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDataDiskUri",
                    "optional": false,
                    "label": "_dataDiskUri"
                },
                {
                    "default": "_diskName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Name of the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disk_name\" <$> TF.attribute",
                    "name": "disk_name",
                    "method": "diskName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDiskName",
                    "optional": false,
                    "label": "_diskName"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "fs_type",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "optional": true,
                    "label": "_fsType"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "read_only",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "optional": true,
                    "label": "_readOnly"
                }
            ],
            "name": "AzureDisk",
            "attributes": [],
            "parameters": [
                {
                    "default": "_cachingMode",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Host Caching mode: None, Read Only, Read Write."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"caching_mode\" <$> TF.attribute",
                    "name": "caching_mode",
                    "method": "cachingMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCachingMode",
                    "optional": false,
                    "label": "_cachingMode"
                },
                {
                    "default": "_dataDiskUri",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The URI the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data_disk_uri\" <$> TF.attribute",
                    "name": "data_disk_uri",
                    "method": "dataDiskUri",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDataDiskUri",
                    "optional": false,
                    "label": "_dataDiskUri"
                },
                {
                    "default": "_diskName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Name of the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disk_name\" <$> TF.attribute",
                    "name": "disk_name",
                    "method": "diskName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDiskName",
                    "optional": false,
                    "label": "_diskName"
                }
            ],
            "hashable": false,
            "type": "AzureDisk s",
            "original": "azure_disk"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A special supplemental group that applies to all containers in a pod. Some",
                        "volume types allow the Kubelet to change the ownership of that volume to be",
                        "owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is",
                        "set (new files created in the volume will be owned by FSGroup) 3. The",
                        "permission bits are OR'd with rw-rw---- If unset, the Kubelet will not",
                        "modify the ownership and permissions of any volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_group\" <$> TF.attribute",
                    "name": "fs_group",
                    "method": "fsGroup",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasFsGroup",
                    "optional": true,
                    "label": "_fsGroup"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Indicates that the container must run as a non-root user. If true, the",
                        "Kubelet will validate the image at runtime to ensure that it does not run as",
                        "UID 0 (root) and fail to start the container if it does."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_non_root\" <$> TF.attribute",
                    "name": "run_as_non_root",
                    "method": "runAsNonRoot",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRunAsNonRoot",
                    "optional": true,
                    "label": "_runAsNonRoot"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The UID to run the entrypoint of the container process. Defaults to user",
                        "specified in image metadata if unspecified"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_user\" <$> TF.attribute",
                    "name": "run_as_user",
                    "method": "runAsUser",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasRunAsUser",
                    "optional": true,
                    "label": "_runAsUser"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The SELinux context to be applied to all containers. If unspecified, the",
                        "container runtime will allocate a random SELinux context for each container.",
                        "May also be set in SecurityContext. If set in both SecurityContext and",
                        "PodSecurityContext, the value specified in SecurityContext takes precedence",
                        "for that container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"se_linux_options\" <$> TF.attribute",
                    "name": "se_linux_options",
                    "method": "seLinuxOptions",
                    "conflicts": [],
                    "type": "TF.Attr s [SeLinuxOptions s]",
                    "class": "HasSeLinuxOptions",
                    "optional": true,
                    "label": "_seLinuxOptions"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of groups applied to the first process run in each container, in",
                        "addition to the container's primary GID. If unspecified, no groups will be",
                        "added to any container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"supplemental_groups\" <$> TF.attribute",
                    "name": "supplemental_groups",
                    "method": "supplementalGroups",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Integer)]",
                    "class": "HasSupplementalGroups",
                    "optional": true,
                    "label": "_supplementalGroups"
                }
            ],
            "name": "SecurityContext",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "SecurityContext s",
            "original": "security_context"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Added capabilities"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"add\" <$> TF.attribute",
                    "name": "add",
                    "method": "add",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasAdd",
                    "optional": true,
                    "label": "_add"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Removed capabilities"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drop\" <$> TF.attribute",
                    "name": "drop",
                    "method": "drop",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasDrop",
                    "optional": true,
                    "label": "_drop"
                }
            ],
            "name": "Capabilities",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "Capabilities s",
            "original": "capabilities"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "fs_type",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "optional": true,
                    "label": "_fsType"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The partition in the volume that you want to mount. If omitted, the default",
                        "is to mount by volume name. Examples: For volume /dev/sda1, you specify the",
                        "partition as \"1\". Similarly, the volume partition for /dev/sda is \"0\" (or",
                        "you can leave the property empty). More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"partition\" <$> TF.attribute",
                    "name": "partition",
                    "method": "partition",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasPartition",
                    "optional": true,
                    "label": "_partition"
                },
                {
                    "default": "_pdName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique name of the PD resource in GCE. Used to identify the disk in GCE.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_name\" <$> TF.attribute",
                    "name": "pd_name",
                    "method": "pdName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdName",
                    "optional": false,
                    "label": "_pdName"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the ReadOnly setting in VolumeMounts. Defaults to false.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "read_only",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "optional": true,
                    "label": "_readOnly"
                }
            ],
            "name": "GcePersistentDisk",
            "attributes": [],
            "parameters": [
                {
                    "default": "_pdName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique name of the PD resource in GCE. Used to identify the disk in GCE.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_name\" <$> TF.attribute",
                    "name": "pd_name",
                    "method": "pdName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdName",
                    "optional": false,
                    "label": "_pdName"
                }
            ],
            "hashable": false,
            "type": "GcePersistentDisk s",
            "original": "gce_persistent_disk"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on created files by default. Must be a value",
                        "between 0 and 0777. Defaults to 0644. Directories within the path are not",
                        "affected by this setting. This might be in conflict with other options that",
                        "affect the file mode, like fsGroup, and the result can be other mode bits",
                        "set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_mode\" <$> TF.attribute",
                    "name": "default_mode",
                    "method": "defaultMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasDefaultMode",
                    "optional": true,
                    "label": "_defaultMode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If unspecified, each key-value pair in the Data field of the referenced",
                        "ConfigMap will be projected into the volume as a file whose name is the key",
                        "and content is the value. If specified, the listed keys will be projected",
                        "into the specified paths, and unlisted keys will not be present. If a key is",
                        "specified which is not present in the ConfigMap, the volume setup will",
                        "error. Paths must be relative and may not contain the '..' path or start",
                        "with '..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"items\" <$> TF.attribute",
                    "name": "items",
                    "method": "items",
                    "conflicts": [],
                    "type": "TF.Attr s [Items s]",
                    "class": "HasItems",
                    "optional": true,
                    "label": "_items"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": true,
                    "label": "_name"
                }
            ],
            "name": "ConfigMap",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "ConfigMap s",
            "original": "config_map"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Group to map volume access to Default is no group"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"group\" <$> TF.attribute",
                    "name": "group",
                    "method": "group",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGroup",
                    "optional": true,
                    "label": "_group"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the Quobyte volume to be mounted with read-only",
                        "permissions. Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "read_only",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "optional": true,
                    "label": "_readOnly"
                },
                {
                    "default": "_registry",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Registry represents a single or multiple Quobyte Registry services specified",
                        "as a string as host:port pair (multiple entries are separated with commas)",
                        "which acts as the central registry for volumes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"registry\" <$> TF.attribute",
                    "name": "registry",
                    "method": "registry",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRegistry",
                    "optional": false,
                    "label": "_registry"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User to map volume access to Defaults to serivceaccount user"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "user",
                    "method": "user",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "optional": true,
                    "label": "_user"
                },
                {
                    "default": "_volume",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume is a string that references an already created Quobyte volume by",
                        "name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "volume",
                    "method": "volume",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolume",
                    "optional": false,
                    "label": "_volume"
                }
            ],
            "name": "Quobyte",
            "attributes": [],
            "parameters": [
                {
                    "default": "_registry",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Registry represents a single or multiple Quobyte Registry services specified",
                        "as a string as host:port pair (multiple entries are separated with commas)",
                        "which acts as the central registry for volumes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"registry\" <$> TF.attribute",
                    "name": "registry",
                    "method": "registry",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRegistry",
                    "optional": false,
                    "label": "_registry"
                },
                {
                    "default": "_volume",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume is a string that references an already created Quobyte volume by",
                        "name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "volume",
                    "method": "volume",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolume",
                    "optional": false,
                    "label": "_volume"
                }
            ],
            "hashable": false,
            "type": "Quobyte s",
            "original": "quobyte"
        },
        {
            "arguments": [],
            "name": "Port",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The name of this port within the service. All ports within the service must",
                        "have unique names. Optional if only one ServicePort is defined on this",
                        "service."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "computedName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "optional": false,
                    "label": "_computedName"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The port on each node on which this service is exposed when `type` is",
                        "`NodePort` or `LoadBalancer`. Usually assigned by the system. If specified,",
                        "it will be allocated to the service if unused or else creation of the",
                        "service will fail. Default is to auto-allocate a port if the `type` of this",
                        "service requires one. More info:",
                        "http://kubernetes.io/docs/user-guide/services#type--nodeport"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"node_port\" <$> TF.attribute",
                    "name": "node_port",
                    "method": "computedNodePort",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedNodePort",
                    "optional": false,
                    "label": "_computedNodePort"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The port that will be exposed by this service."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "port",
                    "method": "computedPort",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedPort",
                    "optional": false,
                    "label": "_computedPort"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The IP protocol for this port. Supports `TCP` and `UDP`. Default is `TCP`."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"protocol\" <$> TF.attribute",
                    "name": "protocol",
                    "method": "computedProtocol",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedProtocol",
                    "optional": false,
                    "label": "_computedProtocol"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Number or name of the port to access on the pods targeted by the service.",
                        "Number must be in the range 1 to 65535. This field is ignored for services",
                        "with `cluster_ip = \"None\"`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#defining-a-service"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_port\" <$> TF.attribute",
                    "name": "target_port",
                    "method": "computedTargetPort",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedTargetPort",
                    "optional": false,
                    "label": "_computedTargetPort"
                }
            ],
            "parameters": [],
            "hashable": false,
            "type": "Port s",
            "original": "port"
        }
    ],
    "arguments": [
        {
            "default": "P.Nothing",
            "computed": false,
            "required": false,
            "help": [
                "PEM-encoded client certificate for TLS authentication."
            ],
            "forceNew": false,
            "encoder": "TF.assign \"client_certificate\" <$>",
            "name": "client_certificate",
            "method": "clientCertificate",
            "conflicts": [],
            "type": "P.Maybe P.Text",
            "class": "HasClientCertificate",
            "optional": true,
            "label": "_clientCertificate"
        },
        {
            "default": "P.Nothing",
            "computed": false,
            "required": false,
            "help": [
                "PEM-encoded client certificate key for TLS authentication."
            ],
            "forceNew": false,
            "encoder": "TF.assign \"client_key\" <$>",
            "name": "client_key",
            "method": "clientKey",
            "conflicts": [],
            "type": "P.Maybe P.Text",
            "class": "HasClientKey",
            "optional": true,
            "label": "_clientKey"
        },
        {
            "default": "P.Nothing",
            "computed": false,
            "required": false,
            "help": [
                "PEM-encoded root certificates bundle for TLS authentication."
            ],
            "forceNew": false,
            "encoder": "TF.assign \"cluster_ca_certificate\" <$>",
            "name": "cluster_ca_certificate",
            "method": "clusterCaCertificate",
            "conflicts": [],
            "type": "P.Maybe P.Text",
            "class": "HasClusterCaCertificate",
            "optional": true,
            "label": "_clusterCaCertificate"
        },
        {
            "default": "P.Nothing",
            "computed": false,
            "required": false,
            "help": [],
            "forceNew": false,
            "encoder": "TF.assign \"config_context\" <$>",
            "name": "config_context",
            "method": "configContext",
            "conflicts": [],
            "type": "P.Maybe P.Text",
            "class": "HasConfigContext",
            "optional": true,
            "label": "_configContext"
        },
        {
            "default": "P.Nothing",
            "computed": false,
            "required": false,
            "help": [],
            "forceNew": false,
            "encoder": "TF.assign \"config_context_auth_info\" <$>",
            "name": "config_context_auth_info",
            "method": "configContextAuthInfo",
            "conflicts": [],
            "type": "P.Maybe P.Text",
            "class": "HasConfigContextAuthInfo",
            "optional": true,
            "label": "_configContextAuthInfo"
        },
        {
            "default": "P.Nothing",
            "computed": false,
            "required": false,
            "help": [],
            "forceNew": false,
            "encoder": "TF.assign \"config_context_cluster\" <$>",
            "name": "config_context_cluster",
            "method": "configContextCluster",
            "conflicts": [],
            "type": "P.Maybe P.Text",
            "class": "HasConfigContextCluster",
            "optional": true,
            "label": "_configContextCluster"
        },
        {
            "default": "P.Nothing",
            "computed": false,
            "required": false,
            "help": [
                "Path to the kube config file, defaults to ~/.kube/config"
            ],
            "forceNew": false,
            "encoder": "TF.assign \"config_path\" <$>",
            "name": "config_path",
            "method": "configPath",
            "conflicts": [],
            "type": "P.Maybe P.Text",
            "class": "HasConfigPath",
            "optional": true,
            "label": "_configPath"
        },
        {
            "default": "P.Nothing",
            "computed": false,
            "required": false,
            "help": [
                "The hostname (in form of URI) of Kubernetes master."
            ],
            "forceNew": false,
            "encoder": "TF.assign \"host\" <$>",
            "name": "host",
            "method": "host",
            "conflicts": [],
            "type": "P.Maybe P.Text",
            "class": "HasHost",
            "optional": true,
            "label": "_host"
        },
        {
            "default": "P.Nothing",
            "computed": false,
            "required": false,
            "help": [
                "Whether server should be accessed without verifying the TLS certificate."
            ],
            "forceNew": false,
            "encoder": "TF.assign \"insecure\" <$>",
            "name": "insecure",
            "method": "insecure",
            "conflicts": [],
            "type": "P.Maybe P.Bool",
            "class": "HasInsecure",
            "optional": true,
            "label": "_insecure"
        },
        {
            "default": "P.Nothing",
            "computed": false,
            "required": false,
            "help": [
                "Load local kubeconfig."
            ],
            "forceNew": false,
            "encoder": "TF.assign \"load_config_file\" <$>",
            "name": "load_config_file",
            "method": "loadConfigFile",
            "conflicts": [],
            "type": "P.Maybe P.Bool",
            "class": "HasLoadConfigFile",
            "optional": true,
            "label": "_loadConfigFile"
        },
        {
            "default": "P.Nothing",
            "computed": false,
            "required": false,
            "help": [
                "The password to use for HTTP basic authentication when accessing the",
                "Kubernetes master endpoint."
            ],
            "forceNew": false,
            "encoder": "TF.assign \"password\" <$>",
            "name": "password",
            "method": "password",
            "conflicts": [],
            "type": "P.Maybe P.Text",
            "class": "HasPassword",
            "optional": true,
            "label": "_password"
        },
        {
            "default": "P.Nothing",
            "computed": false,
            "required": false,
            "help": [
                "Token to authentifcate an service account"
            ],
            "forceNew": false,
            "encoder": "TF.assign \"token\" <$>",
            "name": "token",
            "method": "token",
            "conflicts": [],
            "type": "P.Maybe P.Text",
            "class": "HasToken",
            "optional": true,
            "label": "_token"
        },
        {
            "default": "P.Nothing",
            "computed": false,
            "required": false,
            "help": [
                "The username to use for HTTP basic authentication when accessing the",
                "Kubernetes master endpoint."
            ],
            "forceNew": false,
            "encoder": "TF.assign \"username\" <$>",
            "name": "username",
            "method": "username",
            "conflicts": [],
            "type": "P.Maybe P.Text",
            "class": "HasUsername",
            "optional": true,
            "label": "_username"
        }
    ],
    "dataSources": [
        {
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                }
            ],
            "schema": "DataSource",
            "name": "ServiceData",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_ingress\" <$> TF.attribute",
                    "name": "load_balancer_ingress",
                    "method": "computedLoadBalancerIngress",
                    "conflicts": [],
                    "type": "TF.Attr s [LoadBalancerIngress s]",
                    "class": "HasComputedLoadBalancerIngress",
                    "optional": false,
                    "label": "_computedLoadBalancerIngress"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Spec defines the behavior of a service.",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "spec",
                    "method": "computedSpec",
                    "conflicts": [],
                    "type": "TF.Attr s [Spec s]",
                    "class": "HasComputedSpec",
                    "optional": false,
                    "label": "_computedSpec"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                }
            ],
            "type": "ServiceData s",
            "original": "kubernetes_service"
        },
        {
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard storage class's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                }
            ],
            "schema": "DataSource",
            "name": "StorageClassData",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The parameters for the provisioner that should create volumes of this",
                        "storage class"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"parameters\" <$> TF.attribute",
                    "name": "parameters",
                    "method": "computedParameters",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasComputedParameters",
                    "optional": false,
                    "label": "_computedParameters"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Indicates the type of the provisioner"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"storage_provisioner\" <$> TF.attribute",
                    "name": "storage_provisioner",
                    "method": "computedStorageProvisioner",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedStorageProvisioner",
                    "optional": false,
                    "label": "_computedStorageProvisioner"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard storage class's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                }
            ],
            "type": "StorageClassData s",
            "original": "kubernetes_storage_class"
        }
    ],
    "resources": [
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A map of the configuration data."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data\" <$> TF.attribute",
                    "name": "data",
                    "method": "data'",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasData'",
                    "optional": true,
                    "label": "_data'"
                },
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard config map's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                }
            ],
            "schema": "Resource",
            "name": "ConfigMapResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard config map's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                }
            ],
            "type": "ConfigMapResource s",
            "original": "kubernetes_config_map"
        },
        {
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard horizontal pod autoscaler's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Behaviour of the autoscaler. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s [Spec s]",
                    "class": "HasSpec",
                    "optional": false,
                    "label": "_spec"
                }
            ],
            "schema": "Resource",
            "name": "HorizontalPodAutoscalerResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard horizontal pod autoscaler's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Behaviour of the autoscaler. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s [Spec s]",
                    "class": "HasSpec",
                    "optional": false,
                    "label": "_spec"
                }
            ],
            "type": "HorizontalPodAutoscalerResource s",
            "original": "kubernetes_horizontal_pod_autoscaler"
        },
        {
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard limit range's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Spec defines the limits enforced. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s [Spec s]",
                    "class": "HasSpec",
                    "optional": true,
                    "label": "_spec"
                }
            ],
            "schema": "Resource",
            "name": "LimitRangeResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard limit range's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                }
            ],
            "type": "LimitRangeResource s",
            "original": "kubernetes_limit_range"
        },
        {
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard namespace's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                }
            ],
            "schema": "Resource",
            "name": "NamespaceResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard namespace's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                }
            ],
            "type": "NamespaceResource s",
            "original": "kubernetes_namespace"
        },
        {
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard persistent volume's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec of the persistent volume owned by the cluster"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s [Spec s]",
                    "class": "HasSpec",
                    "optional": false,
                    "label": "_spec"
                }
            ],
            "schema": "Resource",
            "name": "PersistentVolumeResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard persistent volume's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec of the persistent volume owned by the cluster"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s [Spec s]",
                    "class": "HasSpec",
                    "optional": false,
                    "label": "_spec"
                }
            ],
            "type": "PersistentVolumeResource s",
            "original": "kubernetes_persistent_volume"
        },
        {
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard persistent volume claim's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the desired characteristics of a volume requested by a pod",
                        "author. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#persistentvolumeclaims"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s [Spec s]",
                    "class": "HasSpec",
                    "optional": false,
                    "label": "_spec"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to wait for the claim to reach `Bound` state (to find volume in",
                        "which to claim the space)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"wait_until_bound\" <$> TF.attribute",
                    "name": "wait_until_bound",
                    "method": "waitUntilBound",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasWaitUntilBound",
                    "optional": true,
                    "label": "_waitUntilBound"
                }
            ],
            "schema": "Resource",
            "name": "PersistentVolumeClaimResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard persistent volume claim's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the desired characteristics of a volume requested by a pod",
                        "author. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#persistentvolumeclaims"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s [Spec s]",
                    "class": "HasSpec",
                    "optional": false,
                    "label": "_spec"
                }
            ],
            "type": "PersistentVolumeClaimResource s",
            "original": "kubernetes_persistent_volume_claim"
        },
        {
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard pod's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec of the pod owned by the cluster"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s [Spec s]",
                    "class": "HasSpec",
                    "optional": false,
                    "label": "_spec"
                }
            ],
            "schema": "Resource",
            "name": "PodResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard pod's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec of the pod owned by the cluster"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s [Spec s]",
                    "class": "HasSpec",
                    "optional": false,
                    "label": "_spec"
                }
            ],
            "type": "PodResource s",
            "original": "kubernetes_pod"
        },
        {
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard replication controller's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the specification of the desired behavior of the replication",
                        "controller. More info:",
                        "http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s [Spec s]",
                    "class": "HasSpec",
                    "optional": false,
                    "label": "_spec"
                }
            ],
            "schema": "Resource",
            "name": "ReplicationControllerResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard replication controller's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the specification of the desired behavior of the replication",
                        "controller. More info:",
                        "http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s [Spec s]",
                    "class": "HasSpec",
                    "optional": false,
                    "label": "_spec"
                }
            ],
            "type": "ReplicationControllerResource s",
            "original": "kubernetes_replication_controller"
        },
        {
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard resource quota's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Spec defines the desired quota.",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s [Spec s]",
                    "class": "HasSpec",
                    "optional": true,
                    "label": "_spec"
                }
            ],
            "schema": "Resource",
            "name": "ResourceQuotaResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard resource quota's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                }
            ],
            "type": "ResourceQuotaResource s",
            "original": "kubernetes_resource_quota"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A map of the secret data."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data\" <$> TF.attribute",
                    "name": "data",
                    "method": "data'",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasData'",
                    "optional": true,
                    "label": "_data'"
                },
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard secret's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                },
                {
                    "default": "TF.value \"Opaque\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Type of secret"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "type",
                    "method": "type'",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "optional": true,
                    "label": "_type'"
                }
            ],
            "schema": "Resource",
            "name": "SecretResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard secret's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                }
            ],
            "type": "SecretResource s",
            "original": "kubernetes_secret"
        },
        {
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the behavior of a service.",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s [Spec s]",
                    "class": "HasSpec",
                    "optional": false,
                    "label": "_spec"
                }
            ],
            "schema": "Resource",
            "name": "ServiceResource",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_ingress\" <$> TF.attribute",
                    "name": "load_balancer_ingress",
                    "method": "computedLoadBalancerIngress",
                    "conflicts": [],
                    "type": "TF.Attr s [LoadBalancerIngress s]",
                    "class": "HasComputedLoadBalancerIngress",
                    "optional": false,
                    "label": "_computedLoadBalancerIngress"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the behavior of a service.",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s [Spec s]",
                    "class": "HasSpec",
                    "optional": false,
                    "label": "_spec"
                }
            ],
            "type": "ServiceResource s",
            "original": "kubernetes_service"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of references to secrets in the same namespace to use for pulling any",
                        "images in pods that reference this Service Account. More info:",
                        "http://kubernetes.io/docs/user-guide/secrets#manually-specifying-an-imagepullsecret"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image_pull_secret\" <$> TF.attribute",
                    "name": "image_pull_secret",
                    "method": "imagePullSecret",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ImagePullSecret s)]",
                    "class": "HasImagePullSecret",
                    "optional": true,
                    "label": "_imagePullSecret"
                },
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service account's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of secrets allowed to be used by pods running using this Service",
                        "Account. More info: http://kubernetes.io/docs/user-guide/secrets"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret\" <$> TF.attribute",
                    "name": "secret",
                    "method": "secret",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (Secret s)]",
                    "class": "HasSecret",
                    "optional": true,
                    "label": "_secret"
                }
            ],
            "schema": "Resource",
            "name": "ServiceAccountResource",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_secret_name\" <$> TF.attribute",
                    "name": "default_secret_name",
                    "method": "computedDefaultSecretName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedDefaultSecretName",
                    "optional": false,
                    "label": "_computedDefaultSecretName"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service account's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                }
            ],
            "type": "ServiceAccountResource s",
            "original": "kubernetes_service_account"
        },
        {
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard storage class's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The parameters for the provisioner that should create volumes of this",
                        "storage class"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"parameters\" <$> TF.attribute",
                    "name": "parameters",
                    "method": "parameters",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasParameters",
                    "optional": true,
                    "label": "_parameters"
                },
                {
                    "default": "_storageProvisioner",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Indicates the type of the provisioner"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"storage_provisioner\" <$> TF.attribute",
                    "name": "storage_provisioner",
                    "method": "storageProvisioner",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasStorageProvisioner",
                    "optional": false,
                    "label": "_storageProvisioner"
                }
            ],
            "schema": "Resource",
            "name": "StorageClassResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard storage class's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s [Metadata s]",
                    "class": "HasMetadata",
                    "optional": false,
                    "label": "_metadata"
                },
                {
                    "default": "_storageProvisioner",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Indicates the type of the provisioner"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"storage_provisioner\" <$> TF.attribute",
                    "name": "storage_provisioner",
                    "method": "storageProvisioner",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasStorageProvisioner",
                    "optional": false,
                    "label": "_storageProvisioner"
                }
            ],
            "type": "StorageClassResource s",
            "original": "kubernetes_storage_class"
        }
    ],
    "dependencies": [
        "base",
        "unordered-containers",
        "text",
        "terrafomo",
        "hashable",
        "microlens"
    ],
    "name": "Kubernetes",
    "parameters": [],
    "package": "terrafomo-kubernetes",
    "type": "Provider",
    "original": "kubernetes"
}