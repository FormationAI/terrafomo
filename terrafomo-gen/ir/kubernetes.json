{
    "settings": [
        {
            "con": {
                "smart": "awsElasticBlockStoreSetting",
                "name": "AwsElasticBlockStoreSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The partition in the volume that you want to mount. If omitted, the default",
                        "is to mount by volume name. Examples: For volume /dev/sda1, you specify the",
                        "partition as \"1\". Similarly, the volume partition for /dev/sda is \"0\" (or",
                        "you can leave the property empty)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"partition\" <$> TF.attribute",
                    "name": "_partition",
                    "method": "partition",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasPartition",
                    "validate": false,
                    "optional": true,
                    "original": "partition"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to set the read-only property in VolumeMounts to \"true\". If omitted,",
                        "the default is \"false\". More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "key": "kubernetes_persistent_volume.spec.persistent_volume_source.aws_elastic_block_store",
            "name": "AwsElasticBlockStoreSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "conflicts": [],
            "type": "AwsElasticBlockStoreSetting s",
            "original": "aws_elastic_block_store"
        },
        {
            "con": {
                "smart": "azureDiskSetting",
                "name": "AzureDiskSetting'"
            },
            "arguments": [
                {
                    "default": "_cachingMode",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Host Caching mode: None, Read Only, Read Write."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"caching_mode\" <$> TF.attribute",
                    "name": "_cachingMode",
                    "method": "cachingMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCachingMode",
                    "validate": false,
                    "optional": false,
                    "original": "caching_mode"
                },
                {
                    "default": "_dataDiskUri",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The URI the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data_disk_uri\" <$> TF.attribute",
                    "name": "_dataDiskUri",
                    "method": "dataDiskUri",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDataDiskUri",
                    "validate": false,
                    "optional": false,
                    "original": "data_disk_uri"
                },
                {
                    "default": "_diskName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Name of the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disk_name\" <$> TF.attribute",
                    "name": "_diskName",
                    "method": "diskName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDiskName",
                    "validate": false,
                    "optional": false,
                    "original": "disk_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "key": "kubernetes_persistent_volume.spec.persistent_volume_source.azure_disk",
            "name": "AzureDiskSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_cachingMode",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Host Caching mode: None, Read Only, Read Write."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"caching_mode\" <$> TF.attribute",
                    "name": "_cachingMode",
                    "method": "cachingMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCachingMode",
                    "validate": false,
                    "optional": false,
                    "original": "caching_mode"
                },
                {
                    "default": "_diskName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Name of the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disk_name\" <$> TF.attribute",
                    "name": "_diskName",
                    "method": "diskName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDiskName",
                    "validate": false,
                    "optional": false,
                    "original": "disk_name"
                },
                {
                    "default": "_dataDiskUri",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The URI the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data_disk_uri\" <$> TF.attribute",
                    "name": "_dataDiskUri",
                    "method": "dataDiskUri",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDataDiskUri",
                    "validate": false,
                    "optional": false,
                    "original": "data_disk_uri"
                }
            ],
            "conflicts": [],
            "type": "AzureDiskSetting s",
            "original": "azure_disk"
        },
        {
            "con": {
                "smart": "azureFileSetting",
                "name": "AzureFileSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_secretName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of secret that contains Azure Storage Account Name and Key"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_name\" <$> TF.attribute",
                    "name": "_secretName",
                    "method": "secretName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretName",
                    "validate": false,
                    "optional": false,
                    "original": "secret_name"
                },
                {
                    "default": "_shareName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Share Name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"share_name\" <$> TF.attribute",
                    "name": "_shareName",
                    "method": "shareName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasShareName",
                    "validate": false,
                    "optional": false,
                    "original": "share_name"
                }
            ],
            "key": "kubernetes_persistent_volume.spec.persistent_volume_source.azure_file",
            "name": "AzureFileSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_secretName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of secret that contains Azure Storage Account Name and Key"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_name\" <$> TF.attribute",
                    "name": "_secretName",
                    "method": "secretName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretName",
                    "validate": false,
                    "optional": false,
                    "original": "secret_name"
                },
                {
                    "default": "_shareName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Share Name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"share_name\" <$> TF.attribute",
                    "name": "_shareName",
                    "method": "shareName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasShareName",
                    "validate": false,
                    "optional": false,
                    "original": "share_name"
                }
            ],
            "conflicts": [],
            "type": "AzureFileSetting s",
            "original": "azure_file"
        },
        {
            "con": {
                "smart": "capabilitiesSetting",
                "name": "CapabilitiesSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Added capabilities"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"add\" <$> TF.attribute",
                    "name": "_add",
                    "method": "add",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasAdd",
                    "validate": false,
                    "optional": true,
                    "original": "add"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Removed capabilities"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drop\" <$> TF.attribute",
                    "name": "_drop",
                    "method": "drop",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasDrop",
                    "validate": false,
                    "optional": true,
                    "original": "drop"
                }
            ],
            "key": "kubernetes_pod.spec.container.security_context.capabilities",
            "name": "CapabilitiesSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "CapabilitiesSetting s",
            "original": "capabilities"
        },
        {
            "con": {
                "smart": "cephFsSetting",
                "name": "CephFsSetting'"
            },
            "arguments": [
                {
                    "default": "_monitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Monitors is a collection of Ceph monitors More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"monitors\" <$> TF.attribute",
                    "name": "_monitors",
                    "method": "monitors",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "monitors"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Used as the mounted root, rather than the full Ceph tree, default is /"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to `false`",
                        "(read/write). More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The path to key ring for User, default is /etc/ceph/user.secret More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_file\" <$> TF.attribute",
                    "name": "_secretFile",
                    "method": "secretFile",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretFile",
                    "validate": false,
                    "optional": true,
                    "original": "secret_file"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Reference to the authentication secret for User, default is empty. More",
                        "info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "_secretRef",
                    "method": "secretRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SecretRefSetting s)",
                    "class": "HasSecretRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User is the rados user name, default is admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "_user",
                    "method": "user",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "validate": false,
                    "optional": true,
                    "original": "user"
                }
            ],
            "key": "kubernetes_persistent_volume.spec.persistent_volume_source.ceph_fs",
            "name": "CephFsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_monitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Monitors is a collection of Ceph monitors More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"monitors\" <$> TF.attribute",
                    "name": "_monitors",
                    "method": "monitors",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "monitors"
                }
            ],
            "conflicts": [],
            "type": "CephFsSetting s",
            "original": "ceph_fs"
        },
        {
            "con": {
                "smart": "cinderSetting",
                "name": "CinderSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write). More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume ID used to identify the volume in Cinder. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "key": "kubernetes_persistent_volume.spec.persistent_volume_source.cinder",
            "name": "CinderSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume ID used to identify the volume in Cinder. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "conflicts": [],
            "type": "CinderSetting s",
            "original": "cinder"
        },
        {
            "con": {
                "smart": "configMapSetting",
                "name": "ConfigMapSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on created files by default. Must be a value",
                        "between 0 and 0777. Defaults to 0644. Directories within the path are not",
                        "affected by this setting. This might be in conflict with other options that",
                        "affect the file mode, like fsGroup, and the result can be other mode bits",
                        "set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_mode\" <$> TF.attribute",
                    "name": "_defaultMode",
                    "method": "defaultMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasDefaultMode",
                    "validate": false,
                    "optional": true,
                    "original": "default_mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If unspecified, each key-value pair in the Data field of the referenced",
                        "ConfigMap will be projected into the volume as a file whose name is the key",
                        "and content is the value. If specified, the listed keys will be projected",
                        "into the specified paths, and unlisted keys will not be present. If a key is",
                        "specified which is not present in the ConfigMap, the volume setup will",
                        "error. Paths must be relative and may not contain the '..' path or start",
                        "with '..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"items\" <$> TF.attribute",
                    "name": "_items",
                    "method": "items",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ItemsSetting s)]",
                    "class": "HasItems",
                    "validate": false,
                    "optional": true,
                    "original": "items"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "key": "kubernetes_pod.spec.volume.config_map",
            "name": "ConfigMapSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ConfigMapSetting s",
            "original": "config_map"
        },
        {
            "con": {
                "smart": "configMapKeyRefSetting",
                "name": "ConfigMapKeyRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key to select."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "key": "kubernetes_pod.spec.container.env.value_from.config_map_key_ref",
            "name": "ConfigMapKeyRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ConfigMapKeyRefSetting s",
            "original": "config_map_key_ref"
        },
        {
            "con": {
                "smart": "containerSetting",
                "name": "ContainerSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Arguments to the entrypoint. The docker image's CMD is used if this is not",
                        "provided. Variable references $(VAR_NAME) are expanded using the container's",
                        "environment. If a variable cannot be resolved, the reference in the input",
                        "string will be unchanged. The $(VAR_NAME) syntax can be escaped with a",
                        "double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,",
                        "regardless of whether the variable exists or not. Cannot be updated. More",
                        "info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"args\" <$> TF.attribute",
                    "name": "_args",
                    "method": "args",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasArgs",
                    "validate": false,
                    "optional": true,
                    "original": "args"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT",
                        "is used if this is not provided. Variable references $(VAR_NAME) are",
                        "expanded using the container's environment. If a variable cannot be",
                        "resolved, the reference in the input string will be unchanged. The",
                        "$(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).",
                        "Escaped references will never be expanded, regardless of whether the",
                        "variable exists or not. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of environment variables to set in the container. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"env\" <$> TF.attribute",
                    "name": "_env",
                    "method": "env",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (EnvSetting s)]",
                    "class": "HasEnv",
                    "validate": false,
                    "optional": true,
                    "original": "env"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Docker image name. More info: http://kubernetes.io/docs/user-guide/images"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image\" <$> TF.attribute",
                    "name": "_image",
                    "method": "image",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasImage",
                    "validate": false,
                    "optional": true,
                    "original": "image"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if",
                        ":latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/images#updating-images"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"image_pull_policy\" <$> TF.attribute",
                    "name": "_imagePullPolicy",
                    "method": "imagePullPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasImagePullPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "image_pull_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Actions that the management system should take in response to container",
                        "lifecycle events"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"lifecycle\" <$> TF.attribute",
                    "name": "_lifecycle",
                    "method": "lifecycle",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (LifecycleSetting s)",
                    "class": "HasLifecycle",
                    "validate": true,
                    "optional": true,
                    "original": "lifecycle"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container liveness. Container will be restarted if the",
                        "probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"liveness_probe\" <$> TF.attribute",
                    "name": "_livenessProbe",
                    "method": "livenessProbe",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (LivenessProbeSetting s)",
                    "class": "HasLivenessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "liveness_probe"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of ports to expose from the container. Exposing a port here gives the",
                        "system additional information about the network connections a container",
                        "uses, but is primarily informational. Not specifying a port here DOES NOT",
                        "prevent that port from being exposed. Any port which is listening on the",
                        "default \"0.0.0.0\" address inside a container will be accessible from the",
                        "network. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PortSetting s)]",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container service readiness. Container will be removed",
                        "from service endpoints if the probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"readiness_probe\" <$> TF.attribute",
                    "name": "_readinessProbe",
                    "method": "readinessProbe",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReadinessProbeSetting s)",
                    "class": "HasReadinessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "readiness_probe"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Compute Resources required by this container. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_resources",
                    "method": "resources",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ResourcesSetting s)",
                    "class": "HasResources",
                    "validate": true,
                    "optional": true,
                    "original": "resources"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Security options the pod should run with. More info:",
                        "http://releases.k8s.io/HEAD/docs/design/security_context.md"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"security_context\" <$> TF.attribute",
                    "name": "_securityContext",
                    "method": "securityContext",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SecurityContextSetting s)",
                    "class": "HasSecurityContext",
                    "validate": true,
                    "optional": true,
                    "original": "security_context"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a buffer for stdin in the container",
                        "runtime. If this is not set, reads from stdin in the container will always",
                        "result in EOF."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"stdin\" <$> TF.attribute",
                    "name": "_stdin",
                    "method": "stdin",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdin",
                    "validate": false,
                    "optional": true,
                    "original": "stdin"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether the container runtime should close the stdin channel after it has",
                        "been opened by a single attach. When stdin is true the stdin stream will",
                        "remain open across multiple attach sessions. If stdinOnce is set to true,",
                        "stdin is opened on container start, is empty until the first client attaches",
                        "to stdin, and then remains open and accepts data until the client",
                        "disconnects, at which time stdin is closed and remains closed until the",
                        "container is restarted. If this flag is false, a container processes that",
                        "reads from stdin will never receive an EOF."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"stdin_once\" <$> TF.attribute",
                    "name": "_stdinOnce",
                    "method": "stdinOnce",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdinOnce",
                    "validate": false,
                    "optional": true,
                    "original": "stdin_once"
                },
                {
                    "default": "TF.value \"/dev/termination-log\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: Path at which the file to which the container's termination",
                        "message will be written is mounted into the container's filesystem. Message",
                        "written is intended to be brief final status, such as an assertion failure",
                        "message. Defaults to /dev/termination-log. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"termination_message_path\" <$> TF.attribute",
                    "name": "_terminationMessagePath",
                    "method": "terminationMessagePath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTerminationMessagePath",
                    "validate": false,
                    "optional": true,
                    "original": "termination_message_path"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a TTY for itself"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"tty\" <$> TF.attribute",
                    "name": "_tty",
                    "method": "tty",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasTty",
                    "validate": false,
                    "optional": true,
                    "original": "tty"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Pod volumes to mount into the container's filesystem. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"volume_mount\" <$> TF.attribute",
                    "name": "_volumeMount",
                    "method": "volumeMount",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (VolumeMountSetting s)]",
                    "class": "HasVolumeMount",
                    "validate": false,
                    "optional": true,
                    "original": "volume_mount"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Container's working directory. If not specified, the container runtime's",
                        "default will be used, which might be configured in the container image.",
                        "Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"working_dir\" <$> TF.attribute",
                    "name": "_workingDir",
                    "method": "workingDir",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasWorkingDir",
                    "validate": false,
                    "optional": true,
                    "original": "working_dir"
                }
            ],
            "key": "kubernetes_pod.spec.container",
            "name": "ContainerSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if",
                        ":latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/images#updating-images"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"image_pull_policy\" <$> TF.attribute",
                    "name": "_computedImagePullPolicy",
                    "method": "computedImagePullPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedImagePullPolicy",
                    "validate": false,
                    "optional": false,
                    "original": "image_pull_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Compute Resources required by this container. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_computedResources",
                    "method": "computedResources",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ResourcesSetting s)",
                    "class": "HasComputedResources",
                    "validate": true,
                    "optional": false,
                    "original": "resources"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "ContainerSetting s",
            "original": "container"
        },
        {
            "con": {
                "smart": "downwardApiSetting",
                "name": "DownwardApiSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on created files by default. Must be a value",
                        "between 0 and 0777. Defaults to 0644. Directories within the path are not",
                        "affected by this setting. This might be in conflict with other options that",
                        "affect the file mode, like fsGroup, and the result can be other mode bits",
                        "set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_mode\" <$> TF.attribute",
                    "name": "_defaultMode",
                    "method": "defaultMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasDefaultMode",
                    "validate": false,
                    "optional": true,
                    "original": "default_mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If unspecified, each key-value pair in the Data field of the referenced",
                        "ConfigMap will be projected into the volume as a file whose name is the key",
                        "and content is the value. If specified, the listed keys will be projected",
                        "into the specified paths, and unlisted keys will not be present. If a key is",
                        "specified which is not present in the ConfigMap, the volume setup will",
                        "error. Paths must be relative and may not contain the '..' path or start",
                        "with '..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"items\" <$> TF.attribute",
                    "name": "_items",
                    "method": "items",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ItemsSetting s)]",
                    "class": "HasItems",
                    "validate": false,
                    "optional": true,
                    "original": "items"
                }
            ],
            "key": "kubernetes_pod.spec.volume.downward_api",
            "name": "DownwardApiSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "DownwardApiSetting s",
            "original": "downward_api"
        },
        {
            "con": {
                "smart": "emptyDirSetting",
                "name": "EmptyDirSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "What type of storage medium should back this directory. The default is \"\"",
                        "which means to use the node's default medium. Must be an empty string",
                        "(default) or Memory. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#emptydir"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"medium\" <$> TF.attribute",
                    "name": "_medium",
                    "method": "medium",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMedium",
                    "validate": false,
                    "optional": true,
                    "original": "medium"
                }
            ],
            "key": "kubernetes_pod.spec.volume.empty_dir",
            "name": "EmptyDirSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "EmptyDirSetting s",
            "original": "empty_dir"
        },
        {
            "con": {
                "smart": "envSetting",
                "name": "EnvSetting'"
            },
            "arguments": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the environment variable. Must be a C_IDENTIFIER"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Variable references $(VAR_NAME) are expanded using the previous defined",
                        "environment variables in the container and any service environment",
                        "variables. If a variable cannot be resolved, the reference in the input",
                        "string will be unchanged. The $(VAR_NAME) syntax can be escaped with a",
                        "double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,",
                        "regardless of whether the variable exists or not. Defaults to \"\"."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Source for the environment variable's value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value_from\" <$> TF.attribute",
                    "name": "_valueFrom",
                    "method": "valueFrom",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ValueFromSetting s)",
                    "class": "HasValueFrom",
                    "validate": true,
                    "optional": true,
                    "original": "value_from"
                }
            ],
            "key": "kubernetes_pod.spec.container.env",
            "name": "EnvSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the environment variable. Must be a C_IDENTIFIER"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "EnvSetting s",
            "original": "env"
        },
        {
            "con": {
                "smart": "execSetting",
                "name": "ExecSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Command is the command line to execute inside the container, the working",
                        "directory for the command is root ('/') in the container's filesystem. The",
                        "command is simply exec'd, it is not run inside a shell, so traditional shell",
                        "instructions. To use a shell, you need to explicitly call out to that shell.",
                        "Exit status of 0 is treated as live/healthy and non-zero is unhealthy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                }
            ],
            "key": "kubernetes_pod.spec.container.lifecycle.post_start.exec",
            "name": "ExecSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ExecSetting s",
            "original": "exec"
        },
        {
            "con": {
                "smart": "fcSetting",
                "name": "FcSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_lun",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target lun number"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "_lun",
                    "method": "lun",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasLun",
                    "validate": false,
                    "optional": false,
                    "original": "lun"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_targetWwNs",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target worldwide names (WWNs)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_ww_ns\" <$> TF.attribute",
                    "name": "_targetWwNs",
                    "method": "targetWwNs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTargetWwNs",
                    "validate": false,
                    "optional": false,
                    "original": "target_ww_ns"
                }
            ],
            "key": "kubernetes_persistent_volume.spec.persistent_volume_source.fc",
            "name": "FcSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_lun",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target lun number"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "_lun",
                    "method": "lun",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasLun",
                    "validate": false,
                    "optional": false,
                    "original": "lun"
                },
                {
                    "default": "_targetWwNs",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target worldwide names (WWNs)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_ww_ns\" <$> TF.attribute",
                    "name": "_targetWwNs",
                    "method": "targetWwNs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTargetWwNs",
                    "validate": false,
                    "optional": false,
                    "original": "target_ww_ns"
                }
            ],
            "conflicts": [],
            "type": "FcSetting s",
            "original": "fc"
        },
        {
            "con": {
                "smart": "fieldRefSetting",
                "name": "FieldRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.value \"v1\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Version of the schema the FieldPath is written in terms of, defaults to",
                        "\"v1\"."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"api_version\" <$> TF.attribute",
                    "name": "_apiVersion",
                    "method": "apiVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasApiVersion",
                    "validate": false,
                    "optional": true,
                    "original": "api_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path of the field to select in the specified API version"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_path\" <$> TF.attribute",
                    "name": "_fieldPath",
                    "method": "fieldPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFieldPath",
                    "validate": false,
                    "optional": true,
                    "original": "field_path"
                }
            ],
            "key": "kubernetes_pod.spec.container.env.value_from.field_ref",
            "name": "FieldRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "FieldRefSetting s",
            "original": "field_ref"
        },
        {
            "con": {
                "smart": "flexVolumeSetting",
                "name": "FlexVolumeSetting'"
            },
            "arguments": [
                {
                    "default": "_driver",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Driver is the name of the driver to use for this volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"driver\" <$> TF.attribute",
                    "name": "_driver",
                    "method": "driver",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDriver",
                    "validate": false,
                    "optional": false,
                    "original": "driver"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". The default filesystem depends",
                        "on FlexVolume script."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Extra command options if any."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"options\" <$> TF.attribute",
                    "name": "_options",
                    "method": "options",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasOptions",
                    "validate": false,
                    "optional": true,
                    "original": "options"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the ReadOnly setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Reference to the secret object containing sensitive information to pass to",
                        "the plugin scripts. This may be empty if no secret object is specified. If",
                        "the secret object contains more than one secret, all secrets are passed to",
                        "the plugin scripts."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "_secretRef",
                    "method": "secretRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SecretRefSetting s)",
                    "class": "HasSecretRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_ref"
                }
            ],
            "key": "kubernetes_persistent_volume.spec.persistent_volume_source.flex_volume",
            "name": "FlexVolumeSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_driver",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Driver is the name of the driver to use for this volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"driver\" <$> TF.attribute",
                    "name": "_driver",
                    "method": "driver",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDriver",
                    "validate": false,
                    "optional": false,
                    "original": "driver"
                }
            ],
            "conflicts": [],
            "type": "FlexVolumeSetting s",
            "original": "flex_volume"
        },
        {
            "con": {
                "smart": "flockerSetting",
                "name": "FlockerSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the dataset stored as metadata -> name on the dataset for Flocker",
                        "should be considered as deprecated"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dataset_name\" <$> TF.attribute",
                    "name": "_datasetName",
                    "method": "datasetName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatasetName",
                    "validate": false,
                    "optional": true,
                    "original": "dataset_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "UUID of the dataset. This is unique identifier of a Flocker dataset"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dataset_uuid\" <$> TF.attribute",
                    "name": "_datasetUuid",
                    "method": "datasetUuid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatasetUuid",
                    "validate": false,
                    "optional": true,
                    "original": "dataset_uuid"
                }
            ],
            "key": "kubernetes_persistent_volume.spec.persistent_volume_source.flocker",
            "name": "FlockerSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "FlockerSetting s",
            "original": "flocker"
        },
        {
            "con": {
                "smart": "gcePersistentDiskSetting",
                "name": "GcePersistentDiskSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The partition in the volume that you want to mount. If omitted, the default",
                        "is to mount by volume name. Examples: For volume /dev/sda1, you specify the",
                        "partition as \"1\". Similarly, the volume partition for /dev/sda is \"0\" (or",
                        "you can leave the property empty). More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"partition\" <$> TF.attribute",
                    "name": "_partition",
                    "method": "partition",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasPartition",
                    "validate": false,
                    "optional": true,
                    "original": "partition"
                },
                {
                    "default": "_pdName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique name of the PD resource in GCE. Used to identify the disk in GCE.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_name\" <$> TF.attribute",
                    "name": "_pdName",
                    "method": "pdName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdName",
                    "validate": false,
                    "optional": false,
                    "original": "pd_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the ReadOnly setting in VolumeMounts. Defaults to false.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "key": "kubernetes_persistent_volume.spec.persistent_volume_source.gce_persistent_disk",
            "name": "GcePersistentDiskSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_pdName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique name of the PD resource in GCE. Used to identify the disk in GCE.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_name\" <$> TF.attribute",
                    "name": "_pdName",
                    "method": "pdName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdName",
                    "validate": false,
                    "optional": false,
                    "original": "pd_name"
                }
            ],
            "conflicts": [],
            "type": "GcePersistentDiskSetting s",
            "original": "gce_persistent_disk"
        },
        {
            "con": {
                "smart": "gitRepoSetting",
                "name": "GitRepoSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Target directory name. Must not contain or start with '..'. If '.' is",
                        "supplied, the volume directory will be the git repository. Otherwise, if",
                        "specified, the volume will contain the git repository in the subdirectory",
                        "with the given name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"directory\" <$> TF.attribute",
                    "name": "_directory",
                    "method": "directory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDirectory",
                    "validate": false,
                    "optional": true,
                    "original": "directory"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Repository URL"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"repository\" <$> TF.attribute",
                    "name": "_repository",
                    "method": "repository",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRepository",
                    "validate": false,
                    "optional": true,
                    "original": "repository"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Commit hash for the specified revision."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"revision\" <$> TF.attribute",
                    "name": "_revision",
                    "method": "revision",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRevision",
                    "validate": false,
                    "optional": true,
                    "original": "revision"
                }
            ],
            "key": "kubernetes_pod.spec.volume.git_repo",
            "name": "GitRepoSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "GitRepoSetting s",
            "original": "git_repo"
        },
        {
            "con": {
                "smart": "glusterfsSetting",
                "name": "GlusterfsSetting'"
            },
            "arguments": [
                {
                    "default": "_endpointsName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The endpoint name that details Glusterfs topology. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"endpoints_name\" <$> TF.attribute",
                    "name": "_endpointsName",
                    "method": "endpointsName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasEndpointsName",
                    "validate": false,
                    "optional": false,
                    "original": "endpoints_name"
                },
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Glusterfs volume path. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the Glusterfs volume to be mounted with read-only",
                        "permissions. Defaults to false. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "key": "kubernetes_persistent_volume.spec.persistent_volume_source.glusterfs",
            "name": "GlusterfsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_endpointsName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The endpoint name that details Glusterfs topology. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"endpoints_name\" <$> TF.attribute",
                    "name": "_endpointsName",
                    "method": "endpointsName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasEndpointsName",
                    "validate": false,
                    "optional": false,
                    "original": "endpoints_name"
                },
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Glusterfs volume path. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                }
            ],
            "conflicts": [],
            "type": "GlusterfsSetting s",
            "original": "glusterfs"
        },
        {
            "con": {
                "smart": "hostPathSetting",
                "name": "HostPathSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path of the directory on the host. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#hostpath"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                }
            ],
            "key": "kubernetes_persistent_volume.spec.persistent_volume_source.host_path",
            "name": "HostPathSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "HostPathSetting s",
            "original": "host_path"
        },
        {
            "con": {
                "smart": "httpGetSetting",
                "name": "HttpGetSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host name to connect to, defaults to the pod IP. You probably want to set",
                        "\"Host\" in httpHeaders instead."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "_host",
                    "method": "host",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHost",
                    "validate": false,
                    "optional": true,
                    "original": "host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_header\" <$> TF.attribute",
                    "name": "_httpHeader",
                    "method": "httpHeader",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (HttpHeaderSetting s)]",
                    "class": "HasHttpHeader",
                    "validate": false,
                    "optional": true,
                    "original": "http_header"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path to access on the HTTP server."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name or number of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.value \"HTTP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scheme\" <$> TF.attribute",
                    "name": "_scheme",
                    "method": "scheme",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScheme",
                    "validate": false,
                    "optional": true,
                    "original": "scheme"
                }
            ],
            "key": "kubernetes_pod.spec.container.lifecycle.post_start.http_get",
            "name": "HttpGetSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "HttpGetSetting s",
            "original": "http_get"
        },
        {
            "con": {
                "smart": "httpHeaderSetting",
                "name": "HttpHeaderSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                }
            ],
            "key": "kubernetes_pod.spec.container.lifecycle.post_start.http_get.http_header",
            "name": "HttpHeaderSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "HttpHeaderSetting s",
            "original": "http_header"
        },
        {
            "con": {
                "smart": "imagePullSecretSetting",
                "name": "ImagePullSecretSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "key": "kubernetes_service_account.image_pull_secret",
            "name": "ImagePullSecretSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ImagePullSecretSetting s",
            "original": "image_pull_secret"
        },
        {
            "con": {
                "smart": "imagePullSecretsSetting",
                "name": "ImagePullSecretsSetting'"
            },
            "arguments": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "key": "kubernetes_pod.spec.image_pull_secrets",
            "name": "ImagePullSecretsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "ImagePullSecretsSetting s",
            "original": "image_pull_secrets"
        },
        {
            "con": {
                "smart": "initContainerSetting",
                "name": "InitContainerSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Arguments to the entrypoint. The docker image's CMD is used if this is not",
                        "provided. Variable references $(VAR_NAME) are expanded using the container's",
                        "environment. If a variable cannot be resolved, the reference in the input",
                        "string will be unchanged. The $(VAR_NAME) syntax can be escaped with a",
                        "double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,",
                        "regardless of whether the variable exists or not. Cannot be updated. More",
                        "info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"args\" <$> TF.attribute",
                    "name": "_args",
                    "method": "args",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasArgs",
                    "validate": false,
                    "optional": true,
                    "original": "args"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT",
                        "is used if this is not provided. Variable references $(VAR_NAME) are",
                        "expanded using the container's environment. If a variable cannot be",
                        "resolved, the reference in the input string will be unchanged. The",
                        "$(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).",
                        "Escaped references will never be expanded, regardless of whether the",
                        "variable exists or not. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of environment variables to set in the container. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"env\" <$> TF.attribute",
                    "name": "_env",
                    "method": "env",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (EnvSetting s)]",
                    "class": "HasEnv",
                    "validate": false,
                    "optional": true,
                    "original": "env"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Docker image name. More info: http://kubernetes.io/docs/user-guide/images"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"image\" <$> TF.attribute",
                    "name": "_image",
                    "method": "image",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasImage",
                    "validate": false,
                    "optional": true,
                    "original": "image"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if",
                        ":latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/images#updating-images"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"image_pull_policy\" <$> TF.attribute",
                    "name": "_imagePullPolicy",
                    "method": "imagePullPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasImagePullPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "image_pull_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Actions that the management system should take in response to container",
                        "lifecycle events"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"lifecycle\" <$> TF.attribute",
                    "name": "_lifecycle",
                    "method": "lifecycle",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (LifecycleSetting s)",
                    "class": "HasLifecycle",
                    "validate": true,
                    "optional": true,
                    "original": "lifecycle"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container liveness. Container will be restarted if the",
                        "probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"liveness_probe\" <$> TF.attribute",
                    "name": "_livenessProbe",
                    "method": "livenessProbe",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (LivenessProbeSetting s)",
                    "class": "HasLivenessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "liveness_probe"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of ports to expose from the container. Exposing a port here gives the",
                        "system additional information about the network connections a container",
                        "uses, but is primarily informational. Not specifying a port here DOES NOT",
                        "prevent that port from being exposed. Any port which is listening on the",
                        "default \"0.0.0.0\" address inside a container will be accessible from the",
                        "network. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PortSetting s)]",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container service readiness. Container will be removed",
                        "from service endpoints if the probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"readiness_probe\" <$> TF.attribute",
                    "name": "_readinessProbe",
                    "method": "readinessProbe",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ReadinessProbeSetting s)",
                    "class": "HasReadinessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "readiness_probe"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Compute Resources required by this container. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_resources",
                    "method": "resources",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ResourcesSetting s)",
                    "class": "HasResources",
                    "validate": true,
                    "optional": true,
                    "original": "resources"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Security options the pod should run with. More info:",
                        "http://releases.k8s.io/HEAD/docs/design/security_context.md"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"security_context\" <$> TF.attribute",
                    "name": "_securityContext",
                    "method": "securityContext",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SecurityContextSetting s)",
                    "class": "HasSecurityContext",
                    "validate": true,
                    "optional": true,
                    "original": "security_context"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a buffer for stdin in the container",
                        "runtime. If this is not set, reads from stdin in the container will always",
                        "result in EOF."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"stdin\" <$> TF.attribute",
                    "name": "_stdin",
                    "method": "stdin",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdin",
                    "validate": false,
                    "optional": true,
                    "original": "stdin"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether the container runtime should close the stdin channel after it has",
                        "been opened by a single attach. When stdin is true the stdin stream will",
                        "remain open across multiple attach sessions. If stdinOnce is set to true,",
                        "stdin is opened on container start, is empty until the first client attaches",
                        "to stdin, and then remains open and accepts data until the client",
                        "disconnects, at which time stdin is closed and remains closed until the",
                        "container is restarted. If this flag is false, a container processes that",
                        "reads from stdin will never receive an EOF."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"stdin_once\" <$> TF.attribute",
                    "name": "_stdinOnce",
                    "method": "stdinOnce",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdinOnce",
                    "validate": false,
                    "optional": true,
                    "original": "stdin_once"
                },
                {
                    "default": "TF.value \"/dev/termination-log\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: Path at which the file to which the container's termination",
                        "message will be written is mounted into the container's filesystem. Message",
                        "written is intended to be brief final status, such as an assertion failure",
                        "message. Defaults to /dev/termination-log. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"termination_message_path\" <$> TF.attribute",
                    "name": "_terminationMessagePath",
                    "method": "terminationMessagePath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTerminationMessagePath",
                    "validate": false,
                    "optional": true,
                    "original": "termination_message_path"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a TTY for itself"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"tty\" <$> TF.attribute",
                    "name": "_tty",
                    "method": "tty",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasTty",
                    "validate": false,
                    "optional": true,
                    "original": "tty"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Pod volumes to mount into the container's filesystem. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"volume_mount\" <$> TF.attribute",
                    "name": "_volumeMount",
                    "method": "volumeMount",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (VolumeMountSetting s)]",
                    "class": "HasVolumeMount",
                    "validate": false,
                    "optional": true,
                    "original": "volume_mount"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Container's working directory. If not specified, the container runtime's",
                        "default will be used, which might be configured in the container image.",
                        "Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"working_dir\" <$> TF.attribute",
                    "name": "_workingDir",
                    "method": "workingDir",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasWorkingDir",
                    "validate": false,
                    "optional": true,
                    "original": "working_dir"
                }
            ],
            "key": "kubernetes_pod.spec.init_container",
            "name": "InitContainerSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if",
                        ":latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/images#updating-images"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"image_pull_policy\" <$> TF.attribute",
                    "name": "_computedImagePullPolicy",
                    "method": "computedImagePullPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedImagePullPolicy",
                    "validate": false,
                    "optional": false,
                    "original": "image_pull_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Compute Resources required by this container. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_computedResources",
                    "method": "computedResources",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ResourcesSetting s)",
                    "class": "HasComputedResources",
                    "validate": true,
                    "optional": false,
                    "original": "resources"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "InitContainerSetting s",
            "original": "init_container"
        },
        {
            "con": {
                "smart": "iscsiSetting",
                "name": "IscsiSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#iscsi"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_iqn",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Target iSCSI Qualified Name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iqn\" <$> TF.attribute",
                    "name": "_iqn",
                    "method": "iqn",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIqn",
                    "validate": false,
                    "optional": false,
                    "original": "iqn"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ISCSI interface name that uses an iSCSI transport. Defaults to 'default'",
                        "(tcp)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi_interface\" <$> TF.attribute",
                    "name": "_iscsiInterface",
                    "method": "iscsiInterface",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIscsiInterface",
                    "validate": false,
                    "optional": true,
                    "original": "iscsi_interface"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ISCSI target lun number."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "_lun",
                    "method": "lun",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasLun",
                    "validate": false,
                    "optional": true,
                    "original": "lun"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_targetPortal",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ISCSI target portal. The portal is either an IP or ip_addr:port if the port",
                        "is other than default (typically TCP ports 860 and 3260)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_portal\" <$> TF.attribute",
                    "name": "_targetPortal",
                    "method": "targetPortal",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTargetPortal",
                    "validate": false,
                    "optional": false,
                    "original": "target_portal"
                }
            ],
            "key": "kubernetes_persistent_volume.spec.persistent_volume_source.iscsi",
            "name": "IscsiSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_iqn",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Target iSCSI Qualified Name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iqn\" <$> TF.attribute",
                    "name": "_iqn",
                    "method": "iqn",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIqn",
                    "validate": false,
                    "optional": false,
                    "original": "iqn"
                },
                {
                    "default": "_targetPortal",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ISCSI target portal. The portal is either an IP or ip_addr:port if the port",
                        "is other than default (typically TCP ports 860 and 3260)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_portal\" <$> TF.attribute",
                    "name": "_targetPortal",
                    "method": "targetPortal",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTargetPortal",
                    "validate": false,
                    "optional": false,
                    "original": "target_portal"
                }
            ],
            "conflicts": [],
            "type": "IscsiSetting s",
            "original": "iscsi"
        },
        {
            "con": {
                "smart": "itemsSetting",
                "name": "ItemsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key to project."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on this file, must be a value between 0 and 0777.",
                        "If not specified, the volume defaultMode will be used. This might be in",
                        "conflict with other options that affect the file mode, like fsGroup, and the",
                        "result can be other mode bits set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mode\" <$> TF.attribute",
                    "name": "_mode",
                    "method": "mode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMode",
                    "validate": false,
                    "optional": true,
                    "original": "mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The relative path of the file to map the key to. May not be an absolute",
                        "path. May not contain the path element '..'. May not start with the string",
                        "'..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "_fieldRef",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Required: Selects a field of the pod: only annotations, labels, name and",
                        "namespace are supported."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_ref\" <$> TF.attribute",
                    "name": "_fieldRef",
                    "method": "fieldRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (FieldRefSetting s)",
                    "class": "HasFieldRef",
                    "validate": true,
                    "optional": false,
                    "original": "field_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a resource of the container: only resources limits and requests",
                        "(limits.cpu, limits.memory, requests.cpu and requests.memory) are currently",
                        "supported."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_field_ref\" <$> TF.attribute",
                    "name": "_resourceFieldRef",
                    "method": "resourceFieldRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ResourceFieldRefSetting s)",
                    "class": "HasResourceFieldRef",
                    "validate": true,
                    "optional": true,
                    "original": "resource_field_ref"
                }
            ],
            "key": "kubernetes_pod.spec.volume.config_map.items",
            "name": "ItemsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_fieldRef",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Required: Selects a field of the pod: only annotations, labels, name and",
                        "namespace are supported."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_ref\" <$> TF.attribute",
                    "name": "_fieldRef",
                    "method": "fieldRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (FieldRefSetting s)",
                    "class": "HasFieldRef",
                    "validate": true,
                    "optional": false,
                    "original": "field_ref"
                }
            ],
            "conflicts": [],
            "type": "ItemsSetting s",
            "original": "items"
        },
        {
            "con": {
                "smart": "lifecycleSetting",
                "name": "LifecycleSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Post_start is called immediately after a container is created. If the",
                        "handler fails, the container is terminated and restarted according to its",
                        "restart policy. Other management of the container blocks until the hook",
                        "completes. More info:",
                        "http://kubernetes.io/docs/user-guide/container-environment#hook-details"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"post_start\" <$> TF.attribute",
                    "name": "_postStart",
                    "method": "postStart",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PostStartSetting s)]",
                    "class": "HasPostStart",
                    "validate": false,
                    "optional": true,
                    "original": "post_start"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Pre_stop is called immediately before a container is terminated. The",
                        "container is terminated after the handler completes. The reason for",
                        "termination is passed to the handler. Regardless of the outcome of the",
                        "handler, the container is eventually terminated. Other management of the",
                        "container blocks until the hook completes. More info:",
                        "http://kubernetes.io/docs/user-guide/container-environment#hook-details"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pre_stop\" <$> TF.attribute",
                    "name": "_preStop",
                    "method": "preStop",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PreStopSetting s)]",
                    "class": "HasPreStop",
                    "validate": false,
                    "optional": true,
                    "original": "pre_stop"
                }
            ],
            "key": "kubernetes_pod.spec.container.lifecycle",
            "name": "LifecycleSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "LifecycleSetting s",
            "original": "lifecycle"
        },
        {
            "con": {
                "smart": "limitSetting",
                "name": "LimitSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Default resource requirement limit value by resource name if resource limit",
                        "is omitted."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default\" <$> TF.attribute",
                    "name": "_default'",
                    "method": "default'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasDefault'",
                    "validate": false,
                    "optional": true,
                    "original": "default"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The default resource requirement request value by resource name if resource",
                        "request is omitted."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_request\" <$> TF.attribute",
                    "name": "_defaultRequest",
                    "method": "defaultRequest",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasDefaultRequest",
                    "validate": false,
                    "optional": true,
                    "original": "default_request"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Max usage constraints on this kind by resource name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"max\" <$> TF.attribute",
                    "name": "_max",
                    "method": "max",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasMax",
                    "validate": false,
                    "optional": true,
                    "original": "max"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The named resource must have a request and limit that are both non-zero",
                        "where limit divided by request is less than or equal to the enumerated",
                        "value; this represents the max burst for the named resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"max_limit_request_ratio\" <$> TF.attribute",
                    "name": "_maxLimitRequestRatio",
                    "method": "maxLimitRequestRatio",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasMaxLimitRequestRatio",
                    "validate": false,
                    "optional": true,
                    "original": "max_limit_request_ratio"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Min usage constraints on this kind by resource name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"min\" <$> TF.attribute",
                    "name": "_min",
                    "method": "min",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasMin",
                    "validate": false,
                    "optional": true,
                    "original": "min"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Type of resource that this limit applies to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": true,
                    "original": "type"
                }
            ],
            "key": "kubernetes_limit_range.spec.limit",
            "name": "LimitSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The default resource requirement request value by resource name if resource",
                        "request is omitted."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_request\" <$> TF.attribute",
                    "name": "_computedDefaultRequest",
                    "method": "computedDefaultRequest",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasComputedDefaultRequest",
                    "validate": false,
                    "optional": false,
                    "original": "default_request"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "LimitSetting s",
            "original": "limit"
        },
        {
            "con": {
                "smart": "limitsSetting",
                "name": "LimitsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_cpu",
                    "method": "cpu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCpu",
                    "validate": false,
                    "optional": true,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_memory",
                    "method": "memory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMemory",
                    "validate": false,
                    "optional": true,
                    "original": "memory"
                }
            ],
            "key": "kubernetes_pod.spec.container.resources.limits",
            "name": "LimitsSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_computedCpu",
                    "method": "computedCpu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedCpu",
                    "validate": false,
                    "optional": false,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_computedMemory",
                    "method": "computedMemory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMemory",
                    "validate": false,
                    "optional": false,
                    "original": "memory"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "LimitsSetting s",
            "original": "limits"
        },
        {
            "con": {
                "smart": "livenessProbeSetting",
                "name": "LivenessProbeSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ExecSetting s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive failures for the probe to be considered failed after",
                        "having succeeded."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failure_threshold\" <$> TF.attribute",
                    "name": "_failureThreshold",
                    "method": "failureThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasFailureThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "failure_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (HttpGetSetting s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after the container has started before liveness probes are",
                        "initiated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"initial_delay_seconds\" <$> TF.attribute",
                    "name": "_initialDelaySeconds",
                    "method": "initialDelaySeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasInitialDelaySeconds",
                    "validate": false,
                    "optional": true,
                    "original": "initial_delay_seconds"
                },
                {
                    "default": "TF.value 10",
                    "computed": false,
                    "required": false,
                    "help": [
                        "How often (in seconds) to perform the probe"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"period_seconds\" <$> TF.attribute",
                    "name": "_periodSeconds",
                    "method": "periodSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasPeriodSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "period_seconds"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive successes for the probe to be considered successful",
                        "after having failed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"success_threshold\" <$> TF.attribute",
                    "name": "_successThreshold",
                    "method": "successThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasSuccessThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "success_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TcpSocketSetting s)]",
                    "class": "HasTcpSocket",
                    "validate": false,
                    "optional": true,
                    "original": "tcp_socket"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after which the probe times out. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"timeout_seconds\" <$> TF.attribute",
                    "name": "_timeoutSeconds",
                    "method": "timeoutSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasTimeoutSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "timeout_seconds"
                }
            ],
            "key": "kubernetes_pod.spec.container.liveness_probe",
            "name": "LivenessProbeSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "LivenessProbeSetting s",
            "original": "liveness_probe"
        },
        {
            "con": {
                "smart": "loadBalancerIngressSetting",
                "name": "LoadBalancerIngressSetting'"
            },
            "arguments": [],
            "key": "kubernetes_service.load_balancer_ingress",
            "name": "LoadBalancerIngressSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"hostname\" <$> TF.attribute",
                    "name": "_computedHostname",
                    "method": "computedHostname",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedHostname",
                    "validate": false,
                    "optional": false,
                    "original": "hostname"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"ip\" <$> TF.attribute",
                    "name": "_computedIp",
                    "method": "computedIp",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedIp",
                    "validate": false,
                    "optional": false,
                    "original": "ip"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "LoadBalancerIngressSetting s",
            "original": "load_balancer_ingress"
        },
        {
            "con": {
                "smart": "matchExpressionsSetting",
                "name": "MatchExpressionsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The label key that the selector applies to."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A key's relationship to a set of values. Valid operators ard `In`, `NotIn`,",
                        "`Exists` and `DoesNotExist`."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"operator\" <$> TF.attribute",
                    "name": "_operator",
                    "method": "operator",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasOperator",
                    "validate": false,
                    "optional": true,
                    "original": "operator"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An array of string values. If the operator is `In` or `NotIn`, the values",
                        "array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the",
                        "values array must be empty. This array is replaced during a strategic merge",
                        "patch."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"values\" <$> TF.attribute",
                    "name": "_values",
                    "method": "values",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasValues",
                    "validate": false,
                    "optional": true,
                    "original": "values"
                }
            ],
            "key": "kubernetes_persistent_volume_claim.spec.selector.match_expressions",
            "name": "MatchExpressionsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "MatchExpressionsSetting s",
            "original": "match_expressions"
        },
        {
            "con": {
                "smart": "metadataSetting",
                "name": "MetadataSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the config map that may be used to",
                        "store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the config map. May match selectors of replication",
                        "controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the config map, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_generateName",
                            "method": "generateName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Namespace defines the space within which name of the config map must be",
                        "unique."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"namespace\" <$> TF.attribute",
                    "name": "_namespace",
                    "method": "namespace",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNamespace",
                    "validate": false,
                    "optional": true,
                    "original": "namespace"
                }
            ],
            "key": "kubernetes_config_map.metadata",
            "name": "MetadataSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the config map, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "threaded": true,
                    "conflicts": [
                        "_generateName"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this config map that",
                        "can be used by clients to determine when config map has changed. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this config map."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this config map. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Prefix, used by the server, to generate a unique name ONLY IF the `name`",
                        "field has not been provided. This value will also be combined with a unique",
                        "suffix. Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"generate_name\" <$> TF.attribute",
                    "name": "_generateName",
                    "method": "generateName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_name",
                            "method": "name"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGenerateName",
                    "validate": false,
                    "optional": true,
                    "original": "generate_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the config map, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_generateName",
                            "method": "generateName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "type": "MetadataSetting s",
            "original": "metadata"
        },
        {
            "con": {
                "smart": "nfsSetting",
                "name": "NfsSetting'"
            },
            "arguments": [
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that is exported by the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the NFS export to be mounted with read-only permissions.",
                        "Defaults to false. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_server",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Server is the hostname or IP address of the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"server\" <$> TF.attribute",
                    "name": "_server",
                    "method": "server",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasServer",
                    "validate": false,
                    "optional": false,
                    "original": "server"
                }
            ],
            "key": "kubernetes_persistent_volume.spec.persistent_volume_source.nfs",
            "name": "NfsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that is exported by the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "_server",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Server is the hostname or IP address of the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"server\" <$> TF.attribute",
                    "name": "_server",
                    "method": "server",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasServer",
                    "validate": false,
                    "optional": false,
                    "original": "server"
                }
            ],
            "conflicts": [],
            "type": "NfsSetting s",
            "original": "nfs"
        },
        {
            "con": {
                "smart": "persistentVolumeClaimSetting",
                "name": "PersistentVolumeClaimSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ClaimName is the name of a PersistentVolumeClaim in the same"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"claim_name\" <$> TF.attribute",
                    "name": "_claimName",
                    "method": "claimName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasClaimName",
                    "validate": false,
                    "optional": true,
                    "original": "claim_name"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Will force the ReadOnly setting in VolumeMounts."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "key": "kubernetes_pod.spec.volume.persistent_volume_claim",
            "name": "PersistentVolumeClaimSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PersistentVolumeClaimSetting s",
            "original": "persistent_volume_claim"
        },
        {
            "con": {
                "smart": "persistentVolumeSourceSetting",
                "name": "PersistentVolumeSourceSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an AWS Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"aws_elastic_block_store\" <$> TF.attribute",
                    "name": "_awsElasticBlockStore",
                    "method": "awsElasticBlockStore",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (AwsElasticBlockStoreSetting s)",
                    "class": "HasAwsElasticBlockStore",
                    "validate": true,
                    "optional": true,
                    "original": "aws_elastic_block_store"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure Data Disk mount on the host and bind mount to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_disk\" <$> TF.attribute",
                    "name": "_azureDisk",
                    "method": "azureDisk",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (AzureDiskSetting s)",
                    "class": "HasAzureDisk",
                    "validate": true,
                    "optional": true,
                    "original": "azure_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure File Service mount on the host and bind mount to the",
                        "pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_file\" <$> TF.attribute",
                    "name": "_azureFile",
                    "method": "azureFile",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (AzureFileSetting s)",
                    "class": "HasAzureFile",
                    "validate": true,
                    "optional": true,
                    "original": "azure_file"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Ceph FS mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_fs\" <$> TF.attribute",
                    "name": "_cephFs",
                    "method": "cephFs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (CephFsSetting s)",
                    "class": "HasCephFs",
                    "validate": true,
                    "optional": true,
                    "original": "ceph_fs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a cinder volume attached and mounted on kubelets host machine.",
                        "More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cinder\" <$> TF.attribute",
                    "name": "_cinder",
                    "method": "cinder",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (CinderSetting s)",
                    "class": "HasCinder",
                    "validate": true,
                    "optional": true,
                    "original": "cinder"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Fibre Channel resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fc\" <$> TF.attribute",
                    "name": "_fc",
                    "method": "fc",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (FcSetting s)",
                    "class": "HasFc",
                    "validate": true,
                    "optional": true,
                    "original": "fc"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a generic volume resource that is provisioned/attached using an",
                        "exec based plugin. This is an alpha feature and may change in future."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flex_volume\" <$> TF.attribute",
                    "name": "_flexVolume",
                    "method": "flexVolume",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (FlexVolumeSetting s)",
                    "class": "HasFlexVolume",
                    "validate": true,
                    "optional": true,
                    "original": "flex_volume"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Flocker volume attached to a kubelet's host machine and exposed",
                        "to the pod for its usage. This depends on the Flocker control service being",
                        "running"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flocker\" <$> TF.attribute",
                    "name": "_flocker",
                    "method": "flocker",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (FlockerSetting s)",
                    "class": "HasFlocker",
                    "validate": true,
                    "optional": true,
                    "original": "flocker"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a GCE Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"gce_persistent_disk\" <$> TF.attribute",
                    "name": "_gcePersistentDisk",
                    "method": "gcePersistentDisk",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (GcePersistentDiskSetting s)",
                    "class": "HasGcePersistentDisk",
                    "validate": true,
                    "optional": true,
                    "original": "gce_persistent_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Glusterfs volume that is attached to a host and exposed to the",
                        "pod. Provisioned by an admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"glusterfs\" <$> TF.attribute",
                    "name": "_glusterfs",
                    "method": "glusterfs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (GlusterfsSetting s)",
                    "class": "HasGlusterfs",
                    "validate": true,
                    "optional": true,
                    "original": "glusterfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a directory on the host. Provisioned by a developer or tester.",
                        "This is useful for single-node development and testing only! On-host storage",
                        "is not supported in any way and WILL NOT WORK in a multi-node cluster. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#hostpath"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_path\" <$> TF.attribute",
                    "name": "_hostPath",
                    "method": "hostPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (HostPathSetting s)",
                    "class": "HasHostPath",
                    "validate": true,
                    "optional": true,
                    "original": "host_path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an ISCSI Disk resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod. Provisioned by an admin."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi\" <$> TF.attribute",
                    "name": "_iscsi",
                    "method": "iscsi",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (IscsiSetting s)",
                    "class": "HasIscsi",
                    "validate": true,
                    "optional": true,
                    "original": "iscsi"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an NFS mount on the host. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"nfs\" <$> TF.attribute",
                    "name": "_nfs",
                    "method": "nfs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (NfsSetting s)",
                    "class": "HasNfs",
                    "validate": true,
                    "optional": true,
                    "original": "nfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a PhotonController persistent disk attached and mounted on",
                        "kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"photon_persistent_disk\" <$> TF.attribute",
                    "name": "_photonPersistentDisk",
                    "method": "photonPersistentDisk",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PhotonPersistentDiskSetting s)",
                    "class": "HasPhotonPersistentDisk",
                    "validate": true,
                    "optional": true,
                    "original": "photon_persistent_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Quobyte represents a Quobyte mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"quobyte\" <$> TF.attribute",
                    "name": "_quobyte",
                    "method": "quobyte",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (QuobyteSetting s)",
                    "class": "HasQuobyte",
                    "validate": true,
                    "optional": true,
                    "original": "quobyte"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Rados Block Device mount on the host that shares a pod's",
                        "lifetime. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd\" <$> TF.attribute",
                    "name": "_rbd",
                    "method": "rbd",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (RbdSetting s)",
                    "class": "HasRbd",
                    "validate": true,
                    "optional": true,
                    "original": "rbd"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a vSphere volume attached and mounted on kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vsphere_volume\" <$> TF.attribute",
                    "name": "_vsphereVolume",
                    "method": "vsphereVolume",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (VsphereVolumeSetting s)",
                    "class": "HasVsphereVolume",
                    "validate": true,
                    "optional": true,
                    "original": "vsphere_volume"
                }
            ],
            "key": "kubernetes_persistent_volume.spec.persistent_volume_source",
            "name": "PersistentVolumeSourceSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PersistentVolumeSourceSetting s",
            "original": "persistent_volume_source"
        },
        {
            "con": {
                "smart": "photonPersistentDiskSetting",
                "name": "PhotonPersistentDiskSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_pdId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ID that identifies Photon Controller persistent disk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_id\" <$> TF.attribute",
                    "name": "_pdId",
                    "method": "pdId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdId",
                    "validate": false,
                    "optional": false,
                    "original": "pd_id"
                }
            ],
            "key": "kubernetes_persistent_volume.spec.persistent_volume_source.photon_persistent_disk",
            "name": "PhotonPersistentDiskSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_pdId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ID that identifies Photon Controller persistent disk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_id\" <$> TF.attribute",
                    "name": "_pdId",
                    "method": "pdId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdId",
                    "validate": false,
                    "optional": false,
                    "original": "pd_id"
                }
            ],
            "conflicts": [],
            "type": "PhotonPersistentDiskSetting s",
            "original": "photon_persistent_disk"
        },
        {
            "con": {
                "smart": "portSetting",
                "name": "PortSetting'"
            },
            "arguments": [
                {
                    "default": "_containerPort",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number of port to expose on the pod's IP address. This must be a valid port",
                        "number, 0 < x < 65536."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_port\" <$> TF.attribute",
                    "name": "_containerPort",
                    "method": "containerPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasContainerPort",
                    "validate": false,
                    "optional": false,
                    "original": "container_port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "What host IP to bind the external port to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_ip\" <$> TF.attribute",
                    "name": "_hostIp",
                    "method": "hostIp",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostIp",
                    "validate": false,
                    "optional": true,
                    "original": "host_ip"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of port to expose on the host. If specified, this must be a valid",
                        "port number, 0 < x < 65536. If HostNetwork is specified, this must match",
                        "ContainerPort. Most containers do not need this."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_port\" <$> TF.attribute",
                    "name": "_hostPort",
                    "method": "hostPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHostPort",
                    "validate": false,
                    "optional": true,
                    "original": "host_port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If specified, this must be an IANA_SVC_NAME and unique within the pod. Each",
                        "named port in a pod must have a unique name. Name for the port that can be",
                        "referred to by services"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.value \"TCP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Protocol for port. Must be UDP or TCP. Defaults to \"TCP\"."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"protocol\" <$> TF.attribute",
                    "name": "_protocol",
                    "method": "protocol",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasProtocol",
                    "validate": false,
                    "optional": true,
                    "original": "protocol"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The port on each node on which this service is exposed when `type` is",
                        "`NodePort` or `LoadBalancer`. Usually assigned by the system. If specified,",
                        "it will be allocated to the service if unused or else creation of the",
                        "service will fail. Default is to auto-allocate a port if the `type` of this",
                        "service requires one. More info:",
                        "http://kubernetes.io/docs/user-guide/services#type--nodeport"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"node_port\" <$> TF.attribute",
                    "name": "_nodePort",
                    "method": "nodePort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasNodePort",
                    "validate": false,
                    "optional": true,
                    "original": "node_port"
                },
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The port that will be exposed by this service."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number or name of the port to access on the pods targeted by the service.",
                        "Number must be in the range 1 to 65535. This field is ignored for services",
                        "with `cluster_ip = \"None\"`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#defining-a-service"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_port\" <$> TF.attribute",
                    "name": "_targetPort",
                    "method": "targetPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTargetPort",
                    "validate": false,
                    "optional": true,
                    "original": "target_port"
                }
            ],
            "key": "kubernetes_pod.spec.container.port",
            "name": "PortSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The port on each node on which this service is exposed when `type` is",
                        "`NodePort` or `LoadBalancer`. Usually assigned by the system. If specified,",
                        "it will be allocated to the service if unused or else creation of the",
                        "service will fail. Default is to auto-allocate a port if the `type` of this",
                        "service requires one. More info:",
                        "http://kubernetes.io/docs/user-guide/services#type--nodeport"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"node_port\" <$> TF.attribute",
                    "name": "_computedNodePort",
                    "method": "computedNodePort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedNodePort",
                    "validate": false,
                    "optional": false,
                    "original": "node_port"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Number or name of the port to access on the pods targeted by the service.",
                        "Number must be in the range 1 to 65535. This field is ignored for services",
                        "with `cluster_ip = \"None\"`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#defining-a-service"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_port\" <$> TF.attribute",
                    "name": "_computedTargetPort",
                    "method": "computedTargetPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedTargetPort",
                    "validate": false,
                    "optional": false,
                    "original": "target_port"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The name of this port within the service. All ports within the service must",
                        "have unique names. Optional if only one ServicePort is defined on this",
                        "service."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The port that will be exposed by this service."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_computedPort",
                    "method": "computedPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The IP protocol for this port. Supports `TCP` and `UDP`. Default is `TCP`."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"protocol\" <$> TF.attribute",
                    "name": "_computedProtocol",
                    "method": "computedProtocol",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedProtocol",
                    "validate": false,
                    "optional": false,
                    "original": "protocol"
                }
            ],
            "parameters": [
                {
                    "default": "_containerPort",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number of port to expose on the pod's IP address. This must be a valid port",
                        "number, 0 < x < 65536."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_port\" <$> TF.attribute",
                    "name": "_containerPort",
                    "method": "containerPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasContainerPort",
                    "validate": false,
                    "optional": false,
                    "original": "container_port"
                },
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The port that will be exposed by this service."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "PortSetting s",
            "original": "port"
        },
        {
            "con": {
                "smart": "postStartSetting",
                "name": "PostStartSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ExecSetting s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (HttpGetSetting s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TcpSocketSetting s)]",
                    "class": "HasTcpSocket",
                    "validate": false,
                    "optional": true,
                    "original": "tcp_socket"
                }
            ],
            "key": "kubernetes_pod.spec.container.lifecycle.post_start",
            "name": "PostStartSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PostStartSetting s",
            "original": "post_start"
        },
        {
            "con": {
                "smart": "preStopSetting",
                "name": "PreStopSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ExecSetting s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (HttpGetSetting s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TcpSocketSetting s)]",
                    "class": "HasTcpSocket",
                    "validate": false,
                    "optional": true,
                    "original": "tcp_socket"
                }
            ],
            "key": "kubernetes_pod.spec.container.lifecycle.pre_stop",
            "name": "PreStopSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PreStopSetting s",
            "original": "pre_stop"
        },
        {
            "con": {
                "smart": "quobyteSetting",
                "name": "QuobyteSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Group to map volume access to Default is no group"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"group\" <$> TF.attribute",
                    "name": "_group",
                    "method": "group",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGroup",
                    "validate": false,
                    "optional": true,
                    "original": "group"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the Quobyte volume to be mounted with read-only",
                        "permissions. Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_registry",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Registry represents a single or multiple Quobyte Registry services specified",
                        "as a string as host:port pair (multiple entries are separated with commas)",
                        "which acts as the central registry for volumes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"registry\" <$> TF.attribute",
                    "name": "_registry",
                    "method": "registry",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRegistry",
                    "validate": false,
                    "optional": false,
                    "original": "registry"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User to map volume access to Defaults to serivceaccount user"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "_user",
                    "method": "user",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "validate": false,
                    "optional": true,
                    "original": "user"
                },
                {
                    "default": "_volume",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume is a string that references an already created Quobyte volume by",
                        "name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "_volume",
                    "method": "volume",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolume",
                    "validate": false,
                    "optional": false,
                    "original": "volume"
                }
            ],
            "key": "kubernetes_persistent_volume.spec.persistent_volume_source.quobyte",
            "name": "QuobyteSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_registry",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Registry represents a single or multiple Quobyte Registry services specified",
                        "as a string as host:port pair (multiple entries are separated with commas)",
                        "which acts as the central registry for volumes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"registry\" <$> TF.attribute",
                    "name": "_registry",
                    "method": "registry",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRegistry",
                    "validate": false,
                    "optional": false,
                    "original": "registry"
                },
                {
                    "default": "_volume",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume is a string that references an already created Quobyte volume by",
                        "name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "_volume",
                    "method": "volume",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolume",
                    "validate": false,
                    "optional": false,
                    "original": "volume"
                }
            ],
            "conflicts": [],
            "type": "QuobyteSetting s",
            "original": "quobyte"
        },
        {
            "con": {
                "smart": "rbdSetting",
                "name": "RbdSetting'"
            },
            "arguments": [
                {
                    "default": "_cephMonitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A collection of Ceph monitors. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_monitors\" <$> TF.attribute",
                    "name": "_cephMonitors",
                    "method": "cephMonitors",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCephMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "ceph_monitors"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#rbd"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring.",
                        "More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"keyring\" <$> TF.attribute",
                    "name": "_keyring",
                    "method": "keyring",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKeyring",
                    "validate": false,
                    "optional": true,
                    "original": "keyring"
                },
                {
                    "default": "TF.value \"admin\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The rados user name. Default is admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rados_user\" <$> TF.attribute",
                    "name": "_radosUser",
                    "method": "radosUser",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRadosUser",
                    "validate": false,
                    "optional": true,
                    "original": "rados_user"
                },
                {
                    "default": "_rbdImage",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The rados image name. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_image\" <$> TF.attribute",
                    "name": "_rbdImage",
                    "method": "rbdImage",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdImage",
                    "validate": false,
                    "optional": false,
                    "original": "rbd_image"
                },
                {
                    "default": "TF.value \"rbd\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The rados pool name. Default is rbd. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_pool\" <$> TF.attribute",
                    "name": "_rbdPool",
                    "method": "rbdPool",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdPool",
                    "validate": false,
                    "optional": true,
                    "original": "rbd_pool"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false.",
                        "More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the authentication secret for RBDUser. If provided overrides",
                        "keyring. Default is nil. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "_secretRef",
                    "method": "secretRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SecretRefSetting s)",
                    "class": "HasSecretRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_ref"
                }
            ],
            "key": "kubernetes_persistent_volume.spec.persistent_volume_source.rbd",
            "name": "RbdSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring.",
                        "More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"keyring\" <$> TF.attribute",
                    "name": "_computedKeyring",
                    "method": "computedKeyring",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedKeyring",
                    "validate": false,
                    "optional": false,
                    "original": "keyring"
                }
            ],
            "parameters": [
                {
                    "default": "_rbdImage",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The rados image name. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_image\" <$> TF.attribute",
                    "name": "_rbdImage",
                    "method": "rbdImage",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdImage",
                    "validate": false,
                    "optional": false,
                    "original": "rbd_image"
                },
                {
                    "default": "_cephMonitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A collection of Ceph monitors. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_monitors\" <$> TF.attribute",
                    "name": "_cephMonitors",
                    "method": "cephMonitors",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCephMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "ceph_monitors"
                }
            ],
            "conflicts": [],
            "type": "RbdSetting s",
            "original": "rbd"
        },
        {
            "con": {
                "smart": "readinessProbeSetting",
                "name": "ReadinessProbeSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ExecSetting s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive failures for the probe to be considered failed after",
                        "having succeeded."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failure_threshold\" <$> TF.attribute",
                    "name": "_failureThreshold",
                    "method": "failureThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasFailureThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "failure_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (HttpGetSetting s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after the container has started before liveness probes are",
                        "initiated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"initial_delay_seconds\" <$> TF.attribute",
                    "name": "_initialDelaySeconds",
                    "method": "initialDelaySeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasInitialDelaySeconds",
                    "validate": false,
                    "optional": true,
                    "original": "initial_delay_seconds"
                },
                {
                    "default": "TF.value 10",
                    "computed": false,
                    "required": false,
                    "help": [
                        "How often (in seconds) to perform the probe"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"period_seconds\" <$> TF.attribute",
                    "name": "_periodSeconds",
                    "method": "periodSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasPeriodSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "period_seconds"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive successes for the probe to be considered successful",
                        "after having failed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"success_threshold\" <$> TF.attribute",
                    "name": "_successThreshold",
                    "method": "successThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasSuccessThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "success_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TcpSocketSetting s)]",
                    "class": "HasTcpSocket",
                    "validate": false,
                    "optional": true,
                    "original": "tcp_socket"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after which the probe times out. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"timeout_seconds\" <$> TF.attribute",
                    "name": "_timeoutSeconds",
                    "method": "timeoutSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasTimeoutSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "timeout_seconds"
                }
            ],
            "key": "kubernetes_pod.spec.container.readiness_probe",
            "name": "ReadinessProbeSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReadinessProbeSetting s",
            "original": "readiness_probe"
        },
        {
            "con": {
                "smart": "requestsSetting",
                "name": "RequestsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_cpu",
                    "method": "cpu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCpu",
                    "validate": false,
                    "optional": true,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_memory",
                    "method": "memory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMemory",
                    "validate": false,
                    "optional": true,
                    "original": "memory"
                }
            ],
            "key": "kubernetes_pod.spec.container.resources.requests",
            "name": "RequestsSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_computedCpu",
                    "method": "computedCpu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedCpu",
                    "validate": false,
                    "optional": false,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_computedMemory",
                    "method": "computedMemory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMemory",
                    "validate": false,
                    "optional": false,
                    "original": "memory"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "RequestsSetting s",
            "original": "requests"
        },
        {
            "con": {
                "smart": "resourceFieldRefSetting",
                "name": "ResourceFieldRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_name\" <$> TF.attribute",
                    "name": "_containerName",
                    "method": "containerName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasContainerName",
                    "validate": false,
                    "optional": true,
                    "original": "container_name"
                },
                {
                    "default": "_resource'",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Resource to select"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource\" <$> TF.attribute",
                    "name": "_resource'",
                    "method": "resource'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResource'",
                    "validate": false,
                    "optional": false,
                    "original": "resource"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"quantity\" <$> TF.attribute",
                    "name": "_quantity",
                    "method": "quantity",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasQuantity",
                    "validate": false,
                    "optional": true,
                    "original": "quantity"
                }
            ],
            "key": "kubernetes_pod.spec.container.env.value_from.resource_field_ref",
            "name": "ResourceFieldRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_resource'",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Resource to select"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource\" <$> TF.attribute",
                    "name": "_resource'",
                    "method": "resource'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResource'",
                    "validate": false,
                    "optional": false,
                    "original": "resource"
                }
            ],
            "conflicts": [],
            "type": "ResourceFieldRefSetting s",
            "original": "resource_field_ref"
        },
        {
            "con": {
                "smart": "resourcesSetting",
                "name": "ResourcesSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map describing the maximum amount of compute resources allowed. More info:",
                        "http://kubernetes.io/docs/user-guide/compute-resources/"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"limits\" <$> TF.attribute",
                    "name": "_limits",
                    "method": "limits",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasLimits",
                    "validate": false,
                    "optional": true,
                    "original": "limits"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map describing the minimum amount of compute resources required. If this is",
                        "omitted for a container, it defaults to `limits` if that is explicitly",
                        "specified, otherwise to an implementation-defined value. More info:",
                        "http://kubernetes.io/docs/user-guide/compute-resources/"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"requests\" <$> TF.attribute",
                    "name": "_requests",
                    "method": "requests",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasRequests",
                    "validate": false,
                    "optional": true,
                    "original": "requests"
                }
            ],
            "key": "kubernetes_persistent_volume_claim.spec.resources",
            "name": "ResourcesSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Describes the maximum amount of compute resources allowed. More info:",
                        "http://kubernetes.io/docs/user-guide/compute-resources/"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"limits\" <$> TF.attribute",
                    "name": "_computedLimits",
                    "method": "computedLimits",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (LimitsSetting s)",
                    "class": "HasComputedLimits",
                    "validate": true,
                    "optional": false,
                    "original": "limits"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"requests\" <$> TF.attribute",
                    "name": "_computedRequests",
                    "method": "computedRequests",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (RequestsSetting s)",
                    "class": "HasComputedRequests",
                    "validate": true,
                    "optional": false,
                    "original": "requests"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "ResourcesSetting s",
            "original": "resources"
        },
        {
            "con": {
                "smart": "scaleTargetRefSetting",
                "name": "ScaleTargetRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "API version of the referent"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"api_version\" <$> TF.attribute",
                    "name": "_apiVersion",
                    "method": "apiVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasApiVersion",
                    "validate": false,
                    "optional": true,
                    "original": "api_version"
                },
                {
                    "default": "_kind",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Kind of the referent. e.g. `ReplicationController`. More info:",
                        "http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#types-kinds"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"kind\" <$> TF.attribute",
                    "name": "_kind",
                    "method": "kind",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKind",
                    "validate": false,
                    "optional": false,
                    "original": "kind"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "key": "kubernetes_horizontal_pod_autoscaler.spec.scale_target_ref",
            "name": "ScaleTargetRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_kind",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Kind of the referent. e.g. `ReplicationController`. More info:",
                        "http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#types-kinds"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"kind\" <$> TF.attribute",
                    "name": "_kind",
                    "method": "kind",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKind",
                    "validate": false,
                    "optional": false,
                    "original": "kind"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "ScaleTargetRefSetting s",
            "original": "scale_target_ref"
        },
        {
            "con": {
                "smart": "seLinuxOptionsSetting",
                "name": "SeLinuxOptionsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Level is SELinux level label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"level\" <$> TF.attribute",
                    "name": "_level",
                    "method": "level",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLevel",
                    "validate": false,
                    "optional": true,
                    "original": "level"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Role is a SELinux role label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"role\" <$> TF.attribute",
                    "name": "_role",
                    "method": "role",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRole",
                    "validate": false,
                    "optional": true,
                    "original": "role"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Type is a SELinux type label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": true,
                    "original": "type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User is a SELinux user label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "_user",
                    "method": "user",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "validate": false,
                    "optional": true,
                    "original": "user"
                }
            ],
            "key": "kubernetes_pod.spec.container.security_context.se_linux_options",
            "name": "SeLinuxOptionsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "SeLinuxOptionsSetting s",
            "original": "se_linux_options"
        },
        {
            "con": {
                "smart": "secretSetting",
                "name": "SecretSetting'"
            },
            "arguments": [
                {
                    "default": "TF.value 420",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on created files by default. Must be a value",
                        "between 0 and 0777. Defaults to 0644. Directories within the path are not",
                        "affected by this setting. This might be in conflict with other options that",
                        "affect the file mode, like fsGroup, and the result can be other mode bits",
                        "set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_mode\" <$> TF.attribute",
                    "name": "_defaultMode",
                    "method": "defaultMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasDefaultMode",
                    "validate": false,
                    "optional": true,
                    "original": "default_mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If unspecified, each key-value pair in the Data field of the referenced",
                        "Secret will be projected into the volume as a file whose name is the key and",
                        "content is the value. If specified, the listed keys will be projected into",
                        "the specified paths, and unlisted keys will not be present. If a key is",
                        "specified which is not present in the Secret, the volume setup will error",
                        "unless it is marked optional. Paths must be relative and may not contain the",
                        "'..' path or start with '..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"items\" <$> TF.attribute",
                    "name": "_items",
                    "method": "items",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ItemsSetting s)]",
                    "class": "HasItems",
                    "validate": false,
                    "optional": true,
                    "original": "items"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: Specify whether the Secret or it's keys must be defined."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"optional\" <$> TF.attribute",
                    "name": "_optional",
                    "method": "optional",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasOptional",
                    "validate": false,
                    "optional": true,
                    "original": "optional"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the secret in the pod's namespace to use. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#secrets"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_name\" <$> TF.attribute",
                    "name": "_secretName",
                    "method": "secretName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretName",
                    "validate": false,
                    "optional": true,
                    "original": "secret_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "key": "kubernetes_pod.spec.volume.secret",
            "name": "SecretSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "SecretSetting s",
            "original": "secret"
        },
        {
            "con": {
                "smart": "secretKeyRefSetting",
                "name": "SecretKeyRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key of the secret to select from. Must be a valid secret key."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "key": "kubernetes_pod.spec.container.env.value_from.secret_key_ref",
            "name": "SecretKeyRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "SecretKeyRefSetting s",
            "original": "secret_key_ref"
        },
        {
            "con": {
                "smart": "secretRefSetting",
                "name": "SecretRefSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "key": "kubernetes_persistent_volume.spec.persistent_volume_source.ceph_fs.secret_ref",
            "name": "SecretRefSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "SecretRefSetting s",
            "original": "secret_ref"
        },
        {
            "con": {
                "smart": "securityContextSetting",
                "name": "SecurityContextSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The capabilities to add/drop when running containers. Defaults to the",
                        "default set of capabilities granted by the container runtime."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"capabilities\" <$> TF.attribute",
                    "name": "_capabilities",
                    "method": "capabilities",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (CapabilitiesSetting s)",
                    "class": "HasCapabilities",
                    "validate": true,
                    "optional": true,
                    "original": "capabilities"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Run container in privileged mode. Processes in privileged containers are",
                        "essentially equivalent to root on the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"privileged\" <$> TF.attribute",
                    "name": "_privileged",
                    "method": "privileged",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasPrivileged",
                    "validate": false,
                    "optional": true,
                    "original": "privileged"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container has a read-only root filesystem."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only_root_filesystem\" <$> TF.attribute",
                    "name": "_readOnlyRootFilesystem",
                    "method": "readOnlyRootFilesystem",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnlyRootFilesystem",
                    "validate": false,
                    "optional": true,
                    "original": "read_only_root_filesystem"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Indicates that the container must run as a non-root user. If true, the",
                        "Kubelet will validate the image at runtime to ensure that it does not run as",
                        "UID 0 (root) and fail to start the container if it does."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_non_root\" <$> TF.attribute",
                    "name": "_runAsNonRoot",
                    "method": "runAsNonRoot",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRunAsNonRoot",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_non_root"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The UID to run the entrypoint of the container process. Defaults to user",
                        "specified in image metadata if unspecified"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_user\" <$> TF.attribute",
                    "name": "_runAsUser",
                    "method": "runAsUser",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasRunAsUser",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_user"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ImagePullSecrets is an optional list of references to secrets in the same",
                        "namespace to use for pulling any of the images used by this PodSpec. If",
                        "specified, these secrets will be passed to individual puller implementations",
                        "for them to use. For example, in the case of docker, only DockerConfig type",
                        "secrets are honored. More info:",
                        "http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"se_linux_options\" <$> TF.attribute",
                    "name": "_seLinuxOptions",
                    "method": "seLinuxOptions",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SeLinuxOptionsSetting s)",
                    "class": "HasSeLinuxOptions",
                    "validate": true,
                    "optional": true,
                    "original": "se_linux_options"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A special supplemental group that applies to all containers in a pod. Some",
                        "volume types allow the Kubelet to change the ownership of that volume to be",
                        "owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is",
                        "set (new files created in the volume will be owned by FSGroup) 3. The",
                        "permission bits are OR'd with rw-rw---- If unset, the Kubelet will not",
                        "modify the ownership and permissions of any volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_group\" <$> TF.attribute",
                    "name": "_fsGroup",
                    "method": "fsGroup",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasFsGroup",
                    "validate": false,
                    "optional": true,
                    "original": "fs_group"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of groups applied to the first process run in each container, in",
                        "addition to the container's primary GID. If unspecified, no groups will be",
                        "added to any container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"supplemental_groups\" <$> TF.attribute",
                    "name": "_supplementalGroups",
                    "method": "supplementalGroups",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Int]",
                    "class": "HasSupplementalGroups",
                    "validate": false,
                    "optional": true,
                    "original": "supplemental_groups"
                }
            ],
            "key": "kubernetes_pod.spec.container.security_context",
            "name": "SecurityContextSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "SecurityContextSetting s",
            "original": "security_context"
        },
        {
            "con": {
                "smart": "selectorSetting",
                "name": "SelectorSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of label selector requirements. The requirements are ANDed."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"match_expressions\" <$> TF.attribute",
                    "name": "_matchExpressions",
                    "method": "matchExpressions",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (MatchExpressionsSetting s)]",
                    "class": "HasMatchExpressions",
                    "validate": false,
                    "optional": true,
                    "original": "match_expressions"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A map of {key,value} pairs. A single {key,value} in the matchLabels map is",
                        "equivalent to an element of `match_expressions`, whose key field is \"key\",",
                        "the operator is \"In\", and the values array contains only \"value\". The",
                        "requirements are ANDed."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"match_labels\" <$> TF.attribute",
                    "name": "_matchLabels",
                    "method": "matchLabels",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasMatchLabels",
                    "validate": false,
                    "optional": true,
                    "original": "match_labels"
                }
            ],
            "key": "kubernetes_persistent_volume_claim.spec.selector",
            "name": "SelectorSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "SelectorSetting s",
            "original": "selector"
        },
        {
            "con": {
                "smart": "specSetting",
                "name": "SpecSetting'"
            },
            "arguments": [
                {
                    "default": "_maxReplicas",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Upper limit for the number of pods that can be set by the autoscaler."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"max_replicas\" <$> TF.attribute",
                    "name": "_maxReplicas",
                    "method": "maxReplicas",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMaxReplicas",
                    "validate": false,
                    "optional": false,
                    "original": "max_replicas"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Lower limit for the number of pods that can be set by the autoscaler,",
                        "defaults to `1`."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"min_replicas\" <$> TF.attribute",
                    "name": "_minReplicas",
                    "method": "minReplicas",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMinReplicas",
                    "validate": false,
                    "optional": true,
                    "original": "min_replicas"
                },
                {
                    "default": "_scaleTargetRef",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Reference to scaled resource. e.g. Replication Controller"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scale_target_ref\" <$> TF.attribute",
                    "name": "_scaleTargetRef",
                    "method": "scaleTargetRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ScaleTargetRefSetting s)",
                    "class": "HasScaleTargetRef",
                    "validate": true,
                    "optional": false,
                    "original": "scale_target_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Target average CPU utilization (represented as a percentage of requested",
                        "CPU) over all the pods. If not specified the default autoscaling policy will",
                        "be used."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_cpu_utilization_percentage\" <$> TF.attribute",
                    "name": "_targetCpuUtilizationPercentage",
                    "method": "targetCpuUtilizationPercentage",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasTargetCpuUtilizationPercentage",
                    "validate": false,
                    "optional": true,
                    "original": "target_cpu_utilization_percentage"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Limits is the list of objects that are enforced."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"limit\" <$> TF.attribute",
                    "name": "_limit",
                    "method": "limit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (LimitSetting s)]",
                    "class": "HasLimit",
                    "validate": false,
                    "optional": true,
                    "original": "limit"
                },
                {
                    "default": "_accessModes",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Contains all ways the volume can be mounted. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"access_modes\" <$> TF.attribute",
                    "name": "_accessModes",
                    "method": "accessModes",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasAccessModes",
                    "validate": false,
                    "optional": false,
                    "original": "access_modes"
                },
                {
                    "default": "_capacity",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A description of the persistent volume's resources and capacity. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#capacity"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"capacity\" <$> TF.attribute",
                    "name": "_capacity",
                    "method": "capacity",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasCapacity",
                    "validate": false,
                    "optional": false,
                    "original": "capacity"
                },
                {
                    "default": "TF.value \"Retain\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "What happens to a persistent volume when released from its claim. Valid",
                        "options are Retain (default) and Recycle. Recycling must be supported by the",
                        "volume plugin underlying this persistent volume. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#recycling-policy"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"persistent_volume_reclaim_policy\" <$> TF.attribute",
                    "name": "_persistentVolumeReclaimPolicy",
                    "method": "persistentVolumeReclaimPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPersistentVolumeReclaimPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "persistent_volume_reclaim_policy"
                },
                {
                    "default": "_persistentVolumeSource",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The specification of a persistent volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"persistent_volume_source\" <$> TF.attribute",
                    "name": "_persistentVolumeSource",
                    "method": "persistentVolumeSource",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSourceSetting s)",
                    "class": "HasPersistentVolumeSource",
                    "validate": true,
                    "optional": false,
                    "original": "persistent_volume_source"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A description of the persistent volume's class. More info:",
                        "https://kubernetes.io/docs/concepts/storage/persistent-volumes/#class"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"storage_class_name\" <$> TF.attribute",
                    "name": "_storageClassName",
                    "method": "storageClassName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasStorageClassName",
                    "validate": false,
                    "optional": true,
                    "original": "storage_class_name"
                },
                {
                    "default": "_resources",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A list of the minimum resources the volume should have. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_resources",
                    "method": "resources",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ResourcesSetting s)",
                    "class": "HasResources",
                    "validate": true,
                    "optional": false,
                    "original": "resources"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A label query over volumes to consider for binding."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"selector\" <$> TF.attribute",
                    "name": "_selector",
                    "method": "selector",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SelectorSetting s)",
                    "class": "HasSelector",
                    "validate": true,
                    "optional": true,
                    "original": "selector"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The binding reference to the PersistentVolume backing this claim."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"volume_name\" <$> TF.attribute",
                    "name": "_volumeName",
                    "method": "volumeName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeName",
                    "validate": false,
                    "optional": true,
                    "original": "volume_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional duration in seconds the pod may be active on the node relative to",
                        "StartTime before the system will actively try to mark it failed and kill",
                        "associated containers. Value must be a positive integer."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"active_deadline_seconds\" <$> TF.attribute",
                    "name": "_activeDeadlineSeconds",
                    "method": "activeDeadlineSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasActiveDeadlineSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "active_deadline_seconds"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of containers belonging to the pod. Containers cannot currently be",
                        "added or removed. There must be at least one container in a Pod. Cannot be",
                        "updated. More info: http://kubernetes.io/docs/user-guide/containers"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"container\" <$> TF.attribute",
                    "name": "_container",
                    "method": "container",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ContainerSetting s)]",
                    "class": "HasContainer",
                    "validate": false,
                    "optional": true,
                    "original": "container"
                },
                {
                    "default": "TF.value \"ClusterFirst\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Set DNS policy for containers within the pod. One of 'ClusterFirst' or",
                        "'Default'. Defaults to 'ClusterFirst'."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"dns_policy\" <$> TF.attribute",
                    "name": "_dnsPolicy",
                    "method": "dnsPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDnsPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "dns_policy"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Use the host's ipc namespace. Optional: Default to false."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_ipc\" <$> TF.attribute",
                    "name": "_hostIpc",
                    "method": "hostIpc",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostIpc",
                    "validate": false,
                    "optional": true,
                    "original": "host_ipc"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host networking requested for this pod. Use the host's network namespace. If",
                        "this option is set, the ports that will be used must be specified."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_network\" <$> TF.attribute",
                    "name": "_hostNetwork",
                    "method": "hostNetwork",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostNetwork",
                    "validate": false,
                    "optional": true,
                    "original": "host_network"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Use the host's pid namespace."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_pid\" <$> TF.attribute",
                    "name": "_hostPid",
                    "method": "hostPid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostPid",
                    "validate": false,
                    "optional": true,
                    "original": "host_pid"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the hostname of the Pod If not specified, the pod's hostname will",
                        "be set to a system-defined value."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"hostname\" <$> TF.attribute",
                    "name": "_hostname",
                    "method": "hostname",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostname",
                    "validate": false,
                    "optional": true,
                    "original": "hostname"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ImagePullSecrets is an optional list of references to secrets in the same",
                        "namespace to use for pulling any of the images used by this PodSpec. If",
                        "specified, these secrets will be passed to individual puller implementations",
                        "for them to use. For example, in the case of docker, only DockerConfig type",
                        "secrets are honored. More info:",
                        "http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"image_pull_secrets\" <$> TF.attribute",
                    "name": "_imagePullSecrets",
                    "method": "imagePullSecrets",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ImagePullSecretsSetting s)]",
                    "class": "HasImagePullSecrets",
                    "validate": false,
                    "optional": true,
                    "original": "image_pull_secrets"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of init containers belonging to the pod. Init containers always run to",
                        "completion and each must complete succesfully before the next is started.",
                        "More info:",
                        "https://kubernetes.io/docs/concepts/workloads/pods/init-containers/"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"init_container\" <$> TF.attribute",
                    "name": "_initContainer",
                    "method": "initContainer",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (InitContainerSetting s)]",
                    "class": "HasInitContainer",
                    "validate": false,
                    "optional": true,
                    "original": "init_container"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "NodeName is a request to schedule this pod onto a specific node. If it is",
                        "non-empty, the scheduler simply schedules this pod onto that node, assuming",
                        "that it fits resource requirements."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"node_name\" <$> TF.attribute",
                    "name": "_nodeName",
                    "method": "nodeName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNodeName",
                    "validate": false,
                    "optional": true,
                    "original": "node_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "NodeSelector is a selector which must be true for the pod to fit on a node.",
                        "Selector which must match a node's labels for the pod to be scheduled on",
                        "that node. More info: http://kubernetes.io/docs/user-guide/node-selection."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"node_selector\" <$> TF.attribute",
                    "name": "_nodeSelector",
                    "method": "nodeSelector",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasNodeSelector",
                    "validate": false,
                    "optional": true,
                    "original": "node_selector"
                },
                {
                    "default": "TF.value \"Always\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Restart policy for all containers within the pod. One of Always, OnFailure,",
                        "Never. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#restartpolicy."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"restart_policy\" <$> TF.attribute",
                    "name": "_restartPolicy",
                    "method": "restartPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRestartPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "restart_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "SecurityContext holds pod-level security attributes and common container",
                        "settings. Optional: Defaults to empty"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"security_context\" <$> TF.attribute",
                    "name": "_securityContext",
                    "method": "securityContext",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SecurityContextSetting s)",
                    "class": "HasSecurityContext",
                    "validate": true,
                    "optional": true,
                    "original": "security_context"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ServiceAccountName is the name of the ServiceAccount to use to run this pod.",
                        "More info: http://releases.k8s.io/HEAD/docs/design/service_accounts.md."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"service_account_name\" <$> TF.attribute",
                    "name": "_serviceAccountName",
                    "method": "serviceAccountName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasServiceAccountName",
                    "validate": false,
                    "optional": true,
                    "original": "service_account_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If specified, the fully qualified Pod hostname will be \"...svc.\". If not",
                        "specified, the pod will not have a domainname at all.."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"subdomain\" <$> TF.attribute",
                    "name": "_subdomain",
                    "method": "subdomain",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSubdomain",
                    "validate": false,
                    "optional": true,
                    "original": "subdomain"
                },
                {
                    "default": "TF.value 30",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional duration in seconds the pod needs to terminate gracefully. May be",
                        "decreased in delete request. Value must be non-negative integer. The value",
                        "zero indicates delete immediately. If this value is nil, the default grace",
                        "period will be used instead. The grace period is the duration in seconds",
                        "after the processes running in the pod are sent a termination signal and the",
                        "time when the processes are forcibly halted with a kill signal. Set this",
                        "value longer than the expected cleanup time for your process."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"termination_grace_period_seconds\" <$> TF.attribute",
                    "name": "_terminationGracePeriodSeconds",
                    "method": "terminationGracePeriodSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasTerminationGracePeriodSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "termination_grace_period_seconds"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of volumes that can be mounted by containers belonging to the pod. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "_volume",
                    "method": "volume",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (VolumeSetting s)]",
                    "class": "HasVolume",
                    "validate": false,
                    "optional": true,
                    "original": "volume"
                },
                {
                    "default": "TF.value 0",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum number of seconds for which a newly created pod should be ready",
                        "without any of its container crashing, for it to be considered available.",
                        "Defaults to 0 (pod will be considered available as soon as it is ready)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"min_ready_seconds\" <$> TF.attribute",
                    "name": "_minReadySeconds",
                    "method": "minReadySeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMinReadySeconds",
                    "validate": false,
                    "optional": true,
                    "original": "min_ready_seconds"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The number of desired replicas. Defaults to 1. More info:",
                        "http://kubernetes.io/docs/user-guide/replication-controller#what-is-a-replication-controller"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"replicas\" <$> TF.attribute",
                    "name": "_replicas",
                    "method": "replicas",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasReplicas",
                    "validate": false,
                    "optional": true,
                    "original": "replicas"
                },
                {
                    "default": "_template",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Describes the pod that will be created if insufficient replicas are",
                        "detected. This takes precedence over a TemplateRef. More info:",
                        "http://kubernetes.io/docs/user-guide/replication-controller#pod-template"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"template\" <$> TF.attribute",
                    "name": "_template",
                    "method": "template",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (TemplateSetting s)",
                    "class": "HasTemplate",
                    "validate": true,
                    "optional": false,
                    "original": "template"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The set of desired hard limits for each named resource. More info:",
                        "http://releases.k8s.io/HEAD/docs/design/admission_control_resource_quota.md#admissioncontrol-plugin-resourcequota"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"hard\" <$> TF.attribute",
                    "name": "_hard",
                    "method": "hard",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasHard",
                    "validate": false,
                    "optional": true,
                    "original": "hard"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A collection of filters that must match each object tracked by a quota. If",
                        "not specified, the quota matches all objects."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"scopes\" <$> TF.attribute",
                    "name": "_scopes",
                    "method": "scopes",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasScopes",
                    "validate": false,
                    "optional": true,
                    "original": "scopes"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The IP address of the service. It is usually assigned randomly by the",
                        "master. If an address is specified manually and is not in use by others, it",
                        "will be allocated to the service; otherwise, creation of the service will",
                        "fail. `None` can be specified for headless services when proxying is not",
                        "required. Ignored if type is `ExternalName`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"cluster_ip\" <$> TF.attribute",
                    "name": "_clusterIp",
                    "method": "clusterIp",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasClusterIp",
                    "validate": false,
                    "optional": true,
                    "original": "cluster_ip"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of IP addresses for which nodes in the cluster will also accept",
                        "traffic for this service. These IPs are not managed by Kubernetes. The user",
                        "is responsible for ensuring that traffic arrives at a node with this IP.  A",
                        "common example is external load-balancers that are not part of the",
                        "Kubernetes system."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"external_ips\" <$> TF.attribute",
                    "name": "_externalIps",
                    "method": "externalIps",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasExternalIps",
                    "validate": false,
                    "optional": true,
                    "original": "external_ips"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The external reference that kubedns or equivalent will return as a CNAME",
                        "record for this service. No proxying will be involved. Must be a valid DNS",
                        "name and requires `type` to be `ExternalName`."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"external_name\" <$> TF.attribute",
                    "name": "_externalName",
                    "method": "externalName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasExternalName",
                    "validate": false,
                    "optional": true,
                    "original": "external_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Only applies to `type = LoadBalancer`. LoadBalancer will get created with",
                        "the IP specified in this field. This feature depends on whether the",
                        "underlying cloud-provider supports specifying this field when a load",
                        "balancer is created. This field will be ignored if the cloud-provider does",
                        "not support the feature."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_ip\" <$> TF.attribute",
                    "name": "_loadBalancerIp",
                    "method": "loadBalancerIp",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLoadBalancerIp",
                    "validate": false,
                    "optional": true,
                    "original": "load_balancer_ip"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If specified and supported by the platform, this will restrict traffic",
                        "through the cloud-provider load-balancer will be restricted to the specified",
                        "client IPs. This field will be ignored if the cloud-provider does not",
                        "support the feature. More info:",
                        "http://kubernetes.io/docs/user-guide/services-firewalls"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_source_ranges\" <$> TF.attribute",
                    "name": "_loadBalancerSourceRanges",
                    "method": "loadBalancerSourceRanges",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasLoadBalancerSourceRanges",
                    "validate": false,
                    "optional": true,
                    "original": "load_balancer_source_ranges"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The list of ports that are exposed by this service. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (TF.Attr s (PortSetting s)))",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.value \"None\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Used to maintain session affinity. Supports `ClientIP` and `None`. Defaults",
                        "to `None`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"session_affinity\" <$> TF.attribute",
                    "name": "_sessionAffinity",
                    "method": "sessionAffinity",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSessionAffinity",
                    "validate": false,
                    "optional": true,
                    "original": "session_affinity"
                },
                {
                    "default": "TF.value \"ClusterIP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Determines how the service is exposed. Defaults to `ClusterIP`. Valid",
                        "options are `ExternalName`, `ClusterIP`, `NodePort`, and `LoadBalancer`.",
                        "`ExternalName` maps to the specified `external_name`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#overview"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": true,
                    "original": "type"
                }
            ],
            "key": "kubernetes_horizontal_pod_autoscaler.spec",
            "name": "SpecSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Target average CPU utilization (represented as a percentage of requested",
                        "CPU) over all the pods. If not specified the default autoscaling policy will",
                        "be used."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_cpu_utilization_percentage\" <$> TF.attribute",
                    "name": "_computedTargetCpuUtilizationPercentage",
                    "method": "computedTargetCpuUtilizationPercentage",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedTargetCpuUtilizationPercentage",
                    "validate": false,
                    "optional": false,
                    "original": "target_cpu_utilization_percentage"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the storage class requested by the claim"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"storage_class_name\" <$> TF.attribute",
                    "name": "_computedStorageClassName",
                    "method": "computedStorageClassName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedStorageClassName",
                    "validate": false,
                    "optional": false,
                    "original": "storage_class_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The binding reference to the PersistentVolume backing this claim."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"volume_name\" <$> TF.attribute",
                    "name": "_computedVolumeName",
                    "method": "computedVolumeName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedVolumeName",
                    "validate": false,
                    "optional": false,
                    "original": "volume_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Specifies the hostname of the Pod If not specified, the pod's hostname will",
                        "be set to a system-defined value."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"hostname\" <$> TF.attribute",
                    "name": "_computedHostname",
                    "method": "computedHostname",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedHostname",
                    "validate": false,
                    "optional": false,
                    "original": "hostname"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "ImagePullSecrets is an optional list of references to secrets in the same",
                        "namespace to use for pulling any of the images used by this PodSpec. If",
                        "specified, these secrets will be passed to individual puller implementations",
                        "for them to use. For example, in the case of docker, only DockerConfig type",
                        "secrets are honored. More info:",
                        "http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"image_pull_secrets\" <$> TF.attribute",
                    "name": "_computedImagePullSecrets",
                    "method": "computedImagePullSecrets",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ImagePullSecretsSetting s)]",
                    "class": "HasComputedImagePullSecrets",
                    "validate": false,
                    "optional": false,
                    "original": "image_pull_secrets"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "NodeName is a request to schedule this pod onto a specific node. If it is",
                        "non-empty, the scheduler simply schedules this pod onto that node, assuming",
                        "that it fits resource requirements."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"node_name\" <$> TF.attribute",
                    "name": "_computedNodeName",
                    "method": "computedNodeName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedNodeName",
                    "validate": false,
                    "optional": false,
                    "original": "node_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "ServiceAccountName is the name of the ServiceAccount to use to run this pod.",
                        "More info: http://releases.k8s.io/HEAD/docs/design/service_accounts.md."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"service_account_name\" <$> TF.attribute",
                    "name": "_computedServiceAccountName",
                    "method": "computedServiceAccountName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedServiceAccountName",
                    "validate": false,
                    "optional": false,
                    "original": "service_account_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The IP address of the service. It is usually assigned randomly by the",
                        "master. If an address is specified manually and is not in use by others, it",
                        "will be allocated to the service; otherwise, creation of the service will",
                        "fail. `None` can be specified for headless services when proxying is not",
                        "required. Ignored if type is `ExternalName`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"cluster_ip\" <$> TF.attribute",
                    "name": "_computedClusterIp",
                    "method": "computedClusterIp",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedClusterIp",
                    "validate": false,
                    "optional": false,
                    "original": "cluster_ip"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A list of IP addresses for which nodes in the cluster will also accept",
                        "traffic for this service. These IPs are not managed by Kubernetes. The user",
                        "is responsible for ensuring that traffic arrives at a node with this IP.  A",
                        "common example is external load-balancers that are not part of the",
                        "Kubernetes system."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"external_ips\" <$> TF.attribute",
                    "name": "_computedExternalIps",
                    "method": "computedExternalIps",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedExternalIps",
                    "validate": false,
                    "optional": false,
                    "original": "external_ips"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The external reference that kubedns or equivalent will return as a CNAME",
                        "record for this service. No proxying will be involved. Must be a valid DNS",
                        "name and requires `type` to be `ExternalName`."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"external_name\" <$> TF.attribute",
                    "name": "_computedExternalName",
                    "method": "computedExternalName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedExternalName",
                    "validate": false,
                    "optional": false,
                    "original": "external_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Only applies to `type = LoadBalancer`. LoadBalancer will get created with",
                        "the IP specified in this field. This feature depends on whether the",
                        "underlying cloud-provider supports specifying this field when a load",
                        "balancer is created. This field will be ignored if the cloud-provider does",
                        "not support the feature."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_ip\" <$> TF.attribute",
                    "name": "_computedLoadBalancerIp",
                    "method": "computedLoadBalancerIp",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedLoadBalancerIp",
                    "validate": false,
                    "optional": false,
                    "original": "load_balancer_ip"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "If specified and supported by the platform, this will restrict traffic",
                        "through the cloud-provider load-balancer will be restricted to the specified",
                        "client IPs. This field will be ignored if the cloud-provider does not",
                        "support the feature. More info:",
                        "http://kubernetes.io/docs/user-guide/services-firewalls"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_source_ranges\" <$> TF.attribute",
                    "name": "_computedLoadBalancerSourceRanges",
                    "method": "computedLoadBalancerSourceRanges",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedLoadBalancerSourceRanges",
                    "validate": false,
                    "optional": false,
                    "original": "load_balancer_source_ranges"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The list of ports that are exposed by this service. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_computedPort",
                    "method": "computedPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (TF.Attr s (PortSetting s)))",
                    "class": "HasComputedPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Route service traffic to pods with label keys and values matching this",
                        "selector. Only applies to types `ClusterIP`, `NodePort`, and `LoadBalancer`.",
                        "More info: http://kubernetes.io/docs/user-guide/services#overview"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"selector\" <$> TF.attribute",
                    "name": "_computedSelector",
                    "method": "computedSelector",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasComputedSelector",
                    "validate": false,
                    "optional": false,
                    "original": "selector"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Used to maintain session affinity. Supports `ClientIP` and `None`. Defaults",
                        "to `None`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"session_affinity\" <$> TF.attribute",
                    "name": "_computedSessionAffinity",
                    "method": "computedSessionAffinity",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSessionAffinity",
                    "validate": false,
                    "optional": false,
                    "original": "session_affinity"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Determines how the service is exposed. Defaults to `ClusterIP`. Valid",
                        "options are `ExternalName`, `ClusterIP`, `NodePort`, and `LoadBalancer`.",
                        "`ExternalName` maps to the specified `external_name`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#overview"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_computedType",
                    "method": "computedType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedType",
                    "validate": false,
                    "optional": false,
                    "original": "type"
                }
            ],
            "parameters": [
                {
                    "default": "_capacity",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A description of the persistent volume's resources and capacity. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#capacity"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"capacity\" <$> TF.attribute",
                    "name": "_capacity",
                    "method": "capacity",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasCapacity",
                    "validate": false,
                    "optional": false,
                    "original": "capacity"
                },
                {
                    "default": "_accessModes",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Contains all ways the volume can be mounted. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#access-modes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"access_modes\" <$> TF.attribute",
                    "name": "_accessModes",
                    "method": "accessModes",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasAccessModes",
                    "validate": false,
                    "optional": false,
                    "original": "access_modes"
                },
                {
                    "default": "_scaleTargetRef",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Reference to scaled resource. e.g. Replication Controller"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scale_target_ref\" <$> TF.attribute",
                    "name": "_scaleTargetRef",
                    "method": "scaleTargetRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ScaleTargetRefSetting s)",
                    "class": "HasScaleTargetRef",
                    "validate": true,
                    "optional": false,
                    "original": "scale_target_ref"
                },
                {
                    "default": "_maxReplicas",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Upper limit for the number of pods that can be set by the autoscaler."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"max_replicas\" <$> TF.attribute",
                    "name": "_maxReplicas",
                    "method": "maxReplicas",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMaxReplicas",
                    "validate": false,
                    "optional": false,
                    "original": "max_replicas"
                },
                {
                    "default": "_resources",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A list of the minimum resources the volume should have. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_resources",
                    "method": "resources",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ResourcesSetting s)",
                    "class": "HasResources",
                    "validate": true,
                    "optional": false,
                    "original": "resources"
                },
                {
                    "default": "_persistentVolumeSource",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The specification of a persistent volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"persistent_volume_source\" <$> TF.attribute",
                    "name": "_persistentVolumeSource",
                    "method": "persistentVolumeSource",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeSourceSetting s)",
                    "class": "HasPersistentVolumeSource",
                    "validate": true,
                    "optional": false,
                    "original": "persistent_volume_source"
                },
                {
                    "default": "_template",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Describes the pod that will be created if insufficient replicas are",
                        "detected. This takes precedence over a TemplateRef. More info:",
                        "http://kubernetes.io/docs/user-guide/replication-controller#pod-template"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"template\" <$> TF.attribute",
                    "name": "_template",
                    "method": "template",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (TemplateSetting s)",
                    "class": "HasTemplate",
                    "validate": true,
                    "optional": false,
                    "original": "template"
                }
            ],
            "conflicts": [],
            "type": "SpecSetting s",
            "original": "spec"
        },
        {
            "con": {
                "smart": "tcpSocketSetting",
                "name": "TcpSocketSetting'"
            },
            "arguments": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "key": "kubernetes_pod.spec.container.lifecycle.post_start.tcp_socket",
            "name": "TcpSocketSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "TcpSocketSetting s",
            "original": "tcp_socket"
        },
        {
            "con": {
                "smart": "templateSetting",
                "name": "TemplateSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional duration in seconds the pod may be active on the node relative to",
                        "StartTime before the system will actively try to mark it failed and kill",
                        "associated containers. Value must be a positive integer."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"active_deadline_seconds\" <$> TF.attribute",
                    "name": "_activeDeadlineSeconds",
                    "method": "activeDeadlineSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasActiveDeadlineSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "active_deadline_seconds"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of containers belonging to the pod. Containers cannot currently be",
                        "added or removed. There must be at least one container in a Pod. Cannot be",
                        "updated. More info: http://kubernetes.io/docs/user-guide/containers"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"container\" <$> TF.attribute",
                    "name": "_container",
                    "method": "container",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ContainerSetting s)]",
                    "class": "HasContainer",
                    "validate": false,
                    "optional": true,
                    "original": "container"
                },
                {
                    "default": "TF.value \"ClusterFirst\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Set DNS policy for containers within the pod. One of 'ClusterFirst' or",
                        "'Default'. Defaults to 'ClusterFirst'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dns_policy\" <$> TF.attribute",
                    "name": "_dnsPolicy",
                    "method": "dnsPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDnsPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "dns_policy"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Use the host's ipc namespace. Optional: Default to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_ipc\" <$> TF.attribute",
                    "name": "_hostIpc",
                    "method": "hostIpc",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostIpc",
                    "validate": false,
                    "optional": true,
                    "original": "host_ipc"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host networking requested for this pod. Use the host's network namespace. If",
                        "this option is set, the ports that will be used must be specified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_network\" <$> TF.attribute",
                    "name": "_hostNetwork",
                    "method": "hostNetwork",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostNetwork",
                    "validate": false,
                    "optional": true,
                    "original": "host_network"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Use the host's pid namespace."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_pid\" <$> TF.attribute",
                    "name": "_hostPid",
                    "method": "hostPid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostPid",
                    "validate": false,
                    "optional": true,
                    "original": "host_pid"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the hostname of the Pod If not specified, the pod's hostname will",
                        "be set to a system-defined value."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"hostname\" <$> TF.attribute",
                    "name": "_hostname",
                    "method": "hostname",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostname",
                    "validate": false,
                    "optional": true,
                    "original": "hostname"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ImagePullSecrets is an optional list of references to secrets in the same",
                        "namespace to use for pulling any of the images used by this PodSpec. If",
                        "specified, these secrets will be passed to individual puller implementations",
                        "for them to use. For example, in the case of docker, only DockerConfig type",
                        "secrets are honored. More info:",
                        "http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image_pull_secrets\" <$> TF.attribute",
                    "name": "_imagePullSecrets",
                    "method": "imagePullSecrets",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ImagePullSecretsSetting s)]",
                    "class": "HasImagePullSecrets",
                    "validate": false,
                    "optional": true,
                    "original": "image_pull_secrets"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of init containers belonging to the pod. Init containers always run to",
                        "completion and each must complete succesfully before the next is started.",
                        "More info:",
                        "https://kubernetes.io/docs/concepts/workloads/pods/init-containers/"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"init_container\" <$> TF.attribute",
                    "name": "_initContainer",
                    "method": "initContainer",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (InitContainerSetting s)]",
                    "class": "HasInitContainer",
                    "validate": false,
                    "optional": true,
                    "original": "init_container"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "NodeName is a request to schedule this pod onto a specific node. If it is",
                        "non-empty, the scheduler simply schedules this pod onto that node, assuming",
                        "that it fits resource requirements."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"node_name\" <$> TF.attribute",
                    "name": "_nodeName",
                    "method": "nodeName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNodeName",
                    "validate": false,
                    "optional": true,
                    "original": "node_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "NodeSelector is a selector which must be true for the pod to fit on a node.",
                        "Selector which must match a node's labels for the pod to be scheduled on",
                        "that node. More info: http://kubernetes.io/docs/user-guide/node-selection."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"node_selector\" <$> TF.attribute",
                    "name": "_nodeSelector",
                    "method": "nodeSelector",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasNodeSelector",
                    "validate": false,
                    "optional": true,
                    "original": "node_selector"
                },
                {
                    "default": "TF.value \"Always\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Restart policy for all containers within the pod. One of Always, OnFailure,",
                        "Never. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#restartpolicy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"restart_policy\" <$> TF.attribute",
                    "name": "_restartPolicy",
                    "method": "restartPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRestartPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "restart_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "SecurityContext holds pod-level security attributes and common container",
                        "settings. Optional: Defaults to empty"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"security_context\" <$> TF.attribute",
                    "name": "_securityContext",
                    "method": "securityContext",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SecurityContextSetting s)",
                    "class": "HasSecurityContext",
                    "validate": true,
                    "optional": true,
                    "original": "security_context"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ServiceAccountName is the name of the ServiceAccount to use to run this pod.",
                        "More info: http://releases.k8s.io/HEAD/docs/design/service_accounts.md."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"service_account_name\" <$> TF.attribute",
                    "name": "_serviceAccountName",
                    "method": "serviceAccountName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasServiceAccountName",
                    "validate": false,
                    "optional": true,
                    "original": "service_account_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If specified, the fully qualified Pod hostname will be \"...svc.\". If not",
                        "specified, the pod will not have a domainname at all.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"subdomain\" <$> TF.attribute",
                    "name": "_subdomain",
                    "method": "subdomain",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSubdomain",
                    "validate": false,
                    "optional": true,
                    "original": "subdomain"
                },
                {
                    "default": "TF.value 30",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional duration in seconds the pod needs to terminate gracefully. May be",
                        "decreased in delete request. Value must be non-negative integer. The value",
                        "zero indicates delete immediately. If this value is nil, the default grace",
                        "period will be used instead. The grace period is the duration in seconds",
                        "after the processes running in the pod are sent a termination signal and the",
                        "time when the processes are forcibly halted with a kill signal. Set this",
                        "value longer than the expected cleanup time for your process."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"termination_grace_period_seconds\" <$> TF.attribute",
                    "name": "_terminationGracePeriodSeconds",
                    "method": "terminationGracePeriodSeconds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasTerminationGracePeriodSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "termination_grace_period_seconds"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of volumes that can be mounted by containers belonging to the pod. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "_volume",
                    "method": "volume",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (VolumeSetting s)]",
                    "class": "HasVolume",
                    "validate": false,
                    "optional": true,
                    "original": "volume"
                }
            ],
            "key": "kubernetes_replication_controller.spec.template",
            "name": "TemplateSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Specifies the hostname of the Pod If not specified, the pod's hostname will",
                        "be set to a system-defined value."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"hostname\" <$> TF.attribute",
                    "name": "_computedHostname",
                    "method": "computedHostname",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedHostname",
                    "validate": false,
                    "optional": false,
                    "original": "hostname"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "ImagePullSecrets is an optional list of references to secrets in the same",
                        "namespace to use for pulling any of the images used by this PodSpec. If",
                        "specified, these secrets will be passed to individual puller implementations",
                        "for them to use. For example, in the case of docker, only DockerConfig type",
                        "secrets are honored. More info:",
                        "http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image_pull_secrets\" <$> TF.attribute",
                    "name": "_computedImagePullSecrets",
                    "method": "computedImagePullSecrets",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ImagePullSecretsSetting s)]",
                    "class": "HasComputedImagePullSecrets",
                    "validate": false,
                    "optional": false,
                    "original": "image_pull_secrets"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "NodeName is a request to schedule this pod onto a specific node. If it is",
                        "non-empty, the scheduler simply schedules this pod onto that node, assuming",
                        "that it fits resource requirements."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"node_name\" <$> TF.attribute",
                    "name": "_computedNodeName",
                    "method": "computedNodeName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedNodeName",
                    "validate": false,
                    "optional": false,
                    "original": "node_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "ServiceAccountName is the name of the ServiceAccount to use to run this pod.",
                        "More info: http://releases.k8s.io/HEAD/docs/design/service_accounts.md."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"service_account_name\" <$> TF.attribute",
                    "name": "_computedServiceAccountName",
                    "method": "computedServiceAccountName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedServiceAccountName",
                    "validate": false,
                    "optional": false,
                    "original": "service_account_name"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "TemplateSetting s",
            "original": "template"
        },
        {
            "con": {
                "smart": "valueFromSetting",
                "name": "ValueFromSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a key of a ConfigMap."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"config_map_key_ref\" <$> TF.attribute",
                    "name": "_configMapKeyRef",
                    "method": "configMapKeyRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ConfigMapKeyRefSetting s)",
                    "class": "HasConfigMapKeyRef",
                    "validate": true,
                    "optional": true,
                    "original": "config_map_key_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_ref\" <$> TF.attribute",
                    "name": "_fieldRef",
                    "method": "fieldRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (FieldRefSetting s)",
                    "class": "HasFieldRef",
                    "validate": true,
                    "optional": true,
                    "original": "field_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_field_ref\" <$> TF.attribute",
                    "name": "_resourceFieldRef",
                    "method": "resourceFieldRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ResourceFieldRefSetting s)",
                    "class": "HasResourceFieldRef",
                    "validate": true,
                    "optional": true,
                    "original": "resource_field_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_key_ref\" <$> TF.attribute",
                    "name": "_secretKeyRef",
                    "method": "secretKeyRef",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SecretKeyRefSetting s)",
                    "class": "HasSecretKeyRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_key_ref"
                }
            ],
            "key": "kubernetes_pod.spec.container.env.value_from",
            "name": "ValueFromSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ValueFromSetting s",
            "original": "value_from"
        },
        {
            "con": {
                "smart": "volumeSetting",
                "name": "VolumeSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an AWS Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"aws_elastic_block_store\" <$> TF.attribute",
                    "name": "_awsElasticBlockStore",
                    "method": "awsElasticBlockStore",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (AwsElasticBlockStoreSetting s)",
                    "class": "HasAwsElasticBlockStore",
                    "validate": true,
                    "optional": true,
                    "original": "aws_elastic_block_store"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure Data Disk mount on the host and bind mount to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_disk\" <$> TF.attribute",
                    "name": "_azureDisk",
                    "method": "azureDisk",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (AzureDiskSetting s)",
                    "class": "HasAzureDisk",
                    "validate": true,
                    "optional": true,
                    "original": "azure_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure File Service mount on the host and bind mount to the",
                        "pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_file\" <$> TF.attribute",
                    "name": "_azureFile",
                    "method": "azureFile",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (AzureFileSetting s)",
                    "class": "HasAzureFile",
                    "validate": true,
                    "optional": true,
                    "original": "azure_file"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Ceph FS mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_fs\" <$> TF.attribute",
                    "name": "_cephFs",
                    "method": "cephFs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (CephFsSetting s)",
                    "class": "HasCephFs",
                    "validate": true,
                    "optional": true,
                    "original": "ceph_fs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a cinder volume attached and mounted on kubelets host machine.",
                        "More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cinder\" <$> TF.attribute",
                    "name": "_cinder",
                    "method": "cinder",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (CinderSetting s)",
                    "class": "HasCinder",
                    "validate": true,
                    "optional": true,
                    "original": "cinder"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ConfigMap represents a configMap that should populate this volume"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"config_map\" <$> TF.attribute",
                    "name": "_configMap",
                    "method": "configMap",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (ConfigMapSetting s)",
                    "class": "HasConfigMap",
                    "validate": true,
                    "optional": true,
                    "original": "config_map"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "DownwardAPI represents downward API about the pod that should populate this",
                        "volume"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"downward_api\" <$> TF.attribute",
                    "name": "_downwardApi",
                    "method": "downwardApi",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (DownwardApiSetting s)",
                    "class": "HasDownwardApi",
                    "validate": true,
                    "optional": true,
                    "original": "downward_api"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "EmptyDir represents a temporary directory that shares a pod's lifetime. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#emptydir"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"empty_dir\" <$> TF.attribute",
                    "name": "_emptyDir",
                    "method": "emptyDir",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (EmptyDirSetting s)",
                    "class": "HasEmptyDir",
                    "validate": true,
                    "optional": true,
                    "original": "empty_dir"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Fibre Channel resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fc\" <$> TF.attribute",
                    "name": "_fc",
                    "method": "fc",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (FcSetting s)",
                    "class": "HasFc",
                    "validate": true,
                    "optional": true,
                    "original": "fc"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a generic volume resource that is provisioned/attached using an",
                        "exec based plugin. This is an alpha feature and may change in future."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flex_volume\" <$> TF.attribute",
                    "name": "_flexVolume",
                    "method": "flexVolume",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (FlexVolumeSetting s)",
                    "class": "HasFlexVolume",
                    "validate": true,
                    "optional": true,
                    "original": "flex_volume"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Flocker volume attached to a kubelet's host machine and exposed",
                        "to the pod for its usage. This depends on the Flocker control service being",
                        "running"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flocker\" <$> TF.attribute",
                    "name": "_flocker",
                    "method": "flocker",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (FlockerSetting s)",
                    "class": "HasFlocker",
                    "validate": true,
                    "optional": true,
                    "original": "flocker"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a GCE Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"gce_persistent_disk\" <$> TF.attribute",
                    "name": "_gcePersistentDisk",
                    "method": "gcePersistentDisk",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (GcePersistentDiskSetting s)",
                    "class": "HasGcePersistentDisk",
                    "validate": true,
                    "optional": true,
                    "original": "gce_persistent_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "GitRepo represents a git repository at a particular revision."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"git_repo\" <$> TF.attribute",
                    "name": "_gitRepo",
                    "method": "gitRepo",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (GitRepoSetting s)",
                    "class": "HasGitRepo",
                    "validate": true,
                    "optional": true,
                    "original": "git_repo"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Glusterfs volume that is attached to a host and exposed to the",
                        "pod. Provisioned by an admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"glusterfs\" <$> TF.attribute",
                    "name": "_glusterfs",
                    "method": "glusterfs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (GlusterfsSetting s)",
                    "class": "HasGlusterfs",
                    "validate": true,
                    "optional": true,
                    "original": "glusterfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a directory on the host. Provisioned by a developer or tester.",
                        "This is useful for single-node development and testing only! On-host storage",
                        "is not supported in any way and WILL NOT WORK in a multi-node cluster. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#hostpath"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_path\" <$> TF.attribute",
                    "name": "_hostPath",
                    "method": "hostPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (HostPathSetting s)",
                    "class": "HasHostPath",
                    "validate": true,
                    "optional": true,
                    "original": "host_path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an ISCSI Disk resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod. Provisioned by an admin."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi\" <$> TF.attribute",
                    "name": "_iscsi",
                    "method": "iscsi",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (IscsiSetting s)",
                    "class": "HasIscsi",
                    "validate": true,
                    "optional": true,
                    "original": "iscsi"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Volume's name. Must be a DNS_LABEL and unique within the pod. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an NFS mount on the host. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"nfs\" <$> TF.attribute",
                    "name": "_nfs",
                    "method": "nfs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (NfsSetting s)",
                    "class": "HasNfs",
                    "validate": true,
                    "optional": true,
                    "original": "nfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The specification of a persistent volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"persistent_volume_claim\" <$> TF.attribute",
                    "name": "_persistentVolumeClaim",
                    "method": "persistentVolumeClaim",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeClaimSetting s)",
                    "class": "HasPersistentVolumeClaim",
                    "validate": true,
                    "optional": true,
                    "original": "persistent_volume_claim"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a PhotonController persistent disk attached and mounted on",
                        "kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"photon_persistent_disk\" <$> TF.attribute",
                    "name": "_photonPersistentDisk",
                    "method": "photonPersistentDisk",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PhotonPersistentDiskSetting s)",
                    "class": "HasPhotonPersistentDisk",
                    "validate": true,
                    "optional": true,
                    "original": "photon_persistent_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Quobyte represents a Quobyte mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"quobyte\" <$> TF.attribute",
                    "name": "_quobyte",
                    "method": "quobyte",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (QuobyteSetting s)",
                    "class": "HasQuobyte",
                    "validate": true,
                    "optional": true,
                    "original": "quobyte"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Rados Block Device mount on the host that shares a pod's",
                        "lifetime. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd\" <$> TF.attribute",
                    "name": "_rbd",
                    "method": "rbd",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (RbdSetting s)",
                    "class": "HasRbd",
                    "validate": true,
                    "optional": true,
                    "original": "rbd"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Secret represents a secret that should populate this volume. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#secrets"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret\" <$> TF.attribute",
                    "name": "_secret",
                    "method": "secret",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SecretSetting s)",
                    "class": "HasSecret",
                    "validate": true,
                    "optional": true,
                    "original": "secret"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a vSphere volume attached and mounted on kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vsphere_volume\" <$> TF.attribute",
                    "name": "_vsphereVolume",
                    "method": "vsphereVolume",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (VsphereVolumeSetting s)",
                    "class": "HasVsphereVolume",
                    "validate": true,
                    "optional": true,
                    "original": "vsphere_volume"
                }
            ],
            "key": "kubernetes_pod.spec.volume",
            "name": "VolumeSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "VolumeSetting s",
            "original": "volume"
        },
        {
            "con": {
                "smart": "volumeMountSetting",
                "name": "VolumeMountSetting'"
            },
            "arguments": [
                {
                    "default": "_mountPath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path within the container at which the volume should be mounted. Must not",
                        "contain ':'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mount_path\" <$> TF.attribute",
                    "name": "_mountPath",
                    "method": "mountPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMountPath",
                    "validate": false,
                    "optional": false,
                    "original": "mount_path"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "This must match the Name of a Volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Mounted read-only if true, read-write otherwise (false or unspecified).",
                        "Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path within the volume from which the container's volume should be mounted.",
                        "Defaults to \"\" (volume's root)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sub_path\" <$> TF.attribute",
                    "name": "_subPath",
                    "method": "subPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSubPath",
                    "validate": false,
                    "optional": true,
                    "original": "sub_path"
                }
            ],
            "key": "kubernetes_pod.spec.container.volume_mount",
            "name": "VolumeMountSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "This must match the Name of a Volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "_mountPath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path within the container at which the volume should be mounted. Must not",
                        "contain ':'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mount_path\" <$> TF.attribute",
                    "name": "_mountPath",
                    "method": "mountPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMountPath",
                    "validate": false,
                    "optional": false,
                    "original": "mount_path"
                }
            ],
            "conflicts": [],
            "type": "VolumeMountSetting s",
            "original": "volume_mount"
        },
        {
            "con": {
                "smart": "vsphereVolumeSetting",
                "name": "VsphereVolumeSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_volumePath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that identifies vSphere volume vmdk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_path\" <$> TF.attribute",
                    "name": "_volumePath",
                    "method": "volumePath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumePath",
                    "validate": false,
                    "optional": false,
                    "original": "volume_path"
                }
            ],
            "key": "kubernetes_persistent_volume.spec.persistent_volume_source.vsphere_volume",
            "name": "VsphereVolumeSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumePath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that identifies vSphere volume vmdk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_path\" <$> TF.attribute",
                    "name": "_volumePath",
                    "method": "volumePath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumePath",
                    "validate": false,
                    "optional": false,
                    "original": "volume_path"
                }
            ],
            "conflicts": [],
            "type": "VsphereVolumeSetting s",
            "original": "vsphere_volume"
        }
    ],
    "url": "https://www.terraform.io/docs/providers/kubernetes/index.html",
    "dataSources": [
        {
            "con": {
                "smart": "serviceData",
                "name": "ServiceData'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/d/service.html",
            "key": "kubernetes_service",
            "name": "ServiceData",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_ingress\" <$> TF.attribute",
                    "name": "_computedLoadBalancerIngress",
                    "method": "computedLoadBalancerIngress",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (LoadBalancerIngressSetting s)]",
                    "class": "HasComputedLoadBalancerIngress",
                    "validate": false,
                    "optional": false,
                    "original": "load_balancer_ingress"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Spec defines the behavior of a service.",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_computedSpec",
                    "method": "computedSpec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SpecSetting s)",
                    "class": "HasComputedSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "ServiceData s",
            "original": "kubernetes_service"
        },
        {
            "con": {
                "smart": "storageClassData",
                "name": "StorageClassData'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard storage class's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/d/storage_class.html",
            "key": "kubernetes_storage_class",
            "name": "StorageClassData",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The parameters for the provisioner that should create volumes of this",
                        "storage class"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"parameters\" <$> TF.attribute",
                    "name": "_computedParameters",
                    "method": "computedParameters",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasComputedParameters",
                    "validate": false,
                    "optional": false,
                    "original": "parameters"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Indicates the type of the provisioner"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"storage_provisioner\" <$> TF.attribute",
                    "name": "_computedStorageProvisioner",
                    "method": "computedStorageProvisioner",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedStorageProvisioner",
                    "validate": false,
                    "optional": false,
                    "original": "storage_provisioner"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard storage class's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "StorageClassData s",
            "original": "kubernetes_storage_class"
        }
    ],
    "resources": [
        {
            "con": {
                "smart": "configMapResource",
                "name": "ConfigMapResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A map of the configuration data."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data\" <$> TF.attribute",
                    "name": "_data'",
                    "method": "data'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasData'",
                    "validate": false,
                    "optional": true,
                    "original": "data"
                },
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard config map's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/config_map.html",
            "key": "kubernetes_config_map",
            "name": "ConfigMapResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard config map's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "ConfigMapResource s",
            "original": "kubernetes_config_map"
        },
        {
            "con": {
                "smart": "horizontalPodAutoscalerResource",
                "name": "HorizontalPodAutoscalerResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard horizontal pod autoscaler's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Behaviour of the autoscaler. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/horizontal_pod_autoscaler.html",
            "key": "kubernetes_horizontal_pod_autoscaler",
            "name": "HorizontalPodAutoscalerResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard horizontal pod autoscaler's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Behaviour of the autoscaler. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "HorizontalPodAutoscalerResource s",
            "original": "kubernetes_horizontal_pod_autoscaler"
        },
        {
            "con": {
                "smart": "limitRangeResource",
                "name": "LimitRangeResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard limit range's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Spec defines the limits enforced. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": true,
                    "original": "spec"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/limit_range.html",
            "key": "kubernetes_limit_range",
            "name": "LimitRangeResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard limit range's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "LimitRangeResource s",
            "original": "kubernetes_limit_range"
        },
        {
            "con": {
                "smart": "namespaceResource",
                "name": "NamespaceResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard namespace's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/namespace.html",
            "key": "kubernetes_namespace",
            "name": "NamespaceResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard namespace's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "NamespaceResource s",
            "original": "kubernetes_namespace"
        },
        {
            "con": {
                "smart": "persistentVolumeResource",
                "name": "PersistentVolumeResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard persistent volume's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec of the persistent volume owned by the cluster"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (SpecSetting s)]",
                    "class": "HasSpec",
                    "validate": false,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/persistent_volume.html",
            "key": "kubernetes_persistent_volume",
            "name": "PersistentVolumeResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard persistent volume's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec of the persistent volume owned by the cluster"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (SpecSetting s)]",
                    "class": "HasSpec",
                    "validate": false,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeResource s",
            "original": "kubernetes_persistent_volume"
        },
        {
            "con": {
                "smart": "persistentVolumeClaimResource",
                "name": "PersistentVolumeClaimResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard persistent volume claim's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the desired characteristics of a volume requested by a pod",
                        "author. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#persistentvolumeclaims"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to wait for the claim to reach `Bound` state (to find volume in",
                        "which to claim the space)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"wait_until_bound\" <$> TF.attribute",
                    "name": "_waitUntilBound",
                    "method": "waitUntilBound",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasWaitUntilBound",
                    "validate": false,
                    "optional": true,
                    "original": "wait_until_bound"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/persistent_volume_claim.html",
            "key": "kubernetes_persistent_volume_claim",
            "name": "PersistentVolumeClaimResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard persistent volume claim's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the desired characteristics of a volume requested by a pod",
                        "author. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#persistentvolumeclaims"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeClaimResource s",
            "original": "kubernetes_persistent_volume_claim"
        },
        {
            "con": {
                "smart": "podResource",
                "name": "PodResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard pod's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec of the pod owned by the cluster"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/pod.html",
            "key": "kubernetes_pod",
            "name": "PodResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard pod's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec of the pod owned by the cluster"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "PodResource s",
            "original": "kubernetes_pod"
        },
        {
            "con": {
                "smart": "replicationControllerResource",
                "name": "ReplicationControllerResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard replication controller's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the specification of the desired behavior of the replication",
                        "controller. More info:",
                        "http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/replication_controller.html",
            "key": "kubernetes_replication_controller",
            "name": "ReplicationControllerResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard replication controller's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the specification of the desired behavior of the replication",
                        "controller. More info:",
                        "http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerResource s",
            "original": "kubernetes_replication_controller"
        },
        {
            "con": {
                "smart": "resourceQuotaResource",
                "name": "ResourceQuotaResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard resource quota's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Spec defines the desired quota.",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": true,
                    "original": "spec"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/resource_quota.html",
            "key": "kubernetes_resource_quota",
            "name": "ResourceQuotaResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard resource quota's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "ResourceQuotaResource s",
            "original": "kubernetes_resource_quota"
        },
        {
            "con": {
                "smart": "secretResource",
                "name": "SecretResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A map of the secret data."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data\" <$> TF.attribute",
                    "name": "_data'",
                    "method": "data'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasData'",
                    "validate": false,
                    "optional": true,
                    "original": "data"
                },
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard secret's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "TF.value \"Opaque\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Type of secret"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": true,
                    "original": "type"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/secret.html",
            "key": "kubernetes_secret",
            "name": "SecretResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard secret's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "SecretResource s",
            "original": "kubernetes_secret"
        },
        {
            "con": {
                "smart": "serviceResource",
                "name": "ServiceResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the behavior of a service.",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/service.html",
            "key": "kubernetes_service",
            "name": "ServiceResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_ingress\" <$> TF.attribute",
                    "name": "_computedLoadBalancerIngress",
                    "method": "computedLoadBalancerIngress",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (LoadBalancerIngressSetting s)]",
                    "class": "HasComputedLoadBalancerIngress",
                    "validate": false,
                    "optional": false,
                    "original": "load_balancer_ingress"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the behavior of a service.",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (SpecSetting s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "ServiceResource s",
            "original": "kubernetes_service"
        },
        {
            "con": {
                "smart": "serviceAccountResource",
                "name": "ServiceAccountResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of references to secrets in the same namespace to use for pulling any",
                        "images in pods that reference this Service Account. More info:",
                        "http://kubernetes.io/docs/user-guide/secrets#manually-specifying-an-imagepullsecret"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image_pull_secret\" <$> TF.attribute",
                    "name": "_imagePullSecret",
                    "method": "imagePullSecret",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ImagePullSecretSetting s)]",
                    "class": "HasImagePullSecret",
                    "validate": false,
                    "optional": true,
                    "original": "image_pull_secret"
                },
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service account's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of secrets allowed to be used by pods running using this Service",
                        "Account. More info: http://kubernetes.io/docs/user-guide/secrets"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret\" <$> TF.attribute",
                    "name": "_secret",
                    "method": "secret",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (SecretSetting s)]",
                    "class": "HasSecret",
                    "validate": false,
                    "optional": true,
                    "original": "secret"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/service_account.html",
            "key": "kubernetes_service_account",
            "name": "ServiceAccountResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_secret_name\" <$> TF.attribute",
                    "name": "_computedDefaultSecretName",
                    "method": "computedDefaultSecretName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedDefaultSecretName",
                    "validate": false,
                    "optional": false,
                    "original": "default_secret_name"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service account's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "ServiceAccountResource s",
            "original": "kubernetes_service_account"
        },
        {
            "con": {
                "smart": "storageClassResource",
                "name": "StorageClassResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard storage class's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The parameters for the provisioner that should create volumes of this",
                        "storage class"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"parameters\" <$> TF.attribute",
                    "name": "_parameters",
                    "method": "parameters",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasParameters",
                    "validate": false,
                    "optional": true,
                    "original": "parameters"
                },
                {
                    "default": "_storageProvisioner",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Indicates the type of the provisioner"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"storage_provisioner\" <$> TF.attribute",
                    "name": "_storageProvisioner",
                    "method": "storageProvisioner",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasStorageProvisioner",
                    "validate": false,
                    "optional": false,
                    "original": "storage_provisioner"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/kubernetes/r/storage_class.html",
            "key": "kubernetes_storage_class",
            "name": "StorageClassResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard storage class's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (MetadataSetting s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_storageProvisioner",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Indicates the type of the provisioner"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"storage_provisioner\" <$> TF.attribute",
                    "name": "_storageProvisioner",
                    "method": "storageProvisioner",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasStorageProvisioner",
                    "validate": false,
                    "optional": false,
                    "original": "storage_provisioner"
                }
            ],
            "conflicts": [],
            "type": "StorageClassResource s",
            "original": "kubernetes_storage_class"
        }
    ],
    "schema": {
        "con": {
            "smart": "newProvider",
            "name": "Provider'"
        },
        "arguments": [
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "PEM-encoded client certificate for TLS authentication."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"client_certificate\" <$>",
                "name": "_clientCertificate",
                "method": "clientCertificate",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasClientCertificate",
                "validate": false,
                "optional": true,
                "original": "client_certificate"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "PEM-encoded client certificate key for TLS authentication."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"client_key\" <$>",
                "name": "_clientKey",
                "method": "clientKey",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasClientKey",
                "validate": false,
                "optional": true,
                "original": "client_key"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "PEM-encoded root certificates bundle for TLS authentication."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"cluster_ca_certificate\" <$>",
                "name": "_clusterCaCertificate",
                "method": "clusterCaCertificate",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasClusterCaCertificate",
                "validate": false,
                "optional": true,
                "original": "cluster_ca_certificate"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [],
                "forceNew": false,
                "encoder": "TF.assign \"config_context\" <$>",
                "name": "_configContext",
                "method": "configContext",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasConfigContext",
                "validate": false,
                "optional": true,
                "original": "config_context"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [],
                "forceNew": false,
                "encoder": "TF.assign \"config_context_auth_info\" <$>",
                "name": "_configContextAuthInfo",
                "method": "configContextAuthInfo",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasConfigContextAuthInfo",
                "validate": false,
                "optional": true,
                "original": "config_context_auth_info"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [],
                "forceNew": false,
                "encoder": "TF.assign \"config_context_cluster\" <$>",
                "name": "_configContextCluster",
                "method": "configContextCluster",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasConfigContextCluster",
                "validate": false,
                "optional": true,
                "original": "config_context_cluster"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "Path to the kube config file, defaults to ~/.kube/config"
                ],
                "forceNew": false,
                "encoder": "TF.assign \"config_path\" <$>",
                "name": "_configPath",
                "method": "configPath",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasConfigPath",
                "validate": false,
                "optional": true,
                "original": "config_path"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "The hostname (in form of URI) of Kubernetes master."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"host\" <$>",
                "name": "_host",
                "method": "host",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasHost",
                "validate": false,
                "optional": true,
                "original": "host"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "Whether server should be accessed without verifying the TLS certificate."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"insecure\" <$>",
                "name": "_insecure",
                "method": "insecure",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Bool",
                "class": "HasInsecure",
                "validate": false,
                "optional": true,
                "original": "insecure"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "Load local kubeconfig."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"load_config_file\" <$>",
                "name": "_loadConfigFile",
                "method": "loadConfigFile",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Bool",
                "class": "HasLoadConfigFile",
                "validate": false,
                "optional": true,
                "original": "load_config_file"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "The password to use for HTTP basic authentication when accessing the",
                    "Kubernetes master endpoint."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"password\" <$>",
                "name": "_password",
                "method": "password",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasPassword",
                "validate": false,
                "optional": true,
                "original": "password"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "Token to authentifcate an service account"
                ],
                "forceNew": false,
                "encoder": "TF.assign \"token\" <$>",
                "name": "_token",
                "method": "token",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasToken",
                "validate": false,
                "optional": true,
                "original": "token"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "The username to use for HTTP basic authentication when accessing the",
                    "Kubernetes master endpoint."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"username\" <$>",
                "name": "_username",
                "method": "username",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasUsername",
                "validate": false,
                "optional": true,
                "original": "username"
            }
        ],
        "key": "provider",
        "name": "Provider",
        "threaded": false,
        "attributes": [],
        "parameters": [],
        "conflicts": [],
        "type": "Provider",
        "original": "provider"
    },
    "dependencies": [
        "aeson",
        "base",
        "containers",
        "microlens",
        "terrafomo",
        "text"
    ],
    "name": "Kubernetes",
    "package": "terrafomo-kubernetes",
    "primitives": [],
    "original": "kubernetes"
}