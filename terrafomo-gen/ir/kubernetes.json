{
    "settings": [
        {
            "con": {
                "smart": "newCephFs",
                "name": "CephFs'"
            },
            "arguments": [
                {
                    "default": "_monitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Monitors is a collection of Ceph monitors More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"monitors\" <$> TF.attribute",
                    "name": "_monitors",
                    "method": "monitors",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "monitors"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Used as the mounted root, rather than the full Ceph tree, default is /"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to `false`",
                        "(read/write). More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The path to key ring for User, default is /etc/ceph/user.secret More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_file\" <$> TF.attribute",
                    "name": "_secretFile",
                    "method": "secretFile",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretFile",
                    "validate": false,
                    "optional": true,
                    "original": "secret_file"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Reference to the authentication secret for User, default is empty. More",
                        "info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "_secretRef",
                    "method": "secretRef",
                    "conflicts": [],
                    "type": "TF.Attr s (SecretRef s)",
                    "class": "HasSecretRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User is the rados user name, default is admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "_user",
                    "method": "user",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "validate": false,
                    "optional": true,
                    "original": "user"
                }
            ],
            "name": "CephFs",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_monitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Monitors is a collection of Ceph monitors More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"monitors\" <$> TF.attribute",
                    "name": "_monitors",
                    "method": "monitors",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "monitors"
                }
            ],
            "conflicts": [],
            "type": "CephFs s",
            "original": "ceph_fs"
        },
        {
            "con": {
                "smart": "newImagePullSecret",
                "name": "ImagePullSecret'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "name": "ImagePullSecret",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ImagePullSecret s",
            "original": "image_pull_secret"
        },
        {
            "con": {
                "smart": "newCinder",
                "name": "Cinder'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write). More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume ID used to identify the volume in Cinder. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "name": "Cinder",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume ID used to identify the volume in Cinder. More info:",
                        "http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "conflicts": [],
            "type": "Cinder s",
            "original": "cinder"
        },
        {
            "con": {
                "smart": "newPostStart",
                "name": "PostStart'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "conflicts": [],
                    "type": "TF.Attr s (Exec s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "conflicts": [],
                    "type": "TF.Attr s (HttpGet s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TcpSocket s)]",
                    "class": "HasTcpSocket",
                    "validate": true,
                    "optional": true,
                    "original": "tcp_socket"
                }
            ],
            "name": "PostStart",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PostStart s",
            "original": "post_start"
        },
        {
            "con": {
                "smart": "newHostPath",
                "name": "HostPath'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path of the directory on the host. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#hostpath"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                }
            ],
            "name": "HostPath",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "HostPath s",
            "original": "host_path"
        },
        {
            "con": {
                "smart": "newFlocker",
                "name": "Flocker'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the dataset stored as metadata -> name on the dataset for Flocker",
                        "should be considered as deprecated"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dataset_name\" <$> TF.attribute",
                    "name": "_datasetName",
                    "method": "datasetName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatasetName",
                    "validate": false,
                    "optional": true,
                    "original": "dataset_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "UUID of the dataset. This is unique identifier of a Flocker dataset"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dataset_uuid\" <$> TF.attribute",
                    "name": "_datasetUuid",
                    "method": "datasetUuid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatasetUuid",
                    "validate": false,
                    "optional": true,
                    "original": "dataset_uuid"
                }
            ],
            "name": "Flocker",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "Flocker s",
            "original": "flocker"
        },
        {
            "con": {
                "smart": "newReadinessProbe",
                "name": "ReadinessProbe'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "conflicts": [],
                    "type": "TF.Attr s (Exec s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive failures for the probe to be considered failed after",
                        "having succeeded."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failure_threshold\" <$> TF.attribute",
                    "name": "_failureThreshold",
                    "method": "failureThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasFailureThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "failure_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "conflicts": [],
                    "type": "TF.Attr s (HttpGet s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after the container has started before liveness probes are",
                        "initiated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"initial_delay_seconds\" <$> TF.attribute",
                    "name": "_initialDelaySeconds",
                    "method": "initialDelaySeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasInitialDelaySeconds",
                    "validate": false,
                    "optional": true,
                    "original": "initial_delay_seconds"
                },
                {
                    "default": "TF.value 10",
                    "computed": false,
                    "required": false,
                    "help": [
                        "How often (in seconds) to perform the probe"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"period_seconds\" <$> TF.attribute",
                    "name": "_periodSeconds",
                    "method": "periodSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasPeriodSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "period_seconds"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive successes for the probe to be considered successful",
                        "after having failed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"success_threshold\" <$> TF.attribute",
                    "name": "_successThreshold",
                    "method": "successThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasSuccessThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "success_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TcpSocket s)]",
                    "class": "HasTcpSocket",
                    "validate": true,
                    "optional": true,
                    "original": "tcp_socket"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after which the probe times out. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"timeout_seconds\" <$> TF.attribute",
                    "name": "_timeoutSeconds",
                    "method": "timeoutSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasTimeoutSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "timeout_seconds"
                }
            ],
            "name": "ReadinessProbe",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ReadinessProbe s",
            "original": "readiness_probe"
        },
        {
            "con": {
                "smart": "newEmptyDir",
                "name": "EmptyDir'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "What type of storage medium should back this directory. The default is \"\"",
                        "which means to use the node's default medium. Must be an empty string",
                        "(default) or Memory. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#emptydir"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"medium\" <$> TF.attribute",
                    "name": "_medium",
                    "method": "medium",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMedium",
                    "validate": false,
                    "optional": true,
                    "original": "medium"
                }
            ],
            "name": "EmptyDir",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "EmptyDir s",
            "original": "empty_dir"
        },
        {
            "con": {
                "smart": "newEnv",
                "name": "Env'"
            },
            "arguments": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the environment variable. Must be a C_IDENTIFIER"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Variable references $(VAR_NAME) are expanded using the previous defined",
                        "environment variables in the container and any service environment",
                        "variables. If a variable cannot be resolved, the reference in the input",
                        "string will be unchanged. The $(VAR_NAME) syntax can be escaped with a",
                        "double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,",
                        "regardless of whether the variable exists or not. Defaults to \"\"."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Source for the environment variable's value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value_from\" <$> TF.attribute",
                    "name": "_valueFrom",
                    "method": "valueFrom",
                    "conflicts": [],
                    "type": "TF.Attr s (ValueFrom s)",
                    "class": "HasValueFrom",
                    "validate": true,
                    "optional": true,
                    "original": "value_from"
                }
            ],
            "name": "Env",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the environment variable. Must be a C_IDENTIFIER"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "Env s",
            "original": "env"
        },
        {
            "con": {
                "smart": "newSelector",
                "name": "Selector'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of label selector requirements. The requirements are ANDed."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"match_expressions\" <$> TF.attribute",
                    "name": "_matchExpressions",
                    "method": "matchExpressions",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (MatchExpressions s)]",
                    "class": "HasMatchExpressions",
                    "validate": true,
                    "optional": true,
                    "original": "match_expressions"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A map of {key,value} pairs. A single {key,value} in the matchLabels map is",
                        "equivalent to an element of `match_expressions`, whose key field is \"key\",",
                        "the operator is \"In\", and the values array contains only \"value\". The",
                        "requirements are ANDed."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"match_labels\" <$> TF.attribute",
                    "name": "_matchLabels",
                    "method": "matchLabels",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasMatchLabels",
                    "validate": false,
                    "optional": true,
                    "original": "match_labels"
                }
            ],
            "name": "Selector",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "Selector s",
            "original": "selector"
        },
        {
            "con": {
                "smart": "newDownwardApi",
                "name": "DownwardApi'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on created files by default. Must be a value",
                        "between 0 and 0777. Defaults to 0644. Directories within the path are not",
                        "affected by this setting. This might be in conflict with other options that",
                        "affect the file mode, like fsGroup, and the result can be other mode bits",
                        "set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_mode\" <$> TF.attribute",
                    "name": "_defaultMode",
                    "method": "defaultMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasDefaultMode",
                    "validate": false,
                    "optional": true,
                    "original": "default_mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If unspecified, each key-value pair in the Data field of the referenced",
                        "ConfigMap will be projected into the volume as a file whose name is the key",
                        "and content is the value. If specified, the listed keys will be projected",
                        "into the specified paths, and unlisted keys will not be present. If a key is",
                        "specified which is not present in the ConfigMap, the volume setup will",
                        "error. Paths must be relative and may not contain the '..' path or start",
                        "with '..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"items\" <$> TF.attribute",
                    "name": "_items",
                    "method": "items",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (Items s)]",
                    "class": "HasItems",
                    "validate": true,
                    "optional": true,
                    "original": "items"
                }
            ],
            "name": "DownwardApi",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "DownwardApi s",
            "original": "downward_api"
        },
        {
            "con": {
                "smart": "newPersistentVolumeSource",
                "name": "PersistentVolumeSource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an AWS Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"aws_elastic_block_store\" <$> TF.attribute",
                    "name": "_awsElasticBlockStore",
                    "method": "awsElasticBlockStore",
                    "conflicts": [],
                    "type": "TF.Attr s (AwsElasticBlockStore s)",
                    "class": "HasAwsElasticBlockStore",
                    "validate": true,
                    "optional": true,
                    "original": "aws_elastic_block_store"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure Data Disk mount on the host and bind mount to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_disk\" <$> TF.attribute",
                    "name": "_azureDisk",
                    "method": "azureDisk",
                    "conflicts": [],
                    "type": "TF.Attr s (AzureDisk s)",
                    "class": "HasAzureDisk",
                    "validate": true,
                    "optional": true,
                    "original": "azure_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure File Service mount on the host and bind mount to the",
                        "pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_file\" <$> TF.attribute",
                    "name": "_azureFile",
                    "method": "azureFile",
                    "conflicts": [],
                    "type": "TF.Attr s (AzureFile s)",
                    "class": "HasAzureFile",
                    "validate": true,
                    "optional": true,
                    "original": "azure_file"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Ceph FS mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_fs\" <$> TF.attribute",
                    "name": "_cephFs",
                    "method": "cephFs",
                    "conflicts": [],
                    "type": "TF.Attr s (CephFs s)",
                    "class": "HasCephFs",
                    "validate": true,
                    "optional": true,
                    "original": "ceph_fs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a cinder volume attached and mounted on kubelets host machine.",
                        "More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cinder\" <$> TF.attribute",
                    "name": "_cinder",
                    "method": "cinder",
                    "conflicts": [],
                    "type": "TF.Attr s (Cinder s)",
                    "class": "HasCinder",
                    "validate": true,
                    "optional": true,
                    "original": "cinder"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Fibre Channel resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fc\" <$> TF.attribute",
                    "name": "_fc",
                    "method": "fc",
                    "conflicts": [],
                    "type": "TF.Attr s (Fc s)",
                    "class": "HasFc",
                    "validate": true,
                    "optional": true,
                    "original": "fc"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a generic volume resource that is provisioned/attached using an",
                        "exec based plugin. This is an alpha feature and may change in future."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flex_volume\" <$> TF.attribute",
                    "name": "_flexVolume",
                    "method": "flexVolume",
                    "conflicts": [],
                    "type": "TF.Attr s (FlexVolume s)",
                    "class": "HasFlexVolume",
                    "validate": true,
                    "optional": true,
                    "original": "flex_volume"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Flocker volume attached to a kubelet's host machine and exposed",
                        "to the pod for its usage. This depends on the Flocker control service being",
                        "running"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flocker\" <$> TF.attribute",
                    "name": "_flocker",
                    "method": "flocker",
                    "conflicts": [],
                    "type": "TF.Attr s (Flocker s)",
                    "class": "HasFlocker",
                    "validate": true,
                    "optional": true,
                    "original": "flocker"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a GCE Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"gce_persistent_disk\" <$> TF.attribute",
                    "name": "_gcePersistentDisk",
                    "method": "gcePersistentDisk",
                    "conflicts": [],
                    "type": "TF.Attr s (GcePersistentDisk s)",
                    "class": "HasGcePersistentDisk",
                    "validate": true,
                    "optional": true,
                    "original": "gce_persistent_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Glusterfs volume that is attached to a host and exposed to the",
                        "pod. Provisioned by an admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"glusterfs\" <$> TF.attribute",
                    "name": "_glusterfs",
                    "method": "glusterfs",
                    "conflicts": [],
                    "type": "TF.Attr s (Glusterfs s)",
                    "class": "HasGlusterfs",
                    "validate": true,
                    "optional": true,
                    "original": "glusterfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a directory on the host. Provisioned by a developer or tester.",
                        "This is useful for single-node development and testing only! On-host storage",
                        "is not supported in any way and WILL NOT WORK in a multi-node cluster. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#hostpath"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_path\" <$> TF.attribute",
                    "name": "_hostPath",
                    "method": "hostPath",
                    "conflicts": [],
                    "type": "TF.Attr s (HostPath s)",
                    "class": "HasHostPath",
                    "validate": true,
                    "optional": true,
                    "original": "host_path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an ISCSI Disk resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod. Provisioned by an admin."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi\" <$> TF.attribute",
                    "name": "_iscsi",
                    "method": "iscsi",
                    "conflicts": [],
                    "type": "TF.Attr s (Iscsi s)",
                    "class": "HasIscsi",
                    "validate": true,
                    "optional": true,
                    "original": "iscsi"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an NFS mount on the host. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"nfs\" <$> TF.attribute",
                    "name": "_nfs",
                    "method": "nfs",
                    "conflicts": [],
                    "type": "TF.Attr s (Nfs s)",
                    "class": "HasNfs",
                    "validate": true,
                    "optional": true,
                    "original": "nfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a PhotonController persistent disk attached and mounted on",
                        "kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"photon_persistent_disk\" <$> TF.attribute",
                    "name": "_photonPersistentDisk",
                    "method": "photonPersistentDisk",
                    "conflicts": [],
                    "type": "TF.Attr s (PhotonPersistentDisk s)",
                    "class": "HasPhotonPersistentDisk",
                    "validate": true,
                    "optional": true,
                    "original": "photon_persistent_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Quobyte represents a Quobyte mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"quobyte\" <$> TF.attribute",
                    "name": "_quobyte",
                    "method": "quobyte",
                    "conflicts": [],
                    "type": "TF.Attr s (Quobyte s)",
                    "class": "HasQuobyte",
                    "validate": true,
                    "optional": true,
                    "original": "quobyte"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Rados Block Device mount on the host that shares a pod's",
                        "lifetime. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd\" <$> TF.attribute",
                    "name": "_rbd",
                    "method": "rbd",
                    "conflicts": [],
                    "type": "TF.Attr s (Rbd s)",
                    "class": "HasRbd",
                    "validate": true,
                    "optional": true,
                    "original": "rbd"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a vSphere volume attached and mounted on kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vsphere_volume\" <$> TF.attribute",
                    "name": "_vsphereVolume",
                    "method": "vsphereVolume",
                    "conflicts": [],
                    "type": "TF.Attr s (VsphereVolume s)",
                    "class": "HasVsphereVolume",
                    "validate": true,
                    "optional": true,
                    "original": "vsphere_volume"
                }
            ],
            "name": "PersistentVolumeSource",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PersistentVolumeSource s",
            "original": "persistent_volume_source"
        },
        {
            "con": {
                "smart": "newVsphereVolume",
                "name": "VsphereVolume'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_volumePath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that identifies vSphere volume vmdk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_path\" <$> TF.attribute",
                    "name": "_volumePath",
                    "method": "volumePath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumePath",
                    "validate": false,
                    "optional": false,
                    "original": "volume_path"
                }
            ],
            "name": "VsphereVolume",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumePath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that identifies vSphere volume vmdk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_path\" <$> TF.attribute",
                    "name": "_volumePath",
                    "method": "volumePath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumePath",
                    "validate": false,
                    "optional": false,
                    "original": "volume_path"
                }
            ],
            "conflicts": [],
            "type": "VsphereVolume s",
            "original": "vsphere_volume"
        },
        {
            "con": {
                "smart": "newSecretRef",
                "name": "SecretRef'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "name": "SecretRef",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "SecretRef s",
            "original": "secret_ref"
        },
        {
            "con": {
                "smart": "newVolume",
                "name": "Volume'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an AWS Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"aws_elastic_block_store\" <$> TF.attribute",
                    "name": "_awsElasticBlockStore",
                    "method": "awsElasticBlockStore",
                    "conflicts": [],
                    "type": "TF.Attr s (AwsElasticBlockStore s)",
                    "class": "HasAwsElasticBlockStore",
                    "validate": true,
                    "optional": true,
                    "original": "aws_elastic_block_store"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure Data Disk mount on the host and bind mount to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_disk\" <$> TF.attribute",
                    "name": "_azureDisk",
                    "method": "azureDisk",
                    "conflicts": [],
                    "type": "TF.Attr s (AzureDisk s)",
                    "class": "HasAzureDisk",
                    "validate": true,
                    "optional": true,
                    "original": "azure_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an Azure File Service mount on the host and bind mount to the",
                        "pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"azure_file\" <$> TF.attribute",
                    "name": "_azureFile",
                    "method": "azureFile",
                    "conflicts": [],
                    "type": "TF.Attr s (AzureFile s)",
                    "class": "HasAzureFile",
                    "validate": true,
                    "optional": true,
                    "original": "azure_file"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Ceph FS mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_fs\" <$> TF.attribute",
                    "name": "_cephFs",
                    "method": "cephFs",
                    "conflicts": [],
                    "type": "TF.Attr s (CephFs s)",
                    "class": "HasCephFs",
                    "validate": true,
                    "optional": true,
                    "original": "ceph_fs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a cinder volume attached and mounted on kubelets host machine.",
                        "More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cinder\" <$> TF.attribute",
                    "name": "_cinder",
                    "method": "cinder",
                    "conflicts": [],
                    "type": "TF.Attr s (Cinder s)",
                    "class": "HasCinder",
                    "validate": true,
                    "optional": true,
                    "original": "cinder"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ConfigMap represents a configMap that should populate this volume"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"config_map\" <$> TF.attribute",
                    "name": "_configMap",
                    "method": "configMap",
                    "conflicts": [],
                    "type": "TF.Attr s (ConfigMap s)",
                    "class": "HasConfigMap",
                    "validate": true,
                    "optional": true,
                    "original": "config_map"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "DownwardAPI represents downward API about the pod that should populate this",
                        "volume"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"downward_api\" <$> TF.attribute",
                    "name": "_downwardApi",
                    "method": "downwardApi",
                    "conflicts": [],
                    "type": "TF.Attr s (DownwardApi s)",
                    "class": "HasDownwardApi",
                    "validate": true,
                    "optional": true,
                    "original": "downward_api"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "EmptyDir represents a temporary directory that shares a pod's lifetime. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#emptydir"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"empty_dir\" <$> TF.attribute",
                    "name": "_emptyDir",
                    "method": "emptyDir",
                    "conflicts": [],
                    "type": "TF.Attr s (EmptyDir s)",
                    "class": "HasEmptyDir",
                    "validate": true,
                    "optional": true,
                    "original": "empty_dir"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Fibre Channel resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fc\" <$> TF.attribute",
                    "name": "_fc",
                    "method": "fc",
                    "conflicts": [],
                    "type": "TF.Attr s (Fc s)",
                    "class": "HasFc",
                    "validate": true,
                    "optional": true,
                    "original": "fc"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a generic volume resource that is provisioned/attached using an",
                        "exec based plugin. This is an alpha feature and may change in future."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flex_volume\" <$> TF.attribute",
                    "name": "_flexVolume",
                    "method": "flexVolume",
                    "conflicts": [],
                    "type": "TF.Attr s (FlexVolume s)",
                    "class": "HasFlexVolume",
                    "validate": true,
                    "optional": true,
                    "original": "flex_volume"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Flocker volume attached to a kubelet's host machine and exposed",
                        "to the pod for its usage. This depends on the Flocker control service being",
                        "running"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"flocker\" <$> TF.attribute",
                    "name": "_flocker",
                    "method": "flocker",
                    "conflicts": [],
                    "type": "TF.Attr s (Flocker s)",
                    "class": "HasFlocker",
                    "validate": true,
                    "optional": true,
                    "original": "flocker"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a GCE Disk resource that is attached to a kubelet's host machine",
                        "and then exposed to the pod. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"gce_persistent_disk\" <$> TF.attribute",
                    "name": "_gcePersistentDisk",
                    "method": "gcePersistentDisk",
                    "conflicts": [],
                    "type": "TF.Attr s (GcePersistentDisk s)",
                    "class": "HasGcePersistentDisk",
                    "validate": true,
                    "optional": true,
                    "original": "gce_persistent_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "GitRepo represents a git repository at a particular revision."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"git_repo\" <$> TF.attribute",
                    "name": "_gitRepo",
                    "method": "gitRepo",
                    "conflicts": [],
                    "type": "TF.Attr s (GitRepo s)",
                    "class": "HasGitRepo",
                    "validate": true,
                    "optional": true,
                    "original": "git_repo"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Glusterfs volume that is attached to a host and exposed to the",
                        "pod. Provisioned by an admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"glusterfs\" <$> TF.attribute",
                    "name": "_glusterfs",
                    "method": "glusterfs",
                    "conflicts": [],
                    "type": "TF.Attr s (Glusterfs s)",
                    "class": "HasGlusterfs",
                    "validate": true,
                    "optional": true,
                    "original": "glusterfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a directory on the host. Provisioned by a developer or tester.",
                        "This is useful for single-node development and testing only! On-host storage",
                        "is not supported in any way and WILL NOT WORK in a multi-node cluster. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#hostpath"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_path\" <$> TF.attribute",
                    "name": "_hostPath",
                    "method": "hostPath",
                    "conflicts": [],
                    "type": "TF.Attr s (HostPath s)",
                    "class": "HasHostPath",
                    "validate": true,
                    "optional": true,
                    "original": "host_path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an ISCSI Disk resource that is attached to a kubelet's host",
                        "machine and then exposed to the pod. Provisioned by an admin."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi\" <$> TF.attribute",
                    "name": "_iscsi",
                    "method": "iscsi",
                    "conflicts": [],
                    "type": "TF.Attr s (Iscsi s)",
                    "class": "HasIscsi",
                    "validate": true,
                    "optional": true,
                    "original": "iscsi"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Volume's name. Must be a DNS_LABEL and unique within the pod. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents an NFS mount on the host. Provisioned by an admin. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"nfs\" <$> TF.attribute",
                    "name": "_nfs",
                    "method": "nfs",
                    "conflicts": [],
                    "type": "TF.Attr s (Nfs s)",
                    "class": "HasNfs",
                    "validate": true,
                    "optional": true,
                    "original": "nfs"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The specification of a persistent volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"persistent_volume_claim\" <$> TF.attribute",
                    "name": "_persistentVolumeClaim",
                    "method": "persistentVolumeClaim",
                    "conflicts": [],
                    "type": "TF.Attr s (PersistentVolumeClaim s)",
                    "class": "HasPersistentVolumeClaim",
                    "validate": true,
                    "optional": true,
                    "original": "persistent_volume_claim"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a PhotonController persistent disk attached and mounted on",
                        "kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"photon_persistent_disk\" <$> TF.attribute",
                    "name": "_photonPersistentDisk",
                    "method": "photonPersistentDisk",
                    "conflicts": [],
                    "type": "TF.Attr s (PhotonPersistentDisk s)",
                    "class": "HasPhotonPersistentDisk",
                    "validate": true,
                    "optional": true,
                    "original": "photon_persistent_disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Quobyte represents a Quobyte mount on the host that shares a pod's lifetime"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"quobyte\" <$> TF.attribute",
                    "name": "_quobyte",
                    "method": "quobyte",
                    "conflicts": [],
                    "type": "TF.Attr s (Quobyte s)",
                    "class": "HasQuobyte",
                    "validate": true,
                    "optional": true,
                    "original": "quobyte"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a Rados Block Device mount on the host that shares a pod's",
                        "lifetime. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd\" <$> TF.attribute",
                    "name": "_rbd",
                    "method": "rbd",
                    "conflicts": [],
                    "type": "TF.Attr s (Rbd s)",
                    "class": "HasRbd",
                    "validate": true,
                    "optional": true,
                    "original": "rbd"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Secret represents a secret that should populate this volume. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#secrets"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret\" <$> TF.attribute",
                    "name": "_secret",
                    "method": "secret",
                    "conflicts": [],
                    "type": "TF.Attr s (Secret s)",
                    "class": "HasSecret",
                    "validate": true,
                    "optional": true,
                    "original": "secret"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Represents a vSphere volume attached and mounted on kubelets host machine"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vsphere_volume\" <$> TF.attribute",
                    "name": "_vsphereVolume",
                    "method": "vsphereVolume",
                    "conflicts": [],
                    "type": "TF.Attr s (VsphereVolume s)",
                    "class": "HasVsphereVolume",
                    "validate": true,
                    "optional": true,
                    "original": "vsphere_volume"
                }
            ],
            "name": "Volume",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "Volume s",
            "original": "volume"
        },
        {
            "con": {
                "smart": "newSeLinuxOptions",
                "name": "SeLinuxOptions'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Level is SELinux level label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"level\" <$> TF.attribute",
                    "name": "_level",
                    "method": "level",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLevel",
                    "validate": false,
                    "optional": true,
                    "original": "level"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Role is a SELinux role label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"role\" <$> TF.attribute",
                    "name": "_role",
                    "method": "role",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRole",
                    "validate": false,
                    "optional": true,
                    "original": "role"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Type is a SELinux type label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": true,
                    "original": "type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User is a SELinux user label that applies to the container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "_user",
                    "method": "user",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "validate": false,
                    "optional": true,
                    "original": "user"
                }
            ],
            "name": "SeLinuxOptions",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "SeLinuxOptions s",
            "original": "se_linux_options"
        },
        {
            "con": {
                "smart": "newExec",
                "name": "Exec'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Command is the command line to execute inside the container, the working",
                        "directory for the command is root ('/') in the container's filesystem. The",
                        "command is simply exec'd, it is not run inside a shell, so traditional shell",
                        "instructions. To use a shell, you need to explicitly call out to that shell.",
                        "Exit status of 0 is treated as live/healthy and non-zero is unhealthy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                }
            ],
            "name": "Exec",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "Exec s",
            "original": "exec"
        },
        {
            "con": {
                "smart": "newGlusterfs",
                "name": "Glusterfs'"
            },
            "arguments": [
                {
                    "default": "_endpointsName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The endpoint name that details Glusterfs topology. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"endpoints_name\" <$> TF.attribute",
                    "name": "_endpointsName",
                    "method": "endpointsName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasEndpointsName",
                    "validate": false,
                    "optional": false,
                    "original": "endpoints_name"
                },
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Glusterfs volume path. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the Glusterfs volume to be mounted with read-only",
                        "permissions. Defaults to false. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "name": "Glusterfs",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_endpointsName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The endpoint name that details Glusterfs topology. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"endpoints_name\" <$> TF.attribute",
                    "name": "_endpointsName",
                    "method": "endpointsName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasEndpointsName",
                    "validate": false,
                    "optional": false,
                    "original": "endpoints_name"
                },
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Glusterfs volume path. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                }
            ],
            "conflicts": [],
            "type": "Glusterfs s",
            "original": "glusterfs"
        },
        {
            "con": {
                "smart": "newNfs",
                "name": "Nfs'"
            },
            "arguments": [
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that is exported by the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the NFS export to be mounted with read-only permissions.",
                        "Defaults to false. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_server",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Server is the hostname or IP address of the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"server\" <$> TF.attribute",
                    "name": "_server",
                    "method": "server",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasServer",
                    "validate": false,
                    "optional": false,
                    "original": "server"
                }
            ],
            "name": "Nfs",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path that is exported by the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "_server",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Server is the hostname or IP address of the NFS server. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#nfs"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"server\" <$> TF.attribute",
                    "name": "_server",
                    "method": "server",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasServer",
                    "validate": false,
                    "optional": false,
                    "original": "server"
                }
            ],
            "conflicts": [],
            "type": "Nfs s",
            "original": "nfs"
        },
        {
            "con": {
                "smart": "newItems",
                "name": "Items'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key to project."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on this file, must be a value between 0 and 0777.",
                        "If not specified, the volume defaultMode will be used. This might be in",
                        "conflict with other options that affect the file mode, like fsGroup, and the",
                        "result can be other mode bits set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mode\" <$> TF.attribute",
                    "name": "_mode",
                    "method": "mode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasMode",
                    "validate": false,
                    "optional": true,
                    "original": "mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The relative path of the file to map the key to. May not be an absolute",
                        "path. May not contain the path element '..'. May not start with the string",
                        "'..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                }
            ],
            "name": "Items",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "Items s",
            "original": "items"
        },
        {
            "con": {
                "smart": "newSecret",
                "name": "Secret'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "name": "Secret",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "Secret s",
            "original": "secret"
        },
        {
            "con": {
                "smart": "newLimits",
                "name": "Limits'"
            },
            "arguments": [],
            "name": "Limits",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_computedCpu",
                    "method": "computedCpu",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedCpu",
                    "validate": false,
                    "optional": true,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_computedMemory",
                    "method": "computedMemory",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMemory",
                    "validate": false,
                    "optional": true,
                    "original": "memory"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "Limits s",
            "original": "limits"
        },
        {
            "con": {
                "smart": "newLifecycle",
                "name": "Lifecycle'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Post_start is called immediately after a container is created. If the",
                        "handler fails, the container is terminated and restarted according to its",
                        "restart policy. Other management of the container blocks until the hook",
                        "completes. More info:",
                        "http://kubernetes.io/docs/user-guide/container-environment#hook-details"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"post_start\" <$> TF.attribute",
                    "name": "_postStart",
                    "method": "postStart",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PostStart s)]",
                    "class": "HasPostStart",
                    "validate": true,
                    "optional": true,
                    "original": "post_start"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Pre_stop is called immediately before a container is terminated. The",
                        "container is terminated after the handler completes. The reason for",
                        "termination is passed to the handler. Regardless of the outcome of the",
                        "handler, the container is eventually terminated. Other management of the",
                        "container blocks until the hook completes. More info:",
                        "http://kubernetes.io/docs/user-guide/container-environment#hook-details"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pre_stop\" <$> TF.attribute",
                    "name": "_preStop",
                    "method": "preStop",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (PreStop s)]",
                    "class": "HasPreStop",
                    "validate": true,
                    "optional": true,
                    "original": "pre_stop"
                }
            ],
            "name": "Lifecycle",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "Lifecycle s",
            "original": "lifecycle"
        },
        {
            "con": {
                "smart": "newResourceFieldRef",
                "name": "ResourceFieldRef'"
            },
            "arguments": [
                {
                    "default": "_containerName",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_name\" <$> TF.attribute",
                    "name": "_containerName",
                    "method": "containerName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasContainerName",
                    "validate": false,
                    "optional": false,
                    "original": "container_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"quantity\" <$> TF.attribute",
                    "name": "_quantity",
                    "method": "quantity",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasQuantity",
                    "validate": false,
                    "optional": true,
                    "original": "quantity"
                },
                {
                    "default": "_resource",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Resource to select"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource\" <$> TF.attribute",
                    "name": "_resource",
                    "method": "resource",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResource",
                    "validate": false,
                    "optional": false,
                    "original": "resource"
                }
            ],
            "name": "ResourceFieldRef",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_containerName",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"container_name\" <$> TF.attribute",
                    "name": "_containerName",
                    "method": "containerName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasContainerName",
                    "validate": false,
                    "optional": false,
                    "original": "container_name"
                },
                {
                    "default": "_resource",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Resource to select"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource\" <$> TF.attribute",
                    "name": "_resource",
                    "method": "resource",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResource",
                    "validate": false,
                    "optional": false,
                    "original": "resource"
                }
            ],
            "conflicts": [],
            "type": "ResourceFieldRef s",
            "original": "resource_field_ref"
        },
        {
            "con": {
                "smart": "newResources",
                "name": "Resources'"
            },
            "arguments": [],
            "name": "Resources",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Describes the maximum amount of compute resources allowed. More info:",
                        "http://kubernetes.io/docs/user-guide/compute-resources/"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"limits\" <$> TF.attribute",
                    "name": "_computedLimits",
                    "method": "computedLimits",
                    "conflicts": [],
                    "type": "TF.Attr s (Limits s)",
                    "class": "HasComputedLimits",
                    "validate": true,
                    "optional": true,
                    "original": "limits"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"requests\" <$> TF.attribute",
                    "name": "_computedRequests",
                    "method": "computedRequests",
                    "conflicts": [],
                    "type": "TF.Attr s (Requests s)",
                    "class": "HasComputedRequests",
                    "validate": true,
                    "optional": true,
                    "original": "requests"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "Resources s",
            "original": "resources"
        },
        {
            "con": {
                "smart": "newHttpGet",
                "name": "HttpGet'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host name to connect to, defaults to the pod IP. You probably want to set",
                        "\"Host\" in httpHeaders instead."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "_host",
                    "method": "host",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHost",
                    "validate": false,
                    "optional": true,
                    "original": "host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_header\" <$> TF.attribute",
                    "name": "_httpHeader",
                    "method": "httpHeader",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (HttpHeader s)]",
                    "class": "HasHttpHeader",
                    "validate": true,
                    "optional": true,
                    "original": "http_header"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path to access on the HTTP server."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name or number of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.value \"HTTP\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Scheme to use for connecting to the host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scheme\" <$> TF.attribute",
                    "name": "_scheme",
                    "method": "scheme",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScheme",
                    "validate": false,
                    "optional": true,
                    "original": "scheme"
                }
            ],
            "name": "HttpGet",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "HttpGet s",
            "original": "http_get"
        },
        {
            "con": {
                "smart": "newAwsElasticBlockStore",
                "name": "AwsElasticBlockStore'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The partition in the volume that you want to mount. If omitted, the default",
                        "is to mount by volume name. Examples: For volume /dev/sda1, you specify the",
                        "partition as \"1\". Similarly, the volume partition for /dev/sda is \"0\" (or",
                        "you can leave the property empty)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"partition\" <$> TF.attribute",
                    "name": "_partition",
                    "method": "partition",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasPartition",
                    "validate": false,
                    "optional": true,
                    "original": "partition"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to set the read-only property in VolumeMounts to \"true\". If omitted,",
                        "the default is \"false\". More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "name": "AwsElasticBlockStore",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_volumeId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More",
                        "info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_id\" <$> TF.attribute",
                    "name": "_volumeId",
                    "method": "volumeId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolumeId",
                    "validate": false,
                    "optional": false,
                    "original": "volume_id"
                }
            ],
            "conflicts": [],
            "type": "AwsElasticBlockStore s",
            "original": "aws_elastic_block_store"
        },
        {
            "con": {
                "smart": "newFieldRef",
                "name": "FieldRef'"
            },
            "arguments": [
                {
                    "default": "TF.value \"v1\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Version of the schema the FieldPath is written in terms of, defaults to",
                        "\"v1\"."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"api_version\" <$> TF.attribute",
                    "name": "_apiVersion",
                    "method": "apiVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasApiVersion",
                    "validate": false,
                    "optional": true,
                    "original": "api_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path of the field to select in the specified API version"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_path\" <$> TF.attribute",
                    "name": "_fieldPath",
                    "method": "fieldPath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFieldPath",
                    "validate": false,
                    "optional": true,
                    "original": "field_path"
                }
            ],
            "name": "FieldRef",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "FieldRef s",
            "original": "field_ref"
        },
        {
            "con": {
                "smart": "newRbd",
                "name": "Rbd'"
            },
            "arguments": [
                {
                    "default": "_cephMonitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A collection of Ceph monitors. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_monitors\" <$> TF.attribute",
                    "name": "_cephMonitors",
                    "method": "cephMonitors",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCephMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "ceph_monitors"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#rbd"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.value \"admin\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The rados user name. Default is admin. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rados_user\" <$> TF.attribute",
                    "name": "_radosUser",
                    "method": "radosUser",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRadosUser",
                    "validate": false,
                    "optional": true,
                    "original": "rados_user"
                },
                {
                    "default": "_rbdImage",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The rados image name. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_image\" <$> TF.attribute",
                    "name": "_rbdImage",
                    "method": "rbdImage",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdImage",
                    "validate": false,
                    "optional": false,
                    "original": "rbd_image"
                },
                {
                    "default": "TF.value \"rbd\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The rados pool name. Default is rbd. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_pool\" <$> TF.attribute",
                    "name": "_rbdPool",
                    "method": "rbdPool",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdPool",
                    "validate": false,
                    "optional": true,
                    "original": "rbd_pool"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false.",
                        "More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the authentication secret for RBDUser. If provided overrides",
                        "keyring. Default is nil. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "_secretRef",
                    "method": "secretRef",
                    "conflicts": [],
                    "type": "TF.Attr s (SecretRef s)",
                    "class": "HasSecretRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_ref"
                }
            ],
            "name": "Rbd",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring.",
                        "More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"keyring\" <$> TF.attribute",
                    "name": "_computedKeyring",
                    "method": "computedKeyring",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedKeyring",
                    "validate": false,
                    "optional": true,
                    "original": "keyring"
                }
            ],
            "parameters": [
                {
                    "default": "_cephMonitors",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A collection of Ceph monitors. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ceph_monitors\" <$> TF.attribute",
                    "name": "_cephMonitors",
                    "method": "cephMonitors",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCephMonitors",
                    "validate": false,
                    "optional": false,
                    "original": "ceph_monitors"
                },
                {
                    "default": "_rbdImage",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The rados image name. More info:",
                        "http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rbd_image\" <$> TF.attribute",
                    "name": "_rbdImage",
                    "method": "rbdImage",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRbdImage",
                    "validate": false,
                    "optional": false,
                    "original": "rbd_image"
                }
            ],
            "conflicts": [],
            "type": "Rbd s",
            "original": "rbd"
        },
        {
            "con": {
                "smart": "newContainer",
                "name": "Container'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Arguments to the entrypoint. The docker image's CMD is used if this is not",
                        "provided. Variable references $(VAR_NAME) are expanded using the container's",
                        "environment. If a variable cannot be resolved, the reference in the input",
                        "string will be unchanged. The $(VAR_NAME) syntax can be escaped with a",
                        "double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,",
                        "regardless of whether the variable exists or not. Cannot be updated. More",
                        "info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"args\" <$> TF.attribute",
                    "name": "_args",
                    "method": "args",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasArgs",
                    "validate": false,
                    "optional": true,
                    "original": "args"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT",
                        "is used if this is not provided. Variable references $(VAR_NAME) are",
                        "expanded using the container's environment. If a variable cannot be",
                        "resolved, the reference in the input string will be unchanged. The",
                        "$(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).",
                        "Escaped references will never be expanded, regardless of whether the",
                        "variable exists or not. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of environment variables to set in the container. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"env\" <$> TF.attribute",
                    "name": "_env",
                    "method": "env",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (Env s)]",
                    "class": "HasEnv",
                    "validate": true,
                    "optional": true,
                    "original": "env"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Docker image name. More info: http://kubernetes.io/docs/user-guide/images"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image\" <$> TF.attribute",
                    "name": "_image",
                    "method": "image",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasImage",
                    "validate": false,
                    "optional": true,
                    "original": "image"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Actions that the management system should take in response to container",
                        "lifecycle events"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"lifecycle\" <$> TF.attribute",
                    "name": "_lifecycle",
                    "method": "lifecycle",
                    "conflicts": [],
                    "type": "TF.Attr s (Lifecycle s)",
                    "class": "HasLifecycle",
                    "validate": true,
                    "optional": true,
                    "original": "lifecycle"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container liveness. Container will be restarted if the",
                        "probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"liveness_probe\" <$> TF.attribute",
                    "name": "_livenessProbe",
                    "method": "livenessProbe",
                    "conflicts": [],
                    "type": "TF.Attr s (LivenessProbe s)",
                    "class": "HasLivenessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "liveness_probe"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of ports to expose from the container. Exposing a port here gives the",
                        "system additional information about the network connections a container",
                        "uses, but is primarily informational. Not specifying a port here DOES NOT",
                        "prevent that port from being exposed. Any port which is listening on the",
                        "default \"0.0.0.0\" address inside a container will be accessible from the",
                        "network. Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (Port s)]",
                    "class": "HasPort",
                    "validate": true,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container service readiness. Container will be removed",
                        "from service endpoints if the probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"readiness_probe\" <$> TF.attribute",
                    "name": "_readinessProbe",
                    "method": "readinessProbe",
                    "conflicts": [],
                    "type": "TF.Attr s (ReadinessProbe s)",
                    "class": "HasReadinessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "readiness_probe"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Security options the pod should run with. More info:",
                        "http://releases.k8s.io/HEAD/docs/design/security_context.md"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"security_context\" <$> TF.attribute",
                    "name": "_securityContext",
                    "method": "securityContext",
                    "conflicts": [],
                    "type": "TF.Attr s (SecurityContext s)",
                    "class": "HasSecurityContext",
                    "validate": true,
                    "optional": true,
                    "original": "security_context"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a buffer for stdin in the container",
                        "runtime. If this is not set, reads from stdin in the container will always",
                        "result in EOF."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"stdin\" <$> TF.attribute",
                    "name": "_stdin",
                    "method": "stdin",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdin",
                    "validate": false,
                    "optional": true,
                    "original": "stdin"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether the container runtime should close the stdin channel after it has",
                        "been opened by a single attach. When stdin is true the stdin stream will",
                        "remain open across multiple attach sessions. If stdinOnce is set to true,",
                        "stdin is opened on container start, is empty until the first client attaches",
                        "to stdin, and then remains open and accepts data until the client",
                        "disconnects, at which time stdin is closed and remains closed until the",
                        "container is restarted. If this flag is false, a container processes that",
                        "reads from stdin will never receive an EOF."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"stdin_once\" <$> TF.attribute",
                    "name": "_stdinOnce",
                    "method": "stdinOnce",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdinOnce",
                    "validate": false,
                    "optional": true,
                    "original": "stdin_once"
                },
                {
                    "default": "TF.value \"/dev/termination-log\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: Path at which the file to which the container's termination",
                        "message will be written is mounted into the container's filesystem. Message",
                        "written is intended to be brief final status, such as an assertion failure",
                        "message. Defaults to /dev/termination-log. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"termination_message_path\" <$> TF.attribute",
                    "name": "_terminationMessagePath",
                    "method": "terminationMessagePath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTerminationMessagePath",
                    "validate": false,
                    "optional": true,
                    "original": "termination_message_path"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a TTY for itself"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tty\" <$> TF.attribute",
                    "name": "_tty",
                    "method": "tty",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasTty",
                    "validate": false,
                    "optional": true,
                    "original": "tty"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Pod volumes to mount into the container's filesystem. Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_mount\" <$> TF.attribute",
                    "name": "_volumeMount",
                    "method": "volumeMount",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (VolumeMount s)]",
                    "class": "HasVolumeMount",
                    "validate": true,
                    "optional": true,
                    "original": "volume_mount"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Container's working directory. If not specified, the container runtime's",
                        "default will be used, which might be configured in the container image.",
                        "Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"working_dir\" <$> TF.attribute",
                    "name": "_workingDir",
                    "method": "workingDir",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasWorkingDir",
                    "validate": false,
                    "optional": true,
                    "original": "working_dir"
                }
            ],
            "name": "Container",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if",
                        ":latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/images#updating-images"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image_pull_policy\" <$> TF.attribute",
                    "name": "_computedImagePullPolicy",
                    "method": "computedImagePullPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedImagePullPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "image_pull_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Compute Resources required by this container. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_computedResources",
                    "method": "computedResources",
                    "conflicts": [],
                    "type": "TF.Attr s (Resources s)",
                    "class": "HasComputedResources",
                    "validate": true,
                    "optional": true,
                    "original": "resources"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "Container s",
            "original": "container"
        },
        {
            "con": {
                "smart": "newPersistentVolumeClaim",
                "name": "PersistentVolumeClaim'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ClaimName is the name of a PersistentVolumeClaim in the same"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"claim_name\" <$> TF.attribute",
                    "name": "_claimName",
                    "method": "claimName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasClaimName",
                    "validate": false,
                    "optional": true,
                    "original": "claim_name"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Will force the ReadOnly setting in VolumeMounts."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "name": "PersistentVolumeClaim",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PersistentVolumeClaim s",
            "original": "persistent_volume_claim"
        },
        {
            "con": {
                "smart": "newConfigMapKeyRef",
                "name": "ConfigMapKeyRef'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key to select."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "name": "ConfigMapKeyRef",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ConfigMapKeyRef s",
            "original": "config_map_key_ref"
        },
        {
            "con": {
                "smart": "newImagePullSecrets",
                "name": "ImagePullSecrets'"
            },
            "arguments": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "name": "ImagePullSecrets",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "ImagePullSecrets s",
            "original": "image_pull_secrets"
        },
        {
            "con": {
                "smart": "newVolumeMount",
                "name": "VolumeMount'"
            },
            "arguments": [
                {
                    "default": "_mountPath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path within the container at which the volume should be mounted. Must not",
                        "contain ':'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mount_path\" <$> TF.attribute",
                    "name": "_mountPath",
                    "method": "mountPath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMountPath",
                    "validate": false,
                    "optional": false,
                    "original": "mount_path"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "This must match the Name of a Volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Mounted read-only if true, read-write otherwise (false or unspecified).",
                        "Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Path within the volume from which the container's volume should be mounted.",
                        "Defaults to \"\" (volume's root)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sub_path\" <$> TF.attribute",
                    "name": "_subPath",
                    "method": "subPath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSubPath",
                    "validate": false,
                    "optional": true,
                    "original": "sub_path"
                }
            ],
            "name": "VolumeMount",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_mountPath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Path within the container at which the volume should be mounted. Must not",
                        "contain ':'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mount_path\" <$> TF.attribute",
                    "name": "_mountPath",
                    "method": "mountPath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMountPath",
                    "validate": false,
                    "optional": false,
                    "original": "mount_path"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "This must match the Name of a Volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "VolumeMount s",
            "original": "volume_mount"
        },
        {
            "con": {
                "smart": "newValueFrom",
                "name": "ValueFrom'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a key of a ConfigMap."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"config_map_key_ref\" <$> TF.attribute",
                    "name": "_configMapKeyRef",
                    "method": "configMapKeyRef",
                    "conflicts": [],
                    "type": "TF.Attr s (ConfigMapKeyRef s)",
                    "class": "HasConfigMapKeyRef",
                    "validate": true,
                    "optional": true,
                    "original": "config_map_key_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"field_ref\" <$> TF.attribute",
                    "name": "_fieldRef",
                    "method": "fieldRef",
                    "conflicts": [],
                    "type": "TF.Attr s (FieldRef s)",
                    "class": "HasFieldRef",
                    "validate": true,
                    "optional": true,
                    "original": "field_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_field_ref\" <$> TF.attribute",
                    "name": "_resourceFieldRef",
                    "method": "resourceFieldRef",
                    "conflicts": [],
                    "type": "TF.Attr s (ResourceFieldRef s)",
                    "class": "HasResourceFieldRef",
                    "validate": true,
                    "optional": true,
                    "original": "resource_field_ref"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Selects a field of the pod: supports metadata.name, metadata.namespace,",
                        "metadata.labels, metadata.annotations, spec.nodeName,",
                        "spec.serviceAccountName, status.podIP.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_key_ref\" <$> TF.attribute",
                    "name": "_secretKeyRef",
                    "method": "secretKeyRef",
                    "conflicts": [],
                    "type": "TF.Attr s (SecretKeyRef s)",
                    "class": "HasSecretKeyRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_key_ref"
                }
            ],
            "name": "ValueFrom",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ValueFrom s",
            "original": "value_from"
        },
        {
            "con": {
                "smart": "newRequests",
                "name": "Requests'"
            },
            "arguments": [],
            "name": "Requests",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu\" <$> TF.attribute",
                    "name": "_computedCpu",
                    "method": "computedCpu",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedCpu",
                    "validate": false,
                    "optional": true,
                    "original": "cpu"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_computedMemory",
                    "method": "computedMemory",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMemory",
                    "validate": false,
                    "optional": true,
                    "original": "memory"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "Requests s",
            "original": "requests"
        },
        {
            "con": {
                "smart": "newPhotonPersistentDisk",
                "name": "PhotonPersistentDisk'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_pdId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ID that identifies Photon Controller persistent disk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_id\" <$> TF.attribute",
                    "name": "_pdId",
                    "method": "pdId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdId",
                    "validate": false,
                    "optional": false,
                    "original": "pd_id"
                }
            ],
            "name": "PhotonPersistentDisk",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_pdId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ID that identifies Photon Controller persistent disk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_id\" <$> TF.attribute",
                    "name": "_pdId",
                    "method": "pdId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdId",
                    "validate": false,
                    "optional": false,
                    "original": "pd_id"
                }
            ],
            "conflicts": [],
            "type": "PhotonPersistentDisk s",
            "original": "photon_persistent_disk"
        },
        {
            "con": {
                "smart": "newInitContainer",
                "name": "InitContainer'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Arguments to the entrypoint. The docker image's CMD is used if this is not",
                        "provided. Variable references $(VAR_NAME) are expanded using the container's",
                        "environment. If a variable cannot be resolved, the reference in the input",
                        "string will be unchanged. The $(VAR_NAME) syntax can be escaped with a",
                        "double $$, ie: $$(VAR_NAME). Escaped references will never be expanded,",
                        "regardless of whether the variable exists or not. Cannot be updated. More",
                        "info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"args\" <$> TF.attribute",
                    "name": "_args",
                    "method": "args",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasArgs",
                    "validate": false,
                    "optional": true,
                    "original": "args"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT",
                        "is used if this is not provided. Variable references $(VAR_NAME) are",
                        "expanded using the container's environment. If a variable cannot be",
                        "resolved, the reference in the input string will be unchanged. The",
                        "$(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME).",
                        "Escaped references will never be expanded, regardless of whether the",
                        "variable exists or not. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/containers#containers-and-commands"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"command\" <$> TF.attribute",
                    "name": "_command",
                    "method": "command",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasCommand",
                    "validate": false,
                    "optional": true,
                    "original": "command"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of environment variables to set in the container. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"env\" <$> TF.attribute",
                    "name": "_env",
                    "method": "env",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (Env s)]",
                    "class": "HasEnv",
                    "validate": true,
                    "optional": true,
                    "original": "env"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Docker image name. More info: http://kubernetes.io/docs/user-guide/images"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image\" <$> TF.attribute",
                    "name": "_image",
                    "method": "image",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasImage",
                    "validate": false,
                    "optional": true,
                    "original": "image"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Actions that the management system should take in response to container",
                        "lifecycle events"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"lifecycle\" <$> TF.attribute",
                    "name": "_lifecycle",
                    "method": "lifecycle",
                    "conflicts": [],
                    "type": "TF.Attr s (Lifecycle s)",
                    "class": "HasLifecycle",
                    "validate": true,
                    "optional": true,
                    "original": "lifecycle"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container liveness. Container will be restarted if the",
                        "probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"liveness_probe\" <$> TF.attribute",
                    "name": "_livenessProbe",
                    "method": "livenessProbe",
                    "conflicts": [],
                    "type": "TF.Attr s (LivenessProbe s)",
                    "class": "HasLivenessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "liveness_probe"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of ports to expose from the container. Exposing a port here gives the",
                        "system additional information about the network connections a container",
                        "uses, but is primarily informational. Not specifying a port here DOES NOT",
                        "prevent that port from being exposed. Any port which is listening on the",
                        "default \"0.0.0.0\" address inside a container will be accessible from the",
                        "network. Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (Port s)]",
                    "class": "HasPort",
                    "validate": true,
                    "optional": true,
                    "original": "port"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Periodic probe of container service readiness. Container will be removed",
                        "from service endpoints if the probe fails. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"readiness_probe\" <$> TF.attribute",
                    "name": "_readinessProbe",
                    "method": "readinessProbe",
                    "conflicts": [],
                    "type": "TF.Attr s (ReadinessProbe s)",
                    "class": "HasReadinessProbe",
                    "validate": true,
                    "optional": true,
                    "original": "readiness_probe"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Security options the pod should run with. More info:",
                        "http://releases.k8s.io/HEAD/docs/design/security_context.md"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"security_context\" <$> TF.attribute",
                    "name": "_securityContext",
                    "method": "securityContext",
                    "conflicts": [],
                    "type": "TF.Attr s (SecurityContext s)",
                    "class": "HasSecurityContext",
                    "validate": true,
                    "optional": true,
                    "original": "security_context"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a buffer for stdin in the container",
                        "runtime. If this is not set, reads from stdin in the container will always",
                        "result in EOF."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"stdin\" <$> TF.attribute",
                    "name": "_stdin",
                    "method": "stdin",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdin",
                    "validate": false,
                    "optional": true,
                    "original": "stdin"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether the container runtime should close the stdin channel after it has",
                        "been opened by a single attach. When stdin is true the stdin stream will",
                        "remain open across multiple attach sessions. If stdinOnce is set to true,",
                        "stdin is opened on container start, is empty until the first client attaches",
                        "to stdin, and then remains open and accepts data until the client",
                        "disconnects, at which time stdin is closed and remains closed until the",
                        "container is restarted. If this flag is false, a container processes that",
                        "reads from stdin will never receive an EOF."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"stdin_once\" <$> TF.attribute",
                    "name": "_stdinOnce",
                    "method": "stdinOnce",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasStdinOnce",
                    "validate": false,
                    "optional": true,
                    "original": "stdin_once"
                },
                {
                    "default": "TF.value \"/dev/termination-log\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: Path at which the file to which the container's termination",
                        "message will be written is mounted into the container's filesystem. Message",
                        "written is intended to be brief final status, such as an assertion failure",
                        "message. Defaults to /dev/termination-log. Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"termination_message_path\" <$> TF.attribute",
                    "name": "_terminationMessagePath",
                    "method": "terminationMessagePath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTerminationMessagePath",
                    "validate": false,
                    "optional": true,
                    "original": "termination_message_path"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether this container should allocate a TTY for itself"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tty\" <$> TF.attribute",
                    "name": "_tty",
                    "method": "tty",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasTty",
                    "validate": false,
                    "optional": true,
                    "original": "tty"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Pod volumes to mount into the container's filesystem. Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume_mount\" <$> TF.attribute",
                    "name": "_volumeMount",
                    "method": "volumeMount",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (VolumeMount s)]",
                    "class": "HasVolumeMount",
                    "validate": true,
                    "optional": true,
                    "original": "volume_mount"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Container's working directory. If not specified, the container runtime's",
                        "default will be used, which might be configured in the container image.",
                        "Cannot be updated."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"working_dir\" <$> TF.attribute",
                    "name": "_workingDir",
                    "method": "workingDir",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasWorkingDir",
                    "validate": false,
                    "optional": true,
                    "original": "working_dir"
                }
            ],
            "name": "InitContainer",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if",
                        ":latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More",
                        "info: http://kubernetes.io/docs/user-guide/images#updating-images"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image_pull_policy\" <$> TF.attribute",
                    "name": "_computedImagePullPolicy",
                    "method": "computedImagePullPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedImagePullPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "image_pull_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Compute Resources required by this container. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#resources"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resources\" <$> TF.attribute",
                    "name": "_computedResources",
                    "method": "computedResources",
                    "conflicts": [],
                    "type": "TF.Attr s (Resources s)",
                    "class": "HasComputedResources",
                    "validate": true,
                    "optional": true,
                    "original": "resources"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the container specified as a DNS_LABEL. Each container in a pod must",
                        "have a unique name (DNS_LABEL). Cannot be updated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "InitContainer s",
            "original": "init_container"
        },
        {
            "con": {
                "smart": "newSpec",
                "name": "Spec'"
            },
            "arguments": [],
            "name": "Spec",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The IP address of the service. It is usually assigned randomly by the",
                        "master. If an address is specified manually and is not in use by others, it",
                        "will be allocated to the service; otherwise, creation of the service will",
                        "fail. `None` can be specified for headless services when proxying is not",
                        "required. Ignored if type is `ExternalName`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cluster_ip\" <$> TF.attribute",
                    "name": "_computedClusterIp",
                    "method": "computedClusterIp",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedClusterIp",
                    "validate": false,
                    "optional": false,
                    "original": "cluster_ip"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A list of IP addresses for which nodes in the cluster will also accept",
                        "traffic for this service. These IPs are not managed by Kubernetes. The user",
                        "is responsible for ensuring that traffic arrives at a node with this IP.  A",
                        "common example is external load-balancers that are not part of the",
                        "Kubernetes system."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"external_ips\" <$> TF.attribute",
                    "name": "_computedExternalIps",
                    "method": "computedExternalIps",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedExternalIps",
                    "validate": false,
                    "optional": false,
                    "original": "external_ips"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The external reference that kubedns or equivalent will return as a CNAME",
                        "record for this service. No proxying will be involved. Must be a valid DNS",
                        "name and requires `type` to be `ExternalName`."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"external_name\" <$> TF.attribute",
                    "name": "_computedExternalName",
                    "method": "computedExternalName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedExternalName",
                    "validate": false,
                    "optional": false,
                    "original": "external_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Only applies to `type = LoadBalancer`. LoadBalancer will get created with",
                        "the IP specified in this field. This feature depends on whether the",
                        "underlying cloud-provider supports specifying this field when a load",
                        "balancer is created. This field will be ignored if the cloud-provider does",
                        "not support the feature."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_ip\" <$> TF.attribute",
                    "name": "_computedLoadBalancerIp",
                    "method": "computedLoadBalancerIp",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedLoadBalancerIp",
                    "validate": false,
                    "optional": false,
                    "original": "load_balancer_ip"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "If specified and supported by the platform, this will restrict traffic",
                        "through the cloud-provider load-balancer will be restricted to the specified",
                        "client IPs. This field will be ignored if the cloud-provider does not",
                        "support the feature. More info:",
                        "http://kubernetes.io/docs/user-guide/services-firewalls"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_source_ranges\" <$> TF.attribute",
                    "name": "_computedLoadBalancerSourceRanges",
                    "method": "computedLoadBalancerSourceRanges",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedLoadBalancerSourceRanges",
                    "validate": false,
                    "optional": false,
                    "original": "load_balancer_source_ranges"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The list of ports that are exposed by this service. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_computedPort",
                    "method": "computedPort",
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (TF.Attr s (Port s)))",
                    "class": "HasComputedPort",
                    "validate": true,
                    "optional": false,
                    "original": "port"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Route service traffic to pods with label keys and values matching this",
                        "selector. Only applies to types `ClusterIP`, `NodePort`, and `LoadBalancer`.",
                        "More info: http://kubernetes.io/docs/user-guide/services#overview"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"selector\" <$> TF.attribute",
                    "name": "_computedSelector",
                    "method": "computedSelector",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasComputedSelector",
                    "validate": false,
                    "optional": false,
                    "original": "selector"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Used to maintain session affinity. Supports `ClientIP` and `None`. Defaults",
                        "to `None`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#virtual-ips-and-service-proxies"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"session_affinity\" <$> TF.attribute",
                    "name": "_computedSessionAffinity",
                    "method": "computedSessionAffinity",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSessionAffinity",
                    "validate": false,
                    "optional": false,
                    "original": "session_affinity"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Determines how the service is exposed. Defaults to `ClusterIP`. Valid",
                        "options are `ExternalName`, `ClusterIP`, `NodePort`, and `LoadBalancer`.",
                        "`ExternalName` maps to the specified `external_name`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#overview"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_computedType",
                    "method": "computedType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedType",
                    "validate": false,
                    "optional": false,
                    "original": "type"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "Spec s",
            "original": "spec"
        },
        {
            "con": {
                "smart": "newMetadata",
                "name": "Metadata'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An unstructured key value map stored with the storage class that may be used",
                        "to store arbitrary metadata. More info:",
                        "http://kubernetes.io/docs/user-guide/annotations"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotations\" <$> TF.attribute",
                    "name": "_annotations",
                    "method": "annotations",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasAnnotations",
                    "validate": false,
                    "optional": true,
                    "original": "annotations"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Map of string keys and values that can be used to organize and categorize",
                        "(scope and select) the storage class. May match selectors of replication",
                        "controllers and services. More info:",
                        "http://kubernetes.io/docs/user-guide/labels"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                }
            ],
            "name": "Metadata",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A sequence number representing a specific generation of the desired state."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"generation\" <$> TF.attribute",
                    "name": "_computedGeneration",
                    "method": "computedGeneration",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedGeneration",
                    "validate": false,
                    "optional": false,
                    "original": "generation"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Name of the storage class, must be unique. Cannot be updated. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "An opaque value that represents the internal version of this storage class",
                        "that can be used by clients to determine when storage class has changed.",
                        "Read more:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_version\" <$> TF.attribute",
                    "name": "_computedResourceVersion",
                    "method": "computedResourceVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourceVersion",
                    "validate": false,
                    "optional": false,
                    "original": "resource_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A URL representing this storage class."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"self_link\" <$> TF.attribute",
                    "name": "_computedSelfLink",
                    "method": "computedSelfLink",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedSelfLink",
                    "validate": false,
                    "optional": false,
                    "original": "self_link"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique in time and space value for this storage class. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#uids"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uid\" <$> TF.attribute",
                    "name": "_computedUid",
                    "method": "computedUid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUid",
                    "validate": false,
                    "optional": false,
                    "original": "uid"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "Metadata s",
            "original": "metadata"
        },
        {
            "con": {
                "smart": "newMatchExpressions",
                "name": "MatchExpressions'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The label key that the selector applies to."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A key's relationship to a set of values. Valid operators ard `In`, `NotIn`,",
                        "`Exists` and `DoesNotExist`."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"operator\" <$> TF.attribute",
                    "name": "_operator",
                    "method": "operator",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasOperator",
                    "validate": false,
                    "optional": true,
                    "original": "operator"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "An array of string values. If the operator is `In` or `NotIn`, the values",
                        "array must be non-empty. If the operator is `Exists` or `DoesNotExist`, the",
                        "values array must be empty. This array is replaced during a strategic merge",
                        "patch."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"values\" <$> TF.attribute",
                    "name": "_values",
                    "method": "values",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasValues",
                    "validate": false,
                    "optional": true,
                    "original": "values"
                }
            ],
            "name": "MatchExpressions",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "MatchExpressions s",
            "original": "match_expressions"
        },
        {
            "con": {
                "smart": "newGitRepo",
                "name": "GitRepo'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Target directory name. Must not contain or start with '..'. If '.' is",
                        "supplied, the volume directory will be the git repository. Otherwise, if",
                        "specified, the volume will contain the git repository in the subdirectory",
                        "with the given name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"directory\" <$> TF.attribute",
                    "name": "_directory",
                    "method": "directory",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDirectory",
                    "validate": false,
                    "optional": true,
                    "original": "directory"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Repository URL"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"repository\" <$> TF.attribute",
                    "name": "_repository",
                    "method": "repository",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRepository",
                    "validate": false,
                    "optional": true,
                    "original": "repository"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Commit hash for the specified revision."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"revision\" <$> TF.attribute",
                    "name": "_revision",
                    "method": "revision",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRevision",
                    "validate": false,
                    "optional": true,
                    "original": "revision"
                }
            ],
            "name": "GitRepo",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "GitRepo s",
            "original": "git_repo"
        },
        {
            "con": {
                "smart": "newTcpSocket",
                "name": "TcpSocket'"
            },
            "arguments": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "name": "TcpSocket",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_port",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Number or name of the port to access on the container. Number must be in the",
                        "range 1 to 65535. Name must be an IANA_SVC_NAME."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_port",
                    "method": "port",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                }
            ],
            "conflicts": [],
            "type": "TcpSocket s",
            "original": "tcp_socket"
        },
        {
            "con": {
                "smart": "newLimit",
                "name": "Limit'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Default resource requirement limit value by resource name if resource limit",
                        "is omitted."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default\" <$> TF.attribute",
                    "name": "_default'",
                    "method": "default'",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasDefault'",
                    "validate": false,
                    "optional": true,
                    "original": "default"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Max usage constraints on this kind by resource name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"max\" <$> TF.attribute",
                    "name": "_max",
                    "method": "max",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasMax",
                    "validate": false,
                    "optional": true,
                    "original": "max"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The named resource must have a request and limit that are both non-zero",
                        "where limit divided by request is less than or equal to the enumerated",
                        "value; this represents the max burst for the named resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"max_limit_request_ratio\" <$> TF.attribute",
                    "name": "_maxLimitRequestRatio",
                    "method": "maxLimitRequestRatio",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasMaxLimitRequestRatio",
                    "validate": false,
                    "optional": true,
                    "original": "max_limit_request_ratio"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Min usage constraints on this kind by resource name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"min\" <$> TF.attribute",
                    "name": "_min",
                    "method": "min",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasMin",
                    "validate": false,
                    "optional": true,
                    "original": "min"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Type of resource that this limit applies to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": true,
                    "original": "type"
                }
            ],
            "name": "Limit",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The default resource requirement request value by resource name if resource",
                        "request is omitted."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_request\" <$> TF.attribute",
                    "name": "_computedDefaultRequest",
                    "method": "computedDefaultRequest",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasComputedDefaultRequest",
                    "validate": false,
                    "optional": true,
                    "original": "default_request"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "Limit s",
            "original": "limit"
        },
        {
            "con": {
                "smart": "newLoadBalancerIngress",
                "name": "LoadBalancerIngress'"
            },
            "arguments": [],
            "name": "LoadBalancerIngress",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"hostname\" <$> TF.attribute",
                    "name": "_computedHostname",
                    "method": "computedHostname",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedHostname",
                    "validate": false,
                    "optional": false,
                    "original": "hostname"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"ip\" <$> TF.attribute",
                    "name": "_computedIp",
                    "method": "computedIp",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedIp",
                    "validate": false,
                    "optional": false,
                    "original": "ip"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "LoadBalancerIngress s",
            "original": "load_balancer_ingress"
        },
        {
            "con": {
                "smart": "newFc",
                "name": "Fc'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_lun",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target lun number"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "_lun",
                    "method": "lun",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasLun",
                    "validate": false,
                    "optional": false,
                    "original": "lun"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_targetWwNs",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target worldwide names (WWNs)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_ww_ns\" <$> TF.attribute",
                    "name": "_targetWwNs",
                    "method": "targetWwNs",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTargetWwNs",
                    "validate": false,
                    "optional": false,
                    "original": "target_ww_ns"
                }
            ],
            "name": "Fc",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_lun",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target lun number"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "_lun",
                    "method": "lun",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasLun",
                    "validate": false,
                    "optional": false,
                    "original": "lun"
                },
                {
                    "default": "_targetWwNs",
                    "computed": false,
                    "required": true,
                    "help": [
                        "FC target worldwide names (WWNs)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_ww_ns\" <$> TF.attribute",
                    "name": "_targetWwNs",
                    "method": "targetWwNs",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTargetWwNs",
                    "validate": false,
                    "optional": false,
                    "original": "target_ww_ns"
                }
            ],
            "conflicts": [],
            "type": "Fc s",
            "original": "fc"
        },
        {
            "con": {
                "smart": "newLivenessProbe",
                "name": "LivenessProbe'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "conflicts": [],
                    "type": "TF.Attr s (Exec s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive failures for the probe to be considered failed after",
                        "having succeeded."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failure_threshold\" <$> TF.attribute",
                    "name": "_failureThreshold",
                    "method": "failureThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasFailureThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "failure_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "conflicts": [],
                    "type": "TF.Attr s (HttpGet s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after the container has started before liveness probes are",
                        "initiated. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"initial_delay_seconds\" <$> TF.attribute",
                    "name": "_initialDelaySeconds",
                    "method": "initialDelaySeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasInitialDelaySeconds",
                    "validate": false,
                    "optional": true,
                    "original": "initial_delay_seconds"
                },
                {
                    "default": "TF.value 10",
                    "computed": false,
                    "required": false,
                    "help": [
                        "How often (in seconds) to perform the probe"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"period_seconds\" <$> TF.attribute",
                    "name": "_periodSeconds",
                    "method": "periodSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasPeriodSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "period_seconds"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Minimum consecutive successes for the probe to be considered successful",
                        "after having failed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"success_threshold\" <$> TF.attribute",
                    "name": "_successThreshold",
                    "method": "successThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasSuccessThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "success_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TcpSocket s)]",
                    "class": "HasTcpSocket",
                    "validate": true,
                    "optional": true,
                    "original": "tcp_socket"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Number of seconds after which the probe times out. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#container-probes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"timeout_seconds\" <$> TF.attribute",
                    "name": "_timeoutSeconds",
                    "method": "timeoutSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasTimeoutSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "timeout_seconds"
                }
            ],
            "name": "LivenessProbe",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "LivenessProbe s",
            "original": "liveness_probe"
        },
        {
            "con": {
                "smart": "newAzureFile",
                "name": "AzureFile'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_secretName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of secret that contains Azure Storage Account Name and Key"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_name\" <$> TF.attribute",
                    "name": "_secretName",
                    "method": "secretName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretName",
                    "validate": false,
                    "optional": false,
                    "original": "secret_name"
                },
                {
                    "default": "_shareName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Share Name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"share_name\" <$> TF.attribute",
                    "name": "_shareName",
                    "method": "shareName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasShareName",
                    "validate": false,
                    "optional": false,
                    "original": "share_name"
                }
            ],
            "name": "AzureFile",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_secretName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of secret that contains Azure Storage Account Name and Key"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_name\" <$> TF.attribute",
                    "name": "_secretName",
                    "method": "secretName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecretName",
                    "validate": false,
                    "optional": false,
                    "original": "secret_name"
                },
                {
                    "default": "_shareName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Share Name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"share_name\" <$> TF.attribute",
                    "name": "_shareName",
                    "method": "shareName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasShareName",
                    "validate": false,
                    "optional": false,
                    "original": "share_name"
                }
            ],
            "conflicts": [],
            "type": "AzureFile s",
            "original": "azure_file"
        },
        {
            "con": {
                "smart": "newScaleTargetRef",
                "name": "ScaleTargetRef'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "API version of the referent"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"api_version\" <$> TF.attribute",
                    "name": "_apiVersion",
                    "method": "apiVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasApiVersion",
                    "validate": false,
                    "optional": true,
                    "original": "api_version"
                },
                {
                    "default": "_kind",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Kind of the referent. e.g. `ReplicationController`. More info:",
                        "http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#types-kinds"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"kind\" <$> TF.attribute",
                    "name": "_kind",
                    "method": "kind",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKind",
                    "validate": false,
                    "optional": false,
                    "original": "kind"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "name": "ScaleTargetRef",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_kind",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Kind of the referent. e.g. `ReplicationController`. More info:",
                        "http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#types-kinds"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"kind\" <$> TF.attribute",
                    "name": "_kind",
                    "method": "kind",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKind",
                    "validate": false,
                    "optional": false,
                    "original": "kind"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "ScaleTargetRef s",
            "original": "scale_target_ref"
        },
        {
            "con": {
                "smart": "newPreStop",
                "name": "PreStop'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Exec specifies the action to take."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"exec\" <$> TF.attribute",
                    "name": "_exec",
                    "method": "exec",
                    "conflicts": [],
                    "type": "TF.Attr s (Exec s)",
                    "class": "HasExec",
                    "validate": true,
                    "optional": true,
                    "original": "exec"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies the http request to perform."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"http_get\" <$> TF.attribute",
                    "name": "_httpGet",
                    "method": "httpGet",
                    "conflicts": [],
                    "type": "TF.Attr s (HttpGet s)",
                    "class": "HasHttpGet",
                    "validate": true,
                    "optional": true,
                    "original": "http_get"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "TCPSocket specifies an action involving a TCP port. TCP hooks not yet",
                        "supported"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tcp_socket\" <$> TF.attribute",
                    "name": "_tcpSocket",
                    "method": "tcpSocket",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TcpSocket s)]",
                    "class": "HasTcpSocket",
                    "validate": true,
                    "optional": true,
                    "original": "tcp_socket"
                }
            ],
            "name": "PreStop",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "PreStop s",
            "original": "pre_stop"
        },
        {
            "con": {
                "smart": "newFlexVolume",
                "name": "FlexVolume'"
            },
            "arguments": [
                {
                    "default": "_driver",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Driver is the name of the driver to use for this volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"driver\" <$> TF.attribute",
                    "name": "_driver",
                    "method": "driver",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDriver",
                    "validate": false,
                    "optional": false,
                    "original": "driver"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". The default filesystem depends",
                        "on FlexVolume script."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Extra command options if any."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"options\" <$> TF.attribute",
                    "name": "_options",
                    "method": "options",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasOptions",
                    "validate": false,
                    "optional": true,
                    "original": "options"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the ReadOnly setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Reference to the secret object containing sensitive information to pass to",
                        "the plugin scripts. This may be empty if no secret object is specified. If",
                        "the secret object contains more than one secret, all secrets are passed to",
                        "the plugin scripts."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret_ref\" <$> TF.attribute",
                    "name": "_secretRef",
                    "method": "secretRef",
                    "conflicts": [],
                    "type": "TF.Attr s (SecretRef s)",
                    "class": "HasSecretRef",
                    "validate": true,
                    "optional": true,
                    "original": "secret_ref"
                }
            ],
            "name": "FlexVolume",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_driver",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Driver is the name of the driver to use for this volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"driver\" <$> TF.attribute",
                    "name": "_driver",
                    "method": "driver",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDriver",
                    "validate": false,
                    "optional": false,
                    "original": "driver"
                }
            ],
            "conflicts": [],
            "type": "FlexVolume s",
            "original": "flex_volume"
        },
        {
            "con": {
                "smart": "newSecretKeyRef",
                "name": "SecretKeyRef'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key of the secret to select from. Must be a valid secret key."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_key",
                    "method": "key",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasKey",
                    "validate": false,
                    "optional": true,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "name": "SecretKeyRef",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "SecretKeyRef s",
            "original": "secret_key_ref"
        },
        {
            "con": {
                "smart": "newHttpHeader",
                "name": "HttpHeader'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field name"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The header field value"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"value\" <$> TF.attribute",
                    "name": "_value",
                    "method": "value",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasValue",
                    "validate": false,
                    "optional": true,
                    "original": "value"
                }
            ],
            "name": "HttpHeader",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "HttpHeader s",
            "original": "http_header"
        },
        {
            "con": {
                "smart": "newTemplate",
                "name": "Template'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional duration in seconds the pod may be active on the node relative to",
                        "StartTime before the system will actively try to mark it failed and kill",
                        "associated containers. Value must be a positive integer."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"active_deadline_seconds\" <$> TF.attribute",
                    "name": "_activeDeadlineSeconds",
                    "method": "activeDeadlineSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasActiveDeadlineSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "active_deadline_seconds"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of containers belonging to the pod. Containers cannot currently be",
                        "added or removed. There must be at least one container in a Pod. Cannot be",
                        "updated. More info: http://kubernetes.io/docs/user-guide/containers"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"container\" <$> TF.attribute",
                    "name": "_container",
                    "method": "container",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (Container s)]",
                    "class": "HasContainer",
                    "validate": true,
                    "optional": true,
                    "original": "container"
                },
                {
                    "default": "TF.value \"ClusterFirst\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Set DNS policy for containers within the pod. One of 'ClusterFirst' or",
                        "'Default'. Defaults to 'ClusterFirst'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dns_policy\" <$> TF.attribute",
                    "name": "_dnsPolicy",
                    "method": "dnsPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDnsPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "dns_policy"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Use the host's ipc namespace. Optional: Default to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_ipc\" <$> TF.attribute",
                    "name": "_hostIpc",
                    "method": "hostIpc",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostIpc",
                    "validate": false,
                    "optional": true,
                    "original": "host_ipc"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Host networking requested for this pod. Use the host's network namespace. If",
                        "this option is set, the ports that will be used must be specified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_network\" <$> TF.attribute",
                    "name": "_hostNetwork",
                    "method": "hostNetwork",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostNetwork",
                    "validate": false,
                    "optional": true,
                    "original": "host_network"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Use the host's pid namespace."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_pid\" <$> TF.attribute",
                    "name": "_hostPid",
                    "method": "hostPid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHostPid",
                    "validate": false,
                    "optional": true,
                    "original": "host_pid"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of init containers belonging to the pod. Init containers always run to",
                        "completion and each must complete succesfully before the next is started.",
                        "More info:",
                        "https://kubernetes.io/docs/concepts/workloads/pods/init-containers/"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"init_container\" <$> TF.attribute",
                    "name": "_initContainer",
                    "method": "initContainer",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (InitContainer s)]",
                    "class": "HasInitContainer",
                    "validate": true,
                    "optional": true,
                    "original": "init_container"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "NodeSelector is a selector which must be true for the pod to fit on a node.",
                        "Selector which must match a node's labels for the pod to be scheduled on",
                        "that node. More info: http://kubernetes.io/docs/user-guide/node-selection."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"node_selector\" <$> TF.attribute",
                    "name": "_nodeSelector",
                    "method": "nodeSelector",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasNodeSelector",
                    "validate": false,
                    "optional": true,
                    "original": "node_selector"
                },
                {
                    "default": "TF.value \"Always\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Restart policy for all containers within the pod. One of Always, OnFailure,",
                        "Never. More info:",
                        "http://kubernetes.io/docs/user-guide/pod-states#restartpolicy."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"restart_policy\" <$> TF.attribute",
                    "name": "_restartPolicy",
                    "method": "restartPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRestartPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "restart_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "SecurityContext holds pod-level security attributes and common container",
                        "settings. Optional: Defaults to empty"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"security_context\" <$> TF.attribute",
                    "name": "_securityContext",
                    "method": "securityContext",
                    "conflicts": [],
                    "type": "TF.Attr s (SecurityContext s)",
                    "class": "HasSecurityContext",
                    "validate": true,
                    "optional": true,
                    "original": "security_context"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If specified, the fully qualified Pod hostname will be \"...svc.\". If not",
                        "specified, the pod will not have a domainname at all.."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"subdomain\" <$> TF.attribute",
                    "name": "_subdomain",
                    "method": "subdomain",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSubdomain",
                    "validate": false,
                    "optional": true,
                    "original": "subdomain"
                },
                {
                    "default": "TF.value 30",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional duration in seconds the pod needs to terminate gracefully. May be",
                        "decreased in delete request. Value must be non-negative integer. The value",
                        "zero indicates delete immediately. If this value is nil, the default grace",
                        "period will be used instead. The grace period is the duration in seconds",
                        "after the processes running in the pod are sent a termination signal and the",
                        "time when the processes are forcibly halted with a kill signal. Set this",
                        "value longer than the expected cleanup time for your process."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"termination_grace_period_seconds\" <$> TF.attribute",
                    "name": "_terminationGracePeriodSeconds",
                    "method": "terminationGracePeriodSeconds",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasTerminationGracePeriodSeconds",
                    "validate": false,
                    "optional": true,
                    "original": "termination_grace_period_seconds"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of volumes that can be mounted by containers belonging to the pod. More",
                        "info: http://kubernetes.io/docs/user-guide/volumes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "_volume",
                    "method": "volume",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (Volume s)]",
                    "class": "HasVolume",
                    "validate": true,
                    "optional": true,
                    "original": "volume"
                }
            ],
            "name": "Template",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Specifies the hostname of the Pod If not specified, the pod's hostname will",
                        "be set to a system-defined value."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"hostname\" <$> TF.attribute",
                    "name": "_computedHostname",
                    "method": "computedHostname",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedHostname",
                    "validate": false,
                    "optional": true,
                    "original": "hostname"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "ImagePullSecrets is an optional list of references to secrets in the same",
                        "namespace to use for pulling any of the images used by this PodSpec. If",
                        "specified, these secrets will be passed to individual puller implementations",
                        "for them to use. For example, in the case of docker, only DockerConfig type",
                        "secrets are honored. More info:",
                        "http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image_pull_secrets\" <$> TF.attribute",
                    "name": "_computedImagePullSecrets",
                    "method": "computedImagePullSecrets",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ImagePullSecrets s)]",
                    "class": "HasComputedImagePullSecrets",
                    "validate": true,
                    "optional": true,
                    "original": "image_pull_secrets"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "NodeName is a request to schedule this pod onto a specific node. If it is",
                        "non-empty, the scheduler simply schedules this pod onto that node, assuming",
                        "that it fits resource requirements."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"node_name\" <$> TF.attribute",
                    "name": "_computedNodeName",
                    "method": "computedNodeName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedNodeName",
                    "validate": false,
                    "optional": true,
                    "original": "node_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "ServiceAccountName is the name of the ServiceAccount to use to run this pod.",
                        "More info: http://releases.k8s.io/HEAD/docs/design/service_accounts.md."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"service_account_name\" <$> TF.attribute",
                    "name": "_computedServiceAccountName",
                    "method": "computedServiceAccountName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedServiceAccountName",
                    "validate": false,
                    "optional": true,
                    "original": "service_account_name"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "Template s",
            "original": "template"
        },
        {
            "con": {
                "smart": "newIscsi",
                "name": "Iscsi'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#iscsi"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "_iqn",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Target iSCSI Qualified Name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iqn\" <$> TF.attribute",
                    "name": "_iqn",
                    "method": "iqn",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIqn",
                    "validate": false,
                    "optional": false,
                    "original": "iqn"
                },
                {
                    "default": "TF.value \"default\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ISCSI interface name that uses an iSCSI transport. Defaults to 'default'",
                        "(tcp)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi_interface\" <$> TF.attribute",
                    "name": "_iscsiInterface",
                    "method": "iscsiInterface",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIscsiInterface",
                    "validate": false,
                    "optional": true,
                    "original": "iscsi_interface"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "ISCSI target lun number."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lun\" <$> TF.attribute",
                    "name": "_lun",
                    "method": "lun",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasLun",
                    "validate": false,
                    "optional": true,
                    "original": "lun"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_targetPortal",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ISCSI target portal. The portal is either an IP or ip_addr:port if the port",
                        "is other than default (typically TCP ports 860 and 3260)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_portal\" <$> TF.attribute",
                    "name": "_targetPortal",
                    "method": "targetPortal",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTargetPortal",
                    "validate": false,
                    "optional": false,
                    "original": "target_portal"
                }
            ],
            "name": "Iscsi",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_iqn",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Target iSCSI Qualified Name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iqn\" <$> TF.attribute",
                    "name": "_iqn",
                    "method": "iqn",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIqn",
                    "validate": false,
                    "optional": false,
                    "original": "iqn"
                },
                {
                    "default": "_targetPortal",
                    "computed": false,
                    "required": true,
                    "help": [
                        "ISCSI target portal. The portal is either an IP or ip_addr:port if the port",
                        "is other than default (typically TCP ports 860 and 3260)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_portal\" <$> TF.attribute",
                    "name": "_targetPortal",
                    "method": "targetPortal",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTargetPortal",
                    "validate": false,
                    "optional": false,
                    "original": "target_portal"
                }
            ],
            "conflicts": [],
            "type": "Iscsi s",
            "original": "iscsi"
        },
        {
            "con": {
                "smart": "newAzureDisk",
                "name": "AzureDisk'"
            },
            "arguments": [
                {
                    "default": "_cachingMode",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Host Caching mode: None, Read Only, Read Write."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"caching_mode\" <$> TF.attribute",
                    "name": "_cachingMode",
                    "method": "cachingMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCachingMode",
                    "validate": false,
                    "optional": false,
                    "original": "caching_mode"
                },
                {
                    "default": "_dataDiskUri",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The URI the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data_disk_uri\" <$> TF.attribute",
                    "name": "_dataDiskUri",
                    "method": "dataDiskUri",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDataDiskUri",
                    "validate": false,
                    "optional": false,
                    "original": "data_disk_uri"
                },
                {
                    "default": "_diskName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Name of the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disk_name\" <$> TF.attribute",
                    "name": "_diskName",
                    "method": "diskName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDiskName",
                    "validate": false,
                    "optional": false,
                    "original": "disk_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type to mount. Must be a filesystem type supported by the host",
                        "operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be",
                        "\"ext4\" if unspecified."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the read-only setting in VolumeMounts. Defaults to false",
                        "(read/write)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "name": "AzureDisk",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_cachingMode",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Host Caching mode: None, Read Only, Read Write."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"caching_mode\" <$> TF.attribute",
                    "name": "_cachingMode",
                    "method": "cachingMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCachingMode",
                    "validate": false,
                    "optional": false,
                    "original": "caching_mode"
                },
                {
                    "default": "_dataDiskUri",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The URI the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data_disk_uri\" <$> TF.attribute",
                    "name": "_dataDiskUri",
                    "method": "dataDiskUri",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDataDiskUri",
                    "validate": false,
                    "optional": false,
                    "original": "data_disk_uri"
                },
                {
                    "default": "_diskName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The Name of the data disk in the blob storage"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disk_name\" <$> TF.attribute",
                    "name": "_diskName",
                    "method": "diskName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDiskName",
                    "validate": false,
                    "optional": false,
                    "original": "disk_name"
                }
            ],
            "conflicts": [],
            "type": "AzureDisk s",
            "original": "azure_disk"
        },
        {
            "con": {
                "smart": "newSecurityContext",
                "name": "SecurityContext'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A special supplemental group that applies to all containers in a pod. Some",
                        "volume types allow the Kubelet to change the ownership of that volume to be",
                        "owned by the pod: 1. The owning GID will be the FSGroup 2. The setgid bit is",
                        "set (new files created in the volume will be owned by FSGroup) 3. The",
                        "permission bits are OR'd with rw-rw---- If unset, the Kubelet will not",
                        "modify the ownership and permissions of any volume."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_group\" <$> TF.attribute",
                    "name": "_fsGroup",
                    "method": "fsGroup",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasFsGroup",
                    "validate": false,
                    "optional": true,
                    "original": "fs_group"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Indicates that the container must run as a non-root user. If true, the",
                        "Kubelet will validate the image at runtime to ensure that it does not run as",
                        "UID 0 (root) and fail to start the container if it does."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_non_root\" <$> TF.attribute",
                    "name": "_runAsNonRoot",
                    "method": "runAsNonRoot",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRunAsNonRoot",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_non_root"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The UID to run the entrypoint of the container process. Defaults to user",
                        "specified in image metadata if unspecified"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_as_user\" <$> TF.attribute",
                    "name": "_runAsUser",
                    "method": "runAsUser",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasRunAsUser",
                    "validate": false,
                    "optional": true,
                    "original": "run_as_user"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The SELinux context to be applied to all containers. If unspecified, the",
                        "container runtime will allocate a random SELinux context for each container.",
                        "May also be set in SecurityContext. If set in both SecurityContext and",
                        "PodSecurityContext, the value specified in SecurityContext takes precedence",
                        "for that container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"se_linux_options\" <$> TF.attribute",
                    "name": "_seLinuxOptions",
                    "method": "seLinuxOptions",
                    "conflicts": [],
                    "type": "TF.Attr s (SeLinuxOptions s)",
                    "class": "HasSeLinuxOptions",
                    "validate": true,
                    "optional": true,
                    "original": "se_linux_options"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of groups applied to the first process run in each container, in",
                        "addition to the container's primary GID. If unspecified, no groups will be",
                        "added to any container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"supplemental_groups\" <$> TF.attribute",
                    "name": "_supplementalGroups",
                    "method": "supplementalGroups",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Integer]",
                    "class": "HasSupplementalGroups",
                    "validate": false,
                    "optional": true,
                    "original": "supplemental_groups"
                }
            ],
            "name": "SecurityContext",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "SecurityContext s",
            "original": "security_context"
        },
        {
            "con": {
                "smart": "newCapabilities",
                "name": "Capabilities'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Added capabilities"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"add\" <$> TF.attribute",
                    "name": "_add",
                    "method": "add",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasAdd",
                    "validate": false,
                    "optional": true,
                    "original": "add"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Removed capabilities"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drop\" <$> TF.attribute",
                    "name": "_drop",
                    "method": "drop",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasDrop",
                    "validate": false,
                    "optional": true,
                    "original": "drop"
                }
            ],
            "name": "Capabilities",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "Capabilities s",
            "original": "capabilities"
        },
        {
            "con": {
                "smart": "newGcePersistentDisk",
                "name": "GcePersistentDisk'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Filesystem type of the volume that you want to mount. Tip: Ensure that the",
                        "filesystem type is supported by the host operating system. Examples: \"ext4\",",
                        "\"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"fs_type\" <$> TF.attribute",
                    "name": "_fsType",
                    "method": "fsType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFsType",
                    "validate": false,
                    "optional": true,
                    "original": "fs_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The partition in the volume that you want to mount. If omitted, the default",
                        "is to mount by volume name. Examples: For volume /dev/sda1, you specify the",
                        "partition as \"1\". Similarly, the volume partition for /dev/sda is \"0\" (or",
                        "you can leave the property empty). More info:",
                        "http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"partition\" <$> TF.attribute",
                    "name": "_partition",
                    "method": "partition",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasPartition",
                    "validate": false,
                    "optional": true,
                    "original": "partition"
                },
                {
                    "default": "_pdName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique name of the PD resource in GCE. Used to identify the disk in GCE.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_name\" <$> TF.attribute",
                    "name": "_pdName",
                    "method": "pdName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdName",
                    "validate": false,
                    "optional": false,
                    "original": "pd_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the ReadOnly setting in VolumeMounts. Defaults to false.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                }
            ],
            "name": "GcePersistentDisk",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_pdName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Unique name of the PD resource in GCE. Used to identify the disk in GCE.",
                        "More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"pd_name\" <$> TF.attribute",
                    "name": "_pdName",
                    "method": "pdName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPdName",
                    "validate": false,
                    "optional": false,
                    "original": "pd_name"
                }
            ],
            "conflicts": [],
            "type": "GcePersistentDisk s",
            "original": "gce_persistent_disk"
        },
        {
            "con": {
                "smart": "newConfigMap",
                "name": "ConfigMap'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Optional: mode bits to use on created files by default. Must be a value",
                        "between 0 and 0777. Defaults to 0644. Directories within the path are not",
                        "affected by this setting. This might be in conflict with other options that",
                        "affect the file mode, like fsGroup, and the result can be other mode bits",
                        "set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_mode\" <$> TF.attribute",
                    "name": "_defaultMode",
                    "method": "defaultMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasDefaultMode",
                    "validate": false,
                    "optional": true,
                    "original": "default_mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If unspecified, each key-value pair in the Data field of the referenced",
                        "ConfigMap will be projected into the volume as a file whose name is the key",
                        "and content is the value. If specified, the listed keys will be projected",
                        "into the specified paths, and unlisted keys will not be present. If a key is",
                        "specified which is not present in the ConfigMap, the volume setup will",
                        "error. Paths must be relative and may not contain the '..' path or start",
                        "with '..'."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"items\" <$> TF.attribute",
                    "name": "_items",
                    "method": "items",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (Items s)]",
                    "class": "HasItems",
                    "validate": true,
                    "optional": true,
                    "original": "items"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Name of the referent. More info:",
                        "http://kubernetes.io/docs/user-guide/identifiers#names"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "name": "ConfigMap",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "ConfigMap s",
            "original": "config_map"
        },
        {
            "con": {
                "smart": "newQuobyte",
                "name": "Quobyte'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Group to map volume access to Default is no group"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"group\" <$> TF.attribute",
                    "name": "_group",
                    "method": "group",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGroup",
                    "validate": false,
                    "optional": true,
                    "original": "group"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to force the Quobyte volume to be mounted with read-only",
                        "permissions. Defaults to false."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"read_only\" <$> TF.attribute",
                    "name": "_readOnly",
                    "method": "readOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasReadOnly",
                    "validate": false,
                    "optional": true,
                    "original": "read_only"
                },
                {
                    "default": "_registry",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Registry represents a single or multiple Quobyte Registry services specified",
                        "as a string as host:port pair (multiple entries are separated with commas)",
                        "which acts as the central registry for volumes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"registry\" <$> TF.attribute",
                    "name": "_registry",
                    "method": "registry",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRegistry",
                    "validate": false,
                    "optional": false,
                    "original": "registry"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User to map volume access to Defaults to serivceaccount user"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"user\" <$> TF.attribute",
                    "name": "_user",
                    "method": "user",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasUser",
                    "validate": false,
                    "optional": true,
                    "original": "user"
                },
                {
                    "default": "_volume",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume is a string that references an already created Quobyte volume by",
                        "name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "_volume",
                    "method": "volume",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolume",
                    "validate": false,
                    "optional": false,
                    "original": "volume"
                }
            ],
            "name": "Quobyte",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_registry",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Registry represents a single or multiple Quobyte Registry services specified",
                        "as a string as host:port pair (multiple entries are separated with commas)",
                        "which acts as the central registry for volumes"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"registry\" <$> TF.attribute",
                    "name": "_registry",
                    "method": "registry",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRegistry",
                    "validate": false,
                    "optional": false,
                    "original": "registry"
                },
                {
                    "default": "_volume",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Volume is a string that references an already created Quobyte volume by",
                        "name."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"volume\" <$> TF.attribute",
                    "name": "_volume",
                    "method": "volume",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVolume",
                    "validate": false,
                    "optional": false,
                    "original": "volume"
                }
            ],
            "conflicts": [],
            "type": "Quobyte s",
            "original": "quobyte"
        },
        {
            "con": {
                "smart": "newPort",
                "name": "Port'"
            },
            "arguments": [],
            "name": "Port",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The name of this port within the service. All ports within the service must",
                        "have unique names. Optional if only one ServicePort is defined on this",
                        "service."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The port on each node on which this service is exposed when `type` is",
                        "`NodePort` or `LoadBalancer`. Usually assigned by the system. If specified,",
                        "it will be allocated to the service if unused or else creation of the",
                        "service will fail. Default is to auto-allocate a port if the `type` of this",
                        "service requires one. More info:",
                        "http://kubernetes.io/docs/user-guide/services#type--nodeport"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"node_port\" <$> TF.attribute",
                    "name": "_computedNodePort",
                    "method": "computedNodePort",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedNodePort",
                    "validate": false,
                    "optional": false,
                    "original": "node_port"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The port that will be exposed by this service."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port\" <$> TF.attribute",
                    "name": "_computedPort",
                    "method": "computedPort",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedPort",
                    "validate": false,
                    "optional": false,
                    "original": "port"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The IP protocol for this port. Supports `TCP` and `UDP`. Default is `TCP`."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"protocol\" <$> TF.attribute",
                    "name": "_computedProtocol",
                    "method": "computedProtocol",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedProtocol",
                    "validate": false,
                    "optional": false,
                    "original": "protocol"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Number or name of the port to access on the pods targeted by the service.",
                        "Number must be in the range 1 to 65535. This field is ignored for services",
                        "with `cluster_ip = \"None\"`. More info:",
                        "http://kubernetes.io/docs/user-guide/services#defining-a-service"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"target_port\" <$> TF.attribute",
                    "name": "_computedTargetPort",
                    "method": "computedTargetPort",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedTargetPort",
                    "validate": false,
                    "optional": false,
                    "original": "target_port"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "Port s",
            "original": "port"
        }
    ],
    "dataSources": [
        {
            "con": {
                "smart": "serviceData",
                "name": "ServiceData'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "name": "ServiceData",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_ingress\" <$> TF.attribute",
                    "name": "_computedLoadBalancerIngress",
                    "method": "computedLoadBalancerIngress",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (LoadBalancerIngress s)]",
                    "class": "HasComputedLoadBalancerIngress",
                    "validate": true,
                    "optional": false,
                    "original": "load_balancer_ingress"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Spec defines the behavior of a service.",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_computedSpec",
                    "method": "computedSpec",
                    "conflicts": [],
                    "type": "TF.Attr s (Spec s)",
                    "class": "HasComputedSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "ServiceData s",
            "original": "kubernetes_service"
        },
        {
            "con": {
                "smart": "storageClassData",
                "name": "StorageClassData'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard storage class's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "name": "StorageClassData",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The parameters for the provisioner that should create volumes of this",
                        "storage class"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"parameters\" <$> TF.attribute",
                    "name": "_computedParameters",
                    "method": "computedParameters",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasComputedParameters",
                    "validate": false,
                    "optional": false,
                    "original": "parameters"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Indicates the type of the provisioner"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"storage_provisioner\" <$> TF.attribute",
                    "name": "_computedStorageProvisioner",
                    "method": "computedStorageProvisioner",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedStorageProvisioner",
                    "validate": false,
                    "optional": false,
                    "original": "storage_provisioner"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard storage class's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "StorageClassData s",
            "original": "kubernetes_storage_class"
        }
    ],
    "resources": [
        {
            "con": {
                "smart": "configMapResource",
                "name": "ConfigMapResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A map of the configuration data."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data\" <$> TF.attribute",
                    "name": "_data'",
                    "method": "data'",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasData'",
                    "validate": false,
                    "optional": true,
                    "original": "data"
                },
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard config map's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "name": "ConfigMapResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard config map's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "ConfigMapResource s",
            "original": "kubernetes_config_map"
        },
        {
            "con": {
                "smart": "horizontalPodAutoscalerResource",
                "name": "HorizontalPodAutoscalerResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard horizontal pod autoscaler's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Behaviour of the autoscaler. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (Spec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "name": "HorizontalPodAutoscalerResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard horizontal pod autoscaler's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Behaviour of the autoscaler. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (Spec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "HorizontalPodAutoscalerResource s",
            "original": "kubernetes_horizontal_pod_autoscaler"
        },
        {
            "con": {
                "smart": "limitRangeResource",
                "name": "LimitRangeResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard limit range's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Spec defines the limits enforced. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (Spec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": true,
                    "original": "spec"
                }
            ],
            "name": "LimitRangeResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard limit range's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "LimitRangeResource s",
            "original": "kubernetes_limit_range"
        },
        {
            "con": {
                "smart": "namespaceResource",
                "name": "NamespaceResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard namespace's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "name": "NamespaceResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard namespace's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "NamespaceResource s",
            "original": "kubernetes_namespace"
        },
        {
            "con": {
                "smart": "persistentVolumeResource",
                "name": "PersistentVolumeResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard persistent volume's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec of the persistent volume owned by the cluster"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (Spec s)]",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "name": "PersistentVolumeResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard persistent volume's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec of the persistent volume owned by the cluster"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (Spec s)]",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeResource s",
            "original": "kubernetes_persistent_volume"
        },
        {
            "con": {
                "smart": "persistentVolumeClaimResource",
                "name": "PersistentVolumeClaimResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard persistent volume claim's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the desired characteristics of a volume requested by a pod",
                        "author. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#persistentvolumeclaims"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (Spec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to wait for the claim to reach `Bound` state (to find volume in",
                        "which to claim the space)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"wait_until_bound\" <$> TF.attribute",
                    "name": "_waitUntilBound",
                    "method": "waitUntilBound",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasWaitUntilBound",
                    "validate": false,
                    "optional": true,
                    "original": "wait_until_bound"
                }
            ],
            "name": "PersistentVolumeClaimResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard persistent volume claim's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the desired characteristics of a volume requested by a pod",
                        "author. More info:",
                        "http://kubernetes.io/docs/user-guide/persistent-volumes#persistentvolumeclaims"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (Spec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "PersistentVolumeClaimResource s",
            "original": "kubernetes_persistent_volume_claim"
        },
        {
            "con": {
                "smart": "podResource",
                "name": "PodResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard pod's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec of the pod owned by the cluster"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (Spec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "name": "PodResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard pod's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec of the pod owned by the cluster"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (Spec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "PodResource s",
            "original": "kubernetes_pod"
        },
        {
            "con": {
                "smart": "replicationControllerResource",
                "name": "ReplicationControllerResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard replication controller's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the specification of the desired behavior of the replication",
                        "controller. More info:",
                        "http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (Spec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "name": "ReplicationControllerResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard replication controller's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the specification of the desired behavior of the replication",
                        "controller. More info:",
                        "http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (Spec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "ReplicationControllerResource s",
            "original": "kubernetes_replication_controller"
        },
        {
            "con": {
                "smart": "resourceQuotaResource",
                "name": "ResourceQuotaResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard resource quota's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Spec defines the desired quota.",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (Spec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": true,
                    "original": "spec"
                }
            ],
            "name": "ResourceQuotaResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard resource quota's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "ResourceQuotaResource s",
            "original": "kubernetes_resource_quota"
        },
        {
            "con": {
                "smart": "secretResource",
                "name": "SecretResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A map of the secret data."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"data\" <$> TF.attribute",
                    "name": "_data'",
                    "method": "data'",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasData'",
                    "validate": false,
                    "optional": true,
                    "original": "data"
                },
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard secret's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "TF.value \"Opaque\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Type of secret"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": true,
                    "original": "type"
                }
            ],
            "name": "SecretResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard secret's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "SecretResource s",
            "original": "kubernetes_secret"
        },
        {
            "con": {
                "smart": "serviceResource",
                "name": "ServiceResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the behavior of a service.",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (Spec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "name": "ServiceResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"load_balancer_ingress\" <$> TF.attribute",
                    "name": "_computedLoadBalancerIngress",
                    "method": "computedLoadBalancerIngress",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (LoadBalancerIngress s)]",
                    "class": "HasComputedLoadBalancerIngress",
                    "validate": true,
                    "optional": false,
                    "original": "load_balancer_ingress"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_spec",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Spec defines the behavior of a service.",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"spec\" <$> TF.attribute",
                    "name": "_spec",
                    "method": "spec",
                    "conflicts": [],
                    "type": "TF.Attr s (Spec s)",
                    "class": "HasSpec",
                    "validate": true,
                    "optional": false,
                    "original": "spec"
                }
            ],
            "conflicts": [],
            "type": "ServiceResource s",
            "original": "kubernetes_service"
        },
        {
            "con": {
                "smart": "serviceAccountResource",
                "name": "ServiceAccountResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of references to secrets in the same namespace to use for pulling any",
                        "images in pods that reference this Service Account. More info:",
                        "http://kubernetes.io/docs/user-guide/secrets#manually-specifying-an-imagepullsecret"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"image_pull_secret\" <$> TF.attribute",
                    "name": "_imagePullSecret",
                    "method": "imagePullSecret",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (ImagePullSecret s)]",
                    "class": "HasImagePullSecret",
                    "validate": true,
                    "optional": true,
                    "original": "image_pull_secret"
                },
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service account's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of secrets allowed to be used by pods running using this Service",
                        "Account. More info: http://kubernetes.io/docs/user-guide/secrets"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"secret\" <$> TF.attribute",
                    "name": "_secret",
                    "method": "secret",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (Secret s)]",
                    "class": "HasSecret",
                    "validate": true,
                    "optional": true,
                    "original": "secret"
                }
            ],
            "name": "ServiceAccountResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_secret_name\" <$> TF.attribute",
                    "name": "_computedDefaultSecretName",
                    "method": "computedDefaultSecretName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedDefaultSecretName",
                    "validate": false,
                    "optional": false,
                    "original": "default_secret_name"
                }
            ],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard service account's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                }
            ],
            "conflicts": [],
            "type": "ServiceAccountResource s",
            "original": "kubernetes_service_account"
        },
        {
            "con": {
                "smart": "storageClassResource",
                "name": "StorageClassResource'"
            },
            "arguments": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard storage class's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The parameters for the provisioner that should create volumes of this",
                        "storage class"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"parameters\" <$> TF.attribute",
                    "name": "_parameters",
                    "method": "parameters",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasParameters",
                    "validate": false,
                    "optional": true,
                    "original": "parameters"
                },
                {
                    "default": "_storageProvisioner",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Indicates the type of the provisioner"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"storage_provisioner\" <$> TF.attribute",
                    "name": "_storageProvisioner",
                    "method": "storageProvisioner",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasStorageProvisioner",
                    "validate": false,
                    "optional": false,
                    "original": "storage_provisioner"
                }
            ],
            "name": "StorageClassResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_metadata",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Standard storage class's metadata. More info:",
                        "https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"metadata\" <$> TF.attribute",
                    "name": "_metadata",
                    "method": "metadata",
                    "conflicts": [],
                    "type": "TF.Attr s (Metadata s)",
                    "class": "HasMetadata",
                    "validate": true,
                    "optional": false,
                    "original": "metadata"
                },
                {
                    "default": "_storageProvisioner",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Indicates the type of the provisioner"
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"storage_provisioner\" <$> TF.attribute",
                    "name": "_storageProvisioner",
                    "method": "storageProvisioner",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasStorageProvisioner",
                    "validate": false,
                    "optional": false,
                    "original": "storage_provisioner"
                }
            ],
            "conflicts": [],
            "type": "StorageClassResource s",
            "original": "kubernetes_storage_class"
        }
    ],
    "schema": {
        "con": {
            "smart": "newProvider",
            "name": "Provider'"
        },
        "arguments": [
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "PEM-encoded client certificate for TLS authentication."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"client_certificate\" <$>",
                "name": "_clientCertificate",
                "method": "clientCertificate",
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasClientCertificate",
                "validate": false,
                "optional": true,
                "original": "client_certificate"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "PEM-encoded client certificate key for TLS authentication."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"client_key\" <$>",
                "name": "_clientKey",
                "method": "clientKey",
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasClientKey",
                "validate": false,
                "optional": true,
                "original": "client_key"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "PEM-encoded root certificates bundle for TLS authentication."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"cluster_ca_certificate\" <$>",
                "name": "_clusterCaCertificate",
                "method": "clusterCaCertificate",
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasClusterCaCertificate",
                "validate": false,
                "optional": true,
                "original": "cluster_ca_certificate"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [],
                "forceNew": false,
                "encoder": "TF.assign \"config_context\" <$>",
                "name": "_configContext",
                "method": "configContext",
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasConfigContext",
                "validate": false,
                "optional": true,
                "original": "config_context"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [],
                "forceNew": false,
                "encoder": "TF.assign \"config_context_auth_info\" <$>",
                "name": "_configContextAuthInfo",
                "method": "configContextAuthInfo",
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasConfigContextAuthInfo",
                "validate": false,
                "optional": true,
                "original": "config_context_auth_info"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [],
                "forceNew": false,
                "encoder": "TF.assign \"config_context_cluster\" <$>",
                "name": "_configContextCluster",
                "method": "configContextCluster",
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasConfigContextCluster",
                "validate": false,
                "optional": true,
                "original": "config_context_cluster"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "Path to the kube config file, defaults to ~/.kube/config"
                ],
                "forceNew": false,
                "encoder": "TF.assign \"config_path\" <$>",
                "name": "_configPath",
                "method": "configPath",
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasConfigPath",
                "validate": false,
                "optional": true,
                "original": "config_path"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "The hostname (in form of URI) of Kubernetes master."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"host\" <$>",
                "name": "_host",
                "method": "host",
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasHost",
                "validate": false,
                "optional": true,
                "original": "host"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "Whether server should be accessed without verifying the TLS certificate."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"insecure\" <$>",
                "name": "_insecure",
                "method": "insecure",
                "conflicts": [],
                "type": "P.Maybe P.Bool",
                "class": "HasInsecure",
                "validate": false,
                "optional": true,
                "original": "insecure"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "Load local kubeconfig."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"load_config_file\" <$>",
                "name": "_loadConfigFile",
                "method": "loadConfigFile",
                "conflicts": [],
                "type": "P.Maybe P.Bool",
                "class": "HasLoadConfigFile",
                "validate": false,
                "optional": true,
                "original": "load_config_file"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "The password to use for HTTP basic authentication when accessing the",
                    "Kubernetes master endpoint."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"password\" <$>",
                "name": "_password",
                "method": "password",
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasPassword",
                "validate": false,
                "optional": true,
                "original": "password"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "Token to authentifcate an service account"
                ],
                "forceNew": false,
                "encoder": "TF.assign \"token\" <$>",
                "name": "_token",
                "method": "token",
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasToken",
                "validate": false,
                "optional": true,
                "original": "token"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "The username to use for HTTP basic authentication when accessing the",
                    "Kubernetes master endpoint."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"username\" <$>",
                "name": "_username",
                "method": "username",
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasUsername",
                "validate": false,
                "optional": true,
                "original": "username"
            }
        ],
        "name": "Provider",
        "threaded": false,
        "attributes": [],
        "parameters": [],
        "conflicts": [],
        "type": "Provider",
        "original": "provider"
    },
    "dependencies": [
        "base",
        "unordered-containers",
        "text",
        "terrafomo",
        "hashable",
        "microlens"
    ],
    "name": "Kubernetes",
    "package": "terrafomo-kubernetes",
    "original": "kubernetes"
}