{
    "settings": [
        {
            "arguments": [
                {
                    "default": "TF.value \"vmxnet3\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The controller type. Can be one of e1000, e1000e, or vmxnet3."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"adapter_type\" <$> TF.attribute",
                    "name": "adapter_type",
                    "method": "adapterType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasAdapterType",
                    "optional": true,
                    "label": "_adapterType"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The upper bandwidth limit of this network interface, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"bandwidth_limit\" <$> TF.attribute",
                    "name": "bandwidth_limit",
                    "method": "bandwidthLimit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasBandwidthLimit",
                    "optional": true,
                    "label": "_bandwidthLimit"
                },
                {
                    "default": "TF.value 0",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The bandwidth reservation of this network interface, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"bandwidth_reservation\" <$> TF.attribute",
                    "name": "bandwidth_reservation",
                    "method": "bandwidthReservation",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasBandwidthReservation",
                    "optional": true,
                    "label": "_bandwidthReservation"
                },
                {
                    "default": "TF.value \"normal\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The bandwidth share allocation level for this interface. Can be one of low,",
                        "normal, high, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"bandwidth_share_level\" <$> TF.attribute",
                    "name": "bandwidth_share_level",
                    "method": "bandwidthShareLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasBandwidthShareLevel",
                    "optional": true,
                    "label": "_bandwidthShareLevel"
                },
                {
                    "default": "_networkId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The ID of the network to connect this network interface to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_id\" <$> TF.attribute",
                    "name": "network_id",
                    "method": "networkId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNetworkId",
                    "optional": false,
                    "label": "_networkId"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If true, the mac_address field is treated as a static MAC address and set",
                        "accordingly."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"use_static_mac\" <$> TF.attribute",
                    "name": "use_static_mac",
                    "method": "useStaticMac",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasUseStaticMac",
                    "optional": true,
                    "label": "_useStaticMac"
                }
            ],
            "name": "NetworkInterface",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The share count for this network interface when the share level is custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"bandwidth_share_count\" <$> TF.attribute",
                    "name": "bandwidth_share_count",
                    "method": "computedBandwidthShareCount",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedBandwidthShareCount",
                    "optional": true,
                    "label": "_computedBandwidthShareCount"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The internally-computed address of this device, such as scsi:0:1, denoting",
                        "scsi bus #0 and device unit 1."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"device_address\" <$> TF.attribute",
                    "name": "device_address",
                    "method": "computedDeviceAddress",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedDeviceAddress",
                    "optional": false,
                    "label": "_computedDeviceAddress"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique device ID for this device within its virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "key",
                    "method": "computedKey",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedKey",
                    "optional": false,
                    "label": "_computedKey"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The MAC address of this network interface. Can only be manually set if",
                        "use_static_mac is true."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mac_address\" <$> TF.attribute",
                    "name": "mac_address",
                    "method": "computedMacAddress",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMacAddress",
                    "optional": true,
                    "label": "_computedMacAddress"
                }
            ],
            "parameters": [
                {
                    "default": "_networkId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The ID of the network to connect this network interface to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_id\" <$> TF.attribute",
                    "name": "network_id",
                    "method": "networkId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNetworkId",
                    "optional": false,
                    "label": "_networkId"
                }
            ],
            "hashable": false,
            "type": "NetworkInterface s",
            "original": "network_interface"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A map of customizable vApp properties and their values. Allows customization",
                        "of VMs cloned from OVF templates which have customizable vApp properties."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"properties\" <$> TF.attribute",
                    "name": "properties",
                    "method": "properties",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasProperties",
                    "optional": true,
                    "label": "_properties"
                }
            ],
            "name": "Vapp",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "Vapp s",
            "original": "vapp"
        },
        {
            "arguments": [
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If this is true, the disk is attached instead of created. Implies",
                        "keep_on_remove."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"attach\" <$> TF.attribute",
                    "name": "attach",
                    "method": "attach",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasAttach",
                    "optional": true,
                    "label": "_attach"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The datastore ID for this virtual disk, if different than the virtual",
                        "machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datastore_id\" <$> TF.attribute",
                    "name": "datastore_id",
                    "method": "datastoreId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastoreId",
                    "optional": true,
                    "label": "_datastoreId"
                },
                {
                    "default": "TF.value \"persistent\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The mode of this this virtual disk for purposes of writes and snapshotting.",
                        "Can be one of append, independent_nonpersistent, independent_persistent,",
                        "nonpersistent, persistent, or undoable."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disk_mode\" <$> TF.attribute",
                    "name": "disk_mode",
                    "method": "diskMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDiskMode",
                    "optional": true,
                    "label": "_diskMode"
                },
                {
                    "default": "TF.value \"sharingNone\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The sharing mode of this virtual disk. Can be one of sharingMultiWriter or",
                        "sharingNone."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disk_sharing\" <$> TF.attribute",
                    "name": "disk_sharing",
                    "method": "diskSharing",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDiskSharing",
                    "optional": true,
                    "label": "_diskSharing"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The virtual disk file zeroing policy when thin_provision is not true. The",
                        "default is false, which lazily-zeros the disk, speeding up thick-provisioned",
                        "disk creation time."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"eagerly_scrub\" <$> TF.attribute",
                    "name": "eagerly_scrub",
                    "method": "eagerlyScrub",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasEagerlyScrub",
                    "optional": true,
                    "label": "_eagerlyScrub"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The upper limit of IOPS that this disk can use."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"io_limit\" <$> TF.attribute",
                    "name": "io_limit",
                    "method": "ioLimit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasIoLimit",
                    "optional": true,
                    "label": "_ioLimit"
                },
                {
                    "default": "TF.value 0",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The I/O guarantee that this disk has, in IOPS."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"io_reservation\" <$> TF.attribute",
                    "name": "io_reservation",
                    "method": "ioReservation",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasIoReservation",
                    "optional": true,
                    "label": "_ioReservation"
                },
                {
                    "default": "TF.value 0",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The share count for this disk when the share level is custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"io_share_count\" <$> TF.attribute",
                    "name": "io_share_count",
                    "method": "ioShareCount",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasIoShareCount",
                    "optional": true,
                    "label": "_ioShareCount"
                },
                {
                    "default": "TF.value \"normal\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The share allocation level for this disk. Can be one of low, normal, high,",
                        "or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"io_share_level\" <$> TF.attribute",
                    "name": "io_share_level",
                    "method": "ioShareLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIoShareLevel",
                    "optional": true,
                    "label": "_ioShareLevel"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Set to true to keep the underlying VMDK file when removing this virtual disk",
                        "from configuration."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"keep_on_remove\" <$> TF.attribute",
                    "name": "keep_on_remove",
                    "method": "keepOnRemove",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasKeepOnRemove",
                    "optional": true,
                    "label": "_keepOnRemove"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A unique label for this disk."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"label\" <$> TF.attribute",
                    "name": "label",
                    "method": "label",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLabel",
                    "optional": true,
                    "label": "_label"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The file name of the disk. This can be either a name or path relative to the",
                        "root of the datastore. If simply a name, the disk is located with the",
                        "virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": true,
                    "label": "_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The size of the disk, in GB."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"size\" <$> TF.attribute",
                    "name": "size",
                    "method": "size",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasSize",
                    "optional": true,
                    "label": "_size"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If true, this disk is thin provisioned, with space for the file being",
                        "allocated on an as-needed basis."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"thin_provisioned\" <$> TF.attribute",
                    "name": "thin_provisioned",
                    "method": "thinProvisioned",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasThinProvisioned",
                    "optional": true,
                    "label": "_thinProvisioned"
                },
                {
                    "default": "TF.value 0",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The unique device number for this disk. This number determines where on the",
                        "SCSI bus this device will be attached."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"unit_number\" <$> TF.attribute",
                    "name": "unit_number",
                    "method": "unitNumber",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasUnitNumber",
                    "optional": true,
                    "label": "_unitNumber"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If true, writes for this disk are sent directly to the filesystem",
                        "immediately instead of being buffered."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"write_through\" <$> TF.attribute",
                    "name": "write_through",
                    "method": "writeThrough",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasWriteThrough",
                    "optional": true,
                    "label": "_writeThrough"
                }
            ],
            "name": "Disk",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The internally-computed address of this device, such as scsi:0:1, denoting",
                        "scsi bus #0 and device unit 1."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"device_address\" <$> TF.attribute",
                    "name": "device_address",
                    "method": "computedDeviceAddress",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedDeviceAddress",
                    "optional": false,
                    "label": "_computedDeviceAddress"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique device ID for this device within its virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "key",
                    "method": "computedKey",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedKey",
                    "optional": false,
                    "label": "_computedKey"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The full path of the virtual disk. This can only be provided if attach is",
                        "set to true, otherwise it is a read-only value."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "path",
                    "method": "computedPath",
                    "conflicts": [
                        "_datastoreClusterId"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedPath",
                    "optional": true,
                    "label": "_computedPath"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The UUID of the virtual disk."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uuid\" <$> TF.attribute",
                    "name": "uuid",
                    "method": "computedUuid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUuid",
                    "optional": false,
                    "label": "_computedUuid"
                }
            ],
            "parameters": [],
            "hashable": false,
            "type": "Disk s",
            "original": "disk"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The new administrator password for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"admin_password\" <$> TF.attribute",
                    "name": "admin_password",
                    "method": "adminPassword",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasAdminPassword",
                    "optional": true,
                    "label": "_adminPassword"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies whether or not the VM automatically logs on as Administrator."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"auto_logon\" <$> TF.attribute",
                    "name": "auto_logon",
                    "method": "autoLogon",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasAutoLogon",
                    "optional": true,
                    "label": "_autoLogon"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies how many times the VM should auto-logon the Administrator account",
                        "when auto_logon is true."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"auto_logon_count\" <$> TF.attribute",
                    "name": "auto_logon_count",
                    "method": "autoLogonCount",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasAutoLogonCount",
                    "optional": true,
                    "label": "_autoLogonCount"
                },
                {
                    "default": "_computerName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The host name for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"computer_name\" <$> TF.attribute",
                    "name": "computer_name",
                    "method": "computerName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputerName",
                    "optional": false,
                    "label": "_computerName"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The password of the domain administrator used to join this virtual machine",
                        "to the domain."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"domain_admin_password\" <$> TF.attribute",
                    "name": "domain_admin_password",
                    "method": "domainAdminPassword",
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "method": "workgroup",
                            "label": "_workgroup"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDomainAdminPassword",
                    "optional": true,
                    "label": "_domainAdminPassword"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The user account of the domain administrator used to join this virtual",
                        "machine to the domain."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"domain_admin_user\" <$> TF.attribute",
                    "name": "domain_admin_user",
                    "method": "domainAdminUser",
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "method": "workgroup",
                            "label": "_workgroup"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDomainAdminUser",
                    "optional": true,
                    "label": "_domainAdminUser"
                },
                {
                    "default": "TF.value \"Administrator\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The full name of the user of this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"full_name\" <$> TF.attribute",
                    "name": "full_name",
                    "method": "fullName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFullName",
                    "optional": true,
                    "label": "_fullName"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The domain that the virtual machine should join."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"join_domain\" <$> TF.attribute",
                    "name": "join_domain",
                    "method": "joinDomain",
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "method": "workgroup",
                            "label": "_workgroup"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasJoinDomain",
                    "optional": true,
                    "label": "_joinDomain"
                },
                {
                    "default": "TF.value \"Managed by Terraform\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The organization name this virtual machine is being installed for."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"organization_name\" <$> TF.attribute",
                    "name": "organization_name",
                    "method": "organizationName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasOrganizationName",
                    "optional": true,
                    "label": "_organizationName"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The product key for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"product_key\" <$> TF.attribute",
                    "name": "product_key",
                    "method": "productKey",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasProductKey",
                    "optional": true,
                    "label": "_productKey"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of commands to run at first user logon, after guest customization."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_once_command_list\" <$> TF.attribute",
                    "name": "run_once_command_list",
                    "method": "runOnceCommandList",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasRunOnceCommandList",
                    "optional": true,
                    "label": "_runOnceCommandList"
                },
                {
                    "default": "TF.value 85",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The new time zone for the virtual machine. This is a sysprep-dictated",
                        "timezone code."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"time_zone\" <$> TF.attribute",
                    "name": "time_zone",
                    "method": "timeZone",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasTimeZone",
                    "optional": true,
                    "label": "_timeZone"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The workgroup for this virtual machine if not joining a domain."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"workgroup\" <$> TF.attribute",
                    "name": "workgroup",
                    "method": "workgroup",
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "method": "domainAdminPassword",
                            "label": "_domainAdminPassword"
                        },
                        {
                            "default": "TF.Nil",
                            "method": "joinDomain",
                            "label": "_joinDomain"
                        },
                        {
                            "default": "TF.Nil",
                            "method": "domainAdminUser",
                            "label": "_domainAdminUser"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasWorkgroup",
                    "optional": true,
                    "label": "_workgroup"
                }
            ],
            "name": "WindowsOptions",
            "attributes": [],
            "parameters": [
                {
                    "default": "_computerName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The host name for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"computer_name\" <$> TF.attribute",
                    "name": "computer_name",
                    "method": "computerName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputerName",
                    "optional": false,
                    "label": "_computerName"
                }
            ],
            "hashable": false,
            "type": "WindowsOptions s",
            "original": "windows_options"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The customization spec for this clone. This allows the user to configure the",
                        "virtual machine post-clone."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"customize\" <$> TF.attribute",
                    "name": "customize",
                    "method": "customize",
                    "conflicts": [],
                    "type": "TF.Attr s [Customize s]",
                    "class": "HasCustomize",
                    "optional": true,
                    "label": "_customize"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether or not to create a linked clone when cloning. When this option is",
                        "used, the source VM must have a single snapshot associated with it."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"linked_clone\" <$> TF.attribute",
                    "name": "linked_clone",
                    "method": "linkedClone",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasLinkedClone",
                    "optional": true,
                    "label": "_linkedClone"
                },
                {
                    "default": "_templateUuid",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The UUID of the source virtual machine or template."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"template_uuid\" <$> TF.attribute",
                    "name": "template_uuid",
                    "method": "templateUuid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTemplateUuid",
                    "optional": false,
                    "label": "_templateUuid"
                },
                {
                    "default": "TF.value 30",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The timeout, in minutes, to wait for the virtual machine clone to complete."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"timeout\" <$> TF.attribute",
                    "name": "timeout",
                    "method": "timeout",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasTimeout",
                    "optional": true,
                    "label": "_timeout"
                }
            ],
            "name": "Clone",
            "attributes": [],
            "parameters": [
                {
                    "default": "_templateUuid",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The UUID of the source virtual machine or template."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"template_uuid\" <$> TF.attribute",
                    "name": "template_uuid",
                    "method": "templateUuid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTemplateUuid",
                    "optional": false,
                    "label": "_templateUuid"
                }
            ],
            "hashable": false,
            "type": "Clone s",
            "original": "clone"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Indicates whether the device should be mapped to a remote client device"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"client_device\" <$> TF.attribute",
                    "name": "client_device",
                    "method": "clientDevice",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasClientDevice",
                    "optional": true,
                    "label": "_clientDevice"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The datastore ID the ISO is located on."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datastore_id\" <$> TF.attribute",
                    "name": "datastore_id",
                    "method": "datastoreId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastoreId",
                    "optional": true,
                    "label": "_datastoreId"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The path to the ISO file on the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "optional": true,
                    "label": "_path"
                }
            ],
            "name": "Cdrom",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The internally-computed address of this device, such as scsi:0:1, denoting",
                        "scsi bus #0 and device unit 1."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"device_address\" <$> TF.attribute",
                    "name": "device_address",
                    "method": "computedDeviceAddress",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedDeviceAddress",
                    "optional": false,
                    "label": "_computedDeviceAddress"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique device ID for this device within its virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "key",
                    "method": "computedKey",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedKey",
                    "optional": false,
                    "label": "_computedKey"
                }
            ],
            "parameters": [],
            "hashable": false,
            "type": "Cdrom s",
            "original": "cdrom"
        },
        {
            "arguments": [],
            "name": "Ports",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The linkable identifier for this port entry."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "key",
                    "method": "computedKey",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedKey",
                    "optional": false,
                    "label": "_computedKey"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The MAC addresses of the network service of the virtual machine connected on",
                        "this port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mac_addresses\" <$> TF.attribute",
                    "name": "mac_addresses",
                    "method": "computedMacAddresses",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedMacAddresses",
                    "optional": false,
                    "label": "_computedMacAddresses"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Type type of the entity connected on this port. Possible values are host",
                        "(VMKkernel), systemManagement (service console), virtualMachine, or unknown."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "type",
                    "method": "computedType'",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedType'",
                    "optional": false,
                    "label": "_computedType'"
                }
            ],
            "parameters": [],
            "hashable": false,
            "type": "Ports s",
            "original": "ports"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The list of DNS servers for a virtual network adapter with a static IP",
                        "address."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dns_server_list\" <$> TF.attribute",
                    "name": "dns_server_list",
                    "method": "dnsServerList",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasDnsServerList",
                    "optional": true,
                    "label": "_dnsServerList"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of DNS search domains to add to the DNS configuration on the virtual",
                        "machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dns_suffix_list\" <$> TF.attribute",
                    "name": "dns_suffix_list",
                    "method": "dnsSuffixList",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasDnsSuffixList",
                    "optional": true,
                    "label": "_dnsSuffixList"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The IPv4 default gateway when using network_interface customization on the",
                        "virtual machine. This address must be local to a static IPv4 address",
                        "configured in an interface sub-resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ipv4_gateway\" <$> TF.attribute",
                    "name": "ipv4_gateway",
                    "method": "ipv4Gateway",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIpv4Gateway",
                    "optional": true,
                    "label": "_ipv4Gateway"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The IPv6 default gateway when using network_interface customization on the",
                        "virtual machine. This address must be local to a static IPv4 address",
                        "configured in an interface sub-resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ipv6_gateway\" <$> TF.attribute",
                    "name": "ipv6_gateway",
                    "method": "ipv6Gateway",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIpv6Gateway",
                    "optional": true,
                    "label": "_ipv6Gateway"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of configuration options specific to Linux virtual machines."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"linux_options\" <$> TF.attribute",
                    "name": "linux_options",
                    "method": "linuxOptions",
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "method": "windowsSysprepText",
                            "label": "_windowsSysprepText"
                        },
                        {
                            "default": "TF.Nil",
                            "method": "windowsOptions",
                            "label": "_windowsOptions"
                        }
                    ],
                    "type": "TF.Attr s [LinuxOptions s]",
                    "class": "HasLinuxOptions",
                    "optional": true,
                    "label": "_linuxOptions"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A specification of network interface configuration options."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_interface\" <$> TF.attribute",
                    "name": "network_interface",
                    "method": "networkInterface",
                    "conflicts": [],
                    "type": "TF.Attr s [NetworkInterface s]",
                    "class": "HasNetworkInterface",
                    "optional": true,
                    "label": "_networkInterface"
                },
                {
                    "default": "TF.value 10",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The amount of time, in minutes, to wait for guest OS customization to",
                        "complete before returning with an error. Setting this value to 0 or a",
                        "negative value skips the waiter."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"timeout\" <$> TF.attribute",
                    "name": "timeout",
                    "method": "timeout",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasTimeout",
                    "optional": true,
                    "label": "_timeout"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of configuration options specific to Windows virtual machines."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"windows_options\" <$> TF.attribute",
                    "name": "windows_options",
                    "method": "windowsOptions",
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "method": "windowsSysprepText",
                            "label": "_windowsSysprepText"
                        },
                        {
                            "default": "TF.Nil",
                            "method": "linuxOptions",
                            "label": "_linuxOptions"
                        }
                    ],
                    "type": "TF.Attr s [WindowsOptions s]",
                    "class": "HasWindowsOptions",
                    "optional": true,
                    "label": "_windowsOptions"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Use this option to specify a windows sysprep file directly."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"windows_sysprep_text\" <$> TF.attribute",
                    "name": "windows_sysprep_text",
                    "method": "windowsSysprepText",
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "method": "linuxOptions",
                            "label": "_linuxOptions"
                        },
                        {
                            "default": "TF.Nil",
                            "method": "windowsOptions",
                            "label": "_windowsOptions"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasWindowsSysprepText",
                    "optional": true,
                    "label": "_windowsSysprepText"
                }
            ],
            "name": "Customize",
            "attributes": [],
            "parameters": [],
            "hashable": false,
            "type": "Customize s",
            "original": "customize"
        },
        {
            "arguments": [
                {
                    "default": "_maxVlan",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The minimum VLAN to use in the range."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"max_vlan\" <$> TF.attribute",
                    "name": "max_vlan",
                    "method": "maxVlan",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasMaxVlan",
                    "optional": false,
                    "label": "_maxVlan"
                },
                {
                    "default": "_minVlan",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The minimum VLAN to use in the range."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"min_vlan\" <$> TF.attribute",
                    "name": "min_vlan",
                    "method": "minVlan",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasMinVlan",
                    "optional": false,
                    "label": "_minVlan"
                }
            ],
            "name": "VlanRange",
            "attributes": [],
            "parameters": [
                {
                    "default": "_maxVlan",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The minimum VLAN to use in the range."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"max_vlan\" <$> TF.attribute",
                    "name": "max_vlan",
                    "method": "maxVlan",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasMaxVlan",
                    "optional": false,
                    "label": "_maxVlan"
                },
                {
                    "default": "_minVlan",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The minimum VLAN to use in the range."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"min_vlan\" <$> TF.attribute",
                    "name": "min_vlan",
                    "method": "minVlan",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasMinVlan",
                    "optional": false,
                    "label": "_minVlan"
                }
            ],
            "hashable": false,
            "type": "VlanRange s",
            "original": "vlan_range"
        },
        {
            "arguments": [
                {
                    "default": "_devices",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the physical NIC to be added to the proxy switch."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"devices\" <$> TF.attribute",
                    "name": "devices",
                    "method": "devices",
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (TF.Attr s P.Text))",
                    "class": "HasDevices",
                    "optional": false,
                    "label": "_devices"
                },
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host this specification applies to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "host_system_id",
                    "method": "hostSystemId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "optional": false,
                    "label": "_hostSystemId"
                }
            ],
            "name": "Host",
            "attributes": [],
            "parameters": [
                {
                    "default": "_devices",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the physical NIC to be added to the proxy switch."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"devices\" <$> TF.attribute",
                    "name": "devices",
                    "method": "devices",
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (TF.Attr s P.Text))",
                    "class": "HasDevices",
                    "optional": false,
                    "label": "_devices"
                },
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host this specification applies to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "host_system_id",
                    "method": "hostSystemId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "optional": false,
                    "label": "_hostSystemId"
                }
            ],
            "hashable": false,
            "type": "Host s",
            "original": "host"
        },
        {
            "arguments": [],
            "name": "Disks",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"eagerly_scrub\" <$> TF.attribute",
                    "name": "eagerly_scrub",
                    "method": "computedEagerlyScrub",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedEagerlyScrub",
                    "optional": false,
                    "label": "_computedEagerlyScrub"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"size\" <$> TF.attribute",
                    "name": "size",
                    "method": "computedSize",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedSize",
                    "optional": false,
                    "label": "_computedSize"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"thin_provisioned\" <$> TF.attribute",
                    "name": "thin_provisioned",
                    "method": "computedThinProvisioned",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedThinProvisioned",
                    "optional": false,
                    "label": "_computedThinProvisioned"
                }
            ],
            "parameters": [],
            "hashable": false,
            "type": "Disks s",
            "original": "disks"
        },
        {
            "arguments": [
                {
                    "default": "_domain",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The FQDN for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"domain\" <$> TF.attribute",
                    "name": "domain",
                    "method": "domain",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDomain",
                    "optional": false,
                    "label": "_domain"
                },
                {
                    "default": "_hostName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The host name for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_name\" <$> TF.attribute",
                    "name": "host_name",
                    "method": "hostName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostName",
                    "optional": false,
                    "label": "_hostName"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies whether or not the hardware clock should be in UTC or not."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"hw_clock_utc\" <$> TF.attribute",
                    "name": "hw_clock_utc",
                    "method": "hwClockUtc",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHwClockUtc",
                    "optional": true,
                    "label": "_hwClockUtc"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Customize the time zone on the VM. This should be a time zone-style entry,",
                        "like America/Los_Angeles."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"time_zone\" <$> TF.attribute",
                    "name": "time_zone",
                    "method": "timeZone",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTimeZone",
                    "optional": true,
                    "label": "_timeZone"
                }
            ],
            "name": "LinuxOptions",
            "attributes": [],
            "parameters": [
                {
                    "default": "_domain",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The FQDN for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"domain\" <$> TF.attribute",
                    "name": "domain",
                    "method": "domain",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDomain",
                    "optional": false,
                    "label": "_domain"
                },
                {
                    "default": "_hostName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The host name for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_name\" <$> TF.attribute",
                    "name": "host_name",
                    "method": "hostName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostName",
                    "optional": false,
                    "label": "_hostName"
                }
            ],
            "hashable": false,
            "type": "LinuxOptions s",
            "original": "linux_options"
        }
    ],
    "arguments": [
        {
            "default": "P.Nothing",
            "computed": false,
            "required": false,
            "help": [
                "If set, VMware vSphere client will permit unverifiable SSL certificates."
            ],
            "forceNew": false,
            "encoder": "TF.assign \"allow_unverified_ssl\" <$>",
            "name": "allow_unverified_ssl",
            "method": "allowUnverifiedSsl",
            "conflicts": [],
            "type": "P.Maybe P.Bool",
            "class": "HasAllowUnverifiedSsl",
            "optional": true,
            "label": "_allowUnverifiedSsl"
        },
        {
            "default": "P.Nothing",
            "computed": false,
            "required": false,
            "help": [
                "Govmomi debug"
            ],
            "forceNew": false,
            "encoder": "TF.assign \"client_debug\" <$>",
            "name": "client_debug",
            "method": "clientDebug",
            "conflicts": [],
            "type": "P.Maybe P.Bool",
            "class": "HasClientDebug",
            "optional": true,
            "label": "_clientDebug"
        },
        {
            "default": "P.Nothing",
            "computed": false,
            "required": false,
            "help": [
                "Govmomi debug path for debug"
            ],
            "forceNew": false,
            "encoder": "TF.assign \"client_debug_path\" <$>",
            "name": "client_debug_path",
            "method": "clientDebugPath",
            "conflicts": [],
            "type": "P.Maybe P.Text",
            "class": "HasClientDebugPath",
            "optional": true,
            "label": "_clientDebugPath"
        },
        {
            "default": "P.Nothing",
            "computed": false,
            "required": false,
            "help": [
                "Govmomi debug path for a single run"
            ],
            "forceNew": false,
            "encoder": "TF.assign \"client_debug_path_run\" <$>",
            "name": "client_debug_path_run",
            "method": "clientDebugPathRun",
            "conflicts": [],
            "type": "P.Maybe P.Text",
            "class": "HasClientDebugPathRun",
            "optional": true,
            "label": "_clientDebugPathRun"
        },
        {
            "default": "_password",
            "computed": false,
            "required": true,
            "help": [
                "The user password for vSphere API operations."
            ],
            "forceNew": false,
            "encoder": "P.Just $ TF.assign \"password\"",
            "name": "password",
            "method": "password",
            "conflicts": [],
            "type": "P.Text",
            "class": "HasPassword",
            "optional": false,
            "label": "_password"
        },
        {
            "default": "P.Nothing",
            "computed": false,
            "required": false,
            "help": [
                "Persist vSphere client sessions to disk"
            ],
            "forceNew": false,
            "encoder": "TF.assign \"persist_session\" <$>",
            "name": "persist_session",
            "method": "persistSession",
            "conflicts": [],
            "type": "P.Maybe P.Bool",
            "class": "HasPersistSession",
            "optional": true,
            "label": "_persistSession"
        },
        {
            "default": "P.Nothing",
            "computed": false,
            "required": false,
            "help": [
                "The directory to save vSphere REST API sessions to"
            ],
            "forceNew": false,
            "encoder": "TF.assign \"rest_session_path\" <$>",
            "name": "rest_session_path",
            "method": "restSessionPath",
            "conflicts": [],
            "type": "P.Maybe P.Text",
            "class": "HasRestSessionPath",
            "optional": true,
            "label": "_restSessionPath"
        },
        {
            "default": "_user",
            "computed": false,
            "required": true,
            "help": [
                "The user name for vSphere API operations."
            ],
            "forceNew": false,
            "encoder": "P.Just $ TF.assign \"user\"",
            "name": "user",
            "method": "user",
            "conflicts": [],
            "type": "P.Text",
            "class": "HasUser",
            "optional": false,
            "label": "_user"
        },
        {
            "default": "P.Nothing",
            "computed": false,
            "required": false,
            "help": [],
            "forceNew": false,
            "encoder": "TF.assign \"vcenter_server\" <$>",
            "name": "vcenter_server",
            "method": "vcenterServer",
            "conflicts": [],
            "type": "P.Maybe P.Text",
            "class": "HasVcenterServer",
            "optional": true,
            "label": "_vcenterServer"
        },
        {
            "default": "P.Nothing",
            "computed": false,
            "required": false,
            "help": [
                "The directory to save vSphere SOAP API sessions to"
            ],
            "forceNew": false,
            "encoder": "TF.assign \"vim_session_path\" <$>",
            "name": "vim_session_path",
            "method": "vimSessionPath",
            "conflicts": [],
            "type": "P.Maybe P.Text",
            "class": "HasVimSessionPath",
            "optional": true,
            "label": "_vimSessionPath"
        },
        {
            "default": "P.Nothing",
            "computed": false,
            "required": false,
            "help": [
                "The vSphere Server name for vSphere API operations."
            ],
            "forceNew": false,
            "encoder": "TF.assign \"vsphere_server\" <$>",
            "name": "vsphere_server",
            "method": "vsphereServer",
            "conflicts": [],
            "type": "P.Maybe P.Text",
            "class": "HasVsphereServer",
            "optional": true,
            "label": "_vsphereServer"
        }
    ],
    "dataSources": [
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object ID of the datacenter the cluster is located in. Not",
                        "required if using an absolute path."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "datacenter_id",
                    "method": "datacenterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "optional": true,
                    "label": "_datacenterId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name or absolute path to the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "schema": "DataSource",
            "name": "ComputeClusterData",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The managed object ID of the cluster's root resource pool."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_pool_id\" <$> TF.attribute",
                    "name": "resource_pool_id",
                    "method": "computedResourcePoolId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourcePoolId",
                    "optional": false,
                    "label": "_computedResourcePoolId"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name or absolute path to the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "type": "ComputeClusterData s",
            "original": "vsphere_compute_cluster"
        },
        {
            "arguments": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the custom attribute."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "schema": "DataSource",
            "name": "CustomAttributeData",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Object type for which the custom attribute is valid. If not specified, the",
                        "attribute is valid for all managed object types."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"managed_object_type\" <$> TF.attribute",
                    "name": "managed_object_type",
                    "method": "computedManagedObjectType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedManagedObjectType",
                    "optional": false,
                    "label": "_computedManagedObjectType"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the custom attribute."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "type": "CustomAttributeData s",
            "original": "vsphere_custom_attribute"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The name of the datacenter. This can be a name or path.\tCan be omitted if",
                        "there is only one datacenter in your inventory."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": true,
                    "label": "_name"
                }
            ],
            "schema": "DataSource",
            "name": "DatacenterData",
            "attributes": [],
            "parameters": [],
            "type": "DatacenterData s",
            "original": "vsphere_datacenter"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object ID of the datacenter the datastore is in. This is not",
                        "required when using ESXi directly, or if there is only one datacenter in",
                        "your infrastructure."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "datacenter_id",
                    "method": "datacenterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "optional": true,
                    "label": "_datacenterId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name or path of the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "schema": "DataSource",
            "name": "DatastoreData",
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name or path of the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "type": "DatastoreData s",
            "original": "vsphere_datastore"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object ID of the datacenter the cluster is located in. Not",
                        "required if using an absolute path."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "datacenter_id",
                    "method": "datacenterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "optional": true,
                    "label": "_datacenterId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name or absolute path to the datastore cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "schema": "DataSource",
            "name": "DatastoreClusterData",
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name or absolute path to the datastore cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "type": "DatastoreClusterData s",
            "original": "vsphere_datastore_cluster"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object ID of the datacenter the DVS is in. This is required if",
                        "the supplied path is not an absolute path containing a datacenter and there",
                        "are multiple datacenters in your infrastructure."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "datacenter_id",
                    "method": "datacenterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "optional": true,
                    "label": "_datacenterId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the distributed virtual switch. This can be a name or path."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "schema": "DataSource",
            "name": "DistributedVirtualSwitchData",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The uplink ports on this DVS."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uplinks\" <$> TF.attribute",
                    "name": "uplinks",
                    "method": "computedUplinks",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedUplinks",
                    "optional": false,
                    "label": "_computedUplinks"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the distributed virtual switch. This can be a name or path."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "type": "DistributedVirtualSwitchData s",
            "original": "vsphere_distributed_virtual_switch"
        },
        {
            "arguments": [
                {
                    "default": "_datacenterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the datacenter to look for the host in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "datacenter_id",
                    "method": "datacenterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "optional": false,
                    "label": "_datacenterId"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The name of the host. This can be a name or path.\tIf not provided, the",
                        "default host is used."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": true,
                    "label": "_name"
                }
            ],
            "schema": "DataSource",
            "name": "HostData",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The managed object ID of the host's root resource pool."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_pool_id\" <$> TF.attribute",
                    "name": "resource_pool_id",
                    "method": "computedResourcePoolId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourcePoolId",
                    "optional": false,
                    "label": "_computedResourcePoolId"
                }
            ],
            "parameters": [
                {
                    "default": "_datacenterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the datacenter to look for the host in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "datacenter_id",
                    "method": "datacenterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "optional": false,
                    "label": "_datacenterId"
                }
            ],
            "type": "HostData s",
            "original": "vsphere_host"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object ID of the datacenter the network is in. This is required",
                        "if the supplied path is not an absolute path containing a datacenter and",
                        "there are multiple datacenters in your infrastructure."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "datacenter_id",
                    "method": "datacenterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "optional": true,
                    "label": "_datacenterId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name or path of the network."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "schema": "DataSource",
            "name": "NetworkData",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The managed object type of the network."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "type",
                    "method": "computedType'",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedType'",
                    "optional": false,
                    "label": "_computedType'"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name or path of the network."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "type": "NetworkData s",
            "original": "vsphere_network"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object ID of the datacenter the resource pool is in. This is not",
                        "required when using ESXi directly, or if there is only one datacenter in",
                        "your infrastructure."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "datacenter_id",
                    "method": "datacenterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "optional": true,
                    "label": "_datacenterId"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The name or path of the resource pool."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": true,
                    "label": "_name"
                }
            ],
            "schema": "DataSource",
            "name": "ResourcePoolData",
            "attributes": [],
            "parameters": [],
            "type": "ResourcePoolData s",
            "original": "vsphere_resource_pool"
        },
        {
            "arguments": [
                {
                    "default": "_categoryId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique identifier of the parent category for this tag."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"category_id\" <$> TF.attribute",
                    "name": "category_id",
                    "method": "categoryId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCategoryId",
                    "optional": false,
                    "label": "_categoryId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the tag."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "schema": "DataSource",
            "name": "TagData",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The description of the tag."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"description\" <$> TF.attribute",
                    "name": "description",
                    "method": "computedDescription",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedDescription",
                    "optional": false,
                    "label": "_computedDescription"
                }
            ],
            "parameters": [
                {
                    "default": "_categoryId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique identifier of the parent category for this tag."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"category_id\" <$> TF.attribute",
                    "name": "category_id",
                    "method": "categoryId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCategoryId",
                    "optional": false,
                    "label": "_categoryId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the tag."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "type": "TagData s",
            "original": "vsphere_tag"
        },
        {
            "arguments": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the category."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "schema": "DataSource",
            "name": "TagCategoryData",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Object types to which this category's tags can be attached."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"associable_types\" <$> TF.attribute",
                    "name": "associable_types",
                    "method": "computedAssociableTypes",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasComputedAssociableTypes",
                    "optional": false,
                    "label": "_computedAssociableTypes"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The associated cardinality of the category. Can be one of SINGLE (object can",
                        "only be assigned one tag in this category) or MULTIPLE (object can be",
                        "assigned multiple tags in this category)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cardinality\" <$> TF.attribute",
                    "name": "cardinality",
                    "method": "computedCardinality",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedCardinality",
                    "optional": false,
                    "label": "_computedCardinality"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The description of the category."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"description\" <$> TF.attribute",
                    "name": "description",
                    "method": "computedDescription",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedDescription",
                    "optional": false,
                    "label": "_computedDescription"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the category."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "type": "TagCategoryData s",
            "original": "vsphere_tag_category"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object ID of the datacenter the virtual machine is in. This is",
                        "not required when using ESXi directly, or if there is only one datacenter in",
                        "your infrastructure."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "datacenter_id",
                    "method": "datacenterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "optional": true,
                    "label": "_datacenterId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name or path of the virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The number of SCSI controllers to scan for disk sizes and controller types",
                        "on."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scsi_controller_scan_count\" <$> TF.attribute",
                    "name": "scsi_controller_scan_count",
                    "method": "scsiControllerScanCount",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasScsiControllerScanCount",
                    "optional": true,
                    "label": "_scsiControllerScanCount"
                }
            ],
            "schema": "DataSource",
            "name": "VirtualMachineData",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The alternate guest name of the virtual machine when guest_id is a",
                        "non-specific operating system, like otherGuest."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"alternate_guest_name\" <$> TF.attribute",
                    "name": "alternate_guest_name",
                    "method": "computedAlternateGuestName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedAlternateGuestName",
                    "optional": false,
                    "label": "_computedAlternateGuestName"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Select configuration attributes from the disks on this virtual machine,",
                        "sorted by bus and unit number."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disks\" <$> TF.attribute",
                    "name": "disks",
                    "method": "computedDisks",
                    "conflicts": [],
                    "type": "TF.Attr s [Disks s]",
                    "class": "HasComputedDisks",
                    "optional": false,
                    "label": "_computedDisks"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The firmware type for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"firmware\" <$> TF.attribute",
                    "name": "firmware",
                    "method": "computedFirmware",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedFirmware",
                    "optional": false,
                    "label": "_computedFirmware"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The guest ID of the virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"guest_id\" <$> TF.attribute",
                    "name": "guest_id",
                    "method": "computedGuestId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedGuestId",
                    "optional": false,
                    "label": "_computedGuestId"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The types of network interfaces found on the virtual machine, sorted by unit",
                        "number."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_interface_types\" <$> TF.attribute",
                    "name": "network_interface_types",
                    "method": "computedNetworkInterfaceTypes",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedNetworkInterfaceTypes",
                    "optional": false,
                    "label": "_computedNetworkInterfaceTypes"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Mode for sharing the SCSI bus."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scsi_bus_sharing\" <$> TF.attribute",
                    "name": "scsi_bus_sharing",
                    "method": "computedScsiBusSharing",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedScsiBusSharing",
                    "optional": false,
                    "label": "_computedScsiBusSharing"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The common SCSI bus type of all controllers on the virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scsi_type\" <$> TF.attribute",
                    "name": "scsi_type",
                    "method": "computedScsiType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedScsiType",
                    "optional": false,
                    "label": "_computedScsiType"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name or path of the virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "type": "VirtualMachineData s",
            "original": "vsphere_virtual_machine"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A regular expression to filter the disks against. Only disks with canonical",
                        "names that match will be included."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"filter\" <$> TF.attribute",
                    "name": "filter",
                    "method": "filter",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFilter",
                    "optional": true,
                    "label": "_filter"
                },
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host to search for disks on."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "host_system_id",
                    "method": "hostSystemId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "optional": false,
                    "label": "_hostSystemId"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Rescan the system for disks before querying. This may lengthen the time it",
                        "takes to gather information."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rescan\" <$> TF.attribute",
                    "name": "rescan",
                    "method": "rescan",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRescan",
                    "optional": true,
                    "label": "_rescan"
                }
            ],
            "schema": "DataSource",
            "name": "VmfsDisksData",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The names of the disks discovered by the search."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disks\" <$> TF.attribute",
                    "name": "disks",
                    "method": "computedDisks",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedDisks",
                    "optional": false,
                    "label": "_computedDisks"
                }
            ],
            "parameters": [
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host to search for disks on."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "host_system_id",
                    "method": "hostSystemId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "optional": false,
                    "label": "_hostSystemId"
                }
            ],
            "type": "VmfsDisksData s",
            "original": "vsphere_vmfs_disks"
        }
    ],
    "resources": [
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of custom attributes to set on this resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"custom_attributes\" <$> TF.attribute",
                    "name": "custom_attributes",
                    "method": "customAttributes",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasCustomAttributes",
                    "optional": true,
                    "label": "_customAttributes"
                },
                {
                    "default": "_datacenterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the datacenter to put the cluster in."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "datacenter_id",
                    "method": "datacenterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "optional": false,
                    "label": "_datacenterId"
                },
                {
                    "default": "TF.value \"manual\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The automation level for host power operations in this cluster. Can be one",
                        "of manual or automated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dpm_automation_level\" <$> TF.attribute",
                    "name": "dpm_automation_level",
                    "method": "dpmAutomationLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDpmAutomationLevel",
                    "optional": true,
                    "label": "_dpmAutomationLevel"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable DPM support for DRS. This allows you to dynamically control the power",
                        "of hosts depending on the needs of virtual machines in the cluster. Requires",
                        "that DRS be enabled."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dpm_enabled\" <$> TF.attribute",
                    "name": "dpm_enabled",
                    "method": "dpmEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasDpmEnabled",
                    "optional": true,
                    "label": "_dpmEnabled"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A value between 1 and 5 indicating the threshold of load within the cluster",
                        "that influences host power operations. This affects both power on and power",
                        "off operations - a lower setting will tolerate more of a surplus/deficit",
                        "than a higher setting."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dpm_threshold\" <$> TF.attribute",
                    "name": "dpm_threshold",
                    "method": "dpmThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasDpmThreshold",
                    "optional": true,
                    "label": "_dpmThreshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Advanced configuration options for DRS and DPM."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drs_advanced_options\" <$> TF.attribute",
                    "name": "drs_advanced_options",
                    "method": "drsAdvancedOptions",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasDrsAdvancedOptions",
                    "optional": true,
                    "label": "_drsAdvancedOptions"
                },
                {
                    "default": "TF.value \"manual\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The default automation level for all virtual machines in this cluster. Can",
                        "be one of manual, partiallyAutomated, or fullyAutomated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drs_automation_level\" <$> TF.attribute",
                    "name": "drs_automation_level",
                    "method": "drsAutomationLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDrsAutomationLevel",
                    "optional": true,
                    "label": "_drsAutomationLevel"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When true, enables DRS to use data from vRealize Operations Manager to make",
                        "proactive DRS recommendations."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drs_enable_predictive_drs\" <$> TF.attribute",
                    "name": "drs_enable_predictive_drs",
                    "method": "drsEnablePredictiveDrs",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasDrsEnablePredictiveDrs",
                    "optional": true,
                    "label": "_drsEnablePredictiveDrs"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When true, allows individual VM overrides within this cluster to be set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drs_enable_vm_overrides\" <$> TF.attribute",
                    "name": "drs_enable_vm_overrides",
                    "method": "drsEnableVmOverrides",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasDrsEnableVmOverrides",
                    "optional": true,
                    "label": "_drsEnableVmOverrides"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable DRS for this cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drs_enabled\" <$> TF.attribute",
                    "name": "drs_enabled",
                    "method": "drsEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasDrsEnabled",
                    "optional": true,
                    "label": "_drsEnabled"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A value between 1 and 5 indicating the threshold of imbalance tolerated",
                        "between hosts. A lower setting will tolerate more imbalance while a higher",
                        "setting will tolerate less."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drs_migration_threshold\" <$> TF.attribute",
                    "name": "drs_migration_threshold",
                    "method": "drsMigrationThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasDrsMigrationThreshold",
                    "optional": true,
                    "label": "_drsMigrationThreshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The name of the folder to locate the cluster in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"folder\" <$> TF.attribute",
                    "name": "folder",
                    "method": "folder",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFolder",
                    "optional": true,
                    "label": "_folder"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Force removal of all hosts in the cluster during destroy and make them",
                        "standalone hosts. Use of this flag mainly exists for testing and is not",
                        "recommended in normal use."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"force_evacuate_on_destroy\" <$> TF.attribute",
                    "name": "force_evacuate_on_destroy",
                    "method": "forceEvacuateOnDestroy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasForceEvacuateOnDestroy",
                    "optional": true,
                    "label": "_forceEvacuateOnDestroy"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When ha_admission_control_policy is failoverHosts, this defines the managed",
                        "object IDs of hosts to use as dedicated failover hosts. These hosts are kept",
                        "as available as possible - admission control will block access to the host,",
                        "and DRS will ignore the host when making recommendations."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_admission_control_failover_host_system_ids\" <$> TF.attribute",
                    "name": "ha_admission_control_failover_host_system_ids",
                    "method": "haAdmissionControlFailoverHostSystemIds",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasHaAdmissionControlFailoverHostSystemIds",
                    "optional": true,
                    "label": "_haAdmissionControlFailoverHostSystemIds"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The maximum number of failed hosts that admission control tolerates when",
                        "making decisions on whether to permit virtual machine operations. The",
                        "maximum is one less than the number of hosts in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_admission_control_host_failure_tolerance\" <$> TF.attribute",
                    "name": "ha_admission_control_host_failure_tolerance",
                    "method": "haAdmissionControlHostFailureTolerance",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasHaAdmissionControlHostFailureTolerance",
                    "optional": true,
                    "label": "_haAdmissionControlHostFailureTolerance"
                },
                {
                    "default": "TF.value 100",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The percentage of resource reduction that a cluster of VMs can tolerate in",
                        "case of a failover. A value of 0 produces warnings only, whereas a value of",
                        "100 disables the setting."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_admission_control_performance_tolerance\" <$> TF.attribute",
                    "name": "ha_admission_control_performance_tolerance",
                    "method": "haAdmissionControlPerformanceTolerance",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasHaAdmissionControlPerformanceTolerance",
                    "optional": true,
                    "label": "_haAdmissionControlPerformanceTolerance"
                },
                {
                    "default": "TF.value \"resourcePercentage\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The type of admission control policy to use with vSphere HA, which controls",
                        "whether or not specific VM operations are permitted in the cluster in order",
                        "to protect the reliability of the cluster. Can be one of resourcePercentage,",
                        "slotPolicy, failoverHosts, or disabled. Note that disabling admission",
                        "control is not recommended and can lead to service issues."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_admission_control_policy\" <$> TF.attribute",
                    "name": "ha_admission_control_policy",
                    "method": "haAdmissionControlPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaAdmissionControlPolicy",
                    "optional": true,
                    "label": "_haAdmissionControlPolicy"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When ha_admission_control_policy is resourcePercentage, automatically",
                        "determine available resource percentages by subtracting the average number",
                        "of host resources represented by the",
                        "ha_admission_control_host_failure_tolerance setting from the total amount of",
                        "resources in the cluster. Disable to supply user-defined values."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_admission_control_resource_percentage_auto_compute\" <$> TF.attribute",
                    "name": "ha_admission_control_resource_percentage_auto_compute",
                    "method": "haAdmissionControlResourcePercentageAutoCompute",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHaAdmissionControlResourcePercentageAutoCompute",
                    "optional": true,
                    "label": "_haAdmissionControlResourcePercentageAutoCompute"
                },
                {
                    "default": "TF.value 100",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When ha_admission_control_policy is resourcePercentage, this controls the",
                        "user-defined percentage of CPU resources in the cluster to reserve for",
                        "failover."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_admission_control_resource_percentage_cpu\" <$> TF.attribute",
                    "name": "ha_admission_control_resource_percentage_cpu",
                    "method": "haAdmissionControlResourcePercentageCpu",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasHaAdmissionControlResourcePercentageCpu",
                    "optional": true,
                    "label": "_haAdmissionControlResourcePercentageCpu"
                },
                {
                    "default": "TF.value 100",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When ha_admission_control_policy is resourcePercentage, this controls the",
                        "user-defined percentage of memory resources in the cluster to reserve for",
                        "failover."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_admission_control_resource_percentage_memory\" <$> TF.attribute",
                    "name": "ha_admission_control_resource_percentage_memory",
                    "method": "haAdmissionControlResourcePercentageMemory",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasHaAdmissionControlResourcePercentageMemory",
                    "optional": true,
                    "label": "_haAdmissionControlResourcePercentageMemory"
                },
                {
                    "default": "TF.value 32",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When ha_admission_control_policy is slotPolicy, this controls the",
                        "user-defined CPU slot size, in MHz."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_admission_control_slot_policy_explicit_cpu\" <$> TF.attribute",
                    "name": "ha_admission_control_slot_policy_explicit_cpu",
                    "method": "haAdmissionControlSlotPolicyExplicitCpu",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasHaAdmissionControlSlotPolicyExplicitCpu",
                    "optional": true,
                    "label": "_haAdmissionControlSlotPolicyExplicitCpu"
                },
                {
                    "default": "TF.value 100",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When ha_admission_control_policy is slotPolicy, this controls the",
                        "user-defined memory slot size, in MB."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_admission_control_slot_policy_explicit_memory\" <$> TF.attribute",
                    "name": "ha_admission_control_slot_policy_explicit_memory",
                    "method": "haAdmissionControlSlotPolicyExplicitMemory",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasHaAdmissionControlSlotPolicyExplicitMemory",
                    "optional": true,
                    "label": "_haAdmissionControlSlotPolicyExplicitMemory"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When ha_admission_control_policy is slotPolicy, this setting controls",
                        "whether or not you wish to supply explicit values to CPU and memory slot",
                        "sizes. The default is to gather a automatic average based on all powered-on",
                        "virtual machines currently in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_admission_control_slot_policy_use_explicit_size\" <$> TF.attribute",
                    "name": "ha_admission_control_slot_policy_use_explicit_size",
                    "method": "haAdmissionControlSlotPolicyUseExplicitSize",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHaAdmissionControlSlotPolicyUseExplicitSize",
                    "optional": true,
                    "label": "_haAdmissionControlSlotPolicyUseExplicitSize"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Advanced configuration options for vSphere HA."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_advanced_options\" <$> TF.attribute",
                    "name": "ha_advanced_options",
                    "method": "haAdvancedOptions",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasHaAdvancedOptions",
                    "optional": true,
                    "label": "_haAdvancedOptions"
                },
                {
                    "default": "TF.value \"none\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When ha_vm_component_protection is enabled, controls the action to take on",
                        "virtual machines if an APD status on an affected datastore clears in the",
                        "middle of an APD event. Can be one of none or reset."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_datastore_apd_recovery_action\" <$> TF.attribute",
                    "name": "ha_datastore_apd_recovery_action",
                    "method": "haDatastoreApdRecoveryAction",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaDatastoreApdRecoveryAction",
                    "optional": true,
                    "label": "_haDatastoreApdRecoveryAction"
                },
                {
                    "default": "TF.value \"disabled\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When ha_vm_component_protection is enabled, controls the action to take on",
                        "virtual machines when the cluster has detected loss to all paths to a",
                        "relevant datastore. Can be one of disabled, warning, restartConservative, or",
                        "restartAggressive."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_datastore_apd_response\" <$> TF.attribute",
                    "name": "ha_datastore_apd_response",
                    "method": "haDatastoreApdResponse",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaDatastoreApdResponse",
                    "optional": true,
                    "label": "_haDatastoreApdResponse"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When ha_vm_component_protection is enabled, controls the delay in minutes to",
                        "wait after an APD timeout event to execute the response action defined in",
                        "ha_datastore_apd_response."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_datastore_apd_response_delay\" <$> TF.attribute",
                    "name": "ha_datastore_apd_response_delay",
                    "method": "haDatastoreApdResponseDelay",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasHaDatastoreApdResponseDelay",
                    "optional": true,
                    "label": "_haDatastoreApdResponseDelay"
                },
                {
                    "default": "TF.value \"disabled\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When ha_vm_component_protection is enabled, controls the action to take on",
                        "virtual machines when the cluster has detected a permanent device loss to a",
                        "relevant datastore. Can be one of disabled, warning, or restartAggressive."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_datastore_pdl_response\" <$> TF.attribute",
                    "name": "ha_datastore_pdl_response",
                    "method": "haDatastorePdlResponse",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaDatastorePdlResponse",
                    "optional": true,
                    "label": "_haDatastorePdlResponse"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable vSphere HA for this cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_enabled\" <$> TF.attribute",
                    "name": "ha_enabled",
                    "method": "haEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHaEnabled",
                    "optional": true,
                    "label": "_haEnabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The list of managed object IDs for preferred datastores to use for HA",
                        "heartbeating. This setting is only useful when ha_heartbeat_datastore_policy",
                        "is set to either userSelectedDs or allFeasibleDsWithUserPreference."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_heartbeat_datastore_ids\" <$> TF.attribute",
                    "name": "ha_heartbeat_datastore_ids",
                    "method": "haHeartbeatDatastoreIds",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasHaHeartbeatDatastoreIds",
                    "optional": true,
                    "label": "_haHeartbeatDatastoreIds"
                },
                {
                    "default": "TF.value \"allFeasibleDsWithUserPreference\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The selection policy for HA heartbeat datastores. Can be one of",
                        "allFeasibleDs, userSelectedDs, or allFeasibleDsWithUserPreference."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_heartbeat_datastore_policy\" <$> TF.attribute",
                    "name": "ha_heartbeat_datastore_policy",
                    "method": "haHeartbeatDatastorePolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaHeartbeatDatastorePolicy",
                    "optional": true,
                    "label": "_haHeartbeatDatastorePolicy"
                },
                {
                    "default": "TF.value \"none\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The action to take on virtual machines when a host has detected that it has",
                        "been isolated from the rest of the cluster. Can be one of none, powerOff, or",
                        "shutdown."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_host_isolation_response\" <$> TF.attribute",
                    "name": "ha_host_isolation_response",
                    "method": "haHostIsolationResponse",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaHostIsolationResponse",
                    "optional": true,
                    "label": "_haHostIsolationResponse"
                },
                {
                    "default": "TF.value \"enabled\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Global setting that controls whether vSphere HA remediates VMs on host",
                        "failure. Can be one of enabled or disabled."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_host_monitoring\" <$> TF.attribute",
                    "name": "ha_host_monitoring",
                    "method": "haHostMonitoring",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaHostMonitoring",
                    "optional": true,
                    "label": "_haHostMonitoring"
                },
                {
                    "default": "TF.value \"enabled\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Controls vSphere VM component protection for virtual machines in this",
                        "cluster. This allows vSphere HA to react to failures between hosts and",
                        "specific virtual machine components, such as datastores. Can be one of",
                        "enabled or disabled."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_component_protection\" <$> TF.attribute",
                    "name": "ha_vm_component_protection",
                    "method": "haVmComponentProtection",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaVmComponentProtection",
                    "optional": true,
                    "label": "_haVmComponentProtection"
                },
                {
                    "default": "TF.value \"none\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The condition used to determine whether or not VMs in a certain restart",
                        "priority class are online, allowing HA to move on to restarting VMs on the",
                        "next priority. Can be one of none, poweredOn, guestHbStatusGreen, or",
                        "appHbStatusGreen."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_dependency_restart_condition\" <$> TF.attribute",
                    "name": "ha_vm_dependency_restart_condition",
                    "method": "haVmDependencyRestartCondition",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaVmDependencyRestartCondition",
                    "optional": true,
                    "label": "_haVmDependencyRestartCondition"
                },
                {
                    "default": "TF.value 30",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If a heartbeat from a virtual machine is not received within this configured",
                        "interval, the virtual machine is marked as failed. The value is in seconds."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_failure_interval\" <$> TF.attribute",
                    "name": "ha_vm_failure_interval",
                    "method": "haVmFailureInterval",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasHaVmFailureInterval",
                    "optional": true,
                    "label": "_haVmFailureInterval"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The length of the reset window in which ha_vm_maximum_resets can operate.",
                        "When this window expires, no more resets are attempted regardless of the",
                        "setting configured in ha_vm_maximum_resets. -1 means no window, meaning an",
                        "unlimited reset time is allotted."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_maximum_failure_window\" <$> TF.attribute",
                    "name": "ha_vm_maximum_failure_window",
                    "method": "haVmMaximumFailureWindow",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasHaVmMaximumFailureWindow",
                    "optional": true,
                    "label": "_haVmMaximumFailureWindow"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The maximum number of resets that HA will perform to a virtual machine when",
                        "responding to a failure event."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_maximum_resets\" <$> TF.attribute",
                    "name": "ha_vm_maximum_resets",
                    "method": "haVmMaximumResets",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasHaVmMaximumResets",
                    "optional": true,
                    "label": "_haVmMaximumResets"
                },
                {
                    "default": "TF.value 120",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The time, in seconds, that HA waits after powering on a virtual machine",
                        "before monitoring for heartbeats."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_minimum_uptime\" <$> TF.attribute",
                    "name": "ha_vm_minimum_uptime",
                    "method": "haVmMinimumUptime",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasHaVmMinimumUptime",
                    "optional": true,
                    "label": "_haVmMinimumUptime"
                },
                {
                    "default": "TF.value \"vmMonitoringDisabled\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The type of virtual machine monitoring to use when HA is enabled in the",
                        "cluster. Can be one of vmMonitoringDisabled, vmMonitoringOnly, or",
                        "vmAndAppMonitoring."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_monitoring\" <$> TF.attribute",
                    "name": "ha_vm_monitoring",
                    "method": "haVmMonitoring",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaVmMonitoring",
                    "optional": true,
                    "label": "_haVmMonitoring"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Additional delay in seconds after ready condition is met. A VM is considered",
                        "ready at this point."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_restart_additional_delay\" <$> TF.attribute",
                    "name": "ha_vm_restart_additional_delay",
                    "method": "haVmRestartAdditionalDelay",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasHaVmRestartAdditionalDelay",
                    "optional": true,
                    "label": "_haVmRestartAdditionalDelay"
                },
                {
                    "default": "TF.value \"medium\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The default restart priority for affected VMs when vSphere detects a host",
                        "failure. Can be one of lowest, low, medium, high, or highest."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_restart_priority\" <$> TF.attribute",
                    "name": "ha_vm_restart_priority",
                    "method": "haVmRestartPriority",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaVmRestartPriority",
                    "optional": true,
                    "label": "_haVmRestartPriority"
                },
                {
                    "default": "TF.value 600",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The maximum time, in seconds, that vSphere HA will wait for virtual machines",
                        "in one priority to be ready before proceeding with the next priority."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_restart_timeout\" <$> TF.attribute",
                    "name": "ha_vm_restart_timeout",
                    "method": "haVmRestartTimeout",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasHaVmRestartTimeout",
                    "optional": true,
                    "label": "_haVmRestartTimeout"
                },
                {
                    "default": "TF.value 3600",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The timeout for each host maintenance mode operation when removing hosts",
                        "from a cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_cluster_exit_timeout\" <$> TF.attribute",
                    "name": "host_cluster_exit_timeout",
                    "method": "hostClusterExitTimeout",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasHostClusterExitTimeout",
                    "optional": true,
                    "label": "_hostClusterExitTimeout"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object IDs of the hosts to put in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_system_ids\" <$> TF.attribute",
                    "name": "host_system_ids",
                    "method": "hostSystemIds",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasHostSystemIds",
                    "optional": true,
                    "label": "_hostSystemIds"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name for the new cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "TF.value \"Manual\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The DRS behavior for proactive HA recommendations. Can be one of Automated",
                        "or Manual."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"proactive_ha_automation_level\" <$> TF.attribute",
                    "name": "proactive_ha_automation_level",
                    "method": "proactiveHaAutomationLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasProactiveHaAutomationLevel",
                    "optional": true,
                    "label": "_proactiveHaAutomationLevel"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enables proactive HA, allowing for vSphere to get HA data from external",
                        "providers and use DRS to perform remediation."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"proactive_ha_enabled\" <$> TF.attribute",
                    "name": "proactive_ha_enabled",
                    "method": "proactiveHaEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasProactiveHaEnabled",
                    "optional": true,
                    "label": "_proactiveHaEnabled"
                },
                {
                    "default": "TF.value \"QuarantineMode\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The configured remediation for moderately degraded hosts. Can be one of",
                        "MaintenanceMode or QuarantineMode. Note that this cannot be set to",
                        "MaintenanceMode when proactive_ha_severe_remediation is set to",
                        "QuarantineMode."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"proactive_ha_moderate_remediation\" <$> TF.attribute",
                    "name": "proactive_ha_moderate_remediation",
                    "method": "proactiveHaModerateRemediation",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasProactiveHaModerateRemediation",
                    "optional": true,
                    "label": "_proactiveHaModerateRemediation"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The list of IDs for health update providers configured for this cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"proactive_ha_provider_ids\" <$> TF.attribute",
                    "name": "proactive_ha_provider_ids",
                    "method": "proactiveHaProviderIds",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasProactiveHaProviderIds",
                    "optional": true,
                    "label": "_proactiveHaProviderIds"
                },
                {
                    "default": "TF.value \"QuarantineMode\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The configured remediation for severely degraded hosts. Can be one of",
                        "MaintenanceMode or QuarantineMode. Note that this cannot be set to",
                        "QuarantineMode when proactive_ha_moderate_remediation is set to",
                        "MaintenanceMode."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"proactive_ha_severe_remediation\" <$> TF.attribute",
                    "name": "proactive_ha_severe_remediation",
                    "method": "proactiveHaSevereRemediation",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasProactiveHaSevereRemediation",
                    "optional": true,
                    "label": "_proactiveHaSevereRemediation"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of tag IDs to apply to this object."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tags\" <$> TF.attribute",
                    "name": "tags",
                    "method": "tags",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasTags",
                    "optional": true,
                    "label": "_tags"
                }
            ],
            "schema": "Resource",
            "name": "ComputeClusterResource",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The managed object ID of the cluster's root resource pool."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_pool_id\" <$> TF.attribute",
                    "name": "resource_pool_id",
                    "method": "computedResourcePoolId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourcePoolId",
                    "optional": false,
                    "label": "_computedResourcePoolId"
                }
            ],
            "parameters": [
                {
                    "default": "_datacenterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the datacenter to put the cluster in."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "datacenter_id",
                    "method": "datacenterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "optional": false,
                    "label": "_datacenterId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name for the new cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "type": "ComputeClusterResource s",
            "original": "vsphere_compute_cluster"
        },
        {
            "arguments": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "compute_cluster_id",
                    "method": "computeClusterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "optional": false,
                    "label": "_computeClusterId"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object IDs of the hosts."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_system_ids\" <$> TF.attribute",
                    "name": "host_system_ids",
                    "method": "hostSystemIds",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasHostSystemIds",
                    "optional": true,
                    "label": "_hostSystemIds"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "schema": "Resource",
            "name": "ComputeClusterHostGroupResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "compute_cluster_id",
                    "method": "computeClusterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "optional": false,
                    "label": "_computeClusterId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "type": "ComputeClusterHostGroupResource s",
            "original": "vsphere_compute_cluster_host_group"
        },
        {
            "arguments": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "compute_cluster_id",
                    "method": "computeClusterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "optional": false,
                    "label": "_computeClusterId"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable this rule in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"enabled\" <$> TF.attribute",
                    "name": "enabled",
                    "method": "enabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasEnabled",
                    "optional": true,
                    "label": "_enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When true, prevents any virtual machine operations that may violate this",
                        "rule."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mandatory\" <$> TF.attribute",
                    "name": "mandatory",
                    "method": "mandatory",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasMandatory",
                    "optional": true,
                    "label": "_mandatory"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "_virtualMachineIds",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The UUIDs of the virtual machines to run on the same host together."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"virtual_machine_ids\" <$> TF.attribute",
                    "name": "virtual_machine_ids",
                    "method": "virtualMachineIds",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasVirtualMachineIds",
                    "optional": false,
                    "label": "_virtualMachineIds"
                }
            ],
            "schema": "Resource",
            "name": "ComputeClusterVmAffinityRuleResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "compute_cluster_id",
                    "method": "computeClusterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "optional": false,
                    "label": "_computeClusterId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "_virtualMachineIds",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The UUIDs of the virtual machines to run on the same host together."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"virtual_machine_ids\" <$> TF.attribute",
                    "name": "virtual_machine_ids",
                    "method": "virtualMachineIds",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasVirtualMachineIds",
                    "optional": false,
                    "label": "_virtualMachineIds"
                }
            ],
            "type": "ComputeClusterVmAffinityRuleResource s",
            "original": "vsphere_compute_cluster_vm_affinity_rule"
        },
        {
            "arguments": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "compute_cluster_id",
                    "method": "computeClusterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "optional": false,
                    "label": "_computeClusterId"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable this rule in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"enabled\" <$> TF.attribute",
                    "name": "enabled",
                    "method": "enabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasEnabled",
                    "optional": true,
                    "label": "_enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When true, prevents any virtual machine operations that may violate this",
                        "rule."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mandatory\" <$> TF.attribute",
                    "name": "mandatory",
                    "method": "mandatory",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasMandatory",
                    "optional": true,
                    "label": "_mandatory"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "_virtualMachineIds",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The UUIDs of the virtual machines to run on hosts different from each other."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"virtual_machine_ids\" <$> TF.attribute",
                    "name": "virtual_machine_ids",
                    "method": "virtualMachineIds",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasVirtualMachineIds",
                    "optional": false,
                    "label": "_virtualMachineIds"
                }
            ],
            "schema": "Resource",
            "name": "ComputeClusterVmAntiAffinityRuleResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "compute_cluster_id",
                    "method": "computeClusterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "optional": false,
                    "label": "_computeClusterId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "_virtualMachineIds",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The UUIDs of the virtual machines to run on hosts different from each other."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"virtual_machine_ids\" <$> TF.attribute",
                    "name": "virtual_machine_ids",
                    "method": "virtualMachineIds",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasVirtualMachineIds",
                    "optional": false,
                    "label": "_virtualMachineIds"
                }
            ],
            "type": "ComputeClusterVmAntiAffinityRuleResource s",
            "original": "vsphere_compute_cluster_vm_anti_affinity_rule"
        },
        {
            "arguments": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "compute_cluster_id",
                    "method": "computeClusterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "optional": false,
                    "label": "_computeClusterId"
                },
                {
                    "default": "_dependencyVmGroupName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the VM group that this rule depends on. The VMs defined in the",
                        "group specified by vm_group_name will not be started until the VMs in this",
                        "group are started."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dependency_vm_group_name\" <$> TF.attribute",
                    "name": "dependency_vm_group_name",
                    "method": "dependencyVmGroupName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDependencyVmGroupName",
                    "optional": false,
                    "label": "_dependencyVmGroupName"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable this rule in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"enabled\" <$> TF.attribute",
                    "name": "enabled",
                    "method": "enabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasEnabled",
                    "optional": true,
                    "label": "_enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When true, prevents any virtual machine operations that may violate this",
                        "rule."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mandatory\" <$> TF.attribute",
                    "name": "mandatory",
                    "method": "mandatory",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasMandatory",
                    "optional": true,
                    "label": "_mandatory"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "_vmGroupName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the VM group that is the subject of this rule. The VMs defined",
                        "in this group will not be started until the VMs in the group specified by",
                        "dependency_vm_group_name are started."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vm_group_name\" <$> TF.attribute",
                    "name": "vm_group_name",
                    "method": "vmGroupName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVmGroupName",
                    "optional": false,
                    "label": "_vmGroupName"
                }
            ],
            "schema": "Resource",
            "name": "ComputeClusterVmDependencyRuleResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "compute_cluster_id",
                    "method": "computeClusterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "optional": false,
                    "label": "_computeClusterId"
                },
                {
                    "default": "_dependencyVmGroupName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the VM group that this rule depends on. The VMs defined in the",
                        "group specified by vm_group_name will not be started until the VMs in this",
                        "group are started."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dependency_vm_group_name\" <$> TF.attribute",
                    "name": "dependency_vm_group_name",
                    "method": "dependencyVmGroupName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDependencyVmGroupName",
                    "optional": false,
                    "label": "_dependencyVmGroupName"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "_vmGroupName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the VM group that is the subject of this rule. The VMs defined",
                        "in this group will not be started until the VMs in the group specified by",
                        "dependency_vm_group_name are started."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vm_group_name\" <$> TF.attribute",
                    "name": "vm_group_name",
                    "method": "vmGroupName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVmGroupName",
                    "optional": false,
                    "label": "_vmGroupName"
                }
            ],
            "type": "ComputeClusterVmDependencyRuleResource s",
            "original": "vsphere_compute_cluster_vm_dependency_rule"
        },
        {
            "arguments": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "compute_cluster_id",
                    "method": "computeClusterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "optional": false,
                    "label": "_computeClusterId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The UUIDs of the virtual machines in this group."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"virtual_machine_ids\" <$> TF.attribute",
                    "name": "virtual_machine_ids",
                    "method": "virtualMachineIds",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasVirtualMachineIds",
                    "optional": true,
                    "label": "_virtualMachineIds"
                }
            ],
            "schema": "Resource",
            "name": "ComputeClusterVmGroupResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "compute_cluster_id",
                    "method": "computeClusterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "optional": false,
                    "label": "_computeClusterId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "type": "ComputeClusterVmGroupResource s",
            "original": "vsphere_compute_cluster_vm_group"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When this field is used, virtual machines defined in vm_group_name will be",
                        "run on the hosts defined in this host group."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"affinity_host_group_name\" <$> TF.attribute",
                    "name": "affinity_host_group_name",
                    "method": "affinityHostGroupName",
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "method": "antiAffinityHostGroupName",
                            "label": "_antiAffinityHostGroupName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasAffinityHostGroupName",
                    "optional": true,
                    "label": "_affinityHostGroupName"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When this field is used, virtual machines defined in vm_group_name will not",
                        "be run on the hosts defined in this host group."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"anti_affinity_host_group_name\" <$> TF.attribute",
                    "name": "anti_affinity_host_group_name",
                    "method": "antiAffinityHostGroupName",
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "method": "affinityHostGroupName",
                            "label": "_affinityHostGroupName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasAntiAffinityHostGroupName",
                    "optional": true,
                    "label": "_antiAffinityHostGroupName"
                },
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "compute_cluster_id",
                    "method": "computeClusterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "optional": false,
                    "label": "_computeClusterId"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable this rule in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"enabled\" <$> TF.attribute",
                    "name": "enabled",
                    "method": "enabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasEnabled",
                    "optional": true,
                    "label": "_enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When true, prevents any virtual machine operations that may violate this",
                        "rule."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mandatory\" <$> TF.attribute",
                    "name": "mandatory",
                    "method": "mandatory",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasMandatory",
                    "optional": true,
                    "label": "_mandatory"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "_vmGroupName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the virtual machine group to use with this rule."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vm_group_name\" <$> TF.attribute",
                    "name": "vm_group_name",
                    "method": "vmGroupName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVmGroupName",
                    "optional": false,
                    "label": "_vmGroupName"
                }
            ],
            "schema": "Resource",
            "name": "ComputeClusterVmHostRuleResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "compute_cluster_id",
                    "method": "computeClusterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "optional": false,
                    "label": "_computeClusterId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "_vmGroupName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the virtual machine group to use with this rule."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vm_group_name\" <$> TF.attribute",
                    "name": "vm_group_name",
                    "method": "vmGroupName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVmGroupName",
                    "optional": false,
                    "label": "_vmGroupName"
                }
            ],
            "type": "ComputeClusterVmHostRuleResource s",
            "original": "vsphere_compute_cluster_vm_host_rule"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Object type for which the custom attribute is valid. If not specified, the",
                        "attribute is valid for all managed object types."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"managed_object_type\" <$> TF.attribute",
                    "name": "managed_object_type",
                    "method": "managedObjectType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasManagedObjectType",
                    "optional": true,
                    "label": "_managedObjectType"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the custom attribute."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "schema": "Resource",
            "name": "CustomAttributeResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the custom attribute."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "type": "CustomAttributeResource s",
            "original": "vsphere_custom_attribute"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of custom attributes to set on this resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"custom_attributes\" <$> TF.attribute",
                    "name": "custom_attributes",
                    "method": "customAttributes",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasCustomAttributes",
                    "optional": true,
                    "label": "_customAttributes"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"folder\" <$> TF.attribute",
                    "name": "folder",
                    "method": "folder",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFolder",
                    "optional": true,
                    "label": "_folder"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of tag IDs to apply to this object."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tags\" <$> TF.attribute",
                    "name": "tags",
                    "method": "tags",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasTags",
                    "optional": true,
                    "label": "_tags"
                }
            ],
            "schema": "Resource",
            "name": "DatacenterResource",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Managed object ID of the datacenter."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"moid\" <$> TF.attribute",
                    "name": "moid",
                    "method": "computedMoid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMoid",
                    "optional": false,
                    "label": "_computedMoid"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "type": "DatacenterResource s",
            "original": "vsphere_datacenter"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of custom attributes to set on this resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"custom_attributes\" <$> TF.attribute",
                    "name": "custom_attributes",
                    "method": "customAttributes",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasCustomAttributes",
                    "optional": true,
                    "label": "_customAttributes"
                },
                {
                    "default": "_datacenterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the datacenter to put the datastore cluster in."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "datacenter_id",
                    "method": "datacenterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "optional": false,
                    "label": "_datacenterId"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The name of the folder to locate the datastore cluster in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"folder\" <$> TF.attribute",
                    "name": "folder",
                    "method": "folder",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFolder",
                    "optional": true,
                    "label": "_folder"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name for the new storage pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Advanced configuration options for storage DRS."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_advanced_options\" <$> TF.attribute",
                    "name": "sdrs_advanced_options",
                    "method": "sdrsAdvancedOptions",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasSdrsAdvancedOptions",
                    "optional": true,
                    "label": "_sdrsAdvancedOptions"
                },
                {
                    "default": "TF.value \"manual\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The default automation level for all virtual machines in this storage",
                        "cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_automation_level\" <$> TF.attribute",
                    "name": "sdrs_automation_level",
                    "method": "sdrsAutomationLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSdrsAutomationLevel",
                    "optional": true,
                    "label": "_sdrsAutomationLevel"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When true, storage DRS keeps VMDKs for individual VMs on the same datastore",
                        "by default."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_default_intra_vm_affinity\" <$> TF.attribute",
                    "name": "sdrs_default_intra_vm_affinity",
                    "method": "sdrsDefaultIntraVmAffinity",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasSdrsDefaultIntraVmAffinity",
                    "optional": true,
                    "label": "_sdrsDefaultIntraVmAffinity"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable storage DRS for this datastore cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_enabled\" <$> TF.attribute",
                    "name": "sdrs_enabled",
                    "method": "sdrsEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasSdrsEnabled",
                    "optional": true,
                    "label": "_sdrsEnabled"
                },
                {
                    "default": "TF.value 50",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The threshold, in GB, that storage DRS uses to make decisions to migrate VMs",
                        "out of a datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_free_space_threshold\" <$> TF.attribute",
                    "name": "sdrs_free_space_threshold",
                    "method": "sdrsFreeSpaceThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasSdrsFreeSpaceThreshold",
                    "optional": true,
                    "label": "_sdrsFreeSpaceThreshold"
                },
                {
                    "default": "TF.value \"utilization\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The free space threshold to use. When set to utilization,",
                        "drs_space_utilization_threshold is used, and when set to freeSpace,",
                        "drs_free_space_threshold is used."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_free_space_threshold_mode\" <$> TF.attribute",
                    "name": "sdrs_free_space_threshold_mode",
                    "method": "sdrsFreeSpaceThresholdMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSdrsFreeSpaceThresholdMode",
                    "optional": true,
                    "label": "_sdrsFreeSpaceThresholdMode"
                },
                {
                    "default": "TF.value 5",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The threshold, in percent, of difference between space utilization in",
                        "datastores before storage DRS makes decisions to balance the space."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_free_space_utilization_difference\" <$> TF.attribute",
                    "name": "sdrs_free_space_utilization_difference",
                    "method": "sdrsFreeSpaceUtilizationDifference",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasSdrsFreeSpaceUtilizationDifference",
                    "optional": true,
                    "label": "_sdrsFreeSpaceUtilizationDifference"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Overrides the default automation settings when correcting I/O load",
                        "imbalances."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_io_balance_automation_level\" <$> TF.attribute",
                    "name": "sdrs_io_balance_automation_level",
                    "method": "sdrsIoBalanceAutomationLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSdrsIoBalanceAutomationLevel",
                    "optional": true,
                    "label": "_sdrsIoBalanceAutomationLevel"
                },
                {
                    "default": "TF.value 15",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The I/O latency threshold, in milliseconds, that storage DRS uses to make",
                        "recommendations to move disks from this datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_io_latency_threshold\" <$> TF.attribute",
                    "name": "sdrs_io_latency_threshold",
                    "method": "sdrsIoLatencyThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasSdrsIoLatencyThreshold",
                    "optional": true,
                    "label": "_sdrsIoLatencyThreshold"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable I/O load balancing for this datastore cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_io_load_balance_enabled\" <$> TF.attribute",
                    "name": "sdrs_io_load_balance_enabled",
                    "method": "sdrsIoLoadBalanceEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasSdrsIoLoadBalanceEnabled",
                    "optional": true,
                    "label": "_sdrsIoLoadBalanceEnabled"
                },
                {
                    "default": "TF.value 5",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The difference between load in datastores in the cluster before storage DRS",
                        "makes recommendations to balance the load."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_io_load_imbalance_threshold\" <$> TF.attribute",
                    "name": "sdrs_io_load_imbalance_threshold",
                    "method": "sdrsIoLoadImbalanceThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasSdrsIoLoadImbalanceThreshold",
                    "optional": true,
                    "label": "_sdrsIoLoadImbalanceThreshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The threshold of reservable IOPS of all virtual machines on the datastore",
                        "before storage DRS makes recommendations to move VMs off of a datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_io_reservable_iops_threshold\" <$> TF.attribute",
                    "name": "sdrs_io_reservable_iops_threshold",
                    "method": "sdrsIoReservableIopsThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasSdrsIoReservableIopsThreshold",
                    "optional": true,
                    "label": "_sdrsIoReservableIopsThreshold"
                },
                {
                    "default": "TF.value 60",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The threshold, in percent, of actual estimated performance of the datastore",
                        "(in IOPS) that storage DRS uses to make recommendations to move VMs off of a",
                        "datastore when the total reservable IOPS exceeds the threshold."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_io_reservable_percent_threshold\" <$> TF.attribute",
                    "name": "sdrs_io_reservable_percent_threshold",
                    "method": "sdrsIoReservablePercentThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasSdrsIoReservablePercentThreshold",
                    "optional": true,
                    "label": "_sdrsIoReservablePercentThreshold"
                },
                {
                    "default": "TF.value \"automated\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The reservable IOPS threshold to use, percent in the event of automatic, or",
                        "manual threshold in the event of manual."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_io_reservable_threshold_mode\" <$> TF.attribute",
                    "name": "sdrs_io_reservable_threshold_mode",
                    "method": "sdrsIoReservableThresholdMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSdrsIoReservableThresholdMode",
                    "optional": true,
                    "label": "_sdrsIoReservableThresholdMode"
                },
                {
                    "default": "TF.value 480",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The storage DRS poll interval, in minutes."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_load_balance_interval\" <$> TF.attribute",
                    "name": "sdrs_load_balance_interval",
                    "method": "sdrsLoadBalanceInterval",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasSdrsLoadBalanceInterval",
                    "optional": true,
                    "label": "_sdrsLoadBalanceInterval"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Overrides the default automation settings when correcting storage and VM",
                        "policy violations."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_policy_enforcement_automation_level\" <$> TF.attribute",
                    "name": "sdrs_policy_enforcement_automation_level",
                    "method": "sdrsPolicyEnforcementAutomationLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSdrsPolicyEnforcementAutomationLevel",
                    "optional": true,
                    "label": "_sdrsPolicyEnforcementAutomationLevel"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Overrides the default automation settings when correcting affinity rule",
                        "violations."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_rule_enforcement_automation_level\" <$> TF.attribute",
                    "name": "sdrs_rule_enforcement_automation_level",
                    "method": "sdrsRuleEnforcementAutomationLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSdrsRuleEnforcementAutomationLevel",
                    "optional": true,
                    "label": "_sdrsRuleEnforcementAutomationLevel"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Overrides the default automation settings when correcting disk space",
                        "imbalances."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_space_balance_automation_level\" <$> TF.attribute",
                    "name": "sdrs_space_balance_automation_level",
                    "method": "sdrsSpaceBalanceAutomationLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSdrsSpaceBalanceAutomationLevel",
                    "optional": true,
                    "label": "_sdrsSpaceBalanceAutomationLevel"
                },
                {
                    "default": "TF.value 80",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The threshold, in percent of used space, that storage DRS uses to make",
                        "decisions to migrate VMs out of a datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_space_utilization_threshold\" <$> TF.attribute",
                    "name": "sdrs_space_utilization_threshold",
                    "method": "sdrsSpaceUtilizationThreshold",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasSdrsSpaceUtilizationThreshold",
                    "optional": true,
                    "label": "_sdrsSpaceUtilizationThreshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Overrides the default automation settings when generating recommendations",
                        "for datastore evacuation."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_vm_evacuation_automation_level\" <$> TF.attribute",
                    "name": "sdrs_vm_evacuation_automation_level",
                    "method": "sdrsVmEvacuationAutomationLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSdrsVmEvacuationAutomationLevel",
                    "optional": true,
                    "label": "_sdrsVmEvacuationAutomationLevel"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of tag IDs to apply to this object."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tags\" <$> TF.attribute",
                    "name": "tags",
                    "method": "tags",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasTags",
                    "optional": true,
                    "label": "_tags"
                }
            ],
            "schema": "Resource",
            "name": "DatastoreClusterResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_datacenterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the datacenter to put the datastore cluster in."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "datacenter_id",
                    "method": "datacenterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "optional": false,
                    "label": "_datacenterId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name for the new storage pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "type": "DatastoreClusterResource s",
            "original": "vsphere_datastore_cluster"
        },
        {
            "arguments": [
                {
                    "default": "_datastoreClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the datastore cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"datastore_cluster_id\" <$> TF.attribute",
                    "name": "datastore_cluster_id",
                    "method": "datastoreClusterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastoreClusterId",
                    "optional": false,
                    "label": "_datastoreClusterId"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable this rule in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"enabled\" <$> TF.attribute",
                    "name": "enabled",
                    "method": "enabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasEnabled",
                    "optional": true,
                    "label": "_enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When true, prevents any virtual machine operations that may violate this",
                        "rule."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mandatory\" <$> TF.attribute",
                    "name": "mandatory",
                    "method": "mandatory",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasMandatory",
                    "optional": true,
                    "label": "_mandatory"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "_virtualMachineIds",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The UUIDs of the virtual machines to run on different datastores from each",
                        "other."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"virtual_machine_ids\" <$> TF.attribute",
                    "name": "virtual_machine_ids",
                    "method": "virtualMachineIds",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasVirtualMachineIds",
                    "optional": false,
                    "label": "_virtualMachineIds"
                }
            ],
            "schema": "Resource",
            "name": "DatastoreClusterVmAntiAffinityRuleResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_datastoreClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the datastore cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"datastore_cluster_id\" <$> TF.attribute",
                    "name": "datastore_cluster_id",
                    "method": "datastoreClusterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastoreClusterId",
                    "optional": false,
                    "label": "_datastoreClusterId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "_virtualMachineIds",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The UUIDs of the virtual machines to run on different datastores from each",
                        "other."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"virtual_machine_ids\" <$> TF.attribute",
                    "name": "virtual_machine_ids",
                    "method": "virtualMachineIds",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasVirtualMachineIds",
                    "optional": false,
                    "label": "_virtualMachineIds"
                }
            ],
            "type": "DatastoreClusterVmAntiAffinityRuleResource s",
            "original": "vsphere_datastore_cluster_vm_anti_affinity_rule"
        },
        {
            "arguments": [
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Auto-expands the port group beyond the port count configured in",
                        "number_of_ports when necessary."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"auto_expand\" <$> TF.attribute",
                    "name": "auto_expand",
                    "method": "autoExpand",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasAutoExpand",
                    "optional": true,
                    "label": "_autoExpand"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow the blocked setting of an individual port to override the setting in",
                        "the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"block_override_allowed\" <$> TF.attribute",
                    "name": "block_override_allowed",
                    "method": "blockOverrideAllowed",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasBlockOverrideAllowed",
                    "optional": true,
                    "label": "_blockOverrideAllowed"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of custom attributes to set on this resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"custom_attributes\" <$> TF.attribute",
                    "name": "custom_attributes",
                    "method": "customAttributes",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasCustomAttributes",
                    "optional": true,
                    "label": "_customAttributes"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The description of the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"description\" <$> TF.attribute",
                    "name": "description",
                    "method": "description",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDescription",
                    "optional": true,
                    "label": "_description"
                },
                {
                    "default": "_distributedVirtualSwitchUuid",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The UUID of the DVS to attach this port group to."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"distributed_virtual_switch_uuid\" <$> TF.attribute",
                    "name": "distributed_virtual_switch_uuid",
                    "method": "distributedVirtualSwitchUuid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDistributedVirtualSwitchUuid",
                    "optional": false,
                    "label": "_distributedVirtualSwitchUuid"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow a live port to be moved in and out of the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"live_port_moving_allowed\" <$> TF.attribute",
                    "name": "live_port_moving_allowed",
                    "method": "livePortMovingAllowed",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasLivePortMovingAllowed",
                    "optional": true,
                    "label": "_livePortMovingAllowed"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow the enabling or disabling of Netflow on a port, contrary to the policy",
                        "in the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"netflow_override_allowed\" <$> TF.attribute",
                    "name": "netflow_override_allowed",
                    "method": "netflowOverrideAllowed",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasNetflowOverrideAllowed",
                    "optional": true,
                    "label": "_netflowOverrideAllowed"
                },
                {
                    "default": "TF.value \"-1\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key of a network resource pool to associate with this portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_resource_pool_key\" <$> TF.attribute",
                    "name": "network_resource_pool_key",
                    "method": "networkResourcePoolKey",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNetworkResourcePoolKey",
                    "optional": true,
                    "label": "_networkResourcePoolKey"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow the network resource pool of an individual port to override the",
                        "setting in the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_resource_pool_override_allowed\" <$> TF.attribute",
                    "name": "network_resource_pool_override_allowed",
                    "method": "networkResourcePoolOverrideAllowed",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasNetworkResourcePoolOverrideAllowed",
                    "optional": true,
                    "label": "_networkResourcePoolOverrideAllowed"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Reset the setting of any ports in this portgroup back to the default setting",
                        "when the port disconnects."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port_config_reset_at_disconnect\" <$> TF.attribute",
                    "name": "port_config_reset_at_disconnect",
                    "method": "portConfigResetAtDisconnect",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasPortConfigResetAtDisconnect",
                    "optional": true,
                    "label": "_portConfigResetAtDisconnect"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A template string to use when creating ports in the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port_name_format\" <$> TF.attribute",
                    "name": "port_name_format",
                    "method": "portNameFormat",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPortNameFormat",
                    "optional": true,
                    "label": "_portNameFormat"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow security policy settings on a port to override those on the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"security_policy_override_allowed\" <$> TF.attribute",
                    "name": "security_policy_override_allowed",
                    "method": "securityPolicyOverrideAllowed",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasSecurityPolicyOverrideAllowed",
                    "optional": true,
                    "label": "_securityPolicyOverrideAllowed"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow the traffic shaping policies of an individual port to override the",
                        "settings in the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"shaping_override_allowed\" <$> TF.attribute",
                    "name": "shaping_override_allowed",
                    "method": "shapingOverrideAllowed",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasShapingOverrideAllowed",
                    "optional": true,
                    "label": "_shapingOverrideAllowed"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of tag IDs to apply to this object."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tags\" <$> TF.attribute",
                    "name": "tags",
                    "method": "tags",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasTags",
                    "optional": true,
                    "label": "_tags"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow any filter policies set on the individual port to override those in",
                        "the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"traffic_filter_override_allowed\" <$> TF.attribute",
                    "name": "traffic_filter_override_allowed",
                    "method": "trafficFilterOverrideAllowed",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasTrafficFilterOverrideAllowed",
                    "optional": true,
                    "label": "_trafficFilterOverrideAllowed"
                },
                {
                    "default": "TF.value \"earlyBinding\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The type of portgroup. Can be one of earlyBinding (static) or ephemeral."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "type",
                    "method": "type'",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "optional": true,
                    "label": "_type'"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow the uplink teaming policies on a port to override those on the",
                        "portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uplink_teaming_override_allowed\" <$> TF.attribute",
                    "name": "uplink_teaming_override_allowed",
                    "method": "uplinkTeamingOverrideAllowed",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasUplinkTeamingOverrideAllowed",
                    "optional": true,
                    "label": "_uplinkTeamingOverrideAllowed"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow the VLAN configuration on a port to override those on the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vlan_override_allowed\" <$> TF.attribute",
                    "name": "vlan_override_allowed",
                    "method": "vlanOverrideAllowed",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasVlanOverrideAllowed",
                    "optional": true,
                    "label": "_vlanOverrideAllowed"
                }
            ],
            "schema": "Resource",
            "name": "DistributedPortGroupResource",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "List of active uplinks used for load balancing, matching the names of the",
                        "uplinks assigned in the DVS."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"active_uplinks\" <$> TF.attribute",
                    "name": "active_uplinks",
                    "method": "computedActiveUplinks",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedActiveUplinks",
                    "optional": true,
                    "label": "_computedActiveUplinks"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Controls whether or not the virtual network adapter is allowed to send",
                        "network traffic with a different MAC address than that of its own."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_forged_transmits\" <$> TF.attribute",
                    "name": "allow_forged_transmits",
                    "method": "computedAllowForgedTransmits",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedAllowForgedTransmits",
                    "optional": true,
                    "label": "_computedAllowForgedTransmits"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Controls whether or not the Media Access Control (MAC) address can be",
                        "changed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_mac_changes\" <$> TF.attribute",
                    "name": "allow_mac_changes",
                    "method": "computedAllowMacChanges",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedAllowMacChanges",
                    "optional": true,
                    "label": "_computedAllowMacChanges"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Enable promiscuous mode on the network. This flag indicates whether or not",
                        "all traffic is seen on a given port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_promiscuous\" <$> TF.attribute",
                    "name": "allow_promiscuous",
                    "method": "computedAllowPromiscuous",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedAllowPromiscuous",
                    "optional": true,
                    "label": "_computedAllowPromiscuous"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Indicates whether to block all ports by default."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"block_all_ports\" <$> TF.attribute",
                    "name": "block_all_ports",
                    "method": "computedBlockAllPorts",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedBlockAllPorts",
                    "optional": true,
                    "label": "_computedBlockAllPorts"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Enable beacon probing on the ports this policy applies to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"check_beacon\" <$> TF.attribute",
                    "name": "check_beacon",
                    "method": "computedCheckBeacon",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedCheckBeacon",
                    "optional": true,
                    "label": "_computedCheckBeacon"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Version string of the configuration that this spec is trying to change."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"config_version\" <$> TF.attribute",
                    "name": "config_version",
                    "method": "computedConfigVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedConfigVersion",
                    "optional": false,
                    "label": "_computedConfigVersion"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Allow VMDirectPath Gen2 on the ports this policy applies to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"directpath_gen2_allowed\" <$> TF.attribute",
                    "name": "directpath_gen2_allowed",
                    "method": "computedDirectpathGen2Allowed",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedDirectpathGen2Allowed",
                    "optional": true,
                    "label": "_computedDirectpathGen2Allowed"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The average egress bandwidth in bits per second if egress shaping is enabled",
                        "on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"egress_shaping_average_bandwidth\" <$> TF.attribute",
                    "name": "egress_shaping_average_bandwidth",
                    "method": "computedEgressShapingAverageBandwidth",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedEgressShapingAverageBandwidth",
                    "optional": true,
                    "label": "_computedEgressShapingAverageBandwidth"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum egress burst size allowed in bytes if egress shaping is enabled",
                        "on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"egress_shaping_burst_size\" <$> TF.attribute",
                    "name": "egress_shaping_burst_size",
                    "method": "computedEgressShapingBurstSize",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedEgressShapingBurstSize",
                    "optional": true,
                    "label": "_computedEgressShapingBurstSize"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "True if the traffic shaper is enabled for egress traffic on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"egress_shaping_enabled\" <$> TF.attribute",
                    "name": "egress_shaping_enabled",
                    "method": "computedEgressShapingEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedEgressShapingEnabled",
                    "optional": true,
                    "label": "_computedEgressShapingEnabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The peak egress bandwidth during bursts in bits per second if egress traffic",
                        "shaping is enabled on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"egress_shaping_peak_bandwidth\" <$> TF.attribute",
                    "name": "egress_shaping_peak_bandwidth",
                    "method": "computedEgressShapingPeakBandwidth",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedEgressShapingPeakBandwidth",
                    "optional": true,
                    "label": "_computedEgressShapingPeakBandwidth"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "If true, the teaming policy will re-activate failed interfaces higher in",
                        "precedence when they come back up."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failback\" <$> TF.attribute",
                    "name": "failback",
                    "method": "computedFailback",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedFailback",
                    "optional": true,
                    "label": "_computedFailback"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The average ingress bandwidth in bits per second if ingress shaping is",
                        "enabled on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ingress_shaping_average_bandwidth\" <$> TF.attribute",
                    "name": "ingress_shaping_average_bandwidth",
                    "method": "computedIngressShapingAverageBandwidth",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedIngressShapingAverageBandwidth",
                    "optional": true,
                    "label": "_computedIngressShapingAverageBandwidth"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum ingress burst size allowed in bytes if ingress shaping is",
                        "enabled on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ingress_shaping_burst_size\" <$> TF.attribute",
                    "name": "ingress_shaping_burst_size",
                    "method": "computedIngressShapingBurstSize",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedIngressShapingBurstSize",
                    "optional": true,
                    "label": "_computedIngressShapingBurstSize"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "True if the traffic shaper is enabled for ingress traffic on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ingress_shaping_enabled\" <$> TF.attribute",
                    "name": "ingress_shaping_enabled",
                    "method": "computedIngressShapingEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedIngressShapingEnabled",
                    "optional": true,
                    "label": "_computedIngressShapingEnabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The peak ingress bandwidth during bursts in bits per second if ingress",
                        "traffic shaping is enabled on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ingress_shaping_peak_bandwidth\" <$> TF.attribute",
                    "name": "ingress_shaping_peak_bandwidth",
                    "method": "computedIngressShapingPeakBandwidth",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedIngressShapingPeakBandwidth",
                    "optional": true,
                    "label": "_computedIngressShapingPeakBandwidth"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The generated UUID of the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "key",
                    "method": "computedKey",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedKey",
                    "optional": false,
                    "label": "_computedKey"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Whether or not to enable LACP on all uplink ports."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lacp_enabled\" <$> TF.attribute",
                    "name": "lacp_enabled",
                    "method": "computedLacpEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedLacpEnabled",
                    "optional": true,
                    "label": "_computedLacpEnabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The uplink LACP mode to use. Can be one of active or passive."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lacp_mode\" <$> TF.attribute",
                    "name": "lacp_mode",
                    "method": "computedLacpMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedLacpMode",
                    "optional": true,
                    "label": "_computedLacpMode"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Indicates whether to enable netflow on all ports."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"netflow_enabled\" <$> TF.attribute",
                    "name": "netflow_enabled",
                    "method": "computedNetflowEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedNetflowEnabled",
                    "optional": true,
                    "label": "_computedNetflowEnabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "If true, the teaming policy will notify the broadcast network of a NIC",
                        "failover, triggering cache updates."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"notify_switches\" <$> TF.attribute",
                    "name": "notify_switches",
                    "method": "computedNotifySwitches",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedNotifySwitches",
                    "optional": true,
                    "label": "_computedNotifySwitches"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The number of ports in this portgroup. The DVS will expand and shrink by",
                        "modifying this setting."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"number_of_ports\" <$> TF.attribute",
                    "name": "number_of_ports",
                    "method": "computedNumberOfPorts",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedNumberOfPorts",
                    "optional": true,
                    "label": "_computedNumberOfPorts"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The secondary VLAN ID for this port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port_private_secondary_vlan_id\" <$> TF.attribute",
                    "name": "port_private_secondary_vlan_id",
                    "method": "computedPortPrivateSecondaryVlanId",
                    "conflicts": [
                        "_vlanId",
                        "_vlanRange"
                    ],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedPortPrivateSecondaryVlanId",
                    "optional": true,
                    "label": "_computedPortPrivateSecondaryVlanId"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "List of active uplinks used for load balancing, matching the names of the",
                        "uplinks assigned in the DVS."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"standby_uplinks\" <$> TF.attribute",
                    "name": "standby_uplinks",
                    "method": "computedStandbyUplinks",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedStandbyUplinks",
                    "optional": true,
                    "label": "_computedStandbyUplinks"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The network adapter teaming policy. Can be one of loadbalance_ip,",
                        "loadbalance_srcmac, loadbalance_srcid, failover_explicit, or",
                        "loadbalance_loadbased."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"teaming_policy\" <$> TF.attribute",
                    "name": "teaming_policy",
                    "method": "computedTeamingPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedTeamingPolicy",
                    "optional": true,
                    "label": "_computedTeamingPolicy"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "If true, a copy of packets sent to the switch will always be forwarded to an",
                        "uplink in addition to the regular packet forwarded done by the switch."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tx_uplink\" <$> TF.attribute",
                    "name": "tx_uplink",
                    "method": "computedTxUplink",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedTxUplink",
                    "optional": true,
                    "label": "_computedTxUplink"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The VLAN ID for single VLAN mode. 0 denotes no VLAN."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vlan_id\" <$> TF.attribute",
                    "name": "vlan_id",
                    "method": "computedVlanId",
                    "conflicts": [
                        "_vlanRange",
                        "_portPrivateSecondaryVlanId"
                    ],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedVlanId",
                    "optional": true,
                    "label": "_computedVlanId"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The VLAN ID for single VLAN mode. 0 denotes no VLAN."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vlan_range\" <$> TF.attribute",
                    "name": "vlan_range",
                    "method": "computedVlanRange",
                    "conflicts": [
                        "_vlanId",
                        "_portPrivateSecondaryVlanId"
                    ],
                    "type": "TF.Attr s [TF.Attr s (VlanRange s)]",
                    "class": "HasComputedVlanRange",
                    "optional": true,
                    "label": "_computedVlanRange"
                }
            ],
            "parameters": [
                {
                    "default": "_distributedVirtualSwitchUuid",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The UUID of the DVS to attach this port group to."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"distributed_virtual_switch_uuid\" <$> TF.attribute",
                    "name": "distributed_virtual_switch_uuid",
                    "method": "distributedVirtualSwitchUuid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDistributedVirtualSwitchUuid",
                    "optional": false,
                    "label": "_distributedVirtualSwitchUuid"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "type": "DistributedPortGroupResource s",
            "original": "vsphere_distributed_port_group"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The contact detail for this DVS."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"contact_detail\" <$> TF.attribute",
                    "name": "contact_detail",
                    "method": "contactDetail",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasContactDetail",
                    "optional": true,
                    "label": "_contactDetail"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The contact name for this DVS."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"contact_name\" <$> TF.attribute",
                    "name": "contact_name",
                    "method": "contactName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasContactName",
                    "optional": true,
                    "label": "_contactName"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of custom attributes to set on this resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"custom_attributes\" <$> TF.attribute",
                    "name": "custom_attributes",
                    "method": "customAttributes",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasCustomAttributes",
                    "optional": true,
                    "label": "_customAttributes"
                },
                {
                    "default": "_datacenterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The ID of the datacenter to create this virtual switch in."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "datacenter_id",
                    "method": "datacenterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "optional": false,
                    "label": "_datacenterId"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The description of the DVS."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"description\" <$> TF.attribute",
                    "name": "description",
                    "method": "description",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDescription",
                    "optional": true,
                    "label": "_description"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The folder to create this virtual switch in, relative to the datacenter."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"folder\" <$> TF.attribute",
                    "name": "folder",
                    "method": "folder",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFolder",
                    "optional": true,
                    "label": "_folder"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A host member specification."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "host",
                    "method": "host",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (Host s)]",
                    "class": "HasHost",
                    "optional": true,
                    "label": "_host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The IPv4 address of the switch. This can be used to see the DVS as a unique",
                        "device with NetFlow."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ipv4_address\" <$> TF.attribute",
                    "name": "ipv4_address",
                    "method": "ipv4Address",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIpv4Address",
                    "optional": true,
                    "label": "_ipv4Address"
                },
                {
                    "default": "TF.value \"listen\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to advertise or listen for link discovery. Valid values are",
                        "advertise, both, listen, and none."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"link_discovery_operation\" <$> TF.attribute",
                    "name": "link_discovery_operation",
                    "method": "linkDiscoveryOperation",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLinkDiscoveryOperation",
                    "optional": true,
                    "label": "_linkDiscoveryOperation"
                },
                {
                    "default": "TF.value \"cdp\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The discovery protocol type. Valid values are cdp and lldp."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"link_discovery_protocol\" <$> TF.attribute",
                    "name": "link_discovery_protocol",
                    "method": "linkDiscoveryProtocol",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLinkDiscoveryProtocol",
                    "optional": true,
                    "label": "_linkDiscoveryProtocol"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name for the DVS. Must be unique in the folder that it is being created",
                        "in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "TF.value 60",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The number of seconds after which active flows are forced to be exported to",
                        "the collector."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"netflow_active_flow_timeout\" <$> TF.attribute",
                    "name": "netflow_active_flow_timeout",
                    "method": "netflowActiveFlowTimeout",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasNetflowActiveFlowTimeout",
                    "optional": true,
                    "label": "_netflowActiveFlowTimeout"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "IP address for the netflow collector, using IPv4 or IPv6. IPv6 is supported",
                        "in vSphere Distributed Switch Version 6.0 or later."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"netflow_collector_ip_address\" <$> TF.attribute",
                    "name": "netflow_collector_ip_address",
                    "method": "netflowCollectorIpAddress",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNetflowCollectorIpAddress",
                    "optional": true,
                    "label": "_netflowCollectorIpAddress"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The port for the netflow collector."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"netflow_collector_port\" <$> TF.attribute",
                    "name": "netflow_collector_port",
                    "method": "netflowCollectorPort",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasNetflowCollectorPort",
                    "optional": true,
                    "label": "_netflowCollectorPort"
                },
                {
                    "default": "TF.value 15",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The number of seconds after which idle flows are forced to be exported to",
                        "the collector."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"netflow_idle_flow_timeout\" <$> TF.attribute",
                    "name": "netflow_idle_flow_timeout",
                    "method": "netflowIdleFlowTimeout",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasNetflowIdleFlowTimeout",
                    "optional": true,
                    "label": "_netflowIdleFlowTimeout"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to limit analysis to traffic that has both source and destination",
                        "served by the same host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"netflow_internal_flows_only\" <$> TF.attribute",
                    "name": "netflow_internal_flows_only",
                    "method": "netflowInternalFlowsOnly",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasNetflowInternalFlowsOnly",
                    "optional": true,
                    "label": "_netflowInternalFlowsOnly"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The observation Domain ID for the netflow collector."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"netflow_observation_domain_id\" <$> TF.attribute",
                    "name": "netflow_observation_domain_id",
                    "method": "netflowObservationDomainId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasNetflowObservationDomainId",
                    "optional": true,
                    "label": "_netflowObservationDomainId"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The ratio of total number of packets to the number of packets analyzed. Set",
                        "to 0 to disable sampling, meaning that all packets are analyzed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"netflow_sampling_rate\" <$> TF.attribute",
                    "name": "netflow_sampling_rate",
                    "method": "netflowSamplingRate",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasNetflowSamplingRate",
                    "optional": true,
                    "label": "_netflowSamplingRate"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether or not to enable network resource control, enabling advanced traffic",
                        "shaping and resource control features."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_resource_control_enabled\" <$> TF.attribute",
                    "name": "network_resource_control_enabled",
                    "method": "networkResourceControlEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasNetworkResourceControlEnabled",
                    "optional": true,
                    "label": "_networkResourceControlEnabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of tag IDs to apply to this object."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tags\" <$> TF.attribute",
                    "name": "tags",
                    "method": "tags",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasTags",
                    "optional": true,
                    "label": "_tags"
                }
            ],
            "schema": "Resource",
            "name": "DistributedVirtualSwitchResource",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "List of active uplinks used for load balancing, matching the names of the",
                        "uplinks assigned in the DVS."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"active_uplinks\" <$> TF.attribute",
                    "name": "active_uplinks",
                    "method": "computedActiveUplinks",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedActiveUplinks",
                    "optional": true,
                    "label": "_computedActiveUplinks"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Controls whether or not the virtual network adapter is allowed to send",
                        "network traffic with a different MAC address than that of its own."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_forged_transmits\" <$> TF.attribute",
                    "name": "allow_forged_transmits",
                    "method": "computedAllowForgedTransmits",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedAllowForgedTransmits",
                    "optional": true,
                    "label": "_computedAllowForgedTransmits"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Controls whether or not the Media Access Control (MAC) address can be",
                        "changed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_mac_changes\" <$> TF.attribute",
                    "name": "allow_mac_changes",
                    "method": "computedAllowMacChanges",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedAllowMacChanges",
                    "optional": true,
                    "label": "_computedAllowMacChanges"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Enable promiscuous mode on the network. This flag indicates whether or not",
                        "all traffic is seen on a given port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_promiscuous\" <$> TF.attribute",
                    "name": "allow_promiscuous",
                    "method": "computedAllowPromiscuous",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedAllowPromiscuous",
                    "optional": true,
                    "label": "_computedAllowPromiscuous"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Indicates whether to block all ports by default."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"block_all_ports\" <$> TF.attribute",
                    "name": "block_all_ports",
                    "method": "computedBlockAllPorts",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedBlockAllPorts",
                    "optional": true,
                    "label": "_computedBlockAllPorts"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Enable beacon probing on the ports this policy applies to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"check_beacon\" <$> TF.attribute",
                    "name": "check_beacon",
                    "method": "computedCheckBeacon",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedCheckBeacon",
                    "optional": true,
                    "label": "_computedCheckBeacon"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The version string of the configuration that this spec is trying to change."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"config_version\" <$> TF.attribute",
                    "name": "config_version",
                    "method": "computedConfigVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedConfigVersion",
                    "optional": false,
                    "label": "_computedConfigVersion"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Allow VMDirectPath Gen2 on the ports this policy applies to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"directpath_gen2_allowed\" <$> TF.attribute",
                    "name": "directpath_gen2_allowed",
                    "method": "computedDirectpathGen2Allowed",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedDirectpathGen2Allowed",
                    "optional": true,
                    "label": "_computedDirectpathGen2Allowed"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The average egress bandwidth in bits per second if egress shaping is enabled",
                        "on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"egress_shaping_average_bandwidth\" <$> TF.attribute",
                    "name": "egress_shaping_average_bandwidth",
                    "method": "computedEgressShapingAverageBandwidth",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedEgressShapingAverageBandwidth",
                    "optional": true,
                    "label": "_computedEgressShapingAverageBandwidth"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum egress burst size allowed in bytes if egress shaping is enabled",
                        "on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"egress_shaping_burst_size\" <$> TF.attribute",
                    "name": "egress_shaping_burst_size",
                    "method": "computedEgressShapingBurstSize",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedEgressShapingBurstSize",
                    "optional": true,
                    "label": "_computedEgressShapingBurstSize"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "True if the traffic shaper is enabled for egress traffic on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"egress_shaping_enabled\" <$> TF.attribute",
                    "name": "egress_shaping_enabled",
                    "method": "computedEgressShapingEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedEgressShapingEnabled",
                    "optional": true,
                    "label": "_computedEgressShapingEnabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The peak egress bandwidth during bursts in bits per second if egress traffic",
                        "shaping is enabled on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"egress_shaping_peak_bandwidth\" <$> TF.attribute",
                    "name": "egress_shaping_peak_bandwidth",
                    "method": "computedEgressShapingPeakBandwidth",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedEgressShapingPeakBandwidth",
                    "optional": true,
                    "label": "_computedEgressShapingPeakBandwidth"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "If true, the teaming policy will re-activate failed interfaces higher in",
                        "precedence when they come back up."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failback\" <$> TF.attribute",
                    "name": "failback",
                    "method": "computedFailback",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedFailback",
                    "optional": true,
                    "label": "_computedFailback"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum allowed usage for the faultTolerance traffic class, in",
                        "Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"faulttolerance_maximum_mbit\" <$> TF.attribute",
                    "name": "faulttolerance_maximum_mbit",
                    "method": "computedFaulttoleranceMaximumMbit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedFaulttoleranceMaximumMbit",
                    "optional": true,
                    "label": "_computedFaulttoleranceMaximumMbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of guaranteed bandwidth for the faultTolerance traffic class, in",
                        "Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"faulttolerance_reservation_mbit\" <$> TF.attribute",
                    "name": "faulttolerance_reservation_mbit",
                    "method": "computedFaulttoleranceReservationMbit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedFaulttoleranceReservationMbit",
                    "optional": true,
                    "label": "_computedFaulttoleranceReservationMbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of shares to allocate to the faultTolerance traffic class for a",
                        "custom share level."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"faulttolerance_share_count\" <$> TF.attribute",
                    "name": "faulttolerance_share_count",
                    "method": "computedFaulttoleranceShareCount",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedFaulttoleranceShareCount",
                    "optional": true,
                    "label": "_computedFaulttoleranceShareCount"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The allocation level for the faultTolerance traffic class. Can be one of",
                        "high, low, normal, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"faulttolerance_share_level\" <$> TF.attribute",
                    "name": "faulttolerance_share_level",
                    "method": "computedFaulttoleranceShareLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedFaulttoleranceShareLevel",
                    "optional": true,
                    "label": "_computedFaulttoleranceShareLevel"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum allowed usage for the hbr traffic class, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"hbr_maximum_mbit\" <$> TF.attribute",
                    "name": "hbr_maximum_mbit",
                    "method": "computedHbrMaximumMbit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedHbrMaximumMbit",
                    "optional": true,
                    "label": "_computedHbrMaximumMbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"hbr_reservation_mbit\" <$> TF.attribute",
                    "name": "hbr_reservation_mbit",
                    "method": "computedHbrReservationMbit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedHbrReservationMbit",
                    "optional": true,
                    "label": "_computedHbrReservationMbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of shares to allocate to the hbr traffic class for a custom share",
                        "level."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"hbr_share_count\" <$> TF.attribute",
                    "name": "hbr_share_count",
                    "method": "computedHbrShareCount",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedHbrShareCount",
                    "optional": true,
                    "label": "_computedHbrShareCount"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The allocation level for the hbr traffic class. Can be one of high, low,",
                        "normal, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"hbr_share_level\" <$> TF.attribute",
                    "name": "hbr_share_level",
                    "method": "computedHbrShareLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedHbrShareLevel",
                    "optional": true,
                    "label": "_computedHbrShareLevel"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The average ingress bandwidth in bits per second if ingress shaping is",
                        "enabled on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ingress_shaping_average_bandwidth\" <$> TF.attribute",
                    "name": "ingress_shaping_average_bandwidth",
                    "method": "computedIngressShapingAverageBandwidth",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedIngressShapingAverageBandwidth",
                    "optional": true,
                    "label": "_computedIngressShapingAverageBandwidth"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum ingress burst size allowed in bytes if ingress shaping is",
                        "enabled on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ingress_shaping_burst_size\" <$> TF.attribute",
                    "name": "ingress_shaping_burst_size",
                    "method": "computedIngressShapingBurstSize",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedIngressShapingBurstSize",
                    "optional": true,
                    "label": "_computedIngressShapingBurstSize"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "True if the traffic shaper is enabled for ingress traffic on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ingress_shaping_enabled\" <$> TF.attribute",
                    "name": "ingress_shaping_enabled",
                    "method": "computedIngressShapingEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedIngressShapingEnabled",
                    "optional": true,
                    "label": "_computedIngressShapingEnabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The peak ingress bandwidth during bursts in bits per second if ingress",
                        "traffic shaping is enabled on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ingress_shaping_peak_bandwidth\" <$> TF.attribute",
                    "name": "ingress_shaping_peak_bandwidth",
                    "method": "computedIngressShapingPeakBandwidth",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedIngressShapingPeakBandwidth",
                    "optional": true,
                    "label": "_computedIngressShapingPeakBandwidth"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum allowed usage for the iSCSI traffic class, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi_maximum_mbit\" <$> TF.attribute",
                    "name": "iscsi_maximum_mbit",
                    "method": "computedIscsiMaximumMbit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedIscsiMaximumMbit",
                    "optional": true,
                    "label": "_computedIscsiMaximumMbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of guaranteed bandwidth for the iSCSI traffic class, in",
                        "Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi_reservation_mbit\" <$> TF.attribute",
                    "name": "iscsi_reservation_mbit",
                    "method": "computedIscsiReservationMbit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedIscsiReservationMbit",
                    "optional": true,
                    "label": "_computedIscsiReservationMbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of shares to allocate to the iSCSI traffic class for a custom",
                        "share level."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi_share_count\" <$> TF.attribute",
                    "name": "iscsi_share_count",
                    "method": "computedIscsiShareCount",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedIscsiShareCount",
                    "optional": true,
                    "label": "_computedIscsiShareCount"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The allocation level for the iSCSI traffic class. Can be one of high, low,",
                        "normal, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi_share_level\" <$> TF.attribute",
                    "name": "iscsi_share_level",
                    "method": "computedIscsiShareLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedIscsiShareLevel",
                    "optional": true,
                    "label": "_computedIscsiShareLevel"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The Link Aggregation Control Protocol group version in the switch. Can be",
                        "one of singleLag or multipleLag."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lacp_api_version\" <$> TF.attribute",
                    "name": "lacp_api_version",
                    "method": "computedLacpApiVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedLacpApiVersion",
                    "optional": true,
                    "label": "_computedLacpApiVersion"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Whether or not to enable LACP on all uplink ports."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lacp_enabled\" <$> TF.attribute",
                    "name": "lacp_enabled",
                    "method": "computedLacpEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedLacpEnabled",
                    "optional": true,
                    "label": "_computedLacpEnabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The uplink LACP mode to use. Can be one of active or passive."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lacp_mode\" <$> TF.attribute",
                    "name": "lacp_mode",
                    "method": "computedLacpMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedLacpMode",
                    "optional": true,
                    "label": "_computedLacpMode"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum allowed usage for the management traffic class, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"management_maximum_mbit\" <$> TF.attribute",
                    "name": "management_maximum_mbit",
                    "method": "computedManagementMaximumMbit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedManagementMaximumMbit",
                    "optional": true,
                    "label": "_computedManagementMaximumMbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of guaranteed bandwidth for the management traffic class, in",
                        "Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"management_reservation_mbit\" <$> TF.attribute",
                    "name": "management_reservation_mbit",
                    "method": "computedManagementReservationMbit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedManagementReservationMbit",
                    "optional": true,
                    "label": "_computedManagementReservationMbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of shares to allocate to the management traffic class for a",
                        "custom share level."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"management_share_count\" <$> TF.attribute",
                    "name": "management_share_count",
                    "method": "computedManagementShareCount",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedManagementShareCount",
                    "optional": true,
                    "label": "_computedManagementShareCount"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The allocation level for the management traffic class. Can be one of high,",
                        "low, normal, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"management_share_level\" <$> TF.attribute",
                    "name": "management_share_level",
                    "method": "computedManagementShareLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedManagementShareLevel",
                    "optional": true,
                    "label": "_computedManagementShareLevel"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum MTU on the switch."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"max_mtu\" <$> TF.attribute",
                    "name": "max_mtu",
                    "method": "computedMaxMtu",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedMaxMtu",
                    "optional": true,
                    "label": "_computedMaxMtu"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The multicast filtering mode on the switch. Can be one of legacyFiltering,",
                        "or snooping."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"multicast_filtering_mode\" <$> TF.attribute",
                    "name": "multicast_filtering_mode",
                    "method": "computedMulticastFilteringMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMulticastFilteringMode",
                    "optional": true,
                    "label": "_computedMulticastFilteringMode"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Indicates whether to enable netflow on all ports."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"netflow_enabled\" <$> TF.attribute",
                    "name": "netflow_enabled",
                    "method": "computedNetflowEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedNetflowEnabled",
                    "optional": true,
                    "label": "_computedNetflowEnabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The network I/O control version to use. Can be one of version2 or version3."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_resource_control_version\" <$> TF.attribute",
                    "name": "network_resource_control_version",
                    "method": "computedNetworkResourceControlVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedNetworkResourceControlVersion",
                    "optional": true,
                    "label": "_computedNetworkResourceControlVersion"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum allowed usage for the nfs traffic class, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"nfs_maximum_mbit\" <$> TF.attribute",
                    "name": "nfs_maximum_mbit",
                    "method": "computedNfsMaximumMbit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedNfsMaximumMbit",
                    "optional": true,
                    "label": "_computedNfsMaximumMbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"nfs_reservation_mbit\" <$> TF.attribute",
                    "name": "nfs_reservation_mbit",
                    "method": "computedNfsReservationMbit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedNfsReservationMbit",
                    "optional": true,
                    "label": "_computedNfsReservationMbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of shares to allocate to the nfs traffic class for a custom share",
                        "level."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"nfs_share_count\" <$> TF.attribute",
                    "name": "nfs_share_count",
                    "method": "computedNfsShareCount",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedNfsShareCount",
                    "optional": true,
                    "label": "_computedNfsShareCount"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The allocation level for the nfs traffic class. Can be one of high, low,",
                        "normal, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"nfs_share_level\" <$> TF.attribute",
                    "name": "nfs_share_level",
                    "method": "computedNfsShareLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedNfsShareLevel",
                    "optional": true,
                    "label": "_computedNfsShareLevel"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "If true, the teaming policy will notify the broadcast network of a NIC",
                        "failover, triggering cache updates."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"notify_switches\" <$> TF.attribute",
                    "name": "notify_switches",
                    "method": "computedNotifySwitches",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedNotifySwitches",
                    "optional": true,
                    "label": "_computedNotifySwitches"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The secondary VLAN ID for this port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port_private_secondary_vlan_id\" <$> TF.attribute",
                    "name": "port_private_secondary_vlan_id",
                    "method": "computedPortPrivateSecondaryVlanId",
                    "conflicts": [
                        "_vlanId",
                        "_vlanRange"
                    ],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedPortPrivateSecondaryVlanId",
                    "optional": true,
                    "label": "_computedPortPrivateSecondaryVlanId"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "List of active uplinks used for load balancing, matching the names of the",
                        "uplinks assigned in the DVS."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"standby_uplinks\" <$> TF.attribute",
                    "name": "standby_uplinks",
                    "method": "computedStandbyUplinks",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedStandbyUplinks",
                    "optional": true,
                    "label": "_computedStandbyUplinks"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The network adapter teaming policy. Can be one of loadbalance_ip,",
                        "loadbalance_srcmac, loadbalance_srcid, failover_explicit, or",
                        "loadbalance_loadbased."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"teaming_policy\" <$> TF.attribute",
                    "name": "teaming_policy",
                    "method": "computedTeamingPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedTeamingPolicy",
                    "optional": true,
                    "label": "_computedTeamingPolicy"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "If true, a copy of packets sent to the switch will always be forwarded to an",
                        "uplink in addition to the regular packet forwarded done by the switch."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tx_uplink\" <$> TF.attribute",
                    "name": "tx_uplink",
                    "method": "computedTxUplink",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedTxUplink",
                    "optional": true,
                    "label": "_computedTxUplink"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A list of uplink ports. The contents of this list control both the uplink",
                        "count and names of the uplinks on the DVS across hosts."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uplinks\" <$> TF.attribute",
                    "name": "uplinks",
                    "method": "computedUplinks",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedUplinks",
                    "optional": true,
                    "label": "_computedUplinks"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum allowed usage for the vdp traffic class, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vdp_maximum_mbit\" <$> TF.attribute",
                    "name": "vdp_maximum_mbit",
                    "method": "computedVdpMaximumMbit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedVdpMaximumMbit",
                    "optional": true,
                    "label": "_computedVdpMaximumMbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vdp_reservation_mbit\" <$> TF.attribute",
                    "name": "vdp_reservation_mbit",
                    "method": "computedVdpReservationMbit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedVdpReservationMbit",
                    "optional": true,
                    "label": "_computedVdpReservationMbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of shares to allocate to the vdp traffic class for a custom share",
                        "level."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vdp_share_count\" <$> TF.attribute",
                    "name": "vdp_share_count",
                    "method": "computedVdpShareCount",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedVdpShareCount",
                    "optional": true,
                    "label": "_computedVdpShareCount"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The allocation level for the vdp traffic class. Can be one of high, low,",
                        "normal, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vdp_share_level\" <$> TF.attribute",
                    "name": "vdp_share_level",
                    "method": "computedVdpShareLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedVdpShareLevel",
                    "optional": true,
                    "label": "_computedVdpShareLevel"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The version of this virtual switch. Allowed versions are 6.5.0, 6.0.0,",
                        "5.5.0, 5.1.0, and 5.0.0."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"version\" <$> TF.attribute",
                    "name": "version",
                    "method": "computedVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedVersion",
                    "optional": true,
                    "label": "_computedVersion"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum allowed usage for the virtualMachine traffic class, in",
                        "Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"virtualmachine_maximum_mbit\" <$> TF.attribute",
                    "name": "virtualmachine_maximum_mbit",
                    "method": "computedVirtualmachineMaximumMbit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedVirtualmachineMaximumMbit",
                    "optional": true,
                    "label": "_computedVirtualmachineMaximumMbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of guaranteed bandwidth for the virtualMachine traffic class, in",
                        "Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"virtualmachine_reservation_mbit\" <$> TF.attribute",
                    "name": "virtualmachine_reservation_mbit",
                    "method": "computedVirtualmachineReservationMbit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedVirtualmachineReservationMbit",
                    "optional": true,
                    "label": "_computedVirtualmachineReservationMbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of shares to allocate to the virtualMachine traffic class for a",
                        "custom share level."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"virtualmachine_share_count\" <$> TF.attribute",
                    "name": "virtualmachine_share_count",
                    "method": "computedVirtualmachineShareCount",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedVirtualmachineShareCount",
                    "optional": true,
                    "label": "_computedVirtualmachineShareCount"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The allocation level for the virtualMachine traffic class. Can be one of",
                        "high, low, normal, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"virtualmachine_share_level\" <$> TF.attribute",
                    "name": "virtualmachine_share_level",
                    "method": "computedVirtualmachineShareLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedVirtualmachineShareLevel",
                    "optional": true,
                    "label": "_computedVirtualmachineShareLevel"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The VLAN ID for single VLAN mode. 0 denotes no VLAN."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vlan_id\" <$> TF.attribute",
                    "name": "vlan_id",
                    "method": "computedVlanId",
                    "conflicts": [
                        "_vlanRange",
                        "_portPrivateSecondaryVlanId"
                    ],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedVlanId",
                    "optional": true,
                    "label": "_computedVlanId"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The VLAN ID for single VLAN mode. 0 denotes no VLAN."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vlan_range\" <$> TF.attribute",
                    "name": "vlan_range",
                    "method": "computedVlanRange",
                    "conflicts": [
                        "_vlanId",
                        "_portPrivateSecondaryVlanId"
                    ],
                    "type": "TF.Attr s [TF.Attr s (VlanRange s)]",
                    "class": "HasComputedVlanRange",
                    "optional": true,
                    "label": "_computedVlanRange"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum allowed usage for the vmotion traffic class, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vmotion_maximum_mbit\" <$> TF.attribute",
                    "name": "vmotion_maximum_mbit",
                    "method": "computedVmotionMaximumMbit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedVmotionMaximumMbit",
                    "optional": true,
                    "label": "_computedVmotionMaximumMbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of guaranteed bandwidth for the vmotion traffic class, in",
                        "Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vmotion_reservation_mbit\" <$> TF.attribute",
                    "name": "vmotion_reservation_mbit",
                    "method": "computedVmotionReservationMbit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedVmotionReservationMbit",
                    "optional": true,
                    "label": "_computedVmotionReservationMbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of shares to allocate to the vmotion traffic class for a custom",
                        "share level."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vmotion_share_count\" <$> TF.attribute",
                    "name": "vmotion_share_count",
                    "method": "computedVmotionShareCount",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedVmotionShareCount",
                    "optional": true,
                    "label": "_computedVmotionShareCount"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The allocation level for the vmotion traffic class. Can be one of high, low,",
                        "normal, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vmotion_share_level\" <$> TF.attribute",
                    "name": "vmotion_share_level",
                    "method": "computedVmotionShareLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedVmotionShareLevel",
                    "optional": true,
                    "label": "_computedVmotionShareLevel"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum allowed usage for the vsan traffic class, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vsan_maximum_mbit\" <$> TF.attribute",
                    "name": "vsan_maximum_mbit",
                    "method": "computedVsanMaximumMbit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedVsanMaximumMbit",
                    "optional": true,
                    "label": "_computedVsanMaximumMbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vsan_reservation_mbit\" <$> TF.attribute",
                    "name": "vsan_reservation_mbit",
                    "method": "computedVsanReservationMbit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedVsanReservationMbit",
                    "optional": true,
                    "label": "_computedVsanReservationMbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of shares to allocate to the vsan traffic class for a custom",
                        "share level."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vsan_share_count\" <$> TF.attribute",
                    "name": "vsan_share_count",
                    "method": "computedVsanShareCount",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedVsanShareCount",
                    "optional": true,
                    "label": "_computedVsanShareCount"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The allocation level for the vsan traffic class. Can be one of high, low,",
                        "normal, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vsan_share_level\" <$> TF.attribute",
                    "name": "vsan_share_level",
                    "method": "computedVsanShareLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedVsanShareLevel",
                    "optional": true,
                    "label": "_computedVsanShareLevel"
                }
            ],
            "parameters": [
                {
                    "default": "_datacenterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The ID of the datacenter to create this virtual switch in."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "datacenter_id",
                    "method": "datacenterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "optional": false,
                    "label": "_datacenterId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name for the DVS. Must be unique in the folder that it is being created",
                        "in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "type": "DistributedVirtualSwitchResource s",
            "original": "vsphere_distributed_virtual_switch"
        },
        {
            "arguments": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "compute_cluster_id",
                    "method": "computeClusterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "optional": false,
                    "label": "_computeClusterId"
                },
                {
                    "default": "TF.value \"manual\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The automation level for power operations on this host. Can be one of manual",
                        "or automated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dpm_automation_level\" <$> TF.attribute",
                    "name": "dpm_automation_level",
                    "method": "dpmAutomationLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDpmAutomationLevel",
                    "optional": true,
                    "label": "_dpmAutomationLevel"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable DPM for this host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dpm_enabled\" <$> TF.attribute",
                    "name": "dpm_enabled",
                    "method": "dpmEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasDpmEnabled",
                    "optional": true,
                    "label": "_dpmEnabled"
                },
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "host_system_id",
                    "method": "hostSystemId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "optional": false,
                    "label": "_hostSystemId"
                }
            ],
            "schema": "Resource",
            "name": "DpmHostOverrideResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "compute_cluster_id",
                    "method": "computeClusterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "optional": false,
                    "label": "_computeClusterId"
                },
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "host_system_id",
                    "method": "hostSystemId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "optional": false,
                    "label": "_hostSystemId"
                }
            ],
            "type": "DpmHostOverrideResource s",
            "original": "vsphere_dpm_host_override"
        },
        {
            "arguments": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "compute_cluster_id",
                    "method": "computeClusterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "optional": false,
                    "label": "_computeClusterId"
                },
                {
                    "default": "TF.value \"manual\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The automation level for this virtual machine in the cluster. Can be one of",
                        "manual, partiallyAutomated, or fullyAutomated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drs_automation_level\" <$> TF.attribute",
                    "name": "drs_automation_level",
                    "method": "drsAutomationLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDrsAutomationLevel",
                    "optional": true,
                    "label": "_drsAutomationLevel"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable DRS for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drs_enabled\" <$> TF.attribute",
                    "name": "drs_enabled",
                    "method": "drsEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasDrsEnabled",
                    "optional": true,
                    "label": "_drsEnabled"
                },
                {
                    "default": "_virtualMachineId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the virtual machine."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"virtual_machine_id\" <$> TF.attribute",
                    "name": "virtual_machine_id",
                    "method": "virtualMachineId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVirtualMachineId",
                    "optional": false,
                    "label": "_virtualMachineId"
                }
            ],
            "schema": "Resource",
            "name": "DrsVmOverrideResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "compute_cluster_id",
                    "method": "computeClusterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "optional": false,
                    "label": "_computeClusterId"
                },
                {
                    "default": "_virtualMachineId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the virtual machine."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"virtual_machine_id\" <$> TF.attribute",
                    "name": "virtual_machine_id",
                    "method": "virtualMachineId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVirtualMachineId",
                    "optional": false,
                    "label": "_virtualMachineId"
                }
            ],
            "type": "DrsVmOverrideResource s",
            "original": "vsphere_drs_vm_override"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"create_directories\" <$> TF.attribute",
                    "name": "create_directories",
                    "method": "createDirectories",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasCreateDirectories",
                    "optional": true,
                    "label": "_createDirectories"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"datacenter\" <$> TF.attribute",
                    "name": "datacenter",
                    "method": "datacenter",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenter",
                    "optional": true,
                    "label": "_datacenter"
                },
                {
                    "default": "_datastore",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"datastore\" <$> TF.attribute",
                    "name": "datastore",
                    "method": "datastore",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastore",
                    "optional": false,
                    "label": "_datastore"
                },
                {
                    "default": "_destinationFile",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"destination_file\" <$> TF.attribute",
                    "name": "destination_file",
                    "method": "destinationFile",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDestinationFile",
                    "optional": false,
                    "label": "_destinationFile"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"source_datacenter\" <$> TF.attribute",
                    "name": "source_datacenter",
                    "method": "sourceDatacenter",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSourceDatacenter",
                    "optional": true,
                    "label": "_sourceDatacenter"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"source_datastore\" <$> TF.attribute",
                    "name": "source_datastore",
                    "method": "sourceDatastore",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSourceDatastore",
                    "optional": true,
                    "label": "_sourceDatastore"
                },
                {
                    "default": "_sourceFile",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"source_file\" <$> TF.attribute",
                    "name": "source_file",
                    "method": "sourceFile",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSourceFile",
                    "optional": false,
                    "label": "_sourceFile"
                }
            ],
            "schema": "Resource",
            "name": "FileResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_datastore",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"datastore\" <$> TF.attribute",
                    "name": "datastore",
                    "method": "datastore",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastore",
                    "optional": false,
                    "label": "_datastore"
                },
                {
                    "default": "_destinationFile",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"destination_file\" <$> TF.attribute",
                    "name": "destination_file",
                    "method": "destinationFile",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDestinationFile",
                    "optional": false,
                    "label": "_destinationFile"
                },
                {
                    "default": "_sourceFile",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"source_file\" <$> TF.attribute",
                    "name": "source_file",
                    "method": "sourceFile",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSourceFile",
                    "optional": false,
                    "label": "_sourceFile"
                }
            ],
            "type": "FileResource s",
            "original": "vsphere_file"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of custom attributes to set on this resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"custom_attributes\" <$> TF.attribute",
                    "name": "custom_attributes",
                    "method": "customAttributes",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasCustomAttributes",
                    "optional": true,
                    "label": "_customAttributes"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The ID of the datacenter. Can be ignored if creating a datacenter folder,",
                        "otherwise required."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "datacenter_id",
                    "method": "datacenterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "optional": true,
                    "label": "_datacenterId"
                },
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The path of the folder and any parents, relative to the datacenter and",
                        "folder type being defined."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "optional": false,
                    "label": "_path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of tag IDs to apply to this object."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tags\" <$> TF.attribute",
                    "name": "tags",
                    "method": "tags",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasTags",
                    "optional": true,
                    "label": "_tags"
                },
                {
                    "default": "_type'",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The type of the folder."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "type",
                    "method": "type'",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "optional": false,
                    "label": "_type'"
                }
            ],
            "schema": "Resource",
            "name": "FolderResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The path of the folder and any parents, relative to the datacenter and",
                        "folder type being defined."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "path",
                    "method": "path",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "optional": false,
                    "label": "_path"
                },
                {
                    "default": "_type'",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The type of the folder."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "type",
                    "method": "type'",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "optional": false,
                    "label": "_type'"
                }
            ],
            "type": "FolderResource s",
            "original": "vsphere_folder"
        },
        {
            "arguments": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "compute_cluster_id",
                    "method": "computeClusterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "optional": false,
                    "label": "_computeClusterId"
                },
                {
                    "default": "TF.value \"useClusterDefault\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Controls the action to take on this virtual machine if an APD status on an",
                        "affected datastore clears in the middle of an APD event. Can be one of",
                        "useClusterDefault, none or reset."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_datastore_apd_recovery_action\" <$> TF.attribute",
                    "name": "ha_datastore_apd_recovery_action",
                    "method": "haDatastoreApdRecoveryAction",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaDatastoreApdRecoveryAction",
                    "optional": true,
                    "label": "_haDatastoreApdRecoveryAction"
                },
                {
                    "default": "TF.value \"clusterDefault\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Controls the action to take on this virtual machine when the cluster has",
                        "detected loss to all paths to a relevant datastore. Can be one of",
                        "clusterDefault, disabled, warning, restartConservative, or",
                        "restartAggressive."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_datastore_apd_response\" <$> TF.attribute",
                    "name": "ha_datastore_apd_response",
                    "method": "haDatastoreApdResponse",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaDatastoreApdResponse",
                    "optional": true,
                    "label": "_haDatastoreApdResponse"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Controls the delay in minutes to wait after an APD timeout event to execute",
                        "the response action defined in ha_datastore_apd_response. Specify -1 to use",
                        "the cluster setting."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_datastore_apd_response_delay\" <$> TF.attribute",
                    "name": "ha_datastore_apd_response_delay",
                    "method": "haDatastoreApdResponseDelay",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasHaDatastoreApdResponseDelay",
                    "optional": true,
                    "label": "_haDatastoreApdResponseDelay"
                },
                {
                    "default": "TF.value \"clusterDefault\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Controls the action to take on this virtual machine when the cluster has",
                        "detected a permanent device loss to a relevant datastore. Can be one of",
                        "clusterDefault, disabled, warning, or restartAggressive."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_datastore_pdl_response\" <$> TF.attribute",
                    "name": "ha_datastore_pdl_response",
                    "method": "haDatastorePdlResponse",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaDatastorePdlResponse",
                    "optional": true,
                    "label": "_haDatastorePdlResponse"
                },
                {
                    "default": "TF.value \"clusterIsolationResponse\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The action to take on this virtual machine when a host is isolated from the",
                        "rest of the cluster. Can be one of clusterIsolationResponse, none, powerOff,",
                        "or shutdown."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_host_isolation_response\" <$> TF.attribute",
                    "name": "ha_host_isolation_response",
                    "method": "haHostIsolationResponse",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaHostIsolationResponse",
                    "optional": true,
                    "label": "_haHostIsolationResponse"
                },
                {
                    "default": "TF.value 30",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If a heartbeat from this virtual machine is not received within this",
                        "configured interval, the virtual machine is marked as failed. The value is",
                        "in seconds."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_failure_interval\" <$> TF.attribute",
                    "name": "ha_vm_failure_interval",
                    "method": "haVmFailureInterval",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasHaVmFailureInterval",
                    "optional": true,
                    "label": "_haVmFailureInterval"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The length of the reset window in which ha_vm_maximum_resets can operate.",
                        "When this window expires, no more resets are attempted regardless of the",
                        "setting configured in ha_vm_maximum_resets. -1 means no window, meaning an",
                        "unlimited reset time is allotted."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_maximum_failure_window\" <$> TF.attribute",
                    "name": "ha_vm_maximum_failure_window",
                    "method": "haVmMaximumFailureWindow",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasHaVmMaximumFailureWindow",
                    "optional": true,
                    "label": "_haVmMaximumFailureWindow"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The maximum number of resets that HA will perform to this virtual machine",
                        "when responding to a failure event."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_maximum_resets\" <$> TF.attribute",
                    "name": "ha_vm_maximum_resets",
                    "method": "haVmMaximumResets",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasHaVmMaximumResets",
                    "optional": true,
                    "label": "_haVmMaximumResets"
                },
                {
                    "default": "TF.value 120",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The time, in seconds, that HA waits after powering on this virtual machine",
                        "before monitoring for heartbeats."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_minimum_uptime\" <$> TF.attribute",
                    "name": "ha_vm_minimum_uptime",
                    "method": "haVmMinimumUptime",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasHaVmMinimumUptime",
                    "optional": true,
                    "label": "_haVmMinimumUptime"
                },
                {
                    "default": "TF.value \"vmMonitoringDisabled\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The type of virtual machine monitoring to use for this virtual machine. Can",
                        "be one of vmMonitoringDisabled, vmMonitoringOnly, or vmAndAppMonitoring."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_monitoring\" <$> TF.attribute",
                    "name": "ha_vm_monitoring",
                    "method": "haVmMonitoring",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaVmMonitoring",
                    "optional": true,
                    "label": "_haVmMonitoring"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Determines whether or not the cluster's default settings or the VM override",
                        "settings specified in this resource are used for virtual machine monitoring.",
                        "The default is true (use cluster defaults) - set to false to have overrides",
                        "take effect."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_monitoring_use_cluster_defaults\" <$> TF.attribute",
                    "name": "ha_vm_monitoring_use_cluster_defaults",
                    "method": "haVmMonitoringUseClusterDefaults",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHaVmMonitoringUseClusterDefaults",
                    "optional": true,
                    "label": "_haVmMonitoringUseClusterDefaults"
                },
                {
                    "default": "TF.value \"clusterRestartPriority\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The restart priority for this virtual machine when vSphere detects a host",
                        "failure. Can be one of clusterRestartPriority, lowest, low, medium, high, or",
                        "highest."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_restart_priority\" <$> TF.attribute",
                    "name": "ha_vm_restart_priority",
                    "method": "haVmRestartPriority",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaVmRestartPriority",
                    "optional": true,
                    "label": "_haVmRestartPriority"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The maximum time, in seconds, that vSphere HA will wait for the virtual",
                        "machine to be ready. Use -1 to use the cluster default."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_restart_timeout\" <$> TF.attribute",
                    "name": "ha_vm_restart_timeout",
                    "method": "haVmRestartTimeout",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasHaVmRestartTimeout",
                    "optional": true,
                    "label": "_haVmRestartTimeout"
                },
                {
                    "default": "_virtualMachineId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the virtual machine."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"virtual_machine_id\" <$> TF.attribute",
                    "name": "virtual_machine_id",
                    "method": "virtualMachineId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVirtualMachineId",
                    "optional": false,
                    "label": "_virtualMachineId"
                }
            ],
            "schema": "Resource",
            "name": "HaVmOverrideResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "compute_cluster_id",
                    "method": "computeClusterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "optional": false,
                    "label": "_computeClusterId"
                },
                {
                    "default": "_virtualMachineId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the virtual machine."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"virtual_machine_id\" <$> TF.attribute",
                    "name": "virtual_machine_id",
                    "method": "virtualMachineId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVirtualMachineId",
                    "optional": false,
                    "label": "_virtualMachineId"
                }
            ],
            "type": "HaVmOverrideResource s",
            "original": "vsphere_ha_vm_override"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of active network adapters used for load balancing."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"active_nics\" <$> TF.attribute",
                    "name": "active_nics",
                    "method": "activeNics",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasActiveNics",
                    "optional": true,
                    "label": "_activeNics"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Controls whether or not the virtual network adapter is allowed to send",
                        "network traffic with a different MAC address than that of its own."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_forged_transmits\" <$> TF.attribute",
                    "name": "allow_forged_transmits",
                    "method": "allowForgedTransmits",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasAllowForgedTransmits",
                    "optional": true,
                    "label": "_allowForgedTransmits"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Controls whether or not the Media Access Control (MAC) address can be",
                        "changed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_mac_changes\" <$> TF.attribute",
                    "name": "allow_mac_changes",
                    "method": "allowMacChanges",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasAllowMacChanges",
                    "optional": true,
                    "label": "_allowMacChanges"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable promiscuous mode on the network. This flag indicates whether or not",
                        "all traffic is seen on a given port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_promiscuous\" <$> TF.attribute",
                    "name": "allow_promiscuous",
                    "method": "allowPromiscuous",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasAllowPromiscuous",
                    "optional": true,
                    "label": "_allowPromiscuous"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable beacon probing. Requires that the vSwitch has been configured to use",
                        "a beacon. If disabled, link status is used only."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"check_beacon\" <$> TF.attribute",
                    "name": "check_beacon",
                    "method": "checkBeacon",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasCheckBeacon",
                    "optional": true,
                    "label": "_checkBeacon"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If true, the teaming policy will re-activate failed interfaces higher in",
                        "precedence when they come back up."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failback\" <$> TF.attribute",
                    "name": "failback",
                    "method": "failback",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasFailback",
                    "optional": true,
                    "label": "_failback"
                },
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host to set the virtual switch up on."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "host_system_id",
                    "method": "hostSystemId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "optional": false,
                    "label": "_hostSystemId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the port group."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If true, the teaming policy will notify the broadcast network of a NIC",
                        "failover, triggering cache updates."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"notify_switches\" <$> TF.attribute",
                    "name": "notify_switches",
                    "method": "notifySwitches",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasNotifySwitches",
                    "optional": true,
                    "label": "_notifySwitches"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The average bandwidth in bits per second if traffic shaping is enabled."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"shaping_average_bandwidth\" <$> TF.attribute",
                    "name": "shaping_average_bandwidth",
                    "method": "shapingAverageBandwidth",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasShapingAverageBandwidth",
                    "optional": true,
                    "label": "_shapingAverageBandwidth"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The maximum burst size allowed in bytes if traffic shaping is enabled."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"shaping_burst_size\" <$> TF.attribute",
                    "name": "shaping_burst_size",
                    "method": "shapingBurstSize",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasShapingBurstSize",
                    "optional": true,
                    "label": "_shapingBurstSize"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable traffic shaping on this virtual switch or port group."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"shaping_enabled\" <$> TF.attribute",
                    "name": "shaping_enabled",
                    "method": "shapingEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasShapingEnabled",
                    "optional": true,
                    "label": "_shapingEnabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The peak bandwidth during bursts in bits per second if traffic shaping is",
                        "enabled."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"shaping_peak_bandwidth\" <$> TF.attribute",
                    "name": "shaping_peak_bandwidth",
                    "method": "shapingPeakBandwidth",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasShapingPeakBandwidth",
                    "optional": true,
                    "label": "_shapingPeakBandwidth"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of standby network adapters used for failover."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"standby_nics\" <$> TF.attribute",
                    "name": "standby_nics",
                    "method": "standbyNics",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasStandbyNics",
                    "optional": true,
                    "label": "_standbyNics"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The network adapter teaming policy. Can be one of loadbalance_ip,",
                        "loadbalance_srcmac, loadbalance_srcid, or failover_explicit."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"teaming_policy\" <$> TF.attribute",
                    "name": "teaming_policy",
                    "method": "teamingPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTeamingPolicy",
                    "optional": true,
                    "label": "_teamingPolicy"
                },
                {
                    "default": "_virtualSwitchName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the virtual switch to bind this port group to."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"virtual_switch_name\" <$> TF.attribute",
                    "name": "virtual_switch_name",
                    "method": "virtualSwitchName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVirtualSwitchName",
                    "optional": false,
                    "label": "_virtualSwitchName"
                },
                {
                    "default": "TF.value 0",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The VLAN ID/trunk mode for this port group. An ID of 0 denotes no tagging,",
                        "an ID of 1-4094 tags with the specific ID, and an ID of 4095 enables trunk",
                        "mode, allowing the guest to manage its own tagging."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vlan_id\" <$> TF.attribute",
                    "name": "vlan_id",
                    "method": "vlanId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasVlanId",
                    "optional": true,
                    "label": "_vlanId"
                }
            ],
            "schema": "Resource",
            "name": "HostPortGroupResource",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The effective network policy after inheritance. Note that this will look",
                        "similar to, but is not the same, as the policy attributes defined in this",
                        "resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"computed_policy\" <$> TF.attribute",
                    "name": "computed_policy",
                    "method": "computedComputedPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasComputedComputedPolicy",
                    "optional": false,
                    "label": "_computedComputedPolicy"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The linkable identifier for this port group."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "key",
                    "method": "computedKey",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedKey",
                    "optional": false,
                    "label": "_computedKey"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The ports that currently exist and are used on this port group."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ports\" <$> TF.attribute",
                    "name": "ports",
                    "method": "computedPorts",
                    "conflicts": [],
                    "type": "TF.Attr s (TF.Attr s (Ports s))",
                    "class": "HasComputedPorts",
                    "optional": false,
                    "label": "_computedPorts"
                }
            ],
            "parameters": [
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host to set the virtual switch up on."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "host_system_id",
                    "method": "hostSystemId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "optional": false,
                    "label": "_hostSystemId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the port group."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "_virtualSwitchName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the virtual switch to bind this port group to."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"virtual_switch_name\" <$> TF.attribute",
                    "name": "virtual_switch_name",
                    "method": "virtualSwitchName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVirtualSwitchName",
                    "optional": false,
                    "label": "_virtualSwitchName"
                }
            ],
            "type": "HostPortGroupResource s",
            "original": "vsphere_host_port_group"
        },
        {
            "arguments": [
                {
                    "default": "_activeNics",
                    "computed": false,
                    "required": true,
                    "help": [
                        "List of active network adapters used for load balancing."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"active_nics\" <$> TF.attribute",
                    "name": "active_nics",
                    "method": "activeNics",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasActiveNics",
                    "optional": false,
                    "label": "_activeNics"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Controls whether or not the virtual network adapter is allowed to send",
                        "network traffic with a different MAC address than that of its own."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_forged_transmits\" <$> TF.attribute",
                    "name": "allow_forged_transmits",
                    "method": "allowForgedTransmits",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasAllowForgedTransmits",
                    "optional": true,
                    "label": "_allowForgedTransmits"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Controls whether or not the Media Access Control (MAC) address can be",
                        "changed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_mac_changes\" <$> TF.attribute",
                    "name": "allow_mac_changes",
                    "method": "allowMacChanges",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasAllowMacChanges",
                    "optional": true,
                    "label": "_allowMacChanges"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable promiscuous mode on the network. This flag indicates whether or not",
                        "all traffic is seen on a given port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_promiscuous\" <$> TF.attribute",
                    "name": "allow_promiscuous",
                    "method": "allowPromiscuous",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasAllowPromiscuous",
                    "optional": true,
                    "label": "_allowPromiscuous"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Determines how often, in seconds, a beacon should be sent to probe for the",
                        "validity of a link."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"beacon_interval\" <$> TF.attribute",
                    "name": "beacon_interval",
                    "method": "beaconInterval",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasBeaconInterval",
                    "optional": true,
                    "label": "_beaconInterval"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable beacon probing. Requires that the vSwitch has been configured to use",
                        "a beacon. If disabled, link status is used only."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"check_beacon\" <$> TF.attribute",
                    "name": "check_beacon",
                    "method": "checkBeacon",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasCheckBeacon",
                    "optional": true,
                    "label": "_checkBeacon"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If true, the teaming policy will re-activate failed interfaces higher in",
                        "precedence when they come back up."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failback\" <$> TF.attribute",
                    "name": "failback",
                    "method": "failback",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasFailback",
                    "optional": true,
                    "label": "_failback"
                },
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host to set the virtual switch up on."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "host_system_id",
                    "method": "hostSystemId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "optional": false,
                    "label": "_hostSystemId"
                },
                {
                    "default": "TF.value \"listen\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to advertise or listen for link discovery. Valid values are",
                        "advertise, both, listen, and none."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"link_discovery_operation\" <$> TF.attribute",
                    "name": "link_discovery_operation",
                    "method": "linkDiscoveryOperation",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLinkDiscoveryOperation",
                    "optional": true,
                    "label": "_linkDiscoveryOperation"
                },
                {
                    "default": "TF.value \"cdp\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The discovery protocol type. Valid values are cdp and lldp."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"link_discovery_protocol\" <$> TF.attribute",
                    "name": "link_discovery_protocol",
                    "method": "linkDiscoveryProtocol",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLinkDiscoveryProtocol",
                    "optional": true,
                    "label": "_linkDiscoveryProtocol"
                },
                {
                    "default": "TF.value 1500",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The maximum transmission unit (MTU) of the virtual switch in bytes."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mtu\" <$> TF.attribute",
                    "name": "mtu",
                    "method": "mtu",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasMtu",
                    "optional": true,
                    "label": "_mtu"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the virtual switch."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "_networkAdapters",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The list of network adapters to bind to this virtual switch."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_adapters\" <$> TF.attribute",
                    "name": "network_adapters",
                    "method": "networkAdapters",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasNetworkAdapters",
                    "optional": false,
                    "label": "_networkAdapters"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If true, the teaming policy will notify the broadcast network of a NIC",
                        "failover, triggering cache updates."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"notify_switches\" <$> TF.attribute",
                    "name": "notify_switches",
                    "method": "notifySwitches",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasNotifySwitches",
                    "optional": true,
                    "label": "_notifySwitches"
                },
                {
                    "default": "TF.value 128",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The number of ports that this virtual switch is configured to use."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"number_of_ports\" <$> TF.attribute",
                    "name": "number_of_ports",
                    "method": "numberOfPorts",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasNumberOfPorts",
                    "optional": true,
                    "label": "_numberOfPorts"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The average bandwidth in bits per second if traffic shaping is enabled."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"shaping_average_bandwidth\" <$> TF.attribute",
                    "name": "shaping_average_bandwidth",
                    "method": "shapingAverageBandwidth",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasShapingAverageBandwidth",
                    "optional": true,
                    "label": "_shapingAverageBandwidth"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The maximum burst size allowed in bytes if traffic shaping is enabled."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"shaping_burst_size\" <$> TF.attribute",
                    "name": "shaping_burst_size",
                    "method": "shapingBurstSize",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasShapingBurstSize",
                    "optional": true,
                    "label": "_shapingBurstSize"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable traffic shaping on this virtual switch or port group."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"shaping_enabled\" <$> TF.attribute",
                    "name": "shaping_enabled",
                    "method": "shapingEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasShapingEnabled",
                    "optional": true,
                    "label": "_shapingEnabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The peak bandwidth during bursts in bits per second if traffic shaping is",
                        "enabled."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"shaping_peak_bandwidth\" <$> TF.attribute",
                    "name": "shaping_peak_bandwidth",
                    "method": "shapingPeakBandwidth",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasShapingPeakBandwidth",
                    "optional": true,
                    "label": "_shapingPeakBandwidth"
                },
                {
                    "default": "_standbyNics",
                    "computed": false,
                    "required": true,
                    "help": [
                        "List of standby network adapters used for failover."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"standby_nics\" <$> TF.attribute",
                    "name": "standby_nics",
                    "method": "standbyNics",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasStandbyNics",
                    "optional": false,
                    "label": "_standbyNics"
                },
                {
                    "default": "TF.value \"loadbalance_srcid\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The network adapter teaming policy. Can be one of loadbalance_ip,",
                        "loadbalance_srcmac, loadbalance_srcid, or failover_explicit."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"teaming_policy\" <$> TF.attribute",
                    "name": "teaming_policy",
                    "method": "teamingPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTeamingPolicy",
                    "optional": true,
                    "label": "_teamingPolicy"
                }
            ],
            "schema": "Resource",
            "name": "HostVirtualSwitchResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_activeNics",
                    "computed": false,
                    "required": true,
                    "help": [
                        "List of active network adapters used for load balancing."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"active_nics\" <$> TF.attribute",
                    "name": "active_nics",
                    "method": "activeNics",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasActiveNics",
                    "optional": false,
                    "label": "_activeNics"
                },
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host to set the virtual switch up on."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "host_system_id",
                    "method": "hostSystemId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "optional": false,
                    "label": "_hostSystemId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the virtual switch."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "_networkAdapters",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The list of network adapters to bind to this virtual switch."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_adapters\" <$> TF.attribute",
                    "name": "network_adapters",
                    "method": "networkAdapters",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasNetworkAdapters",
                    "optional": false,
                    "label": "_networkAdapters"
                },
                {
                    "default": "_standbyNics",
                    "computed": false,
                    "required": true,
                    "help": [
                        "List of standby network adapters used for failover."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"standby_nics\" <$> TF.attribute",
                    "name": "standby_nics",
                    "method": "standbyNics",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasStandbyNics",
                    "optional": false,
                    "label": "_standbyNics"
                }
            ],
            "type": "HostVirtualSwitchResource s",
            "original": "vsphere_host_virtual_switch"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "labels",
                    "method": "labels",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "optional": true,
                    "label": "_labels"
                },
                {
                    "default": "_licenseKey",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"license_key\" <$> TF.attribute",
                    "name": "license_key",
                    "method": "licenseKey",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLicenseKey",
                    "optional": false,
                    "label": "_licenseKey"
                }
            ],
            "schema": "Resource",
            "name": "LicenseResource",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"edition_key\" <$> TF.attribute",
                    "name": "edition_key",
                    "method": "computedEditionKey",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedEditionKey",
                    "optional": false,
                    "label": "_computedEditionKey"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "computedName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "optional": false,
                    "label": "_computedName"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"total\" <$> TF.attribute",
                    "name": "total",
                    "method": "computedTotal",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedTotal",
                    "optional": false,
                    "label": "_computedTotal"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"used\" <$> TF.attribute",
                    "name": "used",
                    "method": "computedUsed",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedUsed",
                    "optional": false,
                    "label": "_computedUsed"
                }
            ],
            "parameters": [
                {
                    "default": "_licenseKey",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"license_key\" <$> TF.attribute",
                    "name": "license_key",
                    "method": "licenseKey",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLicenseKey",
                    "optional": false,
                    "label": "_licenseKey"
                }
            ],
            "type": "LicenseResource s",
            "original": "vsphere_license"
        },
        {
            "arguments": [
                {
                    "default": "TF.value \"readWrite\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Access mode for the mount point. Can be one of readOnly or readWrite."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"access_mode\" <$> TF.attribute",
                    "name": "access_mode",
                    "method": "accessMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasAccessMode",
                    "optional": true,
                    "label": "_accessMode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of custom attributes to set on this resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"custom_attributes\" <$> TF.attribute",
                    "name": "custom_attributes",
                    "method": "customAttributes",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasCustomAttributes",
                    "optional": true,
                    "label": "_customAttributes"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object ID of the datastore cluster to place the datastore in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datastore_cluster_id\" <$> TF.attribute",
                    "name": "datastore_cluster_id",
                    "method": "datastoreClusterId",
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "method": "folder",
                            "label": "_folder"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastoreClusterId",
                    "optional": true,
                    "label": "_datastoreClusterId"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The path to the datastore folder to put the datastore in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"folder\" <$> TF.attribute",
                    "name": "folder",
                    "method": "folder",
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "method": "datastoreClusterId",
                            "label": "_datastoreClusterId"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFolder",
                    "optional": true,
                    "label": "_folder"
                },
                {
                    "default": "_hostSystemIds",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object IDs of the hosts to mount the datastore on."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_system_ids\" <$> TF.attribute",
                    "name": "host_system_ids",
                    "method": "hostSystemIds",
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (TF.Attr s (TF.Attr s P.Text)))",
                    "class": "HasHostSystemIds",
                    "optional": false,
                    "label": "_hostSystemIds"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "_remoteHosts",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The hostnames or IP addresses of the remote server or servers. Only one",
                        "element should be present for NFS v3 but multiple can be present for NFS",
                        "v4.1."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"remote_hosts\" <$> TF.attribute",
                    "name": "remote_hosts",
                    "method": "remoteHosts",
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (TF.Attr s P.Text))",
                    "class": "HasRemoteHosts",
                    "optional": false,
                    "label": "_remoteHosts"
                },
                {
                    "default": "_remotePath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The remote path of the mount point."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"remote_path\" <$> TF.attribute",
                    "name": "remote_path",
                    "method": "remotePath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRemotePath",
                    "optional": false,
                    "label": "_remotePath"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The security type to use."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"security_type\" <$> TF.attribute",
                    "name": "security_type",
                    "method": "securityType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecurityType",
                    "optional": true,
                    "label": "_securityType"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of tag IDs to apply to this object."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tags\" <$> TF.attribute",
                    "name": "tags",
                    "method": "tags",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasTags",
                    "optional": true,
                    "label": "_tags"
                },
                {
                    "default": "TF.value \"NFS\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The type of NAS volume. Can be one of NFS (to denote v3) or NFS41 (to denote",
                        "NFS v4.1)."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "type",
                    "method": "type'",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "optional": true,
                    "label": "_type'"
                }
            ],
            "schema": "Resource",
            "name": "NasDatastoreResource",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The connectivity status of the datastore. If this is false, some other",
                        "computed attributes may be out of date."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"accessible\" <$> TF.attribute",
                    "name": "accessible",
                    "method": "computedAccessible",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedAccessible",
                    "optional": false,
                    "label": "_computedAccessible"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Maximum capacity of the datastore, in MB."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"capacity\" <$> TF.attribute",
                    "name": "capacity",
                    "method": "computedCapacity",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedCapacity",
                    "optional": false,
                    "label": "_computedCapacity"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Available space of this datastore, in MB."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"free_space\" <$> TF.attribute",
                    "name": "free_space",
                    "method": "computedFreeSpace",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedFreeSpace",
                    "optional": false,
                    "label": "_computedFreeSpace"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The current maintenance mode state of the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"maintenance_mode\" <$> TF.attribute",
                    "name": "maintenance_mode",
                    "method": "computedMaintenanceMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMaintenanceMode",
                    "optional": false,
                    "label": "_computedMaintenanceMode"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "If true, more than one host in the datacenter has been configured with",
                        "access to the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"multiple_host_access\" <$> TF.attribute",
                    "name": "multiple_host_access",
                    "method": "computedMultipleHostAccess",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedMultipleHostAccess",
                    "optional": false,
                    "label": "_computedMultipleHostAccess"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Indicates that this NAS volume is a protocol endpoint. This field is only",
                        "populated if the host supports virtual datastores."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"protocol_endpoint\" <$> TF.attribute",
                    "name": "protocol_endpoint",
                    "method": "computedProtocolEndpoint",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedProtocolEndpoint",
                    "optional": false,
                    "label": "_computedProtocolEndpoint"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Total additional storage space, in MB, potentially used by all virtual",
                        "machines on this datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uncommitted_space\" <$> TF.attribute",
                    "name": "uncommitted_space",
                    "method": "computedUncommittedSpace",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedUncommittedSpace",
                    "optional": false,
                    "label": "_computedUncommittedSpace"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique locator for the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"url\" <$> TF.attribute",
                    "name": "url",
                    "method": "computedUrl",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUrl",
                    "optional": false,
                    "label": "_computedUrl"
                }
            ],
            "parameters": [
                {
                    "default": "_hostSystemIds",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object IDs of the hosts to mount the datastore on."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_system_ids\" <$> TF.attribute",
                    "name": "host_system_ids",
                    "method": "hostSystemIds",
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (TF.Attr s (TF.Attr s P.Text)))",
                    "class": "HasHostSystemIds",
                    "optional": false,
                    "label": "_hostSystemIds"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "_remoteHosts",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The hostnames or IP addresses of the remote server or servers. Only one",
                        "element should be present for NFS v3 but multiple can be present for NFS",
                        "v4.1."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"remote_hosts\" <$> TF.attribute",
                    "name": "remote_hosts",
                    "method": "remoteHosts",
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (TF.Attr s P.Text))",
                    "class": "HasRemoteHosts",
                    "optional": false,
                    "label": "_remoteHosts"
                },
                {
                    "default": "_remotePath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The remote path of the mount point."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"remote_path\" <$> TF.attribute",
                    "name": "remote_path",
                    "method": "remotePath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRemotePath",
                    "optional": false,
                    "label": "_remotePath"
                }
            ],
            "type": "NasDatastoreResource s",
            "original": "vsphere_nas_datastore"
        },
        {
            "arguments": [
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Determines if the reservation on a resource pool can grow beyond the",
                        "specified value, if the parent resource pool has unreserved resources."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_expandable\" <$> TF.attribute",
                    "name": "cpu_expandable",
                    "method": "cpuExpandable",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasCpuExpandable",
                    "optional": true,
                    "label": "_cpuExpandable"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The utilization of a resource pool will not exceed this limit, even if there",
                        "are available resources. Set to -1 for unlimited."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_limit\" <$> TF.attribute",
                    "name": "cpu_limit",
                    "method": "cpuLimit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasCpuLimit",
                    "optional": true,
                    "label": "_cpuLimit"
                },
                {
                    "default": "TF.value 0",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Amount of CPU (MHz) that is guaranteed available to the resource pool."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_reservation\" <$> TF.attribute",
                    "name": "cpu_reservation",
                    "method": "cpuReservation",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasCpuReservation",
                    "optional": true,
                    "label": "_cpuReservation"
                },
                {
                    "default": "TF.value \"normal\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The allocation level. The level is a simplified view of shares. Levels map",
                        "to a pre-determined set of numeric values for shares. Can be one of low,",
                        "normal, high, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_share_level\" <$> TF.attribute",
                    "name": "cpu_share_level",
                    "method": "cpuShareLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCpuShareLevel",
                    "optional": true,
                    "label": "_cpuShareLevel"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of custom attributes to set on this resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"custom_attributes\" <$> TF.attribute",
                    "name": "custom_attributes",
                    "method": "customAttributes",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasCustomAttributes",
                    "optional": true,
                    "label": "_customAttributes"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Determines if the reservation on a resource pool can grow beyond the",
                        "specified value, if the parent resource pool has unreserved resources."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_expandable\" <$> TF.attribute",
                    "name": "memory_expandable",
                    "method": "memoryExpandable",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasMemoryExpandable",
                    "optional": true,
                    "label": "_memoryExpandable"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The utilization of a resource pool will not exceed this limit, even if there",
                        "are available resources. Set to -1 for unlimited."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_limit\" <$> TF.attribute",
                    "name": "memory_limit",
                    "method": "memoryLimit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasMemoryLimit",
                    "optional": true,
                    "label": "_memoryLimit"
                },
                {
                    "default": "TF.value 0",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Amount of memory (MB) that is guaranteed available to the resource pool."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_reservation\" <$> TF.attribute",
                    "name": "memory_reservation",
                    "method": "memoryReservation",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasMemoryReservation",
                    "optional": true,
                    "label": "_memoryReservation"
                },
                {
                    "default": "TF.value \"normal\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The allocation level. The level is a simplified view of shares. Levels map",
                        "to a pre-determined set of numeric values for shares. Can be one of low,",
                        "normal, high, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_share_level\" <$> TF.attribute",
                    "name": "memory_share_level",
                    "method": "memoryShareLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMemoryShareLevel",
                    "optional": true,
                    "label": "_memoryShareLevel"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of resource pool."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "_parentResourcePoolId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The ID of the root resource pool of the compute resource the resource pool",
                        "is in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"parent_resource_pool_id\" <$> TF.attribute",
                    "name": "parent_resource_pool_id",
                    "method": "parentResourcePoolId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasParentResourcePoolId",
                    "optional": false,
                    "label": "_parentResourcePoolId"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of tag IDs to apply to this object."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tags\" <$> TF.attribute",
                    "name": "tags",
                    "method": "tags",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasTags",
                    "optional": true,
                    "label": "_tags"
                }
            ],
            "schema": "Resource",
            "name": "ResourcePoolResource",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The number of shares allocated. Used to determine resource allocation in",
                        "case of resource contention. If this is set, cpu_share_level must be custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_shares\" <$> TF.attribute",
                    "name": "cpu_shares",
                    "method": "computedCpuShares",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedCpuShares",
                    "optional": true,
                    "label": "_computedCpuShares"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The number of shares allocated. Used to determine resource allocation in",
                        "case of resource contention. If this is set, memory_share_level must be",
                        "custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_shares\" <$> TF.attribute",
                    "name": "memory_shares",
                    "method": "computedMemoryShares",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedMemoryShares",
                    "optional": true,
                    "label": "_computedMemoryShares"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of resource pool."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "_parentResourcePoolId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The ID of the root resource pool of the compute resource the resource pool",
                        "is in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"parent_resource_pool_id\" <$> TF.attribute",
                    "name": "parent_resource_pool_id",
                    "method": "parentResourcePoolId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasParentResourcePoolId",
                    "optional": false,
                    "label": "_parentResourcePoolId"
                }
            ],
            "type": "ResourcePoolResource s",
            "original": "vsphere_resource_pool"
        },
        {
            "arguments": [
                {
                    "default": "_datastoreClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the datastore cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"datastore_cluster_id\" <$> TF.attribute",
                    "name": "datastore_cluster_id",
                    "method": "datastoreClusterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastoreClusterId",
                    "optional": false,
                    "label": "_datastoreClusterId"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Overrides any Storage DRS automation levels for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_automation_level\" <$> TF.attribute",
                    "name": "sdrs_automation_level",
                    "method": "sdrsAutomationLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSdrsAutomationLevel",
                    "optional": true,
                    "label": "_sdrsAutomationLevel"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Overrides the default Storage DRS setting for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_enabled\" <$> TF.attribute",
                    "name": "sdrs_enabled",
                    "method": "sdrsEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSdrsEnabled",
                    "optional": true,
                    "label": "_sdrsEnabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Overrides the intra-VM affinity setting for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_intra_vm_affinity\" <$> TF.attribute",
                    "name": "sdrs_intra_vm_affinity",
                    "method": "sdrsIntraVmAffinity",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSdrsIntraVmAffinity",
                    "optional": true,
                    "label": "_sdrsIntraVmAffinity"
                },
                {
                    "default": "_virtualMachineId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the virtual machine."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"virtual_machine_id\" <$> TF.attribute",
                    "name": "virtual_machine_id",
                    "method": "virtualMachineId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVirtualMachineId",
                    "optional": false,
                    "label": "_virtualMachineId"
                }
            ],
            "schema": "Resource",
            "name": "StorageDrsVmOverrideResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_datastoreClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the datastore cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"datastore_cluster_id\" <$> TF.attribute",
                    "name": "datastore_cluster_id",
                    "method": "datastoreClusterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastoreClusterId",
                    "optional": false,
                    "label": "_datastoreClusterId"
                },
                {
                    "default": "_virtualMachineId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the virtual machine."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"virtual_machine_id\" <$> TF.attribute",
                    "name": "virtual_machine_id",
                    "method": "virtualMachineId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVirtualMachineId",
                    "optional": false,
                    "label": "_virtualMachineId"
                }
            ],
            "type": "StorageDrsVmOverrideResource s",
            "original": "vsphere_storage_drs_vm_override"
        },
        {
            "arguments": [
                {
                    "default": "_categoryId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique identifier of the parent category in which this tag will be",
                        "created."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"category_id\" <$> TF.attribute",
                    "name": "category_id",
                    "method": "categoryId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCategoryId",
                    "optional": false,
                    "label": "_categoryId"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The description of the tag."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"description\" <$> TF.attribute",
                    "name": "description",
                    "method": "description",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDescription",
                    "optional": true,
                    "label": "_description"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the tag. The name must be unique within its category."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "schema": "Resource",
            "name": "TagResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_categoryId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique identifier of the parent category in which this tag will be",
                        "created."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"category_id\" <$> TF.attribute",
                    "name": "category_id",
                    "method": "categoryId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCategoryId",
                    "optional": false,
                    "label": "_categoryId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the tag. The name must be unique within its category."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "type": "TagResource s",
            "original": "vsphere_tag"
        },
        {
            "arguments": [
                {
                    "default": "_associableTypes",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Object types to which this category's tags can be attached."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"associable_types\" <$> TF.attribute",
                    "name": "associable_types",
                    "method": "associableTypes",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasAssociableTypes",
                    "optional": false,
                    "label": "_associableTypes"
                },
                {
                    "default": "_cardinality",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The associated cardinality of the category. Can be one of SINGLE (object can",
                        "only be assigned one tag in this category) or MULTIPLE (object can be",
                        "assigned multiple tags in this category)."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"cardinality\" <$> TF.attribute",
                    "name": "cardinality",
                    "method": "cardinality",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCardinality",
                    "optional": false,
                    "label": "_cardinality"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The description of the category."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"description\" <$> TF.attribute",
                    "name": "description",
                    "method": "description",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDescription",
                    "optional": true,
                    "label": "_description"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the category."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "schema": "Resource",
            "name": "TagCategoryResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_associableTypes",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Object types to which this category's tags can be attached."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"associable_types\" <$> TF.attribute",
                    "name": "associable_types",
                    "method": "associableTypes",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasAssociableTypes",
                    "optional": false,
                    "label": "_associableTypes"
                },
                {
                    "default": "_cardinality",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The associated cardinality of the category. Can be one of SINGLE (object can",
                        "only be assigned one tag in this category) or MULTIPLE (object can be",
                        "assigned multiple tags in this category)."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"cardinality\" <$> TF.attribute",
                    "name": "cardinality",
                    "method": "cardinality",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCardinality",
                    "optional": false,
                    "label": "_cardinality"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the category."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "type": "TagCategoryResource s",
            "original": "vsphere_tag_category"
        },
        {
            "arguments": [
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Determines if the reservation on a vApp container can grow beyond the",
                        "specified value, if the parent resource pool has unreserved resources."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_expandable\" <$> TF.attribute",
                    "name": "cpu_expandable",
                    "method": "cpuExpandable",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasCpuExpandable",
                    "optional": true,
                    "label": "_cpuExpandable"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The utilization of a vApp container will not exceed this limit, even if",
                        "there are available resources. Set to -1 for unlimited."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_limit\" <$> TF.attribute",
                    "name": "cpu_limit",
                    "method": "cpuLimit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasCpuLimit",
                    "optional": true,
                    "label": "_cpuLimit"
                },
                {
                    "default": "TF.value 0",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Amount of CPU (MHz) that is guaranteed available to the vApp container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_reservation\" <$> TF.attribute",
                    "name": "cpu_reservation",
                    "method": "cpuReservation",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasCpuReservation",
                    "optional": true,
                    "label": "_cpuReservation"
                },
                {
                    "default": "TF.value \"normal\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The allocation level. The level is a simplified view of shares. Levels map",
                        "to a pre-determined set of numeric values for shares. Can be one of low,",
                        "normal, high, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_share_level\" <$> TF.attribute",
                    "name": "cpu_share_level",
                    "method": "cpuShareLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCpuShareLevel",
                    "optional": true,
                    "label": "_cpuShareLevel"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of custom attributes to set on this resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"custom_attributes\" <$> TF.attribute",
                    "name": "custom_attributes",
                    "method": "customAttributes",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasCustomAttributes",
                    "optional": true,
                    "label": "_customAttributes"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Determines if the reservation on a vApp container can grow beyond the",
                        "specified value, if the parent resource pool has unreserved resources."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_expandable\" <$> TF.attribute",
                    "name": "memory_expandable",
                    "method": "memoryExpandable",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasMemoryExpandable",
                    "optional": true,
                    "label": "_memoryExpandable"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The utilization of a vApp container will not exceed this limit, even if",
                        "there are available resources. Set to -1 for unlimited."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_limit\" <$> TF.attribute",
                    "name": "memory_limit",
                    "method": "memoryLimit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasMemoryLimit",
                    "optional": true,
                    "label": "_memoryLimit"
                },
                {
                    "default": "TF.value 0",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Amount of memory (MB) that is guaranteed available to the vApp container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_reservation\" <$> TF.attribute",
                    "name": "memory_reservation",
                    "method": "memoryReservation",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasMemoryReservation",
                    "optional": true,
                    "label": "_memoryReservation"
                },
                {
                    "default": "TF.value \"normal\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The allocation level. The level is a simplified view of shares. Levels map",
                        "to a pre-determined set of numeric values for shares. Can be one of low,",
                        "normal, high, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_share_level\" <$> TF.attribute",
                    "name": "memory_share_level",
                    "method": "memoryShareLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMemoryShareLevel",
                    "optional": true,
                    "label": "_memoryShareLevel"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the vApp container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The ID of the parent VM folder."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"parent_folder_id\" <$> TF.attribute",
                    "name": "parent_folder_id",
                    "method": "parentFolderId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasParentFolderId",
                    "optional": true,
                    "label": "_parentFolderId"
                },
                {
                    "default": "_parentResourcePoolId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the parent resource pool or the compute resource",
                        "the vApp container is in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"parent_resource_pool_id\" <$> TF.attribute",
                    "name": "parent_resource_pool_id",
                    "method": "parentResourcePoolId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasParentResourcePoolId",
                    "optional": false,
                    "label": "_parentResourcePoolId"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of tag IDs to apply to this object."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tags\" <$> TF.attribute",
                    "name": "tags",
                    "method": "tags",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasTags",
                    "optional": true,
                    "label": "_tags"
                }
            ],
            "schema": "Resource",
            "name": "VappContainerResource",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The number of shares allocated. Used to determine resource allocation in",
                        "case of resource contention. If this is set, cpu_share_level must be custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_shares\" <$> TF.attribute",
                    "name": "cpu_shares",
                    "method": "computedCpuShares",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedCpuShares",
                    "optional": true,
                    "label": "_computedCpuShares"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The number of shares allocated. Used to determine resource allocation in",
                        "case of resource contention. If this is set, memory_share_level must be",
                        "custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_shares\" <$> TF.attribute",
                    "name": "memory_shares",
                    "method": "computedMemoryShares",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedMemoryShares",
                    "optional": true,
                    "label": "_computedMemoryShares"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the vApp container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "_parentResourcePoolId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the parent resource pool or the compute resource",
                        "the vApp container is in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"parent_resource_pool_id\" <$> TF.attribute",
                    "name": "parent_resource_pool_id",
                    "method": "parentResourcePoolId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasParentResourcePoolId",
                    "optional": false,
                    "label": "_parentResourcePoolId"
                }
            ],
            "type": "VappContainerResource s",
            "original": "vsphere_vapp_container"
        },
        {
            "arguments": [
                {
                    "default": "TF.value \"lsiLogic\"",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"adapter_type\" <$> TF.attribute",
                    "name": "adapter_type",
                    "method": "adapterType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasAdapterType",
                    "optional": true,
                    "label": "_adapterType"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"create_directories\" <$> TF.attribute",
                    "name": "create_directories",
                    "method": "createDirectories",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasCreateDirectories",
                    "optional": true,
                    "label": "_createDirectories"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"datacenter\" <$> TF.attribute",
                    "name": "datacenter",
                    "method": "datacenter",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenter",
                    "optional": true,
                    "label": "_datacenter"
                },
                {
                    "default": "_datastore",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"datastore\" <$> TF.attribute",
                    "name": "datastore",
                    "method": "datastore",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastore",
                    "optional": false,
                    "label": "_datastore"
                },
                {
                    "default": "_size",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"size\" <$> TF.attribute",
                    "name": "size",
                    "method": "size",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasSize",
                    "optional": false,
                    "label": "_size"
                },
                {
                    "default": "TF.value \"eagerZeroedThick\"",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "type",
                    "method": "type'",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "optional": true,
                    "label": "_type'"
                },
                {
                    "default": "_vmdkPath",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"vmdk_path\" <$> TF.attribute",
                    "name": "vmdk_path",
                    "method": "vmdkPath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVmdkPath",
                    "optional": false,
                    "label": "_vmdkPath"
                }
            ],
            "schema": "Resource",
            "name": "VirtualDiskResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_datastore",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"datastore\" <$> TF.attribute",
                    "name": "datastore",
                    "method": "datastore",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastore",
                    "optional": false,
                    "label": "_datastore"
                },
                {
                    "default": "_size",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"size\" <$> TF.attribute",
                    "name": "size",
                    "method": "size",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasSize",
                    "optional": false,
                    "label": "_size"
                },
                {
                    "default": "_vmdkPath",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"vmdk_path\" <$> TF.attribute",
                    "name": "vmdk_path",
                    "method": "vmdkPath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVmdkPath",
                    "optional": false,
                    "label": "_vmdkPath"
                }
            ],
            "type": "VirtualDiskResource s",
            "original": "vsphere_virtual_disk"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The guest name for the operating system when guest_id is other or other-64."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"alternate_guest_name\" <$> TF.attribute",
                    "name": "alternate_guest_name",
                    "method": "alternateGuestName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasAlternateGuestName",
                    "optional": true,
                    "label": "_alternateGuestName"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User-provided description of the virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotation\" <$> TF.attribute",
                    "name": "annotation",
                    "method": "annotation",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasAnnotation",
                    "optional": true,
                    "label": "_annotation"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The number of milliseconds to wait before starting the boot sequence."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"boot_delay\" <$> TF.attribute",
                    "name": "boot_delay",
                    "method": "bootDelay",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasBootDelay",
                    "optional": true,
                    "label": "_bootDelay"
                },
                {
                    "default": "TF.value 10000",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The number of milliseconds to wait before retrying the boot sequence. This",
                        "only valid if boot_retry_enabled is true."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"boot_retry_delay\" <$> TF.attribute",
                    "name": "boot_retry_delay",
                    "method": "bootRetryDelay",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasBootRetryDelay",
                    "optional": true,
                    "label": "_bootRetryDelay"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If set to true, a virtual machine that fails to boot will try again after",
                        "the delay defined in boot_retry_delay."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"boot_retry_enabled\" <$> TF.attribute",
                    "name": "boot_retry_enabled",
                    "method": "bootRetryEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasBootRetryEnabled",
                    "optional": true,
                    "label": "_bootRetryEnabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A specification for a CDROM device on this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cdrom\" <$> TF.attribute",
                    "name": "cdrom",
                    "method": "cdrom",
                    "conflicts": [],
                    "type": "TF.Attr s [Cdrom s]",
                    "class": "HasCdrom",
                    "optional": true,
                    "label": "_cdrom"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A specification for cloning a virtual machine from template."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"clone\" <$> TF.attribute",
                    "name": "clone",
                    "method": "clone",
                    "conflicts": [],
                    "type": "TF.Attr s [Clone s]",
                    "class": "HasClone",
                    "optional": true,
                    "label": "_clone"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow CPUs to be added to this virtual machine while it is running."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_hot_add_enabled\" <$> TF.attribute",
                    "name": "cpu_hot_add_enabled",
                    "method": "cpuHotAddEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasCpuHotAddEnabled",
                    "optional": true,
                    "label": "_cpuHotAddEnabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow CPUs to be added to this virtual machine while it is running."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_hot_remove_enabled\" <$> TF.attribute",
                    "name": "cpu_hot_remove_enabled",
                    "method": "cpuHotRemoveEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasCpuHotRemoveEnabled",
                    "optional": true,
                    "label": "_cpuHotRemoveEnabled"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The maximum amount of memory (in MB) or CPU (in MHz) that this virtual",
                        "machine can consume, regardless of available resources.%!(EXTRA string=cpu)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_limit\" <$> TF.attribute",
                    "name": "cpu_limit",
                    "method": "cpuLimit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasCpuLimit",
                    "optional": true,
                    "label": "_cpuLimit"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable CPU performance counters on this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_performance_counters_enabled\" <$> TF.attribute",
                    "name": "cpu_performance_counters_enabled",
                    "method": "cpuPerformanceCountersEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasCpuPerformanceCountersEnabled",
                    "optional": true,
                    "label": "_cpuPerformanceCountersEnabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The amount of memory (in MB) or CPU (in MHz) that this virtual machine is",
                        "guaranteed.%!(EXTRA string=cpu)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_reservation\" <$> TF.attribute",
                    "name": "cpu_reservation",
                    "method": "cpuReservation",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasCpuReservation",
                    "optional": true,
                    "label": "_cpuReservation"
                },
                {
                    "default": "TF.value \"normal\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The allocation level for cpu resources. Can be one of high, low, normal, or",
                        "custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_share_level\" <$> TF.attribute",
                    "name": "cpu_share_level",
                    "method": "cpuShareLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCpuShareLevel",
                    "optional": true,
                    "label": "_cpuShareLevel"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of custom attributes to set on this resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"custom_attributes\" <$> TF.attribute",
                    "name": "custom_attributes",
                    "method": "customAttributes",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasCustomAttributes",
                    "optional": true,
                    "label": "_customAttributes"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The ID of a datastore cluster to put the virtual machine in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datastore_cluster_id\" <$> TF.attribute",
                    "name": "datastore_cluster_id",
                    "method": "datastoreClusterId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastoreClusterId",
                    "optional": true,
                    "label": "_datastoreClusterId"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When the boot type set in firmware is efi, this enables EFI secure boot."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"efi_secure_boot_enabled\" <$> TF.attribute",
                    "name": "efi_secure_boot_enabled",
                    "method": "efiSecureBootEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasEfiSecureBootEnabled",
                    "optional": true,
                    "label": "_efiSecureBootEnabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Expose the UUIDs of attached virtual disks to the virtual machine, allowing",
                        "access to them in the guest."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"enable_disk_uuid\" <$> TF.attribute",
                    "name": "enable_disk_uuid",
                    "method": "enableDiskUuid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasEnableDiskUuid",
                    "optional": true,
                    "label": "_enableDiskUuid"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable logging on this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"enable_logging\" <$> TF.attribute",
                    "name": "enable_logging",
                    "method": "enableLogging",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasEnableLogging",
                    "optional": true,
                    "label": "_enableLogging"
                },
                {
                    "default": "TF.value \"automatic\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The EPT/RVI (hardware memory virtualization) setting for this virtual",
                        "machine. Can be one of automatic, on, or off."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ept_rvi_mode\" <$> TF.attribute",
                    "name": "ept_rvi_mode",
                    "method": "eptRviMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasEptRviMode",
                    "optional": true,
                    "label": "_eptRviMode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Extra configuration data for this virtual machine. Can be used to supply",
                        "advanced parameters not normally in configuration, such as data for",
                        "cloud-config (under the guestinfo namespace), or configuration data for OVF",
                        "images."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"extra_config\" <$> TF.attribute",
                    "name": "extra_config",
                    "method": "extraConfig",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasExtraConfig",
                    "optional": true,
                    "label": "_extraConfig"
                },
                {
                    "default": "TF.value \"bios\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The firmware interface to use on the virtual machine. Can be one of bios or",
                        "EFI."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"firmware\" <$> TF.attribute",
                    "name": "firmware",
                    "method": "firmware",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFirmware",
                    "optional": true,
                    "label": "_firmware"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The name of the folder to locate the virtual machine in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"folder\" <$> TF.attribute",
                    "name": "folder",
                    "method": "folder",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFolder",
                    "optional": true,
                    "label": "_folder"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Set to true to force power-off a virtual machine if a graceful guest",
                        "shutdown failed for a necessary operation."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"force_power_off\" <$> TF.attribute",
                    "name": "force_power_off",
                    "method": "forcePowerOff",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasForcePowerOff",
                    "optional": true,
                    "label": "_forcePowerOff"
                },
                {
                    "default": "TF.value \"other-64\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The guest ID for the operating system."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"guest_id\" <$> TF.attribute",
                    "name": "guest_id",
                    "method": "guestId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGuestId",
                    "optional": true,
                    "label": "_guestId"
                },
                {
                    "default": "TF.value \"hvAuto\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The (non-nested) hardware virtualization setting for this virtual machine.",
                        "Can be one of hvAuto, hvOn, or hvOff."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"hv_mode\" <$> TF.attribute",
                    "name": "hv_mode",
                    "method": "hvMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHvMode",
                    "optional": true,
                    "label": "_hvMode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Controls the scheduling delay of the virtual machine. Use a higher",
                        "sensitivity for applications that require lower latency, such as VOIP, media",
                        "player applications, or applications that require frequent access to mouse",
                        "or keyboard devices. Can be one of low, normal, medium, or high."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"latency_sensitivity\" <$> TF.attribute",
                    "name": "latency_sensitivity",
                    "method": "latencySensitivity",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLatencySensitivity",
                    "optional": true,
                    "label": "_latencySensitivity"
                },
                {
                    "default": "TF.value 1024",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The size of the virtual machine's memory, in MB."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "memory",
                    "method": "memory",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasMemory",
                    "optional": true,
                    "label": "_memory"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow memory to be added to this virtual machine while it is running."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_hot_add_enabled\" <$> TF.attribute",
                    "name": "memory_hot_add_enabled",
                    "method": "memoryHotAddEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasMemoryHotAddEnabled",
                    "optional": true,
                    "label": "_memoryHotAddEnabled"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The maximum amount of memory (in MB) or CPU (in MHz) that this virtual",
                        "machine can consume, regardless of available resources.%!(EXTRA",
                        "string=memory)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_limit\" <$> TF.attribute",
                    "name": "memory_limit",
                    "method": "memoryLimit",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasMemoryLimit",
                    "optional": true,
                    "label": "_memoryLimit"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The amount of memory (in MB) or CPU (in MHz) that this virtual machine is",
                        "guaranteed.%!(EXTRA string=memory)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_reservation\" <$> TF.attribute",
                    "name": "memory_reservation",
                    "method": "memoryReservation",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasMemoryReservation",
                    "optional": true,
                    "label": "_memoryReservation"
                },
                {
                    "default": "TF.value \"normal\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The allocation level for memory resources. Can be one of high, low, normal,",
                        "or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_share_level\" <$> TF.attribute",
                    "name": "memory_share_level",
                    "method": "memoryShareLevel",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMemoryShareLevel",
                    "optional": true,
                    "label": "_memoryShareLevel"
                },
                {
                    "default": "TF.value 30",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The amount of time, in minutes, to wait for a vMotion operation to complete",
                        "before failing."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"migrate_wait_timeout\" <$> TF.attribute",
                    "name": "migrate_wait_timeout",
                    "method": "migrateWaitTimeout",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasMigrateWaitTimeout",
                    "optional": true,
                    "label": "_migrateWaitTimeout"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable nested hardware virtualization on this virtual machine, facilitating",
                        "nested virtualization in the guest."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"nested_hv_enabled\" <$> TF.attribute",
                    "name": "nested_hv_enabled",
                    "method": "nestedHvEnabled",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasNestedHvEnabled",
                    "optional": true,
                    "label": "_nestedHvEnabled"
                },
                {
                    "default": "_networkInterface",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A specification for a virtual NIC on this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_interface\" <$> TF.attribute",
                    "name": "network_interface",
                    "method": "networkInterface",
                    "conflicts": [],
                    "type": "TF.Attr s [NetworkInterface s]",
                    "class": "HasNetworkInterface",
                    "optional": false,
                    "label": "_networkInterface"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The number of cores to distribute amongst the CPUs in this virtual machine.",
                        "If specified, the value supplied to num_cpus must be evenly divisible by",
                        "this value."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"num_cores_per_socket\" <$> TF.attribute",
                    "name": "num_cores_per_socket",
                    "method": "numCoresPerSocket",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasNumCoresPerSocket",
                    "optional": true,
                    "label": "_numCoresPerSocket"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The number of virtual processors to assign to this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"num_cpus\" <$> TF.attribute",
                    "name": "num_cpus",
                    "method": "numCpus",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasNumCpus",
                    "optional": true,
                    "label": "_numCpus"
                },
                {
                    "default": "_resourcePoolId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The ID of a resource pool to put the virtual machine in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_pool_id\" <$> TF.attribute",
                    "name": "resource_pool_id",
                    "method": "resourcePoolId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResourcePoolId",
                    "optional": false,
                    "label": "_resourcePoolId"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable the execution of post-power-on scripts when VMware tools is",
                        "installed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_tools_scripts_after_power_on\" <$> TF.attribute",
                    "name": "run_tools_scripts_after_power_on",
                    "method": "runToolsScriptsAfterPowerOn",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRunToolsScriptsAfterPowerOn",
                    "optional": true,
                    "label": "_runToolsScriptsAfterPowerOn"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable the execution of post-resume scripts when VMware tools is installed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_tools_scripts_after_resume\" <$> TF.attribute",
                    "name": "run_tools_scripts_after_resume",
                    "method": "runToolsScriptsAfterResume",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRunToolsScriptsAfterResume",
                    "optional": true,
                    "label": "_runToolsScriptsAfterResume"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable the execution of pre-reboot scripts when VMware tools is installed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_tools_scripts_before_guest_reboot\" <$> TF.attribute",
                    "name": "run_tools_scripts_before_guest_reboot",
                    "method": "runToolsScriptsBeforeGuestReboot",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRunToolsScriptsBeforeGuestReboot",
                    "optional": true,
                    "label": "_runToolsScriptsBeforeGuestReboot"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable the execution of pre-shutdown scripts when VMware tools is installed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_tools_scripts_before_guest_shutdown\" <$> TF.attribute",
                    "name": "run_tools_scripts_before_guest_shutdown",
                    "method": "runToolsScriptsBeforeGuestShutdown",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRunToolsScriptsBeforeGuestShutdown",
                    "optional": true,
                    "label": "_runToolsScriptsBeforeGuestShutdown"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable the execution of pre-standby scripts when VMware tools is installed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_tools_scripts_before_guest_standby\" <$> TF.attribute",
                    "name": "run_tools_scripts_before_guest_standby",
                    "method": "runToolsScriptsBeforeGuestStandby",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRunToolsScriptsBeforeGuestStandby",
                    "optional": true,
                    "label": "_runToolsScriptsBeforeGuestStandby"
                },
                {
                    "default": "TF.value \"noSharing\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Mode for sharing the SCSI bus. The modes are physicalSharing,",
                        "virtualSharing, and noSharing."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scsi_bus_sharing\" <$> TF.attribute",
                    "name": "scsi_bus_sharing",
                    "method": "scsiBusSharing",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScsiBusSharing",
                    "optional": true,
                    "label": "_scsiBusSharing"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The number of SCSI controllers that Terraform manages on this virtual",
                        "machine. This directly affects the amount of disks you can add to the",
                        "virtual machine and the maximum disk unit number. Note that lowering this",
                        "value does not remove controllers."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scsi_controller_count\" <$> TF.attribute",
                    "name": "scsi_controller_count",
                    "method": "scsiControllerCount",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasScsiControllerCount",
                    "optional": true,
                    "label": "_scsiControllerCount"
                },
                {
                    "default": "TF.value \"pvscsi\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The type of SCSI bus this virtual machine will have. Can be one of lsilogic,",
                        "lsilogic-sas or pvscsi."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scsi_type\" <$> TF.attribute",
                    "name": "scsi_type",
                    "method": "scsiType",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScsiType",
                    "optional": true,
                    "label": "_scsiType"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The amount of time, in minutes, to wait for shutdown when making necessary",
                        "updates to the virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"shutdown_wait_timeout\" <$> TF.attribute",
                    "name": "shutdown_wait_timeout",
                    "method": "shutdownWaitTimeout",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasShutdownWaitTimeout",
                    "optional": true,
                    "label": "_shutdownWaitTimeout"
                },
                {
                    "default": "TF.value \"inherit\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The swap file placement policy for this virtual machine. Can be one of",
                        "inherit, hostLocal, or vmDirectory."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"swap_placement_policy\" <$> TF.attribute",
                    "name": "swap_placement_policy",
                    "method": "swapPlacementPolicy",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSwapPlacementPolicy",
                    "optional": true,
                    "label": "_swapPlacementPolicy"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable guest clock synchronization with the host. Requires VMware tools to",
                        "be installed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sync_time_with_host\" <$> TF.attribute",
                    "name": "sync_time_with_host",
                    "method": "syncTimeWithHost",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasSyncTimeWithHost",
                    "optional": true,
                    "label": "_syncTimeWithHost"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of tag IDs to apply to this object."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tags\" <$> TF.attribute",
                    "name": "tags",
                    "method": "tags",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasTags",
                    "optional": true,
                    "label": "_tags"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "VApp configuration data for this virtual machine. Can be used to provide",
                        "configuration data for OVF images."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vapp\" <$> TF.attribute",
                    "name": "vapp",
                    "method": "vapp",
                    "conflicts": [],
                    "type": "TF.Attr s [Vapp s]",
                    "class": "HasVapp",
                    "optional": true,
                    "label": "_vapp"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Controls whether or not the guest network waiter waits for a routable",
                        "address. When false, the waiter does not wait for a default gateway, nor are",
                        "IP addresses checked against any discovered default gateways as part of its",
                        "success criteria."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"wait_for_guest_net_routable\" <$> TF.attribute",
                    "name": "wait_for_guest_net_routable",
                    "method": "waitForGuestNetRoutable",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasWaitForGuestNetRoutable",
                    "optional": true,
                    "label": "_waitForGuestNetRoutable"
                },
                {
                    "default": "TF.value 5",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The amount of time, in minutes, to wait for an available IP address on this",
                        "virtual machine. A value less than 1 disables the waiter."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"wait_for_guest_net_timeout\" <$> TF.attribute",
                    "name": "wait_for_guest_net_timeout",
                    "method": "waitForGuestNetTimeout",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasWaitForGuestNetTimeout",
                    "optional": true,
                    "label": "_waitForGuestNetTimeout"
                }
            ],
            "schema": "Resource",
            "name": "VirtualMachineResource",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A unique identifier for a given version of the last configuration applied,",
                        "such the timestamp of the last update to the configuration."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"change_version\" <$> TF.attribute",
                    "name": "change_version",
                    "method": "computedChangeVersion",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedChangeVersion",
                    "optional": false,
                    "label": "_computedChangeVersion"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of shares to allocate to cpu for a custom share level."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_share_count\" <$> TF.attribute",
                    "name": "cpu_share_count",
                    "method": "computedCpuShareCount",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedCpuShareCount",
                    "optional": true,
                    "label": "_computedCpuShareCount"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The ID of the virtual machine's datastore. The virtual machine configuration",
                        "is placed here, along with any virtual disks that are created without",
                        "datastores."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datastore_id\" <$> TF.attribute",
                    "name": "datastore_id",
                    "method": "computedDatastoreId",
                    "conflicts": [
                        "_datastoreClusterId"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedDatastoreId",
                    "optional": true,
                    "label": "_computedDatastoreId"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The IP address selected by Terraform to be used for the provisioner."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_ip_address\" <$> TF.attribute",
                    "name": "default_ip_address",
                    "method": "computedDefaultIpAddress",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedDefaultIpAddress",
                    "optional": false,
                    "label": "_computedDefaultIpAddress"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A specification for a virtual disk device on this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disk\" <$> TF.attribute",
                    "name": "disk",
                    "method": "computedDisk",
                    "conflicts": [],
                    "type": "TF.Attr s [Disk s]",
                    "class": "HasComputedDisk",
                    "optional": true,
                    "label": "_computedDisk"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The current list of IP addresses on this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"guest_ip_addresses\" <$> TF.attribute",
                    "name": "guest_ip_addresses",
                    "method": "computedGuestIpAddresses",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedGuestIpAddresses",
                    "optional": false,
                    "label": "_computedGuestIpAddresses"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The ID of an optional host system to pin the virtual machine to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "host_system_id",
                    "method": "computedHostSystemId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedHostSystemId",
                    "optional": true,
                    "label": "_computedHostSystemId"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A flag internal to Terraform that indicates that this resource was either",
                        "imported or came from a earlier major version of this resource. Reset after",
                        "the first post-import or post-upgrade apply."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"imported\" <$> TF.attribute",
                    "name": "imported",
                    "method": "computedImported",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedImported",
                    "optional": false,
                    "label": "_computedImported"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of shares to allocate to memory for a custom share level."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_share_count\" <$> TF.attribute",
                    "name": "memory_share_count",
                    "method": "computedMemoryShareCount",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedMemoryShareCount",
                    "optional": true,
                    "label": "_computedMemoryShareCount"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The machine object ID from VMWare"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"moid\" <$> TF.attribute",
                    "name": "moid",
                    "method": "computedMoid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMoid",
                    "optional": false,
                    "label": "_computedMoid"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Value internal to Terraform used to determine if a configuration set change",
                        "requires a reboot."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"reboot_required\" <$> TF.attribute",
                    "name": "reboot_required",
                    "method": "computedRebootRequired",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedRebootRequired",
                    "optional": false,
                    "label": "_computedRebootRequired"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The UUID of the virtual machine. Also exposed as the ID of the resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uuid\" <$> TF.attribute",
                    "name": "uuid",
                    "method": "computedUuid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUuid",
                    "optional": false,
                    "label": "_computedUuid"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "VApp transport methods supported by virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vapp_transport\" <$> TF.attribute",
                    "name": "vapp_transport",
                    "method": "computedVappTransport",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedVappTransport",
                    "optional": false,
                    "label": "_computedVappTransport"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The state of VMware tools in the guest. This will determine the proper",
                        "course of action for some device operations."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vmware_tools_status\" <$> TF.attribute",
                    "name": "vmware_tools_status",
                    "method": "computedVmwareToolsStatus",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedVmwareToolsStatus",
                    "optional": false,
                    "label": "_computedVmwareToolsStatus"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The path of the virtual machine's configuration file in the VM's datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vmx_path\" <$> TF.attribute",
                    "name": "vmx_path",
                    "method": "computedVmxPath",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedVmxPath",
                    "optional": false,
                    "label": "_computedVmxPath"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "_networkInterface",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A specification for a virtual NIC on this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_interface\" <$> TF.attribute",
                    "name": "network_interface",
                    "method": "networkInterface",
                    "conflicts": [],
                    "type": "TF.Attr s [NetworkInterface s]",
                    "class": "HasNetworkInterface",
                    "optional": false,
                    "label": "_networkInterface"
                },
                {
                    "default": "_resourcePoolId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The ID of a resource pool to put the virtual machine in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_pool_id\" <$> TF.attribute",
                    "name": "resource_pool_id",
                    "method": "resourcePoolId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResourcePoolId",
                    "optional": false,
                    "label": "_resourcePoolId"
                }
            ],
            "type": "VirtualMachineResource s",
            "original": "vsphere_virtual_machine"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"consolidate\" <$> TF.attribute",
                    "name": "consolidate",
                    "method": "consolidate",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasConsolidate",
                    "optional": true,
                    "label": "_consolidate"
                },
                {
                    "default": "_description",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"description\" <$> TF.attribute",
                    "name": "description",
                    "method": "description",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDescription",
                    "optional": false,
                    "label": "_description"
                },
                {
                    "default": "_memory",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "memory",
                    "method": "memory",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasMemory",
                    "optional": false,
                    "label": "_memory"
                },
                {
                    "default": "_quiesce",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"quiesce\" <$> TF.attribute",
                    "name": "quiesce",
                    "method": "quiesce",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasQuiesce",
                    "optional": false,
                    "label": "_quiesce"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"remove_children\" <$> TF.attribute",
                    "name": "remove_children",
                    "method": "removeChildren",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRemoveChildren",
                    "optional": true,
                    "label": "_removeChildren"
                },
                {
                    "default": "_snapshotName",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"snapshot_name\" <$> TF.attribute",
                    "name": "snapshot_name",
                    "method": "snapshotName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSnapshotName",
                    "optional": false,
                    "label": "_snapshotName"
                },
                {
                    "default": "_virtualMachineUuid",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"virtual_machine_uuid\" <$> TF.attribute",
                    "name": "virtual_machine_uuid",
                    "method": "virtualMachineUuid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVirtualMachineUuid",
                    "optional": false,
                    "label": "_virtualMachineUuid"
                }
            ],
            "schema": "Resource",
            "name": "VirtualMachineSnapshotResource",
            "attributes": [],
            "parameters": [
                {
                    "default": "_description",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"description\" <$> TF.attribute",
                    "name": "description",
                    "method": "description",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDescription",
                    "optional": false,
                    "label": "_description"
                },
                {
                    "default": "_memory",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "memory",
                    "method": "memory",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasMemory",
                    "optional": false,
                    "label": "_memory"
                },
                {
                    "default": "_quiesce",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"quiesce\" <$> TF.attribute",
                    "name": "quiesce",
                    "method": "quiesce",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasQuiesce",
                    "optional": false,
                    "label": "_quiesce"
                },
                {
                    "default": "_snapshotName",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"snapshot_name\" <$> TF.attribute",
                    "name": "snapshot_name",
                    "method": "snapshotName",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSnapshotName",
                    "optional": false,
                    "label": "_snapshotName"
                },
                {
                    "default": "_virtualMachineUuid",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"virtual_machine_uuid\" <$> TF.attribute",
                    "name": "virtual_machine_uuid",
                    "method": "virtualMachineUuid",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVirtualMachineUuid",
                    "optional": false,
                    "label": "_virtualMachineUuid"
                }
            ],
            "type": "VirtualMachineSnapshotResource s",
            "original": "vsphere_virtual_machine_snapshot"
        },
        {
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of custom attributes to set on this resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"custom_attributes\" <$> TF.attribute",
                    "name": "custom_attributes",
                    "method": "customAttributes",
                    "conflicts": [],
                    "type": "TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))",
                    "class": "HasCustomAttributes",
                    "optional": true,
                    "label": "_customAttributes"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object ID of the datastore cluster to place the datastore in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datastore_cluster_id\" <$> TF.attribute",
                    "name": "datastore_cluster_id",
                    "method": "datastoreClusterId",
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "method": "folder",
                            "label": "_folder"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastoreClusterId",
                    "optional": true,
                    "label": "_datastoreClusterId"
                },
                {
                    "default": "_disks",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The disks to add to the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disks\" <$> TF.attribute",
                    "name": "disks",
                    "method": "disks",
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (TF.Attr s P.Text))",
                    "class": "HasDisks",
                    "optional": false,
                    "label": "_disks"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The path to the datastore folder to put the datastore in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"folder\" <$> TF.attribute",
                    "name": "folder",
                    "method": "folder",
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "method": "datastoreClusterId",
                            "label": "_datastoreClusterId"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFolder",
                    "optional": true,
                    "label": "_folder"
                },
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host to set up the datastore on."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "host_system_id",
                    "method": "hostSystemId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "optional": false,
                    "label": "_hostSystemId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of tag IDs to apply to this object."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tags\" <$> TF.attribute",
                    "name": "tags",
                    "method": "tags",
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (TF.Attr s P.Text)]",
                    "class": "HasTags",
                    "optional": true,
                    "label": "_tags"
                }
            ],
            "schema": "Resource",
            "name": "VmfsDatastoreResource",
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The connectivity status of the datastore. If this is false, some other",
                        "computed attributes may be out of date."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"accessible\" <$> TF.attribute",
                    "name": "accessible",
                    "method": "computedAccessible",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedAccessible",
                    "optional": false,
                    "label": "_computedAccessible"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Maximum capacity of the datastore, in MB."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"capacity\" <$> TF.attribute",
                    "name": "capacity",
                    "method": "computedCapacity",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedCapacity",
                    "optional": false,
                    "label": "_computedCapacity"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Available space of this datastore, in MB."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"free_space\" <$> TF.attribute",
                    "name": "free_space",
                    "method": "computedFreeSpace",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedFreeSpace",
                    "optional": false,
                    "label": "_computedFreeSpace"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The current maintenance mode state of the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"maintenance_mode\" <$> TF.attribute",
                    "name": "maintenance_mode",
                    "method": "computedMaintenanceMode",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMaintenanceMode",
                    "optional": false,
                    "label": "_computedMaintenanceMode"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "If true, more than one host in the datacenter has been configured with",
                        "access to the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"multiple_host_access\" <$> TF.attribute",
                    "name": "multiple_host_access",
                    "method": "computedMultipleHostAccess",
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedMultipleHostAccess",
                    "optional": false,
                    "label": "_computedMultipleHostAccess"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Total additional storage space, in MB, potentially used by all virtual",
                        "machines on this datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uncommitted_space\" <$> TF.attribute",
                    "name": "uncommitted_space",
                    "method": "computedUncommittedSpace",
                    "conflicts": [],
                    "type": "TF.Attr s P.Integer",
                    "class": "HasComputedUncommittedSpace",
                    "optional": false,
                    "label": "_computedUncommittedSpace"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique locator for the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"url\" <$> TF.attribute",
                    "name": "url",
                    "method": "computedUrl",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUrl",
                    "optional": false,
                    "label": "_computedUrl"
                }
            ],
            "parameters": [
                {
                    "default": "_disks",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The disks to add to the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disks\" <$> TF.attribute",
                    "name": "disks",
                    "method": "disks",
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (TF.Attr s P.Text))",
                    "class": "HasDisks",
                    "optional": false,
                    "label": "_disks"
                },
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host to set up the datastore on."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "host_system_id",
                    "method": "hostSystemId",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "optional": false,
                    "label": "_hostSystemId"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "name",
                    "method": "name",
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "optional": false,
                    "label": "_name"
                }
            ],
            "type": "VmfsDatastoreResource s",
            "original": "vsphere_vmfs_datastore"
        }
    ],
    "dependencies": [
        "base",
        "unordered-containers",
        "text",
        "terrafomo",
        "hashable",
        "microlens"
    ],
    "name": "VSphere",
    "parameters": [
        {
            "default": "_password",
            "computed": false,
            "required": true,
            "help": [
                "The user password for vSphere API operations."
            ],
            "forceNew": false,
            "encoder": "P.Just $ TF.assign \"password\"",
            "name": "password",
            "method": "password",
            "conflicts": [],
            "type": "P.Text",
            "class": "HasPassword",
            "optional": false,
            "label": "_password"
        },
        {
            "default": "_user",
            "computed": false,
            "required": true,
            "help": [
                "The user name for vSphere API operations."
            ],
            "forceNew": false,
            "encoder": "P.Just $ TF.assign \"user\"",
            "name": "user",
            "method": "user",
            "conflicts": [],
            "type": "P.Text",
            "class": "HasUser",
            "optional": false,
            "label": "_user"
        }
    ],
    "package": "terrafomo-vsphere",
    "type": "Provider",
    "original": "vsphere"
}