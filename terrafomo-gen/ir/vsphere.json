{
    "settings": [
        {
            "con": {
                "smart": "newCdromSetting",
                "name": "CdromSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Indicates whether the device should be mapped to a remote client device"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"client_device\" <$> TF.attribute",
                    "name": "_clientDevice",
                    "method": "clientDevice",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasClientDevice",
                    "validate": false,
                    "optional": true,
                    "original": "client_device"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The datastore ID the ISO is located on."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datastore_id\" <$> TF.attribute",
                    "name": "_datastoreId",
                    "method": "datastoreId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastoreId",
                    "validate": false,
                    "optional": true,
                    "original": "datastore_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The path to the ISO file on the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                }
            ],
            "key": "vsphere_virtual_machine.cdrom",
            "name": "CdromSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The internally-computed address of this device, such as scsi:0:1, denoting",
                        "scsi bus #0 and device unit 1."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"device_address\" <$> TF.attribute",
                    "name": "_computedDeviceAddress",
                    "method": "computedDeviceAddress",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedDeviceAddress",
                    "validate": false,
                    "optional": false,
                    "original": "device_address"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique device ID for this device within its virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_computedKey",
                    "method": "computedKey",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedKey",
                    "validate": false,
                    "optional": false,
                    "original": "key"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "CdromSetting s",
            "original": "cdrom"
        },
        {
            "con": {
                "smart": "newCloneSetting",
                "name": "CloneSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The customization spec for this clone. This allows the user to configure the",
                        "virtual machine post-clone."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"customize\" <$> TF.attribute",
                    "name": "_customize",
                    "method": "customize",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (CustomizeSetting s)",
                    "class": "HasCustomize",
                    "validate": true,
                    "optional": true,
                    "original": "customize"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether or not to create a linked clone when cloning. When this option is",
                        "used, the source VM must have a single snapshot associated with it."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"linked_clone\" <$> TF.attribute",
                    "name": "_linkedClone",
                    "method": "linkedClone",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasLinkedClone",
                    "validate": false,
                    "optional": true,
                    "original": "linked_clone"
                },
                {
                    "default": "_templateUuid",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The UUID of the source virtual machine or template."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"template_uuid\" <$> TF.attribute",
                    "name": "_templateUuid",
                    "method": "templateUuid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTemplateUuid",
                    "validate": false,
                    "optional": false,
                    "original": "template_uuid"
                },
                {
                    "default": "TF.value 30",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The timeout, in minutes, to wait for the virtual machine clone to complete."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"timeout\" <$> TF.attribute",
                    "name": "_timeout",
                    "method": "timeout",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasTimeout",
                    "validate": false,
                    "optional": true,
                    "original": "timeout"
                }
            ],
            "key": "vsphere_virtual_machine.clone",
            "name": "CloneSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_templateUuid",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The UUID of the source virtual machine or template."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"template_uuid\" <$> TF.attribute",
                    "name": "_templateUuid",
                    "method": "templateUuid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTemplateUuid",
                    "validate": false,
                    "optional": false,
                    "original": "template_uuid"
                }
            ],
            "conflicts": [],
            "type": "CloneSetting s",
            "original": "clone"
        },
        {
            "con": {
                "smart": "newCustomizeSetting",
                "name": "CustomizeSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The list of DNS servers for a virtual network adapter with a static IP",
                        "address."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dns_server_list\" <$> TF.attribute",
                    "name": "_dnsServerList",
                    "method": "dnsServerList",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasDnsServerList",
                    "validate": false,
                    "optional": true,
                    "original": "dns_server_list"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of DNS search domains to add to the DNS configuration on the virtual",
                        "machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dns_suffix_list\" <$> TF.attribute",
                    "name": "_dnsSuffixList",
                    "method": "dnsSuffixList",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasDnsSuffixList",
                    "validate": false,
                    "optional": true,
                    "original": "dns_suffix_list"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The IPv4 default gateway when using network_interface customization on the",
                        "virtual machine. This address must be local to a static IPv4 address",
                        "configured in an interface sub-resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ipv4_gateway\" <$> TF.attribute",
                    "name": "_ipv4Gateway",
                    "method": "ipv4Gateway",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIpv4Gateway",
                    "validate": false,
                    "optional": true,
                    "original": "ipv4_gateway"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The IPv6 default gateway when using network_interface customization on the",
                        "virtual machine. This address must be local to a static IPv4 address",
                        "configured in an interface sub-resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ipv6_gateway\" <$> TF.attribute",
                    "name": "_ipv6Gateway",
                    "method": "ipv6Gateway",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIpv6Gateway",
                    "validate": false,
                    "optional": true,
                    "original": "ipv6_gateway"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of configuration options specific to Linux virtual machines."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"linux_options\" <$> TF.attribute",
                    "name": "_linuxOptions",
                    "method": "linuxOptions",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_windowsOptions",
                            "method": "windowsOptions"
                        },
                        {
                            "default": "TF.Nil",
                            "name": "_windowsSysprepText",
                            "method": "windowsSysprepText"
                        }
                    ],
                    "type": "TF.Attr s (LinuxOptionsSetting s)",
                    "class": "HasLinuxOptions",
                    "validate": true,
                    "optional": true,
                    "original": "linux_options"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A specification of network interface configuration options."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_interface\" <$> TF.attribute",
                    "name": "_networkInterface",
                    "method": "networkInterface",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (NetworkInterfaceSetting s)]",
                    "class": "HasNetworkInterface",
                    "validate": false,
                    "optional": true,
                    "original": "network_interface"
                },
                {
                    "default": "TF.value 10",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The amount of time, in minutes, to wait for guest OS customization to",
                        "complete before returning with an error. Setting this value to 0 or a",
                        "negative value skips the waiter."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"timeout\" <$> TF.attribute",
                    "name": "_timeout",
                    "method": "timeout",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasTimeout",
                    "validate": false,
                    "optional": true,
                    "original": "timeout"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of configuration options specific to Windows virtual machines."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"windows_options\" <$> TF.attribute",
                    "name": "_windowsOptions",
                    "method": "windowsOptions",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_linuxOptions",
                            "method": "linuxOptions"
                        },
                        {
                            "default": "TF.Nil",
                            "name": "_windowsSysprepText",
                            "method": "windowsSysprepText"
                        }
                    ],
                    "type": "TF.Attr s (WindowsOptionsSetting s)",
                    "class": "HasWindowsOptions",
                    "validate": true,
                    "optional": true,
                    "original": "windows_options"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Use this option to specify a windows sysprep file directly."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"windows_sysprep_text\" <$> TF.attribute",
                    "name": "_windowsSysprepText",
                    "method": "windowsSysprepText",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_linuxOptions",
                            "method": "linuxOptions"
                        },
                        {
                            "default": "TF.Nil",
                            "name": "_windowsOptions",
                            "method": "windowsOptions"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasWindowsSysprepText",
                    "validate": false,
                    "optional": true,
                    "original": "windows_sysprep_text"
                }
            ],
            "key": "vsphere_virtual_machine.clone.customize",
            "name": "CustomizeSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of configuration options specific to Linux virtual machines."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"linux_options\" <$> TF.attribute",
                    "name": "_linuxOptions",
                    "method": "linuxOptions",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_windowsOptions",
                            "method": "windowsOptions"
                        },
                        {
                            "default": "TF.Nil",
                            "name": "_windowsSysprepText",
                            "method": "windowsSysprepText"
                        }
                    ],
                    "type": "TF.Attr s (LinuxOptionsSetting s)",
                    "class": "HasLinuxOptions",
                    "validate": true,
                    "optional": true,
                    "original": "linux_options"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of configuration options specific to Windows virtual machines."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"windows_options\" <$> TF.attribute",
                    "name": "_windowsOptions",
                    "method": "windowsOptions",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_linuxOptions",
                            "method": "linuxOptions"
                        },
                        {
                            "default": "TF.Nil",
                            "name": "_windowsSysprepText",
                            "method": "windowsSysprepText"
                        }
                    ],
                    "type": "TF.Attr s (WindowsOptionsSetting s)",
                    "class": "HasWindowsOptions",
                    "validate": true,
                    "optional": true,
                    "original": "windows_options"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Use this option to specify a windows sysprep file directly."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"windows_sysprep_text\" <$> TF.attribute",
                    "name": "_windowsSysprepText",
                    "method": "windowsSysprepText",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_linuxOptions",
                            "method": "linuxOptions"
                        },
                        {
                            "default": "TF.Nil",
                            "name": "_windowsOptions",
                            "method": "windowsOptions"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasWindowsSysprepText",
                    "validate": false,
                    "optional": true,
                    "original": "windows_sysprep_text"
                }
            ],
            "type": "CustomizeSetting s",
            "original": "customize"
        },
        {
            "con": {
                "smart": "newDiskSetting",
                "name": "DiskSetting'"
            },
            "arguments": [
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If this is true, the disk is attached instead of created. Implies",
                        "keep_on_remove."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"attach\" <$> TF.attribute",
                    "name": "_attach",
                    "method": "attach",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasAttach",
                    "validate": false,
                    "optional": true,
                    "original": "attach"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The datastore ID for this virtual disk, if different than the virtual",
                        "machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datastore_id\" <$> TF.attribute",
                    "name": "_datastoreId",
                    "method": "datastoreId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastoreId",
                    "validate": false,
                    "optional": true,
                    "original": "datastore_id"
                },
                {
                    "default": "TF.value \"persistent\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The mode of this this virtual disk for purposes of writes and snapshotting.",
                        "Can be one of append, independent_nonpersistent, independent_persistent,",
                        "nonpersistent, persistent, or undoable."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disk_mode\" <$> TF.attribute",
                    "name": "_diskMode",
                    "method": "diskMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDiskMode",
                    "validate": false,
                    "optional": true,
                    "original": "disk_mode"
                },
                {
                    "default": "TF.value \"sharingNone\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The sharing mode of this virtual disk. Can be one of sharingMultiWriter or",
                        "sharingNone."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disk_sharing\" <$> TF.attribute",
                    "name": "_diskSharing",
                    "method": "diskSharing",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDiskSharing",
                    "validate": false,
                    "optional": true,
                    "original": "disk_sharing"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The virtual disk file zeroing policy when thin_provision is not true. The",
                        "default is false, which lazily-zeros the disk, speeding up thick-provisioned",
                        "disk creation time."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"eagerly_scrub\" <$> TF.attribute",
                    "name": "_eagerlyScrub",
                    "method": "eagerlyScrub",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasEagerlyScrub",
                    "validate": false,
                    "optional": true,
                    "original": "eagerly_scrub"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The upper limit of IOPS that this disk can use."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"io_limit\" <$> TF.attribute",
                    "name": "_ioLimit",
                    "method": "ioLimit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasIoLimit",
                    "validate": false,
                    "optional": true,
                    "original": "io_limit"
                },
                {
                    "default": "TF.value 0",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The I/O guarantee that this disk has, in IOPS."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"io_reservation\" <$> TF.attribute",
                    "name": "_ioReservation",
                    "method": "ioReservation",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasIoReservation",
                    "validate": false,
                    "optional": true,
                    "original": "io_reservation"
                },
                {
                    "default": "TF.value 0",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The share count for this disk when the share level is custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"io_share_count\" <$> TF.attribute",
                    "name": "_ioShareCount",
                    "method": "ioShareCount",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasIoShareCount",
                    "validate": false,
                    "optional": true,
                    "original": "io_share_count"
                },
                {
                    "default": "TF.value \"normal\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The share allocation level for this disk. Can be one of low, normal, high,",
                        "or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"io_share_level\" <$> TF.attribute",
                    "name": "_ioShareLevel",
                    "method": "ioShareLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIoShareLevel",
                    "validate": false,
                    "optional": true,
                    "original": "io_share_level"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Set to true to keep the underlying VMDK file when removing this virtual disk",
                        "from configuration."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"keep_on_remove\" <$> TF.attribute",
                    "name": "_keepOnRemove",
                    "method": "keepOnRemove",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasKeepOnRemove",
                    "validate": false,
                    "optional": true,
                    "original": "keep_on_remove"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A unique label for this disk."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"label\" <$> TF.attribute",
                    "name": "_label",
                    "method": "label",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLabel",
                    "validate": false,
                    "optional": true,
                    "original": "label"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The size of the disk, in GB."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"size\" <$> TF.attribute",
                    "name": "_size",
                    "method": "size",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasSize",
                    "validate": false,
                    "optional": true,
                    "original": "size"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If true, this disk is thin provisioned, with space for the file being",
                        "allocated on an as-needed basis."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"thin_provisioned\" <$> TF.attribute",
                    "name": "_thinProvisioned",
                    "method": "thinProvisioned",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasThinProvisioned",
                    "validate": false,
                    "optional": true,
                    "original": "thin_provisioned"
                },
                {
                    "default": "TF.value 0",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The unique device number for this disk. This number determines where on the",
                        "SCSI bus this device will be attached."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"unit_number\" <$> TF.attribute",
                    "name": "_unitNumber",
                    "method": "unitNumber",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasUnitNumber",
                    "validate": false,
                    "optional": true,
                    "original": "unit_number"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If true, writes for this disk are sent directly to the filesystem",
                        "immediately instead of being buffered."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"write_through\" <$> TF.attribute",
                    "name": "_writeThrough",
                    "method": "writeThrough",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasWriteThrough",
                    "validate": false,
                    "optional": true,
                    "original": "write_through"
                }
            ],
            "key": "vsphere_virtual_machine.disk",
            "name": "DiskSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The internally-computed address of this device, such as scsi:0:1, denoting",
                        "scsi bus #0 and device unit 1."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"device_address\" <$> TF.attribute",
                    "name": "_computedDeviceAddress",
                    "method": "computedDeviceAddress",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedDeviceAddress",
                    "validate": false,
                    "optional": false,
                    "original": "device_address"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique device ID for this device within its virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_computedKey",
                    "method": "computedKey",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedKey",
                    "validate": false,
                    "optional": false,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The full path of the virtual disk. This can only be provided if attach is",
                        "set to true, otherwise it is a read-only value."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_computedPath",
                    "method": "computedPath",
                    "threaded": true,
                    "conflicts": [
                        "_datastoreClusterId"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedPath",
                    "validate": false,
                    "optional": true,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The UUID of the virtual disk."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uuid\" <$> TF.attribute",
                    "name": "_computedUuid",
                    "method": "computedUuid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUuid",
                    "validate": false,
                    "optional": false,
                    "original": "uuid"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "DiskSetting s",
            "original": "disk"
        },
        {
            "con": {
                "smart": "newDisksSetting",
                "name": "DisksSetting'"
            },
            "arguments": [],
            "key": "vsphere_virtual_machine.disks",
            "name": "DisksSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"eagerly_scrub\" <$> TF.attribute",
                    "name": "_computedEagerlyScrub",
                    "method": "computedEagerlyScrub",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedEagerlyScrub",
                    "validate": false,
                    "optional": false,
                    "original": "eagerly_scrub"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"size\" <$> TF.attribute",
                    "name": "_computedSize",
                    "method": "computedSize",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedSize",
                    "validate": false,
                    "optional": false,
                    "original": "size"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"thin_provisioned\" <$> TF.attribute",
                    "name": "_computedThinProvisioned",
                    "method": "computedThinProvisioned",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedThinProvisioned",
                    "validate": false,
                    "optional": false,
                    "original": "thin_provisioned"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "DisksSetting s",
            "original": "disks"
        },
        {
            "con": {
                "smart": "newHostSetting",
                "name": "HostSetting'"
            },
            "arguments": [
                {
                    "default": "_devices",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the physical NIC to be added to the proxy switch."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"devices\" <$> TF.attribute",
                    "name": "_devices",
                    "method": "devices",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (TF.Attr s P.Text))",
                    "class": "HasDevices",
                    "validate": false,
                    "optional": false,
                    "original": "devices"
                },
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host this specification applies to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "_hostSystemId",
                    "method": "hostSystemId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "validate": false,
                    "optional": false,
                    "original": "host_system_id"
                }
            ],
            "key": "vsphere_distributed_virtual_switch.host",
            "name": "HostSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_devices",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of the physical NIC to be added to the proxy switch."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"devices\" <$> TF.attribute",
                    "name": "_devices",
                    "method": "devices",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (TF.Attr s P.Text))",
                    "class": "HasDevices",
                    "validate": false,
                    "optional": false,
                    "original": "devices"
                },
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host this specification applies to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "_hostSystemId",
                    "method": "hostSystemId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "validate": false,
                    "optional": false,
                    "original": "host_system_id"
                }
            ],
            "conflicts": [],
            "type": "HostSetting s",
            "original": "host"
        },
        {
            "con": {
                "smart": "newLinuxOptionsSetting",
                "name": "LinuxOptionsSetting'"
            },
            "arguments": [
                {
                    "default": "_domain",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The FQDN for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"domain\" <$> TF.attribute",
                    "name": "_domain",
                    "method": "domain",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDomain",
                    "validate": false,
                    "optional": false,
                    "original": "domain"
                },
                {
                    "default": "_hostName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The host name for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_name\" <$> TF.attribute",
                    "name": "_hostName",
                    "method": "hostName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostName",
                    "validate": false,
                    "optional": false,
                    "original": "host_name"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies whether or not the hardware clock should be in UTC or not."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"hw_clock_utc\" <$> TF.attribute",
                    "name": "_hwClockUtc",
                    "method": "hwClockUtc",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHwClockUtc",
                    "validate": false,
                    "optional": true,
                    "original": "hw_clock_utc"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Customize the time zone on the VM. This should be a time zone-style entry,",
                        "like America/Los_Angeles."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"time_zone\" <$> TF.attribute",
                    "name": "_timeZone",
                    "method": "timeZone",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTimeZone",
                    "validate": false,
                    "optional": true,
                    "original": "time_zone"
                }
            ],
            "key": "vsphere_virtual_machine.clone.customize.linux_options",
            "name": "LinuxOptionsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_domain",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The FQDN for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"domain\" <$> TF.attribute",
                    "name": "_domain",
                    "method": "domain",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDomain",
                    "validate": false,
                    "optional": false,
                    "original": "domain"
                },
                {
                    "default": "_hostName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The host name for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_name\" <$> TF.attribute",
                    "name": "_hostName",
                    "method": "hostName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostName",
                    "validate": false,
                    "optional": false,
                    "original": "host_name"
                }
            ],
            "conflicts": [],
            "type": "LinuxOptionsSetting s",
            "original": "linux_options"
        },
        {
            "con": {
                "smart": "newNetworkInterfaceSetting",
                "name": "NetworkInterfaceSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A DNS search domain to add to the DNS configuration on the virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dns_domain\" <$> TF.attribute",
                    "name": "_dnsDomain",
                    "method": "dnsDomain",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDnsDomain",
                    "validate": false,
                    "optional": true,
                    "original": "dns_domain"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Network-interface specific DNS settings for Windows operating systems.",
                        "Ignored on Linux."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dns_server_list\" <$> TF.attribute",
                    "name": "_dnsServerList",
                    "method": "dnsServerList",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasDnsServerList",
                    "validate": false,
                    "optional": true,
                    "original": "dns_server_list"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The IPv4 address assigned to this network adapter. If left blank, DHCP is",
                        "used."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ipv4_address\" <$> TF.attribute",
                    "name": "_ipv4Address",
                    "method": "ipv4Address",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIpv4Address",
                    "validate": false,
                    "optional": true,
                    "original": "ipv4_address"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The IPv4 CIDR netmask for the supplied IP address. Ignored if DHCP is",
                        "selected."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ipv4_netmask\" <$> TF.attribute",
                    "name": "_ipv4Netmask",
                    "method": "ipv4Netmask",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasIpv4Netmask",
                    "validate": false,
                    "optional": true,
                    "original": "ipv4_netmask"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The IPv6 address assigned to this network adapter. If left blank, default",
                        "auto-configuration is used."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ipv6_address\" <$> TF.attribute",
                    "name": "_ipv6Address",
                    "method": "ipv6Address",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIpv6Address",
                    "validate": false,
                    "optional": true,
                    "original": "ipv6_address"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The IPv6 CIDR netmask for the supplied IP address. Ignored if",
                        "auto-configuration is selected."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ipv6_netmask\" <$> TF.attribute",
                    "name": "_ipv6Netmask",
                    "method": "ipv6Netmask",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasIpv6Netmask",
                    "validate": false,
                    "optional": true,
                    "original": "ipv6_netmask"
                },
                {
                    "default": "TF.value \"vmxnet3\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The controller type. Can be one of e1000, e1000e, or vmxnet3."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"adapter_type\" <$> TF.attribute",
                    "name": "_adapterType",
                    "method": "adapterType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasAdapterType",
                    "validate": false,
                    "optional": true,
                    "original": "adapter_type"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The upper bandwidth limit of this network interface, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"bandwidth_limit\" <$> TF.attribute",
                    "name": "_bandwidthLimit",
                    "method": "bandwidthLimit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasBandwidthLimit",
                    "validate": false,
                    "optional": true,
                    "original": "bandwidth_limit"
                },
                {
                    "default": "TF.value 0",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The bandwidth reservation of this network interface, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"bandwidth_reservation\" <$> TF.attribute",
                    "name": "_bandwidthReservation",
                    "method": "bandwidthReservation",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasBandwidthReservation",
                    "validate": false,
                    "optional": true,
                    "original": "bandwidth_reservation"
                },
                {
                    "default": "TF.value \"normal\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The bandwidth share allocation level for this interface. Can be one of low,",
                        "normal, high, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"bandwidth_share_level\" <$> TF.attribute",
                    "name": "_bandwidthShareLevel",
                    "method": "bandwidthShareLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasBandwidthShareLevel",
                    "validate": false,
                    "optional": true,
                    "original": "bandwidth_share_level"
                },
                {
                    "default": "_networkId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The ID of the network to connect this network interface to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_id\" <$> TF.attribute",
                    "name": "_networkId",
                    "method": "networkId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNetworkId",
                    "validate": false,
                    "optional": false,
                    "original": "network_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If true, the mac_address field is treated as a static MAC address and set",
                        "accordingly."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"use_static_mac\" <$> TF.attribute",
                    "name": "_useStaticMac",
                    "method": "useStaticMac",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasUseStaticMac",
                    "validate": false,
                    "optional": true,
                    "original": "use_static_mac"
                }
            ],
            "key": "vsphere_virtual_machine.clone.customize.network_interface",
            "name": "NetworkInterfaceSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The share count for this network interface when the share level is custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"bandwidth_share_count\" <$> TF.attribute",
                    "name": "_computedBandwidthShareCount",
                    "method": "computedBandwidthShareCount",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedBandwidthShareCount",
                    "validate": false,
                    "optional": true,
                    "original": "bandwidth_share_count"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The internally-computed address of this device, such as scsi:0:1, denoting",
                        "scsi bus #0 and device unit 1."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"device_address\" <$> TF.attribute",
                    "name": "_computedDeviceAddress",
                    "method": "computedDeviceAddress",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedDeviceAddress",
                    "validate": false,
                    "optional": false,
                    "original": "device_address"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique device ID for this device within its virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_computedKey",
                    "method": "computedKey",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedKey",
                    "validate": false,
                    "optional": false,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The MAC address of this network interface. Can only be manually set if",
                        "use_static_mac is true."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mac_address\" <$> TF.attribute",
                    "name": "_computedMacAddress",
                    "method": "computedMacAddress",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMacAddress",
                    "validate": false,
                    "optional": true,
                    "original": "mac_address"
                }
            ],
            "parameters": [
                {
                    "default": "_networkId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The ID of the network to connect this network interface to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_id\" <$> TF.attribute",
                    "name": "_networkId",
                    "method": "networkId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNetworkId",
                    "validate": false,
                    "optional": false,
                    "original": "network_id"
                }
            ],
            "conflicts": [],
            "type": "NetworkInterfaceSetting s",
            "original": "network_interface"
        },
        {
            "con": {
                "smart": "newPortsSetting",
                "name": "PortsSetting'"
            },
            "arguments": [],
            "key": "vsphere_host_port_group.ports",
            "name": "PortsSetting",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The linkable identifier for this port entry."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_computedKey",
                    "method": "computedKey",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedKey",
                    "validate": false,
                    "optional": false,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The MAC addresses of the network service of the virtual machine connected on",
                        "this port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mac_addresses\" <$> TF.attribute",
                    "name": "_computedMacAddresses",
                    "method": "computedMacAddresses",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedMacAddresses",
                    "validate": false,
                    "optional": false,
                    "original": "mac_addresses"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Type type of the entity connected on this port. Possible values are host",
                        "(VMKkernel), systemManagement (service console), virtualMachine, or unknown."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_computedType",
                    "method": "computedType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedType",
                    "validate": false,
                    "optional": false,
                    "original": "type"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "PortsSetting s",
            "original": "ports"
        },
        {
            "con": {
                "smart": "newVappSetting",
                "name": "VappSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A map of customizable vApp properties and their values. Allows customization",
                        "of VMs cloned from OVF templates which have customizable vApp properties."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"properties\" <$> TF.attribute",
                    "name": "_properties",
                    "method": "properties",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasProperties",
                    "validate": false,
                    "optional": true,
                    "original": "properties"
                }
            ],
            "key": "vsphere_virtual_machine.vapp",
            "name": "VappSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [],
            "conflicts": [],
            "type": "VappSetting s",
            "original": "vapp"
        },
        {
            "con": {
                "smart": "newVlanRangeSetting",
                "name": "VlanRangeSetting'"
            },
            "arguments": [
                {
                    "default": "_maxVlan",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The minimum VLAN to use in the range."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"max_vlan\" <$> TF.attribute",
                    "name": "_maxVlan",
                    "method": "maxVlan",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMaxVlan",
                    "validate": false,
                    "optional": false,
                    "original": "max_vlan"
                },
                {
                    "default": "_minVlan",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The minimum VLAN to use in the range."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"min_vlan\" <$> TF.attribute",
                    "name": "_minVlan",
                    "method": "minVlan",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMinVlan",
                    "validate": false,
                    "optional": false,
                    "original": "min_vlan"
                }
            ],
            "key": "vsphere_distributed_port_group.vlan_range",
            "name": "VlanRangeSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_maxVlan",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The minimum VLAN to use in the range."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"max_vlan\" <$> TF.attribute",
                    "name": "_maxVlan",
                    "method": "maxVlan",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMaxVlan",
                    "validate": false,
                    "optional": false,
                    "original": "max_vlan"
                },
                {
                    "default": "_minVlan",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The minimum VLAN to use in the range."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"min_vlan\" <$> TF.attribute",
                    "name": "_minVlan",
                    "method": "minVlan",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMinVlan",
                    "validate": false,
                    "optional": false,
                    "original": "min_vlan"
                }
            ],
            "conflicts": [],
            "type": "VlanRangeSetting s",
            "original": "vlan_range"
        },
        {
            "con": {
                "smart": "newWindowsOptionsSetting",
                "name": "WindowsOptionsSetting'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The new administrator password for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"admin_password\" <$> TF.attribute",
                    "name": "_adminPassword",
                    "method": "adminPassword",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasAdminPassword",
                    "validate": false,
                    "optional": true,
                    "original": "admin_password"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies whether or not the VM automatically logs on as Administrator."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"auto_logon\" <$> TF.attribute",
                    "name": "_autoLogon",
                    "method": "autoLogon",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasAutoLogon",
                    "validate": false,
                    "optional": true,
                    "original": "auto_logon"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Specifies how many times the VM should auto-logon the Administrator account",
                        "when auto_logon is true."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"auto_logon_count\" <$> TF.attribute",
                    "name": "_autoLogonCount",
                    "method": "autoLogonCount",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasAutoLogonCount",
                    "validate": false,
                    "optional": true,
                    "original": "auto_logon_count"
                },
                {
                    "default": "_computerName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The host name for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"computer_name\" <$> TF.attribute",
                    "name": "_computerName",
                    "method": "computerName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputerName",
                    "validate": false,
                    "optional": false,
                    "original": "computer_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The password of the domain administrator used to join this virtual machine",
                        "to the domain."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"domain_admin_password\" <$> TF.attribute",
                    "name": "_domainAdminPassword",
                    "method": "domainAdminPassword",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_workgroup",
                            "method": "workgroup"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDomainAdminPassword",
                    "validate": false,
                    "optional": true,
                    "original": "domain_admin_password"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The user account of the domain administrator used to join this virtual",
                        "machine to the domain."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"domain_admin_user\" <$> TF.attribute",
                    "name": "_domainAdminUser",
                    "method": "domainAdminUser",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_workgroup",
                            "method": "workgroup"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDomainAdminUser",
                    "validate": false,
                    "optional": true,
                    "original": "domain_admin_user"
                },
                {
                    "default": "TF.value \"Administrator\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The full name of the user of this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"full_name\" <$> TF.attribute",
                    "name": "_fullName",
                    "method": "fullName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFullName",
                    "validate": false,
                    "optional": true,
                    "original": "full_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The domain that the virtual machine should join."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"join_domain\" <$> TF.attribute",
                    "name": "_joinDomain",
                    "method": "joinDomain",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_workgroup",
                            "method": "workgroup"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasJoinDomain",
                    "validate": false,
                    "optional": true,
                    "original": "join_domain"
                },
                {
                    "default": "TF.value \"Managed by Terraform\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The organization name this virtual machine is being installed for."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"organization_name\" <$> TF.attribute",
                    "name": "_organizationName",
                    "method": "organizationName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasOrganizationName",
                    "validate": false,
                    "optional": true,
                    "original": "organization_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The product key for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"product_key\" <$> TF.attribute",
                    "name": "_productKey",
                    "method": "productKey",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasProductKey",
                    "validate": false,
                    "optional": true,
                    "original": "product_key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of commands to run at first user logon, after guest customization."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_once_command_list\" <$> TF.attribute",
                    "name": "_runOnceCommandList",
                    "method": "runOnceCommandList",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasRunOnceCommandList",
                    "validate": false,
                    "optional": true,
                    "original": "run_once_command_list"
                },
                {
                    "default": "TF.value 85",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The new time zone for the virtual machine. This is a sysprep-dictated",
                        "timezone code."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"time_zone\" <$> TF.attribute",
                    "name": "_timeZone",
                    "method": "timeZone",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasTimeZone",
                    "validate": false,
                    "optional": true,
                    "original": "time_zone"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The workgroup for this virtual machine if not joining a domain."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"workgroup\" <$> TF.attribute",
                    "name": "_workgroup",
                    "method": "workgroup",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_domainAdminPassword",
                            "method": "domainAdminPassword"
                        },
                        {
                            "default": "TF.Nil",
                            "name": "_domainAdminUser",
                            "method": "domainAdminUser"
                        },
                        {
                            "default": "TF.Nil",
                            "name": "_joinDomain",
                            "method": "joinDomain"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasWorkgroup",
                    "validate": false,
                    "optional": true,
                    "original": "workgroup"
                }
            ],
            "key": "vsphere_virtual_machine.clone.customize.windows_options",
            "name": "WindowsOptionsSetting",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_computerName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The host name for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"computer_name\" <$> TF.attribute",
                    "name": "_computerName",
                    "method": "computerName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputerName",
                    "validate": false,
                    "optional": false,
                    "original": "computer_name"
                }
            ],
            "conflicts": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The password of the domain administrator used to join this virtual machine",
                        "to the domain."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"domain_admin_password\" <$> TF.attribute",
                    "name": "_domainAdminPassword",
                    "method": "domainAdminPassword",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_workgroup",
                            "method": "workgroup"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDomainAdminPassword",
                    "validate": false,
                    "optional": true,
                    "original": "domain_admin_password"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The user account of the domain administrator used to join this virtual",
                        "machine to the domain."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"domain_admin_user\" <$> TF.attribute",
                    "name": "_domainAdminUser",
                    "method": "domainAdminUser",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_workgroup",
                            "method": "workgroup"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDomainAdminUser",
                    "validate": false,
                    "optional": true,
                    "original": "domain_admin_user"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The domain that the virtual machine should join."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"join_domain\" <$> TF.attribute",
                    "name": "_joinDomain",
                    "method": "joinDomain",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_workgroup",
                            "method": "workgroup"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasJoinDomain",
                    "validate": false,
                    "optional": true,
                    "original": "join_domain"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The workgroup for this virtual machine if not joining a domain."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"workgroup\" <$> TF.attribute",
                    "name": "_workgroup",
                    "method": "workgroup",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_domainAdminPassword",
                            "method": "domainAdminPassword"
                        },
                        {
                            "default": "TF.Nil",
                            "name": "_domainAdminUser",
                            "method": "domainAdminUser"
                        },
                        {
                            "default": "TF.Nil",
                            "name": "_joinDomain",
                            "method": "joinDomain"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasWorkgroup",
                    "validate": false,
                    "optional": true,
                    "original": "workgroup"
                }
            ],
            "type": "WindowsOptionsSetting s",
            "original": "windows_options"
        }
    ],
    "url": "https://www.terraform.io/docs/providers/vsphere/index.html",
    "dataSources": [
        {
            "con": {
                "smart": "computeClusterData",
                "name": "ComputeClusterData'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object ID of the datacenter the cluster is located in. Not",
                        "required if using an absolute path."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "_datacenterId",
                    "method": "datacenterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "validate": false,
                    "optional": true,
                    "original": "datacenter_id"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name or absolute path to the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/d/compute_cluster.html",
            "key": "vsphere_compute_cluster",
            "name": "ComputeClusterData",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The managed object ID of the cluster's root resource pool."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_pool_id\" <$> TF.attribute",
                    "name": "_computedResourcePoolId",
                    "method": "computedResourcePoolId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourcePoolId",
                    "validate": false,
                    "optional": false,
                    "original": "resource_pool_id"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name or absolute path to the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "ComputeClusterData s",
            "original": "vsphere_compute_cluster"
        },
        {
            "con": {
                "smart": "customAttributeData",
                "name": "CustomAttributeData'"
            },
            "arguments": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the custom attribute."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/d/custom_attribute.html",
            "key": "vsphere_custom_attribute",
            "name": "CustomAttributeData",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Object type for which the custom attribute is valid. If not specified, the",
                        "attribute is valid for all managed object types."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"managed_object_type\" <$> TF.attribute",
                    "name": "_computedManagedObjectType",
                    "method": "computedManagedObjectType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedManagedObjectType",
                    "validate": false,
                    "optional": false,
                    "original": "managed_object_type"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the custom attribute."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "CustomAttributeData s",
            "original": "vsphere_custom_attribute"
        },
        {
            "con": {
                "smart": "datacenterData",
                "name": "DatacenterData'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The name of the datacenter. This can be a name or path.\tCan be omitted if",
                        "there is only one datacenter in your inventory."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/d/datacenter.html",
            "key": "vsphere_datacenter",
            "name": "DatacenterData",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "DatacenterData s",
            "original": "vsphere_datacenter"
        },
        {
            "con": {
                "smart": "datastoreData",
                "name": "DatastoreData'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object ID of the datacenter the datastore is in. This is not",
                        "required when using ESXi directly, or if there is only one datacenter in",
                        "your infrastructure."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "_datacenterId",
                    "method": "datacenterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "validate": false,
                    "optional": true,
                    "original": "datacenter_id"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name or path of the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/d/datastore.html",
            "key": "vsphere_datastore",
            "name": "DatastoreData",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name or path of the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "DatastoreData s",
            "original": "vsphere_datastore"
        },
        {
            "con": {
                "smart": "datastoreClusterData",
                "name": "DatastoreClusterData'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object ID of the datacenter the cluster is located in. Not",
                        "required if using an absolute path."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "_datacenterId",
                    "method": "datacenterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "validate": false,
                    "optional": true,
                    "original": "datacenter_id"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name or absolute path to the datastore cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/d/datastore_cluster.html",
            "key": "vsphere_datastore_cluster",
            "name": "DatastoreClusterData",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name or absolute path to the datastore cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "DatastoreClusterData s",
            "original": "vsphere_datastore_cluster"
        },
        {
            "con": {
                "smart": "distributedVirtualSwitchData",
                "name": "DistributedVirtualSwitchData'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object ID of the datacenter the DVS is in. This is required if",
                        "the supplied path is not an absolute path containing a datacenter and there",
                        "are multiple datacenters in your infrastructure."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "_datacenterId",
                    "method": "datacenterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "validate": false,
                    "optional": true,
                    "original": "datacenter_id"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the distributed virtual switch. This can be a name or path."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/d/distributed_virtual_switch.html",
            "key": "vsphere_distributed_virtual_switch",
            "name": "DistributedVirtualSwitchData",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The uplink ports on this DVS."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uplinks\" <$> TF.attribute",
                    "name": "_computedUplinks",
                    "method": "computedUplinks",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedUplinks",
                    "validate": false,
                    "optional": false,
                    "original": "uplinks"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the distributed virtual switch. This can be a name or path."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "DistributedVirtualSwitchData s",
            "original": "vsphere_distributed_virtual_switch"
        },
        {
            "con": {
                "smart": "hostData",
                "name": "HostData'"
            },
            "arguments": [
                {
                    "default": "_datacenterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the datacenter to look for the host in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "_datacenterId",
                    "method": "datacenterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "validate": false,
                    "optional": false,
                    "original": "datacenter_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The name of the host. This can be a name or path.\tIf not provided, the",
                        "default host is used."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/d/host.html",
            "key": "vsphere_host",
            "name": "HostData",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The managed object ID of the host's root resource pool."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_pool_id\" <$> TF.attribute",
                    "name": "_computedResourcePoolId",
                    "method": "computedResourcePoolId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourcePoolId",
                    "validate": false,
                    "optional": false,
                    "original": "resource_pool_id"
                }
            ],
            "parameters": [
                {
                    "default": "_datacenterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the datacenter to look for the host in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "_datacenterId",
                    "method": "datacenterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "validate": false,
                    "optional": false,
                    "original": "datacenter_id"
                }
            ],
            "conflicts": [],
            "type": "HostData s",
            "original": "vsphere_host"
        },
        {
            "con": {
                "smart": "networkData",
                "name": "NetworkData'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object ID of the datacenter the network is in. This is required",
                        "if the supplied path is not an absolute path containing a datacenter and",
                        "there are multiple datacenters in your infrastructure."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "_datacenterId",
                    "method": "datacenterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "validate": false,
                    "optional": true,
                    "original": "datacenter_id"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name or path of the network."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/d/network.html",
            "key": "vsphere_network",
            "name": "NetworkData",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The managed object type of the network."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_computedType",
                    "method": "computedType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedType",
                    "validate": false,
                    "optional": false,
                    "original": "type"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name or path of the network."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "NetworkData s",
            "original": "vsphere_network"
        },
        {
            "con": {
                "smart": "resourcePoolData",
                "name": "ResourcePoolData'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object ID of the datacenter the resource pool is in. This is not",
                        "required when using ESXi directly, or if there is only one datacenter in",
                        "your infrastructure."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "_datacenterId",
                    "method": "datacenterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "validate": false,
                    "optional": true,
                    "original": "datacenter_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The name or path of the resource pool."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": true,
                    "original": "name"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/d/resource_pool.html",
            "key": "vsphere_resource_pool",
            "name": "ResourcePoolData",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                }
            ],
            "parameters": [],
            "conflicts": [],
            "type": "ResourcePoolData s",
            "original": "vsphere_resource_pool"
        },
        {
            "con": {
                "smart": "tagData",
                "name": "TagData'"
            },
            "arguments": [
                {
                    "default": "_categoryId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique identifier of the parent category for this tag."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"category_id\" <$> TF.attribute",
                    "name": "_categoryId",
                    "method": "categoryId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCategoryId",
                    "validate": false,
                    "optional": false,
                    "original": "category_id"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the tag."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/d/tag.html",
            "key": "vsphere_tag",
            "name": "TagData",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The description of the tag."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"description\" <$> TF.attribute",
                    "name": "_computedDescription",
                    "method": "computedDescription",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedDescription",
                    "validate": false,
                    "optional": false,
                    "original": "description"
                }
            ],
            "parameters": [
                {
                    "default": "_categoryId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique identifier of the parent category for this tag."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"category_id\" <$> TF.attribute",
                    "name": "_categoryId",
                    "method": "categoryId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCategoryId",
                    "validate": false,
                    "optional": false,
                    "original": "category_id"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the tag."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "TagData s",
            "original": "vsphere_tag"
        },
        {
            "con": {
                "smart": "tagCategoryData",
                "name": "TagCategoryData'"
            },
            "arguments": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the category."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/d/tag_category.html",
            "key": "vsphere_tag_category",
            "name": "TagCategoryData",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Object types to which this category's tags can be attached."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"associable_types\" <$> TF.attribute",
                    "name": "_computedAssociableTypes",
                    "method": "computedAssociableTypes",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedAssociableTypes",
                    "validate": false,
                    "optional": false,
                    "original": "associable_types"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The associated cardinality of the category. Can be one of SINGLE (object can",
                        "only be assigned one tag in this category) or MULTIPLE (object can be",
                        "assigned multiple tags in this category)."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cardinality\" <$> TF.attribute",
                    "name": "_computedCardinality",
                    "method": "computedCardinality",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedCardinality",
                    "validate": false,
                    "optional": false,
                    "original": "cardinality"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The description of the category."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"description\" <$> TF.attribute",
                    "name": "_computedDescription",
                    "method": "computedDescription",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedDescription",
                    "validate": false,
                    "optional": false,
                    "original": "description"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the category."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "TagCategoryData s",
            "original": "vsphere_tag_category"
        },
        {
            "con": {
                "smart": "virtualMachineData",
                "name": "VirtualMachineData'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object ID of the datacenter the virtual machine is in. This is",
                        "not required when using ESXi directly, or if there is only one datacenter in",
                        "your infrastructure."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "_datacenterId",
                    "method": "datacenterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "validate": false,
                    "optional": true,
                    "original": "datacenter_id"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name or path of the virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The number of SCSI controllers to scan for disk sizes and controller types",
                        "on."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scsi_controller_scan_count\" <$> TF.attribute",
                    "name": "_scsiControllerScanCount",
                    "method": "scsiControllerScanCount",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasScsiControllerScanCount",
                    "validate": false,
                    "optional": true,
                    "original": "scsi_controller_scan_count"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/d/virtual_machine.html",
            "key": "vsphere_virtual_machine",
            "name": "VirtualMachineData",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The alternate guest name of the virtual machine when guest_id is a",
                        "non-specific operating system, like otherGuest."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"alternate_guest_name\" <$> TF.attribute",
                    "name": "_computedAlternateGuestName",
                    "method": "computedAlternateGuestName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedAlternateGuestName",
                    "validate": false,
                    "optional": false,
                    "original": "alternate_guest_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Select configuration attributes from the disks on this virtual machine,",
                        "sorted by bus and unit number."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disks\" <$> TF.attribute",
                    "name": "_computedDisks",
                    "method": "computedDisks",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (DisksSetting s)]",
                    "class": "HasComputedDisks",
                    "validate": false,
                    "optional": false,
                    "original": "disks"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The firmware type for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"firmware\" <$> TF.attribute",
                    "name": "_computedFirmware",
                    "method": "computedFirmware",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedFirmware",
                    "validate": false,
                    "optional": false,
                    "original": "firmware"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The guest ID of the virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"guest_id\" <$> TF.attribute",
                    "name": "_computedGuestId",
                    "method": "computedGuestId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedGuestId",
                    "validate": false,
                    "optional": false,
                    "original": "guest_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The types of network interfaces found on the virtual machine, sorted by unit",
                        "number."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_interface_types\" <$> TF.attribute",
                    "name": "_computedNetworkInterfaceTypes",
                    "method": "computedNetworkInterfaceTypes",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedNetworkInterfaceTypes",
                    "validate": false,
                    "optional": false,
                    "original": "network_interface_types"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Mode for sharing the SCSI bus."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scsi_bus_sharing\" <$> TF.attribute",
                    "name": "_computedScsiBusSharing",
                    "method": "computedScsiBusSharing",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedScsiBusSharing",
                    "validate": false,
                    "optional": false,
                    "original": "scsi_bus_sharing"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The common SCSI bus type of all controllers on the virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scsi_type\" <$> TF.attribute",
                    "name": "_computedScsiType",
                    "method": "computedScsiType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedScsiType",
                    "validate": false,
                    "optional": false,
                    "original": "scsi_type"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name or path of the virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "VirtualMachineData s",
            "original": "vsphere_virtual_machine"
        },
        {
            "con": {
                "smart": "vmfsDisksData",
                "name": "VmfsDisksData'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A regular expression to filter the disks against. Only disks with canonical",
                        "names that match will be included."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"filter\" <$> TF.attribute",
                    "name": "_filter",
                    "method": "filter",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFilter",
                    "validate": false,
                    "optional": true,
                    "original": "filter"
                },
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host to search for disks on."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "_hostSystemId",
                    "method": "hostSystemId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "validate": false,
                    "optional": false,
                    "original": "host_system_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Rescan the system for disks before querying. This may lengthen the time it",
                        "takes to gather information."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"rescan\" <$> TF.attribute",
                    "name": "_rescan",
                    "method": "rescan",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRescan",
                    "validate": false,
                    "optional": true,
                    "original": "rescan"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/d/vmfs_disks.html",
            "key": "vsphere_vmfs_disks",
            "name": "VmfsDisksData",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"id\" <$> TF.attribute",
                    "name": "_computedId",
                    "method": "computedId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedId",
                    "validate": false,
                    "optional": false,
                    "original": "id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The names of the disks discovered by the search."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disks\" <$> TF.attribute",
                    "name": "_computedDisks",
                    "method": "computedDisks",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedDisks",
                    "validate": false,
                    "optional": false,
                    "original": "disks"
                }
            ],
            "parameters": [
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host to search for disks on."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "_hostSystemId",
                    "method": "hostSystemId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "validate": false,
                    "optional": false,
                    "original": "host_system_id"
                }
            ],
            "conflicts": [],
            "type": "VmfsDisksData s",
            "original": "vsphere_vmfs_disks"
        }
    ],
    "resources": [
        {
            "con": {
                "smart": "computeClusterResource",
                "name": "ComputeClusterResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of custom attributes to set on this resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"custom_attributes\" <$> TF.attribute",
                    "name": "_customAttributes",
                    "method": "customAttributes",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasCustomAttributes",
                    "validate": false,
                    "optional": true,
                    "original": "custom_attributes"
                },
                {
                    "default": "_datacenterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the datacenter to put the cluster in."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "_datacenterId",
                    "method": "datacenterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "validate": false,
                    "optional": false,
                    "original": "datacenter_id"
                },
                {
                    "default": "TF.value \"manual\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The automation level for host power operations in this cluster. Can be one",
                        "of manual or automated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dpm_automation_level\" <$> TF.attribute",
                    "name": "_dpmAutomationLevel",
                    "method": "dpmAutomationLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDpmAutomationLevel",
                    "validate": false,
                    "optional": true,
                    "original": "dpm_automation_level"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable DPM support for DRS. This allows you to dynamically control the power",
                        "of hosts depending on the needs of virtual machines in the cluster. Requires",
                        "that DRS be enabled."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dpm_enabled\" <$> TF.attribute",
                    "name": "_dpmEnabled",
                    "method": "dpmEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasDpmEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "dpm_enabled"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A value between 1 and 5 indicating the threshold of load within the cluster",
                        "that influences host power operations. This affects both power on and power",
                        "off operations - a lower setting will tolerate more of a surplus/deficit",
                        "than a higher setting."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dpm_threshold\" <$> TF.attribute",
                    "name": "_dpmThreshold",
                    "method": "dpmThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasDpmThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "dpm_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Advanced configuration options for DRS and DPM."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drs_advanced_options\" <$> TF.attribute",
                    "name": "_drsAdvancedOptions",
                    "method": "drsAdvancedOptions",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasDrsAdvancedOptions",
                    "validate": false,
                    "optional": true,
                    "original": "drs_advanced_options"
                },
                {
                    "default": "TF.value \"manual\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The default automation level for all virtual machines in this cluster. Can",
                        "be one of manual, partiallyAutomated, or fullyAutomated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drs_automation_level\" <$> TF.attribute",
                    "name": "_drsAutomationLevel",
                    "method": "drsAutomationLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDrsAutomationLevel",
                    "validate": false,
                    "optional": true,
                    "original": "drs_automation_level"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When true, enables DRS to use data from vRealize Operations Manager to make",
                        "proactive DRS recommendations."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drs_enable_predictive_drs\" <$> TF.attribute",
                    "name": "_drsEnablePredictiveDrs",
                    "method": "drsEnablePredictiveDrs",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasDrsEnablePredictiveDrs",
                    "validate": false,
                    "optional": true,
                    "original": "drs_enable_predictive_drs"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When true, allows individual VM overrides within this cluster to be set."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drs_enable_vm_overrides\" <$> TF.attribute",
                    "name": "_drsEnableVmOverrides",
                    "method": "drsEnableVmOverrides",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasDrsEnableVmOverrides",
                    "validate": false,
                    "optional": true,
                    "original": "drs_enable_vm_overrides"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable DRS for this cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drs_enabled\" <$> TF.attribute",
                    "name": "_drsEnabled",
                    "method": "drsEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasDrsEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "drs_enabled"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A value between 1 and 5 indicating the threshold of imbalance tolerated",
                        "between hosts. A lower setting will tolerate more imbalance while a higher",
                        "setting will tolerate less."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drs_migration_threshold\" <$> TF.attribute",
                    "name": "_drsMigrationThreshold",
                    "method": "drsMigrationThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasDrsMigrationThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "drs_migration_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The name of the folder to locate the cluster in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"folder\" <$> TF.attribute",
                    "name": "_folder",
                    "method": "folder",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFolder",
                    "validate": false,
                    "optional": true,
                    "original": "folder"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Force removal of all hosts in the cluster during destroy and make them",
                        "standalone hosts. Use of this flag mainly exists for testing and is not",
                        "recommended in normal use."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"force_evacuate_on_destroy\" <$> TF.attribute",
                    "name": "_forceEvacuateOnDestroy",
                    "method": "forceEvacuateOnDestroy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasForceEvacuateOnDestroy",
                    "validate": false,
                    "optional": true,
                    "original": "force_evacuate_on_destroy"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When ha_admission_control_policy is failoverHosts, this defines the managed",
                        "object IDs of hosts to use as dedicated failover hosts. These hosts are kept",
                        "as available as possible - admission control will block access to the host,",
                        "and DRS will ignore the host when making recommendations."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_admission_control_failover_host_system_ids\" <$> TF.attribute",
                    "name": "_haAdmissionControlFailoverHostSystemIds",
                    "method": "haAdmissionControlFailoverHostSystemIds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasHaAdmissionControlFailoverHostSystemIds",
                    "validate": false,
                    "optional": true,
                    "original": "ha_admission_control_failover_host_system_ids"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The maximum number of failed hosts that admission control tolerates when",
                        "making decisions on whether to permit virtual machine operations. The",
                        "maximum is one less than the number of hosts in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_admission_control_host_failure_tolerance\" <$> TF.attribute",
                    "name": "_haAdmissionControlHostFailureTolerance",
                    "method": "haAdmissionControlHostFailureTolerance",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHaAdmissionControlHostFailureTolerance",
                    "validate": false,
                    "optional": true,
                    "original": "ha_admission_control_host_failure_tolerance"
                },
                {
                    "default": "TF.value 100",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The percentage of resource reduction that a cluster of VMs can tolerate in",
                        "case of a failover. A value of 0 produces warnings only, whereas a value of",
                        "100 disables the setting."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_admission_control_performance_tolerance\" <$> TF.attribute",
                    "name": "_haAdmissionControlPerformanceTolerance",
                    "method": "haAdmissionControlPerformanceTolerance",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHaAdmissionControlPerformanceTolerance",
                    "validate": false,
                    "optional": true,
                    "original": "ha_admission_control_performance_tolerance"
                },
                {
                    "default": "TF.value \"resourcePercentage\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The type of admission control policy to use with vSphere HA, which controls",
                        "whether or not specific VM operations are permitted in the cluster in order",
                        "to protect the reliability of the cluster. Can be one of resourcePercentage,",
                        "slotPolicy, failoverHosts, or disabled. Note that disabling admission",
                        "control is not recommended and can lead to service issues."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_admission_control_policy\" <$> TF.attribute",
                    "name": "_haAdmissionControlPolicy",
                    "method": "haAdmissionControlPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaAdmissionControlPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "ha_admission_control_policy"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When ha_admission_control_policy is resourcePercentage, automatically",
                        "determine available resource percentages by subtracting the average number",
                        "of host resources represented by the",
                        "ha_admission_control_host_failure_tolerance setting from the total amount of",
                        "resources in the cluster. Disable to supply user-defined values."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_admission_control_resource_percentage_auto_compute\" <$> TF.attribute",
                    "name": "_haAdmissionControlResourcePercentageAutoCompute",
                    "method": "haAdmissionControlResourcePercentageAutoCompute",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHaAdmissionControlResourcePercentageAutoCompute",
                    "validate": false,
                    "optional": true,
                    "original": "ha_admission_control_resource_percentage_auto_compute"
                },
                {
                    "default": "TF.value 100",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When ha_admission_control_policy is resourcePercentage, this controls the",
                        "user-defined percentage of CPU resources in the cluster to reserve for",
                        "failover."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_admission_control_resource_percentage_cpu\" <$> TF.attribute",
                    "name": "_haAdmissionControlResourcePercentageCpu",
                    "method": "haAdmissionControlResourcePercentageCpu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHaAdmissionControlResourcePercentageCpu",
                    "validate": false,
                    "optional": true,
                    "original": "ha_admission_control_resource_percentage_cpu"
                },
                {
                    "default": "TF.value 100",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When ha_admission_control_policy is resourcePercentage, this controls the",
                        "user-defined percentage of memory resources in the cluster to reserve for",
                        "failover."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_admission_control_resource_percentage_memory\" <$> TF.attribute",
                    "name": "_haAdmissionControlResourcePercentageMemory",
                    "method": "haAdmissionControlResourcePercentageMemory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHaAdmissionControlResourcePercentageMemory",
                    "validate": false,
                    "optional": true,
                    "original": "ha_admission_control_resource_percentage_memory"
                },
                {
                    "default": "TF.value 32",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When ha_admission_control_policy is slotPolicy, this controls the",
                        "user-defined CPU slot size, in MHz."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_admission_control_slot_policy_explicit_cpu\" <$> TF.attribute",
                    "name": "_haAdmissionControlSlotPolicyExplicitCpu",
                    "method": "haAdmissionControlSlotPolicyExplicitCpu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHaAdmissionControlSlotPolicyExplicitCpu",
                    "validate": false,
                    "optional": true,
                    "original": "ha_admission_control_slot_policy_explicit_cpu"
                },
                {
                    "default": "TF.value 100",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When ha_admission_control_policy is slotPolicy, this controls the",
                        "user-defined memory slot size, in MB."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_admission_control_slot_policy_explicit_memory\" <$> TF.attribute",
                    "name": "_haAdmissionControlSlotPolicyExplicitMemory",
                    "method": "haAdmissionControlSlotPolicyExplicitMemory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHaAdmissionControlSlotPolicyExplicitMemory",
                    "validate": false,
                    "optional": true,
                    "original": "ha_admission_control_slot_policy_explicit_memory"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When ha_admission_control_policy is slotPolicy, this setting controls",
                        "whether or not you wish to supply explicit values to CPU and memory slot",
                        "sizes. The default is to gather a automatic average based on all powered-on",
                        "virtual machines currently in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_admission_control_slot_policy_use_explicit_size\" <$> TF.attribute",
                    "name": "_haAdmissionControlSlotPolicyUseExplicitSize",
                    "method": "haAdmissionControlSlotPolicyUseExplicitSize",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHaAdmissionControlSlotPolicyUseExplicitSize",
                    "validate": false,
                    "optional": true,
                    "original": "ha_admission_control_slot_policy_use_explicit_size"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Advanced configuration options for vSphere HA."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_advanced_options\" <$> TF.attribute",
                    "name": "_haAdvancedOptions",
                    "method": "haAdvancedOptions",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasHaAdvancedOptions",
                    "validate": false,
                    "optional": true,
                    "original": "ha_advanced_options"
                },
                {
                    "default": "TF.value \"none\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When ha_vm_component_protection is enabled, controls the action to take on",
                        "virtual machines if an APD status on an affected datastore clears in the",
                        "middle of an APD event. Can be one of none or reset."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_datastore_apd_recovery_action\" <$> TF.attribute",
                    "name": "_haDatastoreApdRecoveryAction",
                    "method": "haDatastoreApdRecoveryAction",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaDatastoreApdRecoveryAction",
                    "validate": false,
                    "optional": true,
                    "original": "ha_datastore_apd_recovery_action"
                },
                {
                    "default": "TF.value \"disabled\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When ha_vm_component_protection is enabled, controls the action to take on",
                        "virtual machines when the cluster has detected loss to all paths to a",
                        "relevant datastore. Can be one of disabled, warning, restartConservative, or",
                        "restartAggressive."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_datastore_apd_response\" <$> TF.attribute",
                    "name": "_haDatastoreApdResponse",
                    "method": "haDatastoreApdResponse",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaDatastoreApdResponse",
                    "validate": false,
                    "optional": true,
                    "original": "ha_datastore_apd_response"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When ha_vm_component_protection is enabled, controls the delay in minutes to",
                        "wait after an APD timeout event to execute the response action defined in",
                        "ha_datastore_apd_response."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_datastore_apd_response_delay\" <$> TF.attribute",
                    "name": "_haDatastoreApdResponseDelay",
                    "method": "haDatastoreApdResponseDelay",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHaDatastoreApdResponseDelay",
                    "validate": false,
                    "optional": true,
                    "original": "ha_datastore_apd_response_delay"
                },
                {
                    "default": "TF.value \"disabled\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When ha_vm_component_protection is enabled, controls the action to take on",
                        "virtual machines when the cluster has detected a permanent device loss to a",
                        "relevant datastore. Can be one of disabled, warning, or restartAggressive."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_datastore_pdl_response\" <$> TF.attribute",
                    "name": "_haDatastorePdlResponse",
                    "method": "haDatastorePdlResponse",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaDatastorePdlResponse",
                    "validate": false,
                    "optional": true,
                    "original": "ha_datastore_pdl_response"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable vSphere HA for this cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_enabled\" <$> TF.attribute",
                    "name": "_haEnabled",
                    "method": "haEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHaEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "ha_enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The list of managed object IDs for preferred datastores to use for HA",
                        "heartbeating. This setting is only useful when ha_heartbeat_datastore_policy",
                        "is set to either userSelectedDs or allFeasibleDsWithUserPreference."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_heartbeat_datastore_ids\" <$> TF.attribute",
                    "name": "_haHeartbeatDatastoreIds",
                    "method": "haHeartbeatDatastoreIds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasHaHeartbeatDatastoreIds",
                    "validate": false,
                    "optional": true,
                    "original": "ha_heartbeat_datastore_ids"
                },
                {
                    "default": "TF.value \"allFeasibleDsWithUserPreference\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The selection policy for HA heartbeat datastores. Can be one of",
                        "allFeasibleDs, userSelectedDs, or allFeasibleDsWithUserPreference."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_heartbeat_datastore_policy\" <$> TF.attribute",
                    "name": "_haHeartbeatDatastorePolicy",
                    "method": "haHeartbeatDatastorePolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaHeartbeatDatastorePolicy",
                    "validate": false,
                    "optional": true,
                    "original": "ha_heartbeat_datastore_policy"
                },
                {
                    "default": "TF.value \"none\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The action to take on virtual machines when a host has detected that it has",
                        "been isolated from the rest of the cluster. Can be one of none, powerOff, or",
                        "shutdown."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_host_isolation_response\" <$> TF.attribute",
                    "name": "_haHostIsolationResponse",
                    "method": "haHostIsolationResponse",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaHostIsolationResponse",
                    "validate": false,
                    "optional": true,
                    "original": "ha_host_isolation_response"
                },
                {
                    "default": "TF.value \"enabled\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Global setting that controls whether vSphere HA remediates VMs on host",
                        "failure. Can be one of enabled or disabled."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_host_monitoring\" <$> TF.attribute",
                    "name": "_haHostMonitoring",
                    "method": "haHostMonitoring",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaHostMonitoring",
                    "validate": false,
                    "optional": true,
                    "original": "ha_host_monitoring"
                },
                {
                    "default": "TF.value \"enabled\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Controls vSphere VM component protection for virtual machines in this",
                        "cluster. This allows vSphere HA to react to failures between hosts and",
                        "specific virtual machine components, such as datastores. Can be one of",
                        "enabled or disabled."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_component_protection\" <$> TF.attribute",
                    "name": "_haVmComponentProtection",
                    "method": "haVmComponentProtection",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaVmComponentProtection",
                    "validate": false,
                    "optional": true,
                    "original": "ha_vm_component_protection"
                },
                {
                    "default": "TF.value \"none\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The condition used to determine whether or not VMs in a certain restart",
                        "priority class are online, allowing HA to move on to restarting VMs on the",
                        "next priority. Can be one of none, poweredOn, guestHbStatusGreen, or",
                        "appHbStatusGreen."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_dependency_restart_condition\" <$> TF.attribute",
                    "name": "_haVmDependencyRestartCondition",
                    "method": "haVmDependencyRestartCondition",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaVmDependencyRestartCondition",
                    "validate": false,
                    "optional": true,
                    "original": "ha_vm_dependency_restart_condition"
                },
                {
                    "default": "TF.value 30",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If a heartbeat from a virtual machine is not received within this configured",
                        "interval, the virtual machine is marked as failed. The value is in seconds."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_failure_interval\" <$> TF.attribute",
                    "name": "_haVmFailureInterval",
                    "method": "haVmFailureInterval",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHaVmFailureInterval",
                    "validate": false,
                    "optional": true,
                    "original": "ha_vm_failure_interval"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The length of the reset window in which ha_vm_maximum_resets can operate.",
                        "When this window expires, no more resets are attempted regardless of the",
                        "setting configured in ha_vm_maximum_resets. -1 means no window, meaning an",
                        "unlimited reset time is allotted."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_maximum_failure_window\" <$> TF.attribute",
                    "name": "_haVmMaximumFailureWindow",
                    "method": "haVmMaximumFailureWindow",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHaVmMaximumFailureWindow",
                    "validate": false,
                    "optional": true,
                    "original": "ha_vm_maximum_failure_window"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The maximum number of resets that HA will perform to a virtual machine when",
                        "responding to a failure event."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_maximum_resets\" <$> TF.attribute",
                    "name": "_haVmMaximumResets",
                    "method": "haVmMaximumResets",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHaVmMaximumResets",
                    "validate": false,
                    "optional": true,
                    "original": "ha_vm_maximum_resets"
                },
                {
                    "default": "TF.value 120",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The time, in seconds, that HA waits after powering on a virtual machine",
                        "before monitoring for heartbeats."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_minimum_uptime\" <$> TF.attribute",
                    "name": "_haVmMinimumUptime",
                    "method": "haVmMinimumUptime",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHaVmMinimumUptime",
                    "validate": false,
                    "optional": true,
                    "original": "ha_vm_minimum_uptime"
                },
                {
                    "default": "TF.value \"vmMonitoringDisabled\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The type of virtual machine monitoring to use when HA is enabled in the",
                        "cluster. Can be one of vmMonitoringDisabled, vmMonitoringOnly, or",
                        "vmAndAppMonitoring."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_monitoring\" <$> TF.attribute",
                    "name": "_haVmMonitoring",
                    "method": "haVmMonitoring",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaVmMonitoring",
                    "validate": false,
                    "optional": true,
                    "original": "ha_vm_monitoring"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Additional delay in seconds after ready condition is met. A VM is considered",
                        "ready at this point."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_restart_additional_delay\" <$> TF.attribute",
                    "name": "_haVmRestartAdditionalDelay",
                    "method": "haVmRestartAdditionalDelay",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHaVmRestartAdditionalDelay",
                    "validate": false,
                    "optional": true,
                    "original": "ha_vm_restart_additional_delay"
                },
                {
                    "default": "TF.value \"medium\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The default restart priority for affected VMs when vSphere detects a host",
                        "failure. Can be one of lowest, low, medium, high, or highest."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_restart_priority\" <$> TF.attribute",
                    "name": "_haVmRestartPriority",
                    "method": "haVmRestartPriority",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaVmRestartPriority",
                    "validate": false,
                    "optional": true,
                    "original": "ha_vm_restart_priority"
                },
                {
                    "default": "TF.value 600",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The maximum time, in seconds, that vSphere HA will wait for virtual machines",
                        "in one priority to be ready before proceeding with the next priority."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_restart_timeout\" <$> TF.attribute",
                    "name": "_haVmRestartTimeout",
                    "method": "haVmRestartTimeout",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHaVmRestartTimeout",
                    "validate": false,
                    "optional": true,
                    "original": "ha_vm_restart_timeout"
                },
                {
                    "default": "TF.value 3600",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The timeout for each host maintenance mode operation when removing hosts",
                        "from a cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_cluster_exit_timeout\" <$> TF.attribute",
                    "name": "_hostClusterExitTimeout",
                    "method": "hostClusterExitTimeout",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHostClusterExitTimeout",
                    "validate": false,
                    "optional": true,
                    "original": "host_cluster_exit_timeout"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object IDs of the hosts to put in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_system_ids\" <$> TF.attribute",
                    "name": "_hostSystemIds",
                    "method": "hostSystemIds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasHostSystemIds",
                    "validate": false,
                    "optional": true,
                    "original": "host_system_ids"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name for the new cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.value \"Manual\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The DRS behavior for proactive HA recommendations. Can be one of Automated",
                        "or Manual."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"proactive_ha_automation_level\" <$> TF.attribute",
                    "name": "_proactiveHaAutomationLevel",
                    "method": "proactiveHaAutomationLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasProactiveHaAutomationLevel",
                    "validate": false,
                    "optional": true,
                    "original": "proactive_ha_automation_level"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enables proactive HA, allowing for vSphere to get HA data from external",
                        "providers and use DRS to perform remediation."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"proactive_ha_enabled\" <$> TF.attribute",
                    "name": "_proactiveHaEnabled",
                    "method": "proactiveHaEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasProactiveHaEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "proactive_ha_enabled"
                },
                {
                    "default": "TF.value \"QuarantineMode\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The configured remediation for moderately degraded hosts. Can be one of",
                        "MaintenanceMode or QuarantineMode. Note that this cannot be set to",
                        "MaintenanceMode when proactive_ha_severe_remediation is set to",
                        "QuarantineMode."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"proactive_ha_moderate_remediation\" <$> TF.attribute",
                    "name": "_proactiveHaModerateRemediation",
                    "method": "proactiveHaModerateRemediation",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasProactiveHaModerateRemediation",
                    "validate": false,
                    "optional": true,
                    "original": "proactive_ha_moderate_remediation"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The list of IDs for health update providers configured for this cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"proactive_ha_provider_ids\" <$> TF.attribute",
                    "name": "_proactiveHaProviderIds",
                    "method": "proactiveHaProviderIds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasProactiveHaProviderIds",
                    "validate": false,
                    "optional": true,
                    "original": "proactive_ha_provider_ids"
                },
                {
                    "default": "TF.value \"QuarantineMode\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The configured remediation for severely degraded hosts. Can be one of",
                        "MaintenanceMode or QuarantineMode. Note that this cannot be set to",
                        "QuarantineMode when proactive_ha_moderate_remediation is set to",
                        "MaintenanceMode."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"proactive_ha_severe_remediation\" <$> TF.attribute",
                    "name": "_proactiveHaSevereRemediation",
                    "method": "proactiveHaSevereRemediation",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasProactiveHaSevereRemediation",
                    "validate": false,
                    "optional": true,
                    "original": "proactive_ha_severe_remediation"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of tag IDs to apply to this object."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tags\" <$> TF.attribute",
                    "name": "_tags",
                    "method": "tags",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTags",
                    "validate": false,
                    "optional": true,
                    "original": "tags"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/compute_cluster.html",
            "key": "vsphere_compute_cluster",
            "name": "ComputeClusterResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The managed object ID of the cluster's root resource pool."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_pool_id\" <$> TF.attribute",
                    "name": "_computedResourcePoolId",
                    "method": "computedResourcePoolId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedResourcePoolId",
                    "validate": false,
                    "optional": false,
                    "original": "resource_pool_id"
                }
            ],
            "parameters": [
                {
                    "default": "_datacenterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the datacenter to put the cluster in."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "_datacenterId",
                    "method": "datacenterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "validate": false,
                    "optional": false,
                    "original": "datacenter_id"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name for the new cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "ComputeClusterResource s",
            "original": "vsphere_compute_cluster"
        },
        {
            "con": {
                "smart": "computeClusterHostGroupResource",
                "name": "ComputeClusterHostGroupResource'"
            },
            "arguments": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "_computeClusterId",
                    "method": "computeClusterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "validate": false,
                    "optional": false,
                    "original": "compute_cluster_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object IDs of the hosts."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_system_ids\" <$> TF.attribute",
                    "name": "_hostSystemIds",
                    "method": "hostSystemIds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasHostSystemIds",
                    "validate": false,
                    "optional": true,
                    "original": "host_system_ids"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/compute_cluster_host_group.html",
            "key": "vsphere_compute_cluster_host_group",
            "name": "ComputeClusterHostGroupResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "_computeClusterId",
                    "method": "computeClusterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "validate": false,
                    "optional": false,
                    "original": "compute_cluster_id"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "ComputeClusterHostGroupResource s",
            "original": "vsphere_compute_cluster_host_group"
        },
        {
            "con": {
                "smart": "computeClusterVmAffinityRuleResource",
                "name": "ComputeClusterVmAffinityRuleResource'"
            },
            "arguments": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "_computeClusterId",
                    "method": "computeClusterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "validate": false,
                    "optional": false,
                    "original": "compute_cluster_id"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable this rule in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"enabled\" <$> TF.attribute",
                    "name": "_enabled",
                    "method": "enabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When true, prevents any virtual machine operations that may violate this",
                        "rule."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mandatory\" <$> TF.attribute",
                    "name": "_mandatory",
                    "method": "mandatory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasMandatory",
                    "validate": false,
                    "optional": true,
                    "original": "mandatory"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "_virtualMachineIds",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The UUIDs of the virtual machines to run on the same host together."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"virtual_machine_ids\" <$> TF.attribute",
                    "name": "_virtualMachineIds",
                    "method": "virtualMachineIds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasVirtualMachineIds",
                    "validate": false,
                    "optional": false,
                    "original": "virtual_machine_ids"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/compute_cluster_vm_affinity_rule.html",
            "key": "vsphere_compute_cluster_vm_affinity_rule",
            "name": "ComputeClusterVmAffinityRuleResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "_computeClusterId",
                    "method": "computeClusterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "validate": false,
                    "optional": false,
                    "original": "compute_cluster_id"
                },
                {
                    "default": "_virtualMachineIds",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The UUIDs of the virtual machines to run on the same host together."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"virtual_machine_ids\" <$> TF.attribute",
                    "name": "_virtualMachineIds",
                    "method": "virtualMachineIds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasVirtualMachineIds",
                    "validate": false,
                    "optional": false,
                    "original": "virtual_machine_ids"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "ComputeClusterVmAffinityRuleResource s",
            "original": "vsphere_compute_cluster_vm_affinity_rule"
        },
        {
            "con": {
                "smart": "computeClusterVmAntiAffinityRuleResource",
                "name": "ComputeClusterVmAntiAffinityRuleResource'"
            },
            "arguments": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "_computeClusterId",
                    "method": "computeClusterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "validate": false,
                    "optional": false,
                    "original": "compute_cluster_id"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable this rule in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"enabled\" <$> TF.attribute",
                    "name": "_enabled",
                    "method": "enabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When true, prevents any virtual machine operations that may violate this",
                        "rule."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mandatory\" <$> TF.attribute",
                    "name": "_mandatory",
                    "method": "mandatory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasMandatory",
                    "validate": false,
                    "optional": true,
                    "original": "mandatory"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "_virtualMachineIds",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The UUIDs of the virtual machines to run on hosts different from each other."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"virtual_machine_ids\" <$> TF.attribute",
                    "name": "_virtualMachineIds",
                    "method": "virtualMachineIds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasVirtualMachineIds",
                    "validate": false,
                    "optional": false,
                    "original": "virtual_machine_ids"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/compute_cluster_vm_anti_affinity_rule.html",
            "key": "vsphere_compute_cluster_vm_anti_affinity_rule",
            "name": "ComputeClusterVmAntiAffinityRuleResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "_computeClusterId",
                    "method": "computeClusterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "validate": false,
                    "optional": false,
                    "original": "compute_cluster_id"
                },
                {
                    "default": "_virtualMachineIds",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The UUIDs of the virtual machines to run on hosts different from each other."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"virtual_machine_ids\" <$> TF.attribute",
                    "name": "_virtualMachineIds",
                    "method": "virtualMachineIds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasVirtualMachineIds",
                    "validate": false,
                    "optional": false,
                    "original": "virtual_machine_ids"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "ComputeClusterVmAntiAffinityRuleResource s",
            "original": "vsphere_compute_cluster_vm_anti_affinity_rule"
        },
        {
            "con": {
                "smart": "computeClusterVmDependencyRuleResource",
                "name": "ComputeClusterVmDependencyRuleResource'"
            },
            "arguments": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "_computeClusterId",
                    "method": "computeClusterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "validate": false,
                    "optional": false,
                    "original": "compute_cluster_id"
                },
                {
                    "default": "_dependencyVmGroupName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the VM group that this rule depends on. The VMs defined in the",
                        "group specified by vm_group_name will not be started until the VMs in this",
                        "group are started."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dependency_vm_group_name\" <$> TF.attribute",
                    "name": "_dependencyVmGroupName",
                    "method": "dependencyVmGroupName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDependencyVmGroupName",
                    "validate": false,
                    "optional": false,
                    "original": "dependency_vm_group_name"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable this rule in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"enabled\" <$> TF.attribute",
                    "name": "_enabled",
                    "method": "enabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When true, prevents any virtual machine operations that may violate this",
                        "rule."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mandatory\" <$> TF.attribute",
                    "name": "_mandatory",
                    "method": "mandatory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasMandatory",
                    "validate": false,
                    "optional": true,
                    "original": "mandatory"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "_vmGroupName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the VM group that is the subject of this rule. The VMs defined",
                        "in this group will not be started until the VMs in the group specified by",
                        "dependency_vm_group_name are started."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vm_group_name\" <$> TF.attribute",
                    "name": "_vmGroupName",
                    "method": "vmGroupName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVmGroupName",
                    "validate": false,
                    "optional": false,
                    "original": "vm_group_name"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/compute_cluster_vm_dependency_rule.html",
            "key": "vsphere_compute_cluster_vm_dependency_rule",
            "name": "ComputeClusterVmDependencyRuleResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "_computeClusterId",
                    "method": "computeClusterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "validate": false,
                    "optional": false,
                    "original": "compute_cluster_id"
                },
                {
                    "default": "_dependencyVmGroupName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the VM group that this rule depends on. The VMs defined in the",
                        "group specified by vm_group_name will not be started until the VMs in this",
                        "group are started."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dependency_vm_group_name\" <$> TF.attribute",
                    "name": "_dependencyVmGroupName",
                    "method": "dependencyVmGroupName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDependencyVmGroupName",
                    "validate": false,
                    "optional": false,
                    "original": "dependency_vm_group_name"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "_vmGroupName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the VM group that is the subject of this rule. The VMs defined",
                        "in this group will not be started until the VMs in the group specified by",
                        "dependency_vm_group_name are started."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vm_group_name\" <$> TF.attribute",
                    "name": "_vmGroupName",
                    "method": "vmGroupName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVmGroupName",
                    "validate": false,
                    "optional": false,
                    "original": "vm_group_name"
                }
            ],
            "conflicts": [],
            "type": "ComputeClusterVmDependencyRuleResource s",
            "original": "vsphere_compute_cluster_vm_dependency_rule"
        },
        {
            "con": {
                "smart": "computeClusterVmGroupResource",
                "name": "ComputeClusterVmGroupResource'"
            },
            "arguments": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "_computeClusterId",
                    "method": "computeClusterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "validate": false,
                    "optional": false,
                    "original": "compute_cluster_id"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The UUIDs of the virtual machines in this group."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"virtual_machine_ids\" <$> TF.attribute",
                    "name": "_virtualMachineIds",
                    "method": "virtualMachineIds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasVirtualMachineIds",
                    "validate": false,
                    "optional": true,
                    "original": "virtual_machine_ids"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/compute_cluster_vm_group.html",
            "key": "vsphere_compute_cluster_vm_group",
            "name": "ComputeClusterVmGroupResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "_computeClusterId",
                    "method": "computeClusterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "validate": false,
                    "optional": false,
                    "original": "compute_cluster_id"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "ComputeClusterVmGroupResource s",
            "original": "vsphere_compute_cluster_vm_group"
        },
        {
            "con": {
                "smart": "computeClusterVmHostRuleResource",
                "name": "ComputeClusterVmHostRuleResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When this field is used, virtual machines defined in vm_group_name will be",
                        "run on the hosts defined in this host group."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"affinity_host_group_name\" <$> TF.attribute",
                    "name": "_affinityHostGroupName",
                    "method": "affinityHostGroupName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_antiAffinityHostGroupName",
                            "method": "antiAffinityHostGroupName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasAffinityHostGroupName",
                    "validate": false,
                    "optional": true,
                    "original": "affinity_host_group_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When this field is used, virtual machines defined in vm_group_name will not",
                        "be run on the hosts defined in this host group."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"anti_affinity_host_group_name\" <$> TF.attribute",
                    "name": "_antiAffinityHostGroupName",
                    "method": "antiAffinityHostGroupName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_affinityHostGroupName",
                            "method": "affinityHostGroupName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasAntiAffinityHostGroupName",
                    "validate": false,
                    "optional": true,
                    "original": "anti_affinity_host_group_name"
                },
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "_computeClusterId",
                    "method": "computeClusterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "validate": false,
                    "optional": false,
                    "original": "compute_cluster_id"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable this rule in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"enabled\" <$> TF.attribute",
                    "name": "_enabled",
                    "method": "enabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When true, prevents any virtual machine operations that may violate this",
                        "rule."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mandatory\" <$> TF.attribute",
                    "name": "_mandatory",
                    "method": "mandatory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasMandatory",
                    "validate": false,
                    "optional": true,
                    "original": "mandatory"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "_vmGroupName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the virtual machine group to use with this rule."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vm_group_name\" <$> TF.attribute",
                    "name": "_vmGroupName",
                    "method": "vmGroupName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVmGroupName",
                    "validate": false,
                    "optional": false,
                    "original": "vm_group_name"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/compute_cluster_vm_host_rule.html",
            "key": "vsphere_compute_cluster_vm_host_rule",
            "name": "ComputeClusterVmHostRuleResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "_computeClusterId",
                    "method": "computeClusterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "validate": false,
                    "optional": false,
                    "original": "compute_cluster_id"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "_vmGroupName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the virtual machine group to use with this rule."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vm_group_name\" <$> TF.attribute",
                    "name": "_vmGroupName",
                    "method": "vmGroupName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVmGroupName",
                    "validate": false,
                    "optional": false,
                    "original": "vm_group_name"
                }
            ],
            "conflicts": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When this field is used, virtual machines defined in vm_group_name will be",
                        "run on the hosts defined in this host group."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"affinity_host_group_name\" <$> TF.attribute",
                    "name": "_affinityHostGroupName",
                    "method": "affinityHostGroupName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_antiAffinityHostGroupName",
                            "method": "antiAffinityHostGroupName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasAffinityHostGroupName",
                    "validate": false,
                    "optional": true,
                    "original": "affinity_host_group_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When this field is used, virtual machines defined in vm_group_name will not",
                        "be run on the hosts defined in this host group."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"anti_affinity_host_group_name\" <$> TF.attribute",
                    "name": "_antiAffinityHostGroupName",
                    "method": "antiAffinityHostGroupName",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_affinityHostGroupName",
                            "method": "affinityHostGroupName"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasAntiAffinityHostGroupName",
                    "validate": false,
                    "optional": true,
                    "original": "anti_affinity_host_group_name"
                }
            ],
            "type": "ComputeClusterVmHostRuleResource s",
            "original": "vsphere_compute_cluster_vm_host_rule"
        },
        {
            "con": {
                "smart": "customAttributeResource",
                "name": "CustomAttributeResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Object type for which the custom attribute is valid. If not specified, the",
                        "attribute is valid for all managed object types."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"managed_object_type\" <$> TF.attribute",
                    "name": "_managedObjectType",
                    "method": "managedObjectType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasManagedObjectType",
                    "validate": false,
                    "optional": true,
                    "original": "managed_object_type"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the custom attribute."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/custom_attribute.html",
            "key": "vsphere_custom_attribute",
            "name": "CustomAttributeResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the custom attribute."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "CustomAttributeResource s",
            "original": "vsphere_custom_attribute"
        },
        {
            "con": {
                "smart": "datacenterResource",
                "name": "DatacenterResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of custom attributes to set on this resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"custom_attributes\" <$> TF.attribute",
                    "name": "_customAttributes",
                    "method": "customAttributes",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasCustomAttributes",
                    "validate": false,
                    "optional": true,
                    "original": "custom_attributes"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"folder\" <$> TF.attribute",
                    "name": "_folder",
                    "method": "folder",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFolder",
                    "validate": false,
                    "optional": true,
                    "original": "folder"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of tag IDs to apply to this object."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tags\" <$> TF.attribute",
                    "name": "_tags",
                    "method": "tags",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTags",
                    "validate": false,
                    "optional": true,
                    "original": "tags"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/datacenter.html",
            "key": "vsphere_datacenter",
            "name": "DatacenterResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Managed object ID of the datacenter."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"moid\" <$> TF.attribute",
                    "name": "_computedMoid",
                    "method": "computedMoid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMoid",
                    "validate": false,
                    "optional": false,
                    "original": "moid"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "DatacenterResource s",
            "original": "vsphere_datacenter"
        },
        {
            "con": {
                "smart": "datastoreClusterResource",
                "name": "DatastoreClusterResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of custom attributes to set on this resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"custom_attributes\" <$> TF.attribute",
                    "name": "_customAttributes",
                    "method": "customAttributes",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasCustomAttributes",
                    "validate": false,
                    "optional": true,
                    "original": "custom_attributes"
                },
                {
                    "default": "_datacenterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the datacenter to put the datastore cluster in."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "_datacenterId",
                    "method": "datacenterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "validate": false,
                    "optional": false,
                    "original": "datacenter_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The name of the folder to locate the datastore cluster in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"folder\" <$> TF.attribute",
                    "name": "_folder",
                    "method": "folder",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFolder",
                    "validate": false,
                    "optional": true,
                    "original": "folder"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name for the new storage pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Advanced configuration options for storage DRS."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_advanced_options\" <$> TF.attribute",
                    "name": "_sdrsAdvancedOptions",
                    "method": "sdrsAdvancedOptions",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasSdrsAdvancedOptions",
                    "validate": false,
                    "optional": true,
                    "original": "sdrs_advanced_options"
                },
                {
                    "default": "TF.value \"manual\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The default automation level for all virtual machines in this storage",
                        "cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_automation_level\" <$> TF.attribute",
                    "name": "_sdrsAutomationLevel",
                    "method": "sdrsAutomationLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSdrsAutomationLevel",
                    "validate": false,
                    "optional": true,
                    "original": "sdrs_automation_level"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When true, storage DRS keeps VMDKs for individual VMs on the same datastore",
                        "by default."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_default_intra_vm_affinity\" <$> TF.attribute",
                    "name": "_sdrsDefaultIntraVmAffinity",
                    "method": "sdrsDefaultIntraVmAffinity",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasSdrsDefaultIntraVmAffinity",
                    "validate": false,
                    "optional": true,
                    "original": "sdrs_default_intra_vm_affinity"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable storage DRS for this datastore cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_enabled\" <$> TF.attribute",
                    "name": "_sdrsEnabled",
                    "method": "sdrsEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasSdrsEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "sdrs_enabled"
                },
                {
                    "default": "TF.value 50",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The threshold, in GB, that storage DRS uses to make decisions to migrate VMs",
                        "out of a datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_free_space_threshold\" <$> TF.attribute",
                    "name": "_sdrsFreeSpaceThreshold",
                    "method": "sdrsFreeSpaceThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasSdrsFreeSpaceThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "sdrs_free_space_threshold"
                },
                {
                    "default": "TF.value \"utilization\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The free space threshold to use. When set to utilization,",
                        "drs_space_utilization_threshold is used, and when set to freeSpace,",
                        "drs_free_space_threshold is used."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_free_space_threshold_mode\" <$> TF.attribute",
                    "name": "_sdrsFreeSpaceThresholdMode",
                    "method": "sdrsFreeSpaceThresholdMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSdrsFreeSpaceThresholdMode",
                    "validate": false,
                    "optional": true,
                    "original": "sdrs_free_space_threshold_mode"
                },
                {
                    "default": "TF.value 5",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The threshold, in percent, of difference between space utilization in",
                        "datastores before storage DRS makes decisions to balance the space."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_free_space_utilization_difference\" <$> TF.attribute",
                    "name": "_sdrsFreeSpaceUtilizationDifference",
                    "method": "sdrsFreeSpaceUtilizationDifference",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasSdrsFreeSpaceUtilizationDifference",
                    "validate": false,
                    "optional": true,
                    "original": "sdrs_free_space_utilization_difference"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Overrides the default automation settings when correcting I/O load",
                        "imbalances."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_io_balance_automation_level\" <$> TF.attribute",
                    "name": "_sdrsIoBalanceAutomationLevel",
                    "method": "sdrsIoBalanceAutomationLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSdrsIoBalanceAutomationLevel",
                    "validate": false,
                    "optional": true,
                    "original": "sdrs_io_balance_automation_level"
                },
                {
                    "default": "TF.value 15",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The I/O latency threshold, in milliseconds, that storage DRS uses to make",
                        "recommendations to move disks from this datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_io_latency_threshold\" <$> TF.attribute",
                    "name": "_sdrsIoLatencyThreshold",
                    "method": "sdrsIoLatencyThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasSdrsIoLatencyThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "sdrs_io_latency_threshold"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable I/O load balancing for this datastore cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_io_load_balance_enabled\" <$> TF.attribute",
                    "name": "_sdrsIoLoadBalanceEnabled",
                    "method": "sdrsIoLoadBalanceEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasSdrsIoLoadBalanceEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "sdrs_io_load_balance_enabled"
                },
                {
                    "default": "TF.value 5",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The difference between load in datastores in the cluster before storage DRS",
                        "makes recommendations to balance the load."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_io_load_imbalance_threshold\" <$> TF.attribute",
                    "name": "_sdrsIoLoadImbalanceThreshold",
                    "method": "sdrsIoLoadImbalanceThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasSdrsIoLoadImbalanceThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "sdrs_io_load_imbalance_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The threshold of reservable IOPS of all virtual machines on the datastore",
                        "before storage DRS makes recommendations to move VMs off of a datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_io_reservable_iops_threshold\" <$> TF.attribute",
                    "name": "_sdrsIoReservableIopsThreshold",
                    "method": "sdrsIoReservableIopsThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasSdrsIoReservableIopsThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "sdrs_io_reservable_iops_threshold"
                },
                {
                    "default": "TF.value 60",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The threshold, in percent, of actual estimated performance of the datastore",
                        "(in IOPS) that storage DRS uses to make recommendations to move VMs off of a",
                        "datastore when the total reservable IOPS exceeds the threshold."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_io_reservable_percent_threshold\" <$> TF.attribute",
                    "name": "_sdrsIoReservablePercentThreshold",
                    "method": "sdrsIoReservablePercentThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasSdrsIoReservablePercentThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "sdrs_io_reservable_percent_threshold"
                },
                {
                    "default": "TF.value \"automated\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The reservable IOPS threshold to use, percent in the event of automatic, or",
                        "manual threshold in the event of manual."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_io_reservable_threshold_mode\" <$> TF.attribute",
                    "name": "_sdrsIoReservableThresholdMode",
                    "method": "sdrsIoReservableThresholdMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSdrsIoReservableThresholdMode",
                    "validate": false,
                    "optional": true,
                    "original": "sdrs_io_reservable_threshold_mode"
                },
                {
                    "default": "TF.value 480",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The storage DRS poll interval, in minutes."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_load_balance_interval\" <$> TF.attribute",
                    "name": "_sdrsLoadBalanceInterval",
                    "method": "sdrsLoadBalanceInterval",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasSdrsLoadBalanceInterval",
                    "validate": false,
                    "optional": true,
                    "original": "sdrs_load_balance_interval"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Overrides the default automation settings when correcting storage and VM",
                        "policy violations."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_policy_enforcement_automation_level\" <$> TF.attribute",
                    "name": "_sdrsPolicyEnforcementAutomationLevel",
                    "method": "sdrsPolicyEnforcementAutomationLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSdrsPolicyEnforcementAutomationLevel",
                    "validate": false,
                    "optional": true,
                    "original": "sdrs_policy_enforcement_automation_level"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Overrides the default automation settings when correcting affinity rule",
                        "violations."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_rule_enforcement_automation_level\" <$> TF.attribute",
                    "name": "_sdrsRuleEnforcementAutomationLevel",
                    "method": "sdrsRuleEnforcementAutomationLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSdrsRuleEnforcementAutomationLevel",
                    "validate": false,
                    "optional": true,
                    "original": "sdrs_rule_enforcement_automation_level"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Overrides the default automation settings when correcting disk space",
                        "imbalances."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_space_balance_automation_level\" <$> TF.attribute",
                    "name": "_sdrsSpaceBalanceAutomationLevel",
                    "method": "sdrsSpaceBalanceAutomationLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSdrsSpaceBalanceAutomationLevel",
                    "validate": false,
                    "optional": true,
                    "original": "sdrs_space_balance_automation_level"
                },
                {
                    "default": "TF.value 80",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The threshold, in percent of used space, that storage DRS uses to make",
                        "decisions to migrate VMs out of a datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_space_utilization_threshold\" <$> TF.attribute",
                    "name": "_sdrsSpaceUtilizationThreshold",
                    "method": "sdrsSpaceUtilizationThreshold",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasSdrsSpaceUtilizationThreshold",
                    "validate": false,
                    "optional": true,
                    "original": "sdrs_space_utilization_threshold"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Overrides the default automation settings when generating recommendations",
                        "for datastore evacuation."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_vm_evacuation_automation_level\" <$> TF.attribute",
                    "name": "_sdrsVmEvacuationAutomationLevel",
                    "method": "sdrsVmEvacuationAutomationLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSdrsVmEvacuationAutomationLevel",
                    "validate": false,
                    "optional": true,
                    "original": "sdrs_vm_evacuation_automation_level"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of tag IDs to apply to this object."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tags\" <$> TF.attribute",
                    "name": "_tags",
                    "method": "tags",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTags",
                    "validate": false,
                    "optional": true,
                    "original": "tags"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/datastore_cluster.html",
            "key": "vsphere_datastore_cluster",
            "name": "DatastoreClusterResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_datacenterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the datacenter to put the datastore cluster in."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "_datacenterId",
                    "method": "datacenterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "validate": false,
                    "optional": false,
                    "original": "datacenter_id"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name for the new storage pod."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "DatastoreClusterResource s",
            "original": "vsphere_datastore_cluster"
        },
        {
            "con": {
                "smart": "datastoreClusterVmAntiAffinityRuleResource",
                "name": "DatastoreClusterVmAntiAffinityRuleResource'"
            },
            "arguments": [
                {
                    "default": "_datastoreClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the datastore cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"datastore_cluster_id\" <$> TF.attribute",
                    "name": "_datastoreClusterId",
                    "method": "datastoreClusterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastoreClusterId",
                    "validate": false,
                    "optional": false,
                    "original": "datastore_cluster_id"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable this rule in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"enabled\" <$> TF.attribute",
                    "name": "_enabled",
                    "method": "enabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When true, prevents any virtual machine operations that may violate this",
                        "rule."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mandatory\" <$> TF.attribute",
                    "name": "_mandatory",
                    "method": "mandatory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasMandatory",
                    "validate": false,
                    "optional": true,
                    "original": "mandatory"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "_virtualMachineIds",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The UUIDs of the virtual machines to run on different datastores from each",
                        "other."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"virtual_machine_ids\" <$> TF.attribute",
                    "name": "_virtualMachineIds",
                    "method": "virtualMachineIds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasVirtualMachineIds",
                    "validate": false,
                    "optional": false,
                    "original": "virtual_machine_ids"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/datastore_cluster_vm_anti_affinity_rule.html",
            "key": "vsphere_datastore_cluster_vm_anti_affinity_rule",
            "name": "DatastoreClusterVmAntiAffinityRuleResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_datastoreClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the datastore cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"datastore_cluster_id\" <$> TF.attribute",
                    "name": "_datastoreClusterId",
                    "method": "datastoreClusterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastoreClusterId",
                    "validate": false,
                    "optional": false,
                    "original": "datastore_cluster_id"
                },
                {
                    "default": "_virtualMachineIds",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The UUIDs of the virtual machines to run on different datastores from each",
                        "other."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"virtual_machine_ids\" <$> TF.attribute",
                    "name": "_virtualMachineIds",
                    "method": "virtualMachineIds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasVirtualMachineIds",
                    "validate": false,
                    "optional": false,
                    "original": "virtual_machine_ids"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique name of the virtual machine group in the cluster."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "DatastoreClusterVmAntiAffinityRuleResource s",
            "original": "vsphere_datastore_cluster_vm_anti_affinity_rule"
        },
        {
            "con": {
                "smart": "distributedPortGroupResource",
                "name": "DistributedPortGroupResource'"
            },
            "arguments": [
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Auto-expands the port group beyond the port count configured in",
                        "number_of_ports when necessary."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"auto_expand\" <$> TF.attribute",
                    "name": "_autoExpand",
                    "method": "autoExpand",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasAutoExpand",
                    "validate": false,
                    "optional": true,
                    "original": "auto_expand"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow the blocked setting of an individual port to override the setting in",
                        "the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"block_override_allowed\" <$> TF.attribute",
                    "name": "_blockOverrideAllowed",
                    "method": "blockOverrideAllowed",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasBlockOverrideAllowed",
                    "validate": false,
                    "optional": true,
                    "original": "block_override_allowed"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of custom attributes to set on this resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"custom_attributes\" <$> TF.attribute",
                    "name": "_customAttributes",
                    "method": "customAttributes",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasCustomAttributes",
                    "validate": false,
                    "optional": true,
                    "original": "custom_attributes"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The description of the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"description\" <$> TF.attribute",
                    "name": "_description",
                    "method": "description",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDescription",
                    "validate": false,
                    "optional": true,
                    "original": "description"
                },
                {
                    "default": "_distributedVirtualSwitchUuid",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The UUID of the DVS to attach this port group to."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"distributed_virtual_switch_uuid\" <$> TF.attribute",
                    "name": "_distributedVirtualSwitchUuid",
                    "method": "distributedVirtualSwitchUuid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDistributedVirtualSwitchUuid",
                    "validate": false,
                    "optional": false,
                    "original": "distributed_virtual_switch_uuid"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow a live port to be moved in and out of the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"live_port_moving_allowed\" <$> TF.attribute",
                    "name": "_livePortMovingAllowed",
                    "method": "livePortMovingAllowed",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasLivePortMovingAllowed",
                    "validate": false,
                    "optional": true,
                    "original": "live_port_moving_allowed"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow the enabling or disabling of Netflow on a port, contrary to the policy",
                        "in the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"netflow_override_allowed\" <$> TF.attribute",
                    "name": "_netflowOverrideAllowed",
                    "method": "netflowOverrideAllowed",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasNetflowOverrideAllowed",
                    "validate": false,
                    "optional": true,
                    "original": "netflow_override_allowed"
                },
                {
                    "default": "TF.value \"-1\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The key of a network resource pool to associate with this portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_resource_pool_key\" <$> TF.attribute",
                    "name": "_networkResourcePoolKey",
                    "method": "networkResourcePoolKey",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNetworkResourcePoolKey",
                    "validate": false,
                    "optional": true,
                    "original": "network_resource_pool_key"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow the network resource pool of an individual port to override the",
                        "setting in the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_resource_pool_override_allowed\" <$> TF.attribute",
                    "name": "_networkResourcePoolOverrideAllowed",
                    "method": "networkResourcePoolOverrideAllowed",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasNetworkResourcePoolOverrideAllowed",
                    "validate": false,
                    "optional": true,
                    "original": "network_resource_pool_override_allowed"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Reset the setting of any ports in this portgroup back to the default setting",
                        "when the port disconnects."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port_config_reset_at_disconnect\" <$> TF.attribute",
                    "name": "_portConfigResetAtDisconnect",
                    "method": "portConfigResetAtDisconnect",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasPortConfigResetAtDisconnect",
                    "validate": false,
                    "optional": true,
                    "original": "port_config_reset_at_disconnect"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A template string to use when creating ports in the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port_name_format\" <$> TF.attribute",
                    "name": "_portNameFormat",
                    "method": "portNameFormat",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPortNameFormat",
                    "validate": false,
                    "optional": true,
                    "original": "port_name_format"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow security policy settings on a port to override those on the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"security_policy_override_allowed\" <$> TF.attribute",
                    "name": "_securityPolicyOverrideAllowed",
                    "method": "securityPolicyOverrideAllowed",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasSecurityPolicyOverrideAllowed",
                    "validate": false,
                    "optional": true,
                    "original": "security_policy_override_allowed"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow the traffic shaping policies of an individual port to override the",
                        "settings in the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"shaping_override_allowed\" <$> TF.attribute",
                    "name": "_shapingOverrideAllowed",
                    "method": "shapingOverrideAllowed",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasShapingOverrideAllowed",
                    "validate": false,
                    "optional": true,
                    "original": "shaping_override_allowed"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of tag IDs to apply to this object."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tags\" <$> TF.attribute",
                    "name": "_tags",
                    "method": "tags",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTags",
                    "validate": false,
                    "optional": true,
                    "original": "tags"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow any filter policies set on the individual port to override those in",
                        "the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"traffic_filter_override_allowed\" <$> TF.attribute",
                    "name": "_trafficFilterOverrideAllowed",
                    "method": "trafficFilterOverrideAllowed",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasTrafficFilterOverrideAllowed",
                    "validate": false,
                    "optional": true,
                    "original": "traffic_filter_override_allowed"
                },
                {
                    "default": "TF.value \"earlyBinding\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The type of portgroup. Can be one of earlyBinding (static) or ephemeral."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": true,
                    "original": "type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow the uplink teaming policies on a port to override those on the",
                        "portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uplink_teaming_override_allowed\" <$> TF.attribute",
                    "name": "_uplinkTeamingOverrideAllowed",
                    "method": "uplinkTeamingOverrideAllowed",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasUplinkTeamingOverrideAllowed",
                    "validate": false,
                    "optional": true,
                    "original": "uplink_teaming_override_allowed"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow the VLAN configuration on a port to override those on the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vlan_override_allowed\" <$> TF.attribute",
                    "name": "_vlanOverrideAllowed",
                    "method": "vlanOverrideAllowed",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasVlanOverrideAllowed",
                    "validate": false,
                    "optional": true,
                    "original": "vlan_override_allowed"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/distributed_port_group.html",
            "key": "vsphere_distributed_port_group",
            "name": "DistributedPortGroupResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "List of active uplinks used for load balancing, matching the names of the",
                        "uplinks assigned in the DVS."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"active_uplinks\" <$> TF.attribute",
                    "name": "_computedActiveUplinks",
                    "method": "computedActiveUplinks",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedActiveUplinks",
                    "validate": false,
                    "optional": true,
                    "original": "active_uplinks"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Controls whether or not the virtual network adapter is allowed to send",
                        "network traffic with a different MAC address than that of its own."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_forged_transmits\" <$> TF.attribute",
                    "name": "_computedAllowForgedTransmits",
                    "method": "computedAllowForgedTransmits",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedAllowForgedTransmits",
                    "validate": false,
                    "optional": true,
                    "original": "allow_forged_transmits"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Controls whether or not the Media Access Control (MAC) address can be",
                        "changed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_mac_changes\" <$> TF.attribute",
                    "name": "_computedAllowMacChanges",
                    "method": "computedAllowMacChanges",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedAllowMacChanges",
                    "validate": false,
                    "optional": true,
                    "original": "allow_mac_changes"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Enable promiscuous mode on the network. This flag indicates whether or not",
                        "all traffic is seen on a given port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_promiscuous\" <$> TF.attribute",
                    "name": "_computedAllowPromiscuous",
                    "method": "computedAllowPromiscuous",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedAllowPromiscuous",
                    "validate": false,
                    "optional": true,
                    "original": "allow_promiscuous"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Indicates whether to block all ports by default."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"block_all_ports\" <$> TF.attribute",
                    "name": "_computedBlockAllPorts",
                    "method": "computedBlockAllPorts",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedBlockAllPorts",
                    "validate": false,
                    "optional": true,
                    "original": "block_all_ports"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Enable beacon probing on the ports this policy applies to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"check_beacon\" <$> TF.attribute",
                    "name": "_computedCheckBeacon",
                    "method": "computedCheckBeacon",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedCheckBeacon",
                    "validate": false,
                    "optional": true,
                    "original": "check_beacon"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Version string of the configuration that this spec is trying to change."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"config_version\" <$> TF.attribute",
                    "name": "_computedConfigVersion",
                    "method": "computedConfigVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedConfigVersion",
                    "validate": false,
                    "optional": false,
                    "original": "config_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Allow VMDirectPath Gen2 on the ports this policy applies to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"directpath_gen2_allowed\" <$> TF.attribute",
                    "name": "_computedDirectpathGen2Allowed",
                    "method": "computedDirectpathGen2Allowed",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedDirectpathGen2Allowed",
                    "validate": false,
                    "optional": true,
                    "original": "directpath_gen2_allowed"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The average egress bandwidth in bits per second if egress shaping is enabled",
                        "on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"egress_shaping_average_bandwidth\" <$> TF.attribute",
                    "name": "_computedEgressShapingAverageBandwidth",
                    "method": "computedEgressShapingAverageBandwidth",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedEgressShapingAverageBandwidth",
                    "validate": false,
                    "optional": true,
                    "original": "egress_shaping_average_bandwidth"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum egress burst size allowed in bytes if egress shaping is enabled",
                        "on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"egress_shaping_burst_size\" <$> TF.attribute",
                    "name": "_computedEgressShapingBurstSize",
                    "method": "computedEgressShapingBurstSize",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedEgressShapingBurstSize",
                    "validate": false,
                    "optional": true,
                    "original": "egress_shaping_burst_size"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "True if the traffic shaper is enabled for egress traffic on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"egress_shaping_enabled\" <$> TF.attribute",
                    "name": "_computedEgressShapingEnabled",
                    "method": "computedEgressShapingEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedEgressShapingEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "egress_shaping_enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The peak egress bandwidth during bursts in bits per second if egress traffic",
                        "shaping is enabled on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"egress_shaping_peak_bandwidth\" <$> TF.attribute",
                    "name": "_computedEgressShapingPeakBandwidth",
                    "method": "computedEgressShapingPeakBandwidth",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedEgressShapingPeakBandwidth",
                    "validate": false,
                    "optional": true,
                    "original": "egress_shaping_peak_bandwidth"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "If true, the teaming policy will re-activate failed interfaces higher in",
                        "precedence when they come back up."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failback\" <$> TF.attribute",
                    "name": "_computedFailback",
                    "method": "computedFailback",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedFailback",
                    "validate": false,
                    "optional": true,
                    "original": "failback"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The average ingress bandwidth in bits per second if ingress shaping is",
                        "enabled on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ingress_shaping_average_bandwidth\" <$> TF.attribute",
                    "name": "_computedIngressShapingAverageBandwidth",
                    "method": "computedIngressShapingAverageBandwidth",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedIngressShapingAverageBandwidth",
                    "validate": false,
                    "optional": true,
                    "original": "ingress_shaping_average_bandwidth"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum ingress burst size allowed in bytes if ingress shaping is",
                        "enabled on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ingress_shaping_burst_size\" <$> TF.attribute",
                    "name": "_computedIngressShapingBurstSize",
                    "method": "computedIngressShapingBurstSize",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedIngressShapingBurstSize",
                    "validate": false,
                    "optional": true,
                    "original": "ingress_shaping_burst_size"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "True if the traffic shaper is enabled for ingress traffic on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ingress_shaping_enabled\" <$> TF.attribute",
                    "name": "_computedIngressShapingEnabled",
                    "method": "computedIngressShapingEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedIngressShapingEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "ingress_shaping_enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The peak ingress bandwidth during bursts in bits per second if ingress",
                        "traffic shaping is enabled on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ingress_shaping_peak_bandwidth\" <$> TF.attribute",
                    "name": "_computedIngressShapingPeakBandwidth",
                    "method": "computedIngressShapingPeakBandwidth",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedIngressShapingPeakBandwidth",
                    "validate": false,
                    "optional": true,
                    "original": "ingress_shaping_peak_bandwidth"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The generated UUID of the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_computedKey",
                    "method": "computedKey",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedKey",
                    "validate": false,
                    "optional": false,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Whether or not to enable LACP on all uplink ports."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lacp_enabled\" <$> TF.attribute",
                    "name": "_computedLacpEnabled",
                    "method": "computedLacpEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedLacpEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "lacp_enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The uplink LACP mode to use. Can be one of active or passive."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lacp_mode\" <$> TF.attribute",
                    "name": "_computedLacpMode",
                    "method": "computedLacpMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedLacpMode",
                    "validate": false,
                    "optional": true,
                    "original": "lacp_mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Indicates whether to enable netflow on all ports."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"netflow_enabled\" <$> TF.attribute",
                    "name": "_computedNetflowEnabled",
                    "method": "computedNetflowEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedNetflowEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "netflow_enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "If true, the teaming policy will notify the broadcast network of a NIC",
                        "failover, triggering cache updates."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"notify_switches\" <$> TF.attribute",
                    "name": "_computedNotifySwitches",
                    "method": "computedNotifySwitches",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedNotifySwitches",
                    "validate": false,
                    "optional": true,
                    "original": "notify_switches"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The number of ports in this portgroup. The DVS will expand and shrink by",
                        "modifying this setting."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"number_of_ports\" <$> TF.attribute",
                    "name": "_computedNumberOfPorts",
                    "method": "computedNumberOfPorts",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedNumberOfPorts",
                    "validate": false,
                    "optional": true,
                    "original": "number_of_ports"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The secondary VLAN ID for this port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port_private_secondary_vlan_id\" <$> TF.attribute",
                    "name": "_computedPortPrivateSecondaryVlanId",
                    "method": "computedPortPrivateSecondaryVlanId",
                    "threaded": true,
                    "conflicts": [
                        "_vlanId",
                        "_vlanRange"
                    ],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedPortPrivateSecondaryVlanId",
                    "validate": false,
                    "optional": true,
                    "original": "port_private_secondary_vlan_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "List of active uplinks used for load balancing, matching the names of the",
                        "uplinks assigned in the DVS."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"standby_uplinks\" <$> TF.attribute",
                    "name": "_computedStandbyUplinks",
                    "method": "computedStandbyUplinks",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedStandbyUplinks",
                    "validate": false,
                    "optional": true,
                    "original": "standby_uplinks"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The network adapter teaming policy. Can be one of loadbalance_ip,",
                        "loadbalance_srcmac, loadbalance_srcid, failover_explicit, or",
                        "loadbalance_loadbased."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"teaming_policy\" <$> TF.attribute",
                    "name": "_computedTeamingPolicy",
                    "method": "computedTeamingPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedTeamingPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "teaming_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "If true, a copy of packets sent to the switch will always be forwarded to an",
                        "uplink in addition to the regular packet forwarded done by the switch."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tx_uplink\" <$> TF.attribute",
                    "name": "_computedTxUplink",
                    "method": "computedTxUplink",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedTxUplink",
                    "validate": false,
                    "optional": true,
                    "original": "tx_uplink"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The VLAN ID for single VLAN mode. 0 denotes no VLAN."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vlan_id\" <$> TF.attribute",
                    "name": "_computedVlanId",
                    "method": "computedVlanId",
                    "threaded": true,
                    "conflicts": [
                        "_portPrivateSecondaryVlanId",
                        "_vlanRange"
                    ],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedVlanId",
                    "validate": false,
                    "optional": true,
                    "original": "vlan_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The VLAN ID for single VLAN mode. 0 denotes no VLAN."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vlan_range\" <$> TF.attribute",
                    "name": "_computedVlanRange",
                    "method": "computedVlanRange",
                    "threaded": true,
                    "conflicts": [
                        "_portPrivateSecondaryVlanId",
                        "_vlanId"
                    ],
                    "type": "TF.Attr s [TF.Attr s (VlanRangeSetting s)]",
                    "class": "HasComputedVlanRange",
                    "validate": false,
                    "optional": true,
                    "original": "vlan_range"
                }
            ],
            "parameters": [
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the portgroup."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "_distributedVirtualSwitchUuid",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The UUID of the DVS to attach this port group to."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"distributed_virtual_switch_uuid\" <$> TF.attribute",
                    "name": "_distributedVirtualSwitchUuid",
                    "method": "distributedVirtualSwitchUuid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDistributedVirtualSwitchUuid",
                    "validate": false,
                    "optional": false,
                    "original": "distributed_virtual_switch_uuid"
                }
            ],
            "conflicts": [],
            "type": "DistributedPortGroupResource s",
            "original": "vsphere_distributed_port_group"
        },
        {
            "con": {
                "smart": "distributedVirtualSwitchResource",
                "name": "DistributedVirtualSwitchResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The contact detail for this DVS."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"contact_detail\" <$> TF.attribute",
                    "name": "_contactDetail",
                    "method": "contactDetail",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasContactDetail",
                    "validate": false,
                    "optional": true,
                    "original": "contact_detail"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The contact name for this DVS."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"contact_name\" <$> TF.attribute",
                    "name": "_contactName",
                    "method": "contactName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasContactName",
                    "validate": false,
                    "optional": true,
                    "original": "contact_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of custom attributes to set on this resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"custom_attributes\" <$> TF.attribute",
                    "name": "_customAttributes",
                    "method": "customAttributes",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasCustomAttributes",
                    "validate": false,
                    "optional": true,
                    "original": "custom_attributes"
                },
                {
                    "default": "_datacenterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The ID of the datacenter to create this virtual switch in."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "_datacenterId",
                    "method": "datacenterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "validate": false,
                    "optional": false,
                    "original": "datacenter_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The description of the DVS."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"description\" <$> TF.attribute",
                    "name": "_description",
                    "method": "description",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDescription",
                    "validate": false,
                    "optional": true,
                    "original": "description"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The folder to create this virtual switch in, relative to the datacenter."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"folder\" <$> TF.attribute",
                    "name": "_folder",
                    "method": "folder",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFolder",
                    "validate": false,
                    "optional": true,
                    "original": "folder"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A host member specification."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host\" <$> TF.attribute",
                    "name": "_host",
                    "method": "host",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (HostSetting s)]",
                    "class": "HasHost",
                    "validate": false,
                    "optional": true,
                    "original": "host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The IPv4 address of the switch. This can be used to see the DVS as a unique",
                        "device with NetFlow."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ipv4_address\" <$> TF.attribute",
                    "name": "_ipv4Address",
                    "method": "ipv4Address",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasIpv4Address",
                    "validate": false,
                    "optional": true,
                    "original": "ipv4_address"
                },
                {
                    "default": "TF.value \"listen\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to advertise or listen for link discovery. Valid values are",
                        "advertise, both, listen, and none."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"link_discovery_operation\" <$> TF.attribute",
                    "name": "_linkDiscoveryOperation",
                    "method": "linkDiscoveryOperation",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLinkDiscoveryOperation",
                    "validate": false,
                    "optional": true,
                    "original": "link_discovery_operation"
                },
                {
                    "default": "TF.value \"cdp\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The discovery protocol type. Valid values are cdp and lldp."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"link_discovery_protocol\" <$> TF.attribute",
                    "name": "_linkDiscoveryProtocol",
                    "method": "linkDiscoveryProtocol",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLinkDiscoveryProtocol",
                    "validate": false,
                    "optional": true,
                    "original": "link_discovery_protocol"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name for the DVS. Must be unique in the folder that it is being created",
                        "in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.value 60",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The number of seconds after which active flows are forced to be exported to",
                        "the collector."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"netflow_active_flow_timeout\" <$> TF.attribute",
                    "name": "_netflowActiveFlowTimeout",
                    "method": "netflowActiveFlowTimeout",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasNetflowActiveFlowTimeout",
                    "validate": false,
                    "optional": true,
                    "original": "netflow_active_flow_timeout"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "IP address for the netflow collector, using IPv4 or IPv6. IPv6 is supported",
                        "in vSphere Distributed Switch Version 6.0 or later."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"netflow_collector_ip_address\" <$> TF.attribute",
                    "name": "_netflowCollectorIpAddress",
                    "method": "netflowCollectorIpAddress",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasNetflowCollectorIpAddress",
                    "validate": false,
                    "optional": true,
                    "original": "netflow_collector_ip_address"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The port for the netflow collector."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"netflow_collector_port\" <$> TF.attribute",
                    "name": "_netflowCollectorPort",
                    "method": "netflowCollectorPort",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasNetflowCollectorPort",
                    "validate": false,
                    "optional": true,
                    "original": "netflow_collector_port"
                },
                {
                    "default": "TF.value 15",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The number of seconds after which idle flows are forced to be exported to",
                        "the collector."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"netflow_idle_flow_timeout\" <$> TF.attribute",
                    "name": "_netflowIdleFlowTimeout",
                    "method": "netflowIdleFlowTimeout",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasNetflowIdleFlowTimeout",
                    "validate": false,
                    "optional": true,
                    "original": "netflow_idle_flow_timeout"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to limit analysis to traffic that has both source and destination",
                        "served by the same host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"netflow_internal_flows_only\" <$> TF.attribute",
                    "name": "_netflowInternalFlowsOnly",
                    "method": "netflowInternalFlowsOnly",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasNetflowInternalFlowsOnly",
                    "validate": false,
                    "optional": true,
                    "original": "netflow_internal_flows_only"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The observation Domain ID for the netflow collector."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"netflow_observation_domain_id\" <$> TF.attribute",
                    "name": "_netflowObservationDomainId",
                    "method": "netflowObservationDomainId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasNetflowObservationDomainId",
                    "validate": false,
                    "optional": true,
                    "original": "netflow_observation_domain_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The ratio of total number of packets to the number of packets analyzed. Set",
                        "to 0 to disable sampling, meaning that all packets are analyzed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"netflow_sampling_rate\" <$> TF.attribute",
                    "name": "_netflowSamplingRate",
                    "method": "netflowSamplingRate",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasNetflowSamplingRate",
                    "validate": false,
                    "optional": true,
                    "original": "netflow_sampling_rate"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether or not to enable network resource control, enabling advanced traffic",
                        "shaping and resource control features."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_resource_control_enabled\" <$> TF.attribute",
                    "name": "_networkResourceControlEnabled",
                    "method": "networkResourceControlEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasNetworkResourceControlEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "network_resource_control_enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of tag IDs to apply to this object."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tags\" <$> TF.attribute",
                    "name": "_tags",
                    "method": "tags",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTags",
                    "validate": false,
                    "optional": true,
                    "original": "tags"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/distributed_virtual_switch.html",
            "key": "vsphere_distributed_virtual_switch",
            "name": "DistributedVirtualSwitchResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "List of active uplinks used for load balancing, matching the names of the",
                        "uplinks assigned in the DVS."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"active_uplinks\" <$> TF.attribute",
                    "name": "_computedActiveUplinks",
                    "method": "computedActiveUplinks",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedActiveUplinks",
                    "validate": false,
                    "optional": true,
                    "original": "active_uplinks"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Controls whether or not the virtual network adapter is allowed to send",
                        "network traffic with a different MAC address than that of its own."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_forged_transmits\" <$> TF.attribute",
                    "name": "_computedAllowForgedTransmits",
                    "method": "computedAllowForgedTransmits",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedAllowForgedTransmits",
                    "validate": false,
                    "optional": true,
                    "original": "allow_forged_transmits"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Controls whether or not the Media Access Control (MAC) address can be",
                        "changed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_mac_changes\" <$> TF.attribute",
                    "name": "_computedAllowMacChanges",
                    "method": "computedAllowMacChanges",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedAllowMacChanges",
                    "validate": false,
                    "optional": true,
                    "original": "allow_mac_changes"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Enable promiscuous mode on the network. This flag indicates whether or not",
                        "all traffic is seen on a given port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_promiscuous\" <$> TF.attribute",
                    "name": "_computedAllowPromiscuous",
                    "method": "computedAllowPromiscuous",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedAllowPromiscuous",
                    "validate": false,
                    "optional": true,
                    "original": "allow_promiscuous"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Indicates whether to block all ports by default."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"block_all_ports\" <$> TF.attribute",
                    "name": "_computedBlockAllPorts",
                    "method": "computedBlockAllPorts",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedBlockAllPorts",
                    "validate": false,
                    "optional": true,
                    "original": "block_all_ports"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Enable beacon probing on the ports this policy applies to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"check_beacon\" <$> TF.attribute",
                    "name": "_computedCheckBeacon",
                    "method": "computedCheckBeacon",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedCheckBeacon",
                    "validate": false,
                    "optional": true,
                    "original": "check_beacon"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The version string of the configuration that this spec is trying to change."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"config_version\" <$> TF.attribute",
                    "name": "_computedConfigVersion",
                    "method": "computedConfigVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedConfigVersion",
                    "validate": false,
                    "optional": false,
                    "original": "config_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Allow VMDirectPath Gen2 on the ports this policy applies to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"directpath_gen2_allowed\" <$> TF.attribute",
                    "name": "_computedDirectpathGen2Allowed",
                    "method": "computedDirectpathGen2Allowed",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedDirectpathGen2Allowed",
                    "validate": false,
                    "optional": true,
                    "original": "directpath_gen2_allowed"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The average egress bandwidth in bits per second if egress shaping is enabled",
                        "on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"egress_shaping_average_bandwidth\" <$> TF.attribute",
                    "name": "_computedEgressShapingAverageBandwidth",
                    "method": "computedEgressShapingAverageBandwidth",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedEgressShapingAverageBandwidth",
                    "validate": false,
                    "optional": true,
                    "original": "egress_shaping_average_bandwidth"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum egress burst size allowed in bytes if egress shaping is enabled",
                        "on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"egress_shaping_burst_size\" <$> TF.attribute",
                    "name": "_computedEgressShapingBurstSize",
                    "method": "computedEgressShapingBurstSize",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedEgressShapingBurstSize",
                    "validate": false,
                    "optional": true,
                    "original": "egress_shaping_burst_size"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "True if the traffic shaper is enabled for egress traffic on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"egress_shaping_enabled\" <$> TF.attribute",
                    "name": "_computedEgressShapingEnabled",
                    "method": "computedEgressShapingEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedEgressShapingEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "egress_shaping_enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The peak egress bandwidth during bursts in bits per second if egress traffic",
                        "shaping is enabled on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"egress_shaping_peak_bandwidth\" <$> TF.attribute",
                    "name": "_computedEgressShapingPeakBandwidth",
                    "method": "computedEgressShapingPeakBandwidth",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedEgressShapingPeakBandwidth",
                    "validate": false,
                    "optional": true,
                    "original": "egress_shaping_peak_bandwidth"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "If true, the teaming policy will re-activate failed interfaces higher in",
                        "precedence when they come back up."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failback\" <$> TF.attribute",
                    "name": "_computedFailback",
                    "method": "computedFailback",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedFailback",
                    "validate": false,
                    "optional": true,
                    "original": "failback"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum allowed usage for the faultTolerance traffic class, in",
                        "Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"faulttolerance_maximum_mbit\" <$> TF.attribute",
                    "name": "_computedFaulttoleranceMaximumMbit",
                    "method": "computedFaulttoleranceMaximumMbit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedFaulttoleranceMaximumMbit",
                    "validate": false,
                    "optional": true,
                    "original": "faulttolerance_maximum_mbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of guaranteed bandwidth for the faultTolerance traffic class, in",
                        "Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"faulttolerance_reservation_mbit\" <$> TF.attribute",
                    "name": "_computedFaulttoleranceReservationMbit",
                    "method": "computedFaulttoleranceReservationMbit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedFaulttoleranceReservationMbit",
                    "validate": false,
                    "optional": true,
                    "original": "faulttolerance_reservation_mbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of shares to allocate to the faultTolerance traffic class for a",
                        "custom share level."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"faulttolerance_share_count\" <$> TF.attribute",
                    "name": "_computedFaulttoleranceShareCount",
                    "method": "computedFaulttoleranceShareCount",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedFaulttoleranceShareCount",
                    "validate": false,
                    "optional": true,
                    "original": "faulttolerance_share_count"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The allocation level for the faultTolerance traffic class. Can be one of",
                        "high, low, normal, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"faulttolerance_share_level\" <$> TF.attribute",
                    "name": "_computedFaulttoleranceShareLevel",
                    "method": "computedFaulttoleranceShareLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedFaulttoleranceShareLevel",
                    "validate": false,
                    "optional": true,
                    "original": "faulttolerance_share_level"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum allowed usage for the hbr traffic class, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"hbr_maximum_mbit\" <$> TF.attribute",
                    "name": "_computedHbrMaximumMbit",
                    "method": "computedHbrMaximumMbit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedHbrMaximumMbit",
                    "validate": false,
                    "optional": true,
                    "original": "hbr_maximum_mbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"hbr_reservation_mbit\" <$> TF.attribute",
                    "name": "_computedHbrReservationMbit",
                    "method": "computedHbrReservationMbit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedHbrReservationMbit",
                    "validate": false,
                    "optional": true,
                    "original": "hbr_reservation_mbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of shares to allocate to the hbr traffic class for a custom share",
                        "level."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"hbr_share_count\" <$> TF.attribute",
                    "name": "_computedHbrShareCount",
                    "method": "computedHbrShareCount",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedHbrShareCount",
                    "validate": false,
                    "optional": true,
                    "original": "hbr_share_count"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The allocation level for the hbr traffic class. Can be one of high, low,",
                        "normal, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"hbr_share_level\" <$> TF.attribute",
                    "name": "_computedHbrShareLevel",
                    "method": "computedHbrShareLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedHbrShareLevel",
                    "validate": false,
                    "optional": true,
                    "original": "hbr_share_level"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The average ingress bandwidth in bits per second if ingress shaping is",
                        "enabled on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ingress_shaping_average_bandwidth\" <$> TF.attribute",
                    "name": "_computedIngressShapingAverageBandwidth",
                    "method": "computedIngressShapingAverageBandwidth",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedIngressShapingAverageBandwidth",
                    "validate": false,
                    "optional": true,
                    "original": "ingress_shaping_average_bandwidth"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum ingress burst size allowed in bytes if ingress shaping is",
                        "enabled on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ingress_shaping_burst_size\" <$> TF.attribute",
                    "name": "_computedIngressShapingBurstSize",
                    "method": "computedIngressShapingBurstSize",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedIngressShapingBurstSize",
                    "validate": false,
                    "optional": true,
                    "original": "ingress_shaping_burst_size"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "True if the traffic shaper is enabled for ingress traffic on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ingress_shaping_enabled\" <$> TF.attribute",
                    "name": "_computedIngressShapingEnabled",
                    "method": "computedIngressShapingEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedIngressShapingEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "ingress_shaping_enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The peak ingress bandwidth during bursts in bits per second if ingress",
                        "traffic shaping is enabled on the port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ingress_shaping_peak_bandwidth\" <$> TF.attribute",
                    "name": "_computedIngressShapingPeakBandwidth",
                    "method": "computedIngressShapingPeakBandwidth",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedIngressShapingPeakBandwidth",
                    "validate": false,
                    "optional": true,
                    "original": "ingress_shaping_peak_bandwidth"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum allowed usage for the iSCSI traffic class, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi_maximum_mbit\" <$> TF.attribute",
                    "name": "_computedIscsiMaximumMbit",
                    "method": "computedIscsiMaximumMbit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedIscsiMaximumMbit",
                    "validate": false,
                    "optional": true,
                    "original": "iscsi_maximum_mbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of guaranteed bandwidth for the iSCSI traffic class, in",
                        "Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi_reservation_mbit\" <$> TF.attribute",
                    "name": "_computedIscsiReservationMbit",
                    "method": "computedIscsiReservationMbit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedIscsiReservationMbit",
                    "validate": false,
                    "optional": true,
                    "original": "iscsi_reservation_mbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of shares to allocate to the iSCSI traffic class for a custom",
                        "share level."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi_share_count\" <$> TF.attribute",
                    "name": "_computedIscsiShareCount",
                    "method": "computedIscsiShareCount",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedIscsiShareCount",
                    "validate": false,
                    "optional": true,
                    "original": "iscsi_share_count"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The allocation level for the iSCSI traffic class. Can be one of high, low,",
                        "normal, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"iscsi_share_level\" <$> TF.attribute",
                    "name": "_computedIscsiShareLevel",
                    "method": "computedIscsiShareLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedIscsiShareLevel",
                    "validate": false,
                    "optional": true,
                    "original": "iscsi_share_level"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The Link Aggregation Control Protocol group version in the switch. Can be",
                        "one of singleLag or multipleLag."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lacp_api_version\" <$> TF.attribute",
                    "name": "_computedLacpApiVersion",
                    "method": "computedLacpApiVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedLacpApiVersion",
                    "validate": false,
                    "optional": true,
                    "original": "lacp_api_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Whether or not to enable LACP on all uplink ports."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lacp_enabled\" <$> TF.attribute",
                    "name": "_computedLacpEnabled",
                    "method": "computedLacpEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedLacpEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "lacp_enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The uplink LACP mode to use. Can be one of active or passive."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"lacp_mode\" <$> TF.attribute",
                    "name": "_computedLacpMode",
                    "method": "computedLacpMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedLacpMode",
                    "validate": false,
                    "optional": true,
                    "original": "lacp_mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum allowed usage for the management traffic class, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"management_maximum_mbit\" <$> TF.attribute",
                    "name": "_computedManagementMaximumMbit",
                    "method": "computedManagementMaximumMbit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedManagementMaximumMbit",
                    "validate": false,
                    "optional": true,
                    "original": "management_maximum_mbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of guaranteed bandwidth for the management traffic class, in",
                        "Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"management_reservation_mbit\" <$> TF.attribute",
                    "name": "_computedManagementReservationMbit",
                    "method": "computedManagementReservationMbit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedManagementReservationMbit",
                    "validate": false,
                    "optional": true,
                    "original": "management_reservation_mbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of shares to allocate to the management traffic class for a",
                        "custom share level."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"management_share_count\" <$> TF.attribute",
                    "name": "_computedManagementShareCount",
                    "method": "computedManagementShareCount",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedManagementShareCount",
                    "validate": false,
                    "optional": true,
                    "original": "management_share_count"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The allocation level for the management traffic class. Can be one of high,",
                        "low, normal, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"management_share_level\" <$> TF.attribute",
                    "name": "_computedManagementShareLevel",
                    "method": "computedManagementShareLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedManagementShareLevel",
                    "validate": false,
                    "optional": true,
                    "original": "management_share_level"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum MTU on the switch."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"max_mtu\" <$> TF.attribute",
                    "name": "_computedMaxMtu",
                    "method": "computedMaxMtu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedMaxMtu",
                    "validate": false,
                    "optional": true,
                    "original": "max_mtu"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The multicast filtering mode on the switch. Can be one of legacyFiltering,",
                        "or snooping."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"multicast_filtering_mode\" <$> TF.attribute",
                    "name": "_computedMulticastFilteringMode",
                    "method": "computedMulticastFilteringMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMulticastFilteringMode",
                    "validate": false,
                    "optional": true,
                    "original": "multicast_filtering_mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Indicates whether to enable netflow on all ports."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"netflow_enabled\" <$> TF.attribute",
                    "name": "_computedNetflowEnabled",
                    "method": "computedNetflowEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedNetflowEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "netflow_enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The network I/O control version to use. Can be one of version2 or version3."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_resource_control_version\" <$> TF.attribute",
                    "name": "_computedNetworkResourceControlVersion",
                    "method": "computedNetworkResourceControlVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedNetworkResourceControlVersion",
                    "validate": false,
                    "optional": true,
                    "original": "network_resource_control_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum allowed usage for the nfs traffic class, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"nfs_maximum_mbit\" <$> TF.attribute",
                    "name": "_computedNfsMaximumMbit",
                    "method": "computedNfsMaximumMbit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedNfsMaximumMbit",
                    "validate": false,
                    "optional": true,
                    "original": "nfs_maximum_mbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"nfs_reservation_mbit\" <$> TF.attribute",
                    "name": "_computedNfsReservationMbit",
                    "method": "computedNfsReservationMbit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedNfsReservationMbit",
                    "validate": false,
                    "optional": true,
                    "original": "nfs_reservation_mbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of shares to allocate to the nfs traffic class for a custom share",
                        "level."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"nfs_share_count\" <$> TF.attribute",
                    "name": "_computedNfsShareCount",
                    "method": "computedNfsShareCount",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedNfsShareCount",
                    "validate": false,
                    "optional": true,
                    "original": "nfs_share_count"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The allocation level for the nfs traffic class. Can be one of high, low,",
                        "normal, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"nfs_share_level\" <$> TF.attribute",
                    "name": "_computedNfsShareLevel",
                    "method": "computedNfsShareLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedNfsShareLevel",
                    "validate": false,
                    "optional": true,
                    "original": "nfs_share_level"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "If true, the teaming policy will notify the broadcast network of a NIC",
                        "failover, triggering cache updates."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"notify_switches\" <$> TF.attribute",
                    "name": "_computedNotifySwitches",
                    "method": "computedNotifySwitches",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedNotifySwitches",
                    "validate": false,
                    "optional": true,
                    "original": "notify_switches"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The secondary VLAN ID for this port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"port_private_secondary_vlan_id\" <$> TF.attribute",
                    "name": "_computedPortPrivateSecondaryVlanId",
                    "method": "computedPortPrivateSecondaryVlanId",
                    "threaded": true,
                    "conflicts": [
                        "_vlanId",
                        "_vlanRange"
                    ],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedPortPrivateSecondaryVlanId",
                    "validate": false,
                    "optional": true,
                    "original": "port_private_secondary_vlan_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "List of active uplinks used for load balancing, matching the names of the",
                        "uplinks assigned in the DVS."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"standby_uplinks\" <$> TF.attribute",
                    "name": "_computedStandbyUplinks",
                    "method": "computedStandbyUplinks",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedStandbyUplinks",
                    "validate": false,
                    "optional": true,
                    "original": "standby_uplinks"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The network adapter teaming policy. Can be one of loadbalance_ip,",
                        "loadbalance_srcmac, loadbalance_srcid, failover_explicit, or",
                        "loadbalance_loadbased."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"teaming_policy\" <$> TF.attribute",
                    "name": "_computedTeamingPolicy",
                    "method": "computedTeamingPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedTeamingPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "teaming_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "If true, a copy of packets sent to the switch will always be forwarded to an",
                        "uplink in addition to the regular packet forwarded done by the switch."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tx_uplink\" <$> TF.attribute",
                    "name": "_computedTxUplink",
                    "method": "computedTxUplink",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedTxUplink",
                    "validate": false,
                    "optional": true,
                    "original": "tx_uplink"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A list of uplink ports. The contents of this list control both the uplink",
                        "count and names of the uplinks on the DVS across hosts."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uplinks\" <$> TF.attribute",
                    "name": "_computedUplinks",
                    "method": "computedUplinks",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedUplinks",
                    "validate": false,
                    "optional": true,
                    "original": "uplinks"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum allowed usage for the vdp traffic class, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vdp_maximum_mbit\" <$> TF.attribute",
                    "name": "_computedVdpMaximumMbit",
                    "method": "computedVdpMaximumMbit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedVdpMaximumMbit",
                    "validate": false,
                    "optional": true,
                    "original": "vdp_maximum_mbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vdp_reservation_mbit\" <$> TF.attribute",
                    "name": "_computedVdpReservationMbit",
                    "method": "computedVdpReservationMbit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedVdpReservationMbit",
                    "validate": false,
                    "optional": true,
                    "original": "vdp_reservation_mbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of shares to allocate to the vdp traffic class for a custom share",
                        "level."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vdp_share_count\" <$> TF.attribute",
                    "name": "_computedVdpShareCount",
                    "method": "computedVdpShareCount",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedVdpShareCount",
                    "validate": false,
                    "optional": true,
                    "original": "vdp_share_count"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The allocation level for the vdp traffic class. Can be one of high, low,",
                        "normal, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vdp_share_level\" <$> TF.attribute",
                    "name": "_computedVdpShareLevel",
                    "method": "computedVdpShareLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedVdpShareLevel",
                    "validate": false,
                    "optional": true,
                    "original": "vdp_share_level"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The version of this virtual switch. Allowed versions are 6.5.0, 6.0.0,",
                        "5.5.0, 5.1.0, and 5.0.0."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"version\" <$> TF.attribute",
                    "name": "_computedVersion",
                    "method": "computedVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedVersion",
                    "validate": false,
                    "optional": true,
                    "original": "version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum allowed usage for the virtualMachine traffic class, in",
                        "Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"virtualmachine_maximum_mbit\" <$> TF.attribute",
                    "name": "_computedVirtualmachineMaximumMbit",
                    "method": "computedVirtualmachineMaximumMbit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedVirtualmachineMaximumMbit",
                    "validate": false,
                    "optional": true,
                    "original": "virtualmachine_maximum_mbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of guaranteed bandwidth for the virtualMachine traffic class, in",
                        "Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"virtualmachine_reservation_mbit\" <$> TF.attribute",
                    "name": "_computedVirtualmachineReservationMbit",
                    "method": "computedVirtualmachineReservationMbit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedVirtualmachineReservationMbit",
                    "validate": false,
                    "optional": true,
                    "original": "virtualmachine_reservation_mbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of shares to allocate to the virtualMachine traffic class for a",
                        "custom share level."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"virtualmachine_share_count\" <$> TF.attribute",
                    "name": "_computedVirtualmachineShareCount",
                    "method": "computedVirtualmachineShareCount",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedVirtualmachineShareCount",
                    "validate": false,
                    "optional": true,
                    "original": "virtualmachine_share_count"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The allocation level for the virtualMachine traffic class. Can be one of",
                        "high, low, normal, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"virtualmachine_share_level\" <$> TF.attribute",
                    "name": "_computedVirtualmachineShareLevel",
                    "method": "computedVirtualmachineShareLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedVirtualmachineShareLevel",
                    "validate": false,
                    "optional": true,
                    "original": "virtualmachine_share_level"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The VLAN ID for single VLAN mode. 0 denotes no VLAN."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vlan_id\" <$> TF.attribute",
                    "name": "_computedVlanId",
                    "method": "computedVlanId",
                    "threaded": true,
                    "conflicts": [
                        "_portPrivateSecondaryVlanId",
                        "_vlanRange"
                    ],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedVlanId",
                    "validate": false,
                    "optional": true,
                    "original": "vlan_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The VLAN ID for single VLAN mode. 0 denotes no VLAN."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vlan_range\" <$> TF.attribute",
                    "name": "_computedVlanRange",
                    "method": "computedVlanRange",
                    "threaded": true,
                    "conflicts": [
                        "_portPrivateSecondaryVlanId",
                        "_vlanId"
                    ],
                    "type": "TF.Attr s [TF.Attr s (VlanRangeSetting s)]",
                    "class": "HasComputedVlanRange",
                    "validate": false,
                    "optional": true,
                    "original": "vlan_range"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum allowed usage for the vmotion traffic class, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vmotion_maximum_mbit\" <$> TF.attribute",
                    "name": "_computedVmotionMaximumMbit",
                    "method": "computedVmotionMaximumMbit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedVmotionMaximumMbit",
                    "validate": false,
                    "optional": true,
                    "original": "vmotion_maximum_mbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of guaranteed bandwidth for the vmotion traffic class, in",
                        "Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vmotion_reservation_mbit\" <$> TF.attribute",
                    "name": "_computedVmotionReservationMbit",
                    "method": "computedVmotionReservationMbit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedVmotionReservationMbit",
                    "validate": false,
                    "optional": true,
                    "original": "vmotion_reservation_mbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of shares to allocate to the vmotion traffic class for a custom",
                        "share level."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vmotion_share_count\" <$> TF.attribute",
                    "name": "_computedVmotionShareCount",
                    "method": "computedVmotionShareCount",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedVmotionShareCount",
                    "validate": false,
                    "optional": true,
                    "original": "vmotion_share_count"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The allocation level for the vmotion traffic class. Can be one of high, low,",
                        "normal, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vmotion_share_level\" <$> TF.attribute",
                    "name": "_computedVmotionShareLevel",
                    "method": "computedVmotionShareLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedVmotionShareLevel",
                    "validate": false,
                    "optional": true,
                    "original": "vmotion_share_level"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The maximum allowed usage for the vsan traffic class, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vsan_maximum_mbit\" <$> TF.attribute",
                    "name": "_computedVsanMaximumMbit",
                    "method": "computedVsanMaximumMbit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedVsanMaximumMbit",
                    "validate": false,
                    "optional": true,
                    "original": "vsan_maximum_mbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vsan_reservation_mbit\" <$> TF.attribute",
                    "name": "_computedVsanReservationMbit",
                    "method": "computedVsanReservationMbit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedVsanReservationMbit",
                    "validate": false,
                    "optional": true,
                    "original": "vsan_reservation_mbit"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of shares to allocate to the vsan traffic class for a custom",
                        "share level."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vsan_share_count\" <$> TF.attribute",
                    "name": "_computedVsanShareCount",
                    "method": "computedVsanShareCount",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedVsanShareCount",
                    "validate": false,
                    "optional": true,
                    "original": "vsan_share_count"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The allocation level for the vsan traffic class. Can be one of high, low,",
                        "normal, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vsan_share_level\" <$> TF.attribute",
                    "name": "_computedVsanShareLevel",
                    "method": "computedVsanShareLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedVsanShareLevel",
                    "validate": false,
                    "optional": true,
                    "original": "vsan_share_level"
                }
            ],
            "parameters": [
                {
                    "default": "_datacenterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The ID of the datacenter to create this virtual switch in."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "_datacenterId",
                    "method": "datacenterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "validate": false,
                    "optional": false,
                    "original": "datacenter_id"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name for the DVS. Must be unique in the folder that it is being created",
                        "in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "DistributedVirtualSwitchResource s",
            "original": "vsphere_distributed_virtual_switch"
        },
        {
            "con": {
                "smart": "dpmHostOverrideResource",
                "name": "DpmHostOverrideResource'"
            },
            "arguments": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "_computeClusterId",
                    "method": "computeClusterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "validate": false,
                    "optional": false,
                    "original": "compute_cluster_id"
                },
                {
                    "default": "TF.value \"manual\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The automation level for power operations on this host. Can be one of manual",
                        "or automated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dpm_automation_level\" <$> TF.attribute",
                    "name": "_dpmAutomationLevel",
                    "method": "dpmAutomationLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDpmAutomationLevel",
                    "validate": false,
                    "optional": true,
                    "original": "dpm_automation_level"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable DPM for this host."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"dpm_enabled\" <$> TF.attribute",
                    "name": "_dpmEnabled",
                    "method": "dpmEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasDpmEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "dpm_enabled"
                },
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "_hostSystemId",
                    "method": "hostSystemId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "validate": false,
                    "optional": false,
                    "original": "host_system_id"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/dpm_host_override.html",
            "key": "vsphere_dpm_host_override",
            "name": "DpmHostOverrideResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "_computeClusterId",
                    "method": "computeClusterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "validate": false,
                    "optional": false,
                    "original": "compute_cluster_id"
                },
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "_hostSystemId",
                    "method": "hostSystemId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "validate": false,
                    "optional": false,
                    "original": "host_system_id"
                }
            ],
            "conflicts": [],
            "type": "DpmHostOverrideResource s",
            "original": "vsphere_dpm_host_override"
        },
        {
            "con": {
                "smart": "drsVmOverrideResource",
                "name": "DrsVmOverrideResource'"
            },
            "arguments": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "_computeClusterId",
                    "method": "computeClusterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "validate": false,
                    "optional": false,
                    "original": "compute_cluster_id"
                },
                {
                    "default": "TF.value \"manual\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The automation level for this virtual machine in the cluster. Can be one of",
                        "manual, partiallyAutomated, or fullyAutomated."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drs_automation_level\" <$> TF.attribute",
                    "name": "_drsAutomationLevel",
                    "method": "drsAutomationLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDrsAutomationLevel",
                    "validate": false,
                    "optional": true,
                    "original": "drs_automation_level"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable DRS for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"drs_enabled\" <$> TF.attribute",
                    "name": "_drsEnabled",
                    "method": "drsEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasDrsEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "drs_enabled"
                },
                {
                    "default": "_virtualMachineId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the virtual machine."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"virtual_machine_id\" <$> TF.attribute",
                    "name": "_virtualMachineId",
                    "method": "virtualMachineId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVirtualMachineId",
                    "validate": false,
                    "optional": false,
                    "original": "virtual_machine_id"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/drs_vm_override.html",
            "key": "vsphere_drs_vm_override",
            "name": "DrsVmOverrideResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "_computeClusterId",
                    "method": "computeClusterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "validate": false,
                    "optional": false,
                    "original": "compute_cluster_id"
                },
                {
                    "default": "_virtualMachineId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the virtual machine."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"virtual_machine_id\" <$> TF.attribute",
                    "name": "_virtualMachineId",
                    "method": "virtualMachineId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVirtualMachineId",
                    "validate": false,
                    "optional": false,
                    "original": "virtual_machine_id"
                }
            ],
            "conflicts": [],
            "type": "DrsVmOverrideResource s",
            "original": "vsphere_drs_vm_override"
        },
        {
            "con": {
                "smart": "fileResource",
                "name": "FileResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"create_directories\" <$> TF.attribute",
                    "name": "_createDirectories",
                    "method": "createDirectories",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasCreateDirectories",
                    "validate": false,
                    "optional": true,
                    "original": "create_directories"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"datacenter\" <$> TF.attribute",
                    "name": "_datacenter",
                    "method": "datacenter",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenter",
                    "validate": false,
                    "optional": true,
                    "original": "datacenter"
                },
                {
                    "default": "_datastore",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"datastore\" <$> TF.attribute",
                    "name": "_datastore",
                    "method": "datastore",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastore",
                    "validate": false,
                    "optional": false,
                    "original": "datastore"
                },
                {
                    "default": "_destinationFile",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"destination_file\" <$> TF.attribute",
                    "name": "_destinationFile",
                    "method": "destinationFile",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDestinationFile",
                    "validate": false,
                    "optional": false,
                    "original": "destination_file"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"source_datacenter\" <$> TF.attribute",
                    "name": "_sourceDatacenter",
                    "method": "sourceDatacenter",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSourceDatacenter",
                    "validate": false,
                    "optional": true,
                    "original": "source_datacenter"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"source_datastore\" <$> TF.attribute",
                    "name": "_sourceDatastore",
                    "method": "sourceDatastore",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSourceDatastore",
                    "validate": false,
                    "optional": true,
                    "original": "source_datastore"
                },
                {
                    "default": "_sourceFile",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"source_file\" <$> TF.attribute",
                    "name": "_sourceFile",
                    "method": "sourceFile",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSourceFile",
                    "validate": false,
                    "optional": false,
                    "original": "source_file"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/file.html",
            "key": "vsphere_file",
            "name": "FileResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_datastore",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"datastore\" <$> TF.attribute",
                    "name": "_datastore",
                    "method": "datastore",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastore",
                    "validate": false,
                    "optional": false,
                    "original": "datastore"
                },
                {
                    "default": "_destinationFile",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"destination_file\" <$> TF.attribute",
                    "name": "_destinationFile",
                    "method": "destinationFile",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDestinationFile",
                    "validate": false,
                    "optional": false,
                    "original": "destination_file"
                },
                {
                    "default": "_sourceFile",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"source_file\" <$> TF.attribute",
                    "name": "_sourceFile",
                    "method": "sourceFile",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSourceFile",
                    "validate": false,
                    "optional": false,
                    "original": "source_file"
                }
            ],
            "conflicts": [],
            "type": "FileResource s",
            "original": "vsphere_file"
        },
        {
            "con": {
                "smart": "folderResource",
                "name": "FolderResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of custom attributes to set on this resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"custom_attributes\" <$> TF.attribute",
                    "name": "_customAttributes",
                    "method": "customAttributes",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasCustomAttributes",
                    "validate": false,
                    "optional": true,
                    "original": "custom_attributes"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The ID of the datacenter. Can be ignored if creating a datacenter folder,",
                        "otherwise required."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"datacenter_id\" <$> TF.attribute",
                    "name": "_datacenterId",
                    "method": "datacenterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenterId",
                    "validate": false,
                    "optional": true,
                    "original": "datacenter_id"
                },
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The path of the folder and any parents, relative to the datacenter and",
                        "folder type being defined."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of tag IDs to apply to this object."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tags\" <$> TF.attribute",
                    "name": "_tags",
                    "method": "tags",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTags",
                    "validate": false,
                    "optional": true,
                    "original": "tags"
                },
                {
                    "default": "_type'",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The type of the folder."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": false,
                    "original": "type"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/folder.html",
            "key": "vsphere_folder",
            "name": "FolderResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_path",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The path of the folder and any parents, relative to the datacenter and",
                        "folder type being defined."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"path\" <$> TF.attribute",
                    "name": "_path",
                    "method": "path",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasPath",
                    "validate": false,
                    "optional": false,
                    "original": "path"
                },
                {
                    "default": "_type'",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The type of the folder."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": false,
                    "original": "type"
                }
            ],
            "conflicts": [],
            "type": "FolderResource s",
            "original": "vsphere_folder"
        },
        {
            "con": {
                "smart": "haVmOverrideResource",
                "name": "HaVmOverrideResource'"
            },
            "arguments": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "_computeClusterId",
                    "method": "computeClusterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "validate": false,
                    "optional": false,
                    "original": "compute_cluster_id"
                },
                {
                    "default": "TF.value \"useClusterDefault\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Controls the action to take on this virtual machine if an APD status on an",
                        "affected datastore clears in the middle of an APD event. Can be one of",
                        "useClusterDefault, none or reset."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_datastore_apd_recovery_action\" <$> TF.attribute",
                    "name": "_haDatastoreApdRecoveryAction",
                    "method": "haDatastoreApdRecoveryAction",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaDatastoreApdRecoveryAction",
                    "validate": false,
                    "optional": true,
                    "original": "ha_datastore_apd_recovery_action"
                },
                {
                    "default": "TF.value \"clusterDefault\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Controls the action to take on this virtual machine when the cluster has",
                        "detected loss to all paths to a relevant datastore. Can be one of",
                        "clusterDefault, disabled, warning, restartConservative, or",
                        "restartAggressive."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_datastore_apd_response\" <$> TF.attribute",
                    "name": "_haDatastoreApdResponse",
                    "method": "haDatastoreApdResponse",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaDatastoreApdResponse",
                    "validate": false,
                    "optional": true,
                    "original": "ha_datastore_apd_response"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Controls the delay in minutes to wait after an APD timeout event to execute",
                        "the response action defined in ha_datastore_apd_response. Specify -1 to use",
                        "the cluster setting."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_datastore_apd_response_delay\" <$> TF.attribute",
                    "name": "_haDatastoreApdResponseDelay",
                    "method": "haDatastoreApdResponseDelay",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHaDatastoreApdResponseDelay",
                    "validate": false,
                    "optional": true,
                    "original": "ha_datastore_apd_response_delay"
                },
                {
                    "default": "TF.value \"clusterDefault\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Controls the action to take on this virtual machine when the cluster has",
                        "detected a permanent device loss to a relevant datastore. Can be one of",
                        "clusterDefault, disabled, warning, or restartAggressive."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_datastore_pdl_response\" <$> TF.attribute",
                    "name": "_haDatastorePdlResponse",
                    "method": "haDatastorePdlResponse",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaDatastorePdlResponse",
                    "validate": false,
                    "optional": true,
                    "original": "ha_datastore_pdl_response"
                },
                {
                    "default": "TF.value \"clusterIsolationResponse\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The action to take on this virtual machine when a host is isolated from the",
                        "rest of the cluster. Can be one of clusterIsolationResponse, none, powerOff,",
                        "or shutdown."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_host_isolation_response\" <$> TF.attribute",
                    "name": "_haHostIsolationResponse",
                    "method": "haHostIsolationResponse",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaHostIsolationResponse",
                    "validate": false,
                    "optional": true,
                    "original": "ha_host_isolation_response"
                },
                {
                    "default": "TF.value 30",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If a heartbeat from this virtual machine is not received within this",
                        "configured interval, the virtual machine is marked as failed. The value is",
                        "in seconds."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_failure_interval\" <$> TF.attribute",
                    "name": "_haVmFailureInterval",
                    "method": "haVmFailureInterval",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHaVmFailureInterval",
                    "validate": false,
                    "optional": true,
                    "original": "ha_vm_failure_interval"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The length of the reset window in which ha_vm_maximum_resets can operate.",
                        "When this window expires, no more resets are attempted regardless of the",
                        "setting configured in ha_vm_maximum_resets. -1 means no window, meaning an",
                        "unlimited reset time is allotted."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_maximum_failure_window\" <$> TF.attribute",
                    "name": "_haVmMaximumFailureWindow",
                    "method": "haVmMaximumFailureWindow",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHaVmMaximumFailureWindow",
                    "validate": false,
                    "optional": true,
                    "original": "ha_vm_maximum_failure_window"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The maximum number of resets that HA will perform to this virtual machine",
                        "when responding to a failure event."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_maximum_resets\" <$> TF.attribute",
                    "name": "_haVmMaximumResets",
                    "method": "haVmMaximumResets",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHaVmMaximumResets",
                    "validate": false,
                    "optional": true,
                    "original": "ha_vm_maximum_resets"
                },
                {
                    "default": "TF.value 120",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The time, in seconds, that HA waits after powering on this virtual machine",
                        "before monitoring for heartbeats."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_minimum_uptime\" <$> TF.attribute",
                    "name": "_haVmMinimumUptime",
                    "method": "haVmMinimumUptime",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHaVmMinimumUptime",
                    "validate": false,
                    "optional": true,
                    "original": "ha_vm_minimum_uptime"
                },
                {
                    "default": "TF.value \"vmMonitoringDisabled\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The type of virtual machine monitoring to use for this virtual machine. Can",
                        "be one of vmMonitoringDisabled, vmMonitoringOnly, or vmAndAppMonitoring."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_monitoring\" <$> TF.attribute",
                    "name": "_haVmMonitoring",
                    "method": "haVmMonitoring",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaVmMonitoring",
                    "validate": false,
                    "optional": true,
                    "original": "ha_vm_monitoring"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Determines whether or not the cluster's default settings or the VM override",
                        "settings specified in this resource are used for virtual machine monitoring.",
                        "The default is true (use cluster defaults) - set to false to have overrides",
                        "take effect."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_monitoring_use_cluster_defaults\" <$> TF.attribute",
                    "name": "_haVmMonitoringUseClusterDefaults",
                    "method": "haVmMonitoringUseClusterDefaults",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasHaVmMonitoringUseClusterDefaults",
                    "validate": false,
                    "optional": true,
                    "original": "ha_vm_monitoring_use_cluster_defaults"
                },
                {
                    "default": "TF.value \"clusterRestartPriority\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The restart priority for this virtual machine when vSphere detects a host",
                        "failure. Can be one of clusterRestartPriority, lowest, low, medium, high, or",
                        "highest."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_restart_priority\" <$> TF.attribute",
                    "name": "_haVmRestartPriority",
                    "method": "haVmRestartPriority",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHaVmRestartPriority",
                    "validate": false,
                    "optional": true,
                    "original": "ha_vm_restart_priority"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The maximum time, in seconds, that vSphere HA will wait for the virtual",
                        "machine to be ready. Use -1 to use the cluster default."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ha_vm_restart_timeout\" <$> TF.attribute",
                    "name": "_haVmRestartTimeout",
                    "method": "haVmRestartTimeout",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasHaVmRestartTimeout",
                    "validate": false,
                    "optional": true,
                    "original": "ha_vm_restart_timeout"
                },
                {
                    "default": "_virtualMachineId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the virtual machine."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"virtual_machine_id\" <$> TF.attribute",
                    "name": "_virtualMachineId",
                    "method": "virtualMachineId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVirtualMachineId",
                    "validate": false,
                    "optional": false,
                    "original": "virtual_machine_id"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/ha_vm_override.html",
            "key": "vsphere_ha_vm_override",
            "name": "HaVmOverrideResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_computeClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"compute_cluster_id\" <$> TF.attribute",
                    "name": "_computeClusterId",
                    "method": "computeClusterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputeClusterId",
                    "validate": false,
                    "optional": false,
                    "original": "compute_cluster_id"
                },
                {
                    "default": "_virtualMachineId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the virtual machine."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"virtual_machine_id\" <$> TF.attribute",
                    "name": "_virtualMachineId",
                    "method": "virtualMachineId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVirtualMachineId",
                    "validate": false,
                    "optional": false,
                    "original": "virtual_machine_id"
                }
            ],
            "conflicts": [],
            "type": "HaVmOverrideResource s",
            "original": "vsphere_ha_vm_override"
        },
        {
            "con": {
                "smart": "hostPortGroupResource",
                "name": "HostPortGroupResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of active network adapters used for load balancing."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"active_nics\" <$> TF.attribute",
                    "name": "_activeNics",
                    "method": "activeNics",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasActiveNics",
                    "validate": false,
                    "optional": true,
                    "original": "active_nics"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Controls whether or not the virtual network adapter is allowed to send",
                        "network traffic with a different MAC address than that of its own."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_forged_transmits\" <$> TF.attribute",
                    "name": "_allowForgedTransmits",
                    "method": "allowForgedTransmits",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasAllowForgedTransmits",
                    "validate": false,
                    "optional": true,
                    "original": "allow_forged_transmits"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Controls whether or not the Media Access Control (MAC) address can be",
                        "changed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_mac_changes\" <$> TF.attribute",
                    "name": "_allowMacChanges",
                    "method": "allowMacChanges",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasAllowMacChanges",
                    "validate": false,
                    "optional": true,
                    "original": "allow_mac_changes"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable promiscuous mode on the network. This flag indicates whether or not",
                        "all traffic is seen on a given port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_promiscuous\" <$> TF.attribute",
                    "name": "_allowPromiscuous",
                    "method": "allowPromiscuous",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasAllowPromiscuous",
                    "validate": false,
                    "optional": true,
                    "original": "allow_promiscuous"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable beacon probing. Requires that the vSwitch has been configured to use",
                        "a beacon. If disabled, link status is used only."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"check_beacon\" <$> TF.attribute",
                    "name": "_checkBeacon",
                    "method": "checkBeacon",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasCheckBeacon",
                    "validate": false,
                    "optional": true,
                    "original": "check_beacon"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If true, the teaming policy will re-activate failed interfaces higher in",
                        "precedence when they come back up."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failback\" <$> TF.attribute",
                    "name": "_failback",
                    "method": "failback",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasFailback",
                    "validate": false,
                    "optional": true,
                    "original": "failback"
                },
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host to set the virtual switch up on."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "_hostSystemId",
                    "method": "hostSystemId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "validate": false,
                    "optional": false,
                    "original": "host_system_id"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the port group."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If true, the teaming policy will notify the broadcast network of a NIC",
                        "failover, triggering cache updates."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"notify_switches\" <$> TF.attribute",
                    "name": "_notifySwitches",
                    "method": "notifySwitches",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasNotifySwitches",
                    "validate": false,
                    "optional": true,
                    "original": "notify_switches"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The average bandwidth in bits per second if traffic shaping is enabled."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"shaping_average_bandwidth\" <$> TF.attribute",
                    "name": "_shapingAverageBandwidth",
                    "method": "shapingAverageBandwidth",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasShapingAverageBandwidth",
                    "validate": false,
                    "optional": true,
                    "original": "shaping_average_bandwidth"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The maximum burst size allowed in bytes if traffic shaping is enabled."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"shaping_burst_size\" <$> TF.attribute",
                    "name": "_shapingBurstSize",
                    "method": "shapingBurstSize",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasShapingBurstSize",
                    "validate": false,
                    "optional": true,
                    "original": "shaping_burst_size"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable traffic shaping on this virtual switch or port group."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"shaping_enabled\" <$> TF.attribute",
                    "name": "_shapingEnabled",
                    "method": "shapingEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasShapingEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "shaping_enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The peak bandwidth during bursts in bits per second if traffic shaping is",
                        "enabled."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"shaping_peak_bandwidth\" <$> TF.attribute",
                    "name": "_shapingPeakBandwidth",
                    "method": "shapingPeakBandwidth",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasShapingPeakBandwidth",
                    "validate": false,
                    "optional": true,
                    "original": "shaping_peak_bandwidth"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "List of standby network adapters used for failover."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"standby_nics\" <$> TF.attribute",
                    "name": "_standbyNics",
                    "method": "standbyNics",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasStandbyNics",
                    "validate": false,
                    "optional": true,
                    "original": "standby_nics"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The network adapter teaming policy. Can be one of loadbalance_ip,",
                        "loadbalance_srcmac, loadbalance_srcid, or failover_explicit."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"teaming_policy\" <$> TF.attribute",
                    "name": "_teamingPolicy",
                    "method": "teamingPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTeamingPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "teaming_policy"
                },
                {
                    "default": "_virtualSwitchName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the virtual switch to bind this port group to."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"virtual_switch_name\" <$> TF.attribute",
                    "name": "_virtualSwitchName",
                    "method": "virtualSwitchName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVirtualSwitchName",
                    "validate": false,
                    "optional": false,
                    "original": "virtual_switch_name"
                },
                {
                    "default": "TF.value 0",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The VLAN ID/trunk mode for this port group. An ID of 0 denotes no tagging,",
                        "an ID of 1-4094 tags with the specific ID, and an ID of 4095 enables trunk",
                        "mode, allowing the guest to manage its own tagging."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vlan_id\" <$> TF.attribute",
                    "name": "_vlanId",
                    "method": "vlanId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasVlanId",
                    "validate": false,
                    "optional": true,
                    "original": "vlan_id"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/host_port_group.html",
            "key": "vsphere_host_port_group",
            "name": "HostPortGroupResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The effective network policy after inheritance. Note that this will look",
                        "similar to, but is not the same, as the policy attributes defined in this",
                        "resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"computed_policy\" <$> TF.attribute",
                    "name": "_computedComputedPolicy",
                    "method": "computedComputedPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasComputedComputedPolicy",
                    "validate": false,
                    "optional": false,
                    "original": "computed_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The linkable identifier for this port group."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"key\" <$> TF.attribute",
                    "name": "_computedKey",
                    "method": "computedKey",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedKey",
                    "validate": false,
                    "optional": false,
                    "original": "key"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The ports that currently exist and are used on this port group."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ports\" <$> TF.attribute",
                    "name": "_computedPorts",
                    "method": "computedPorts",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (PortsSetting s)",
                    "class": "HasComputedPorts",
                    "validate": true,
                    "optional": false,
                    "original": "ports"
                }
            ],
            "parameters": [
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host to set the virtual switch up on."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "_hostSystemId",
                    "method": "hostSystemId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "validate": false,
                    "optional": false,
                    "original": "host_system_id"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the port group."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "_virtualSwitchName",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the virtual switch to bind this port group to."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"virtual_switch_name\" <$> TF.attribute",
                    "name": "_virtualSwitchName",
                    "method": "virtualSwitchName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVirtualSwitchName",
                    "validate": false,
                    "optional": false,
                    "original": "virtual_switch_name"
                }
            ],
            "conflicts": [],
            "type": "HostPortGroupResource s",
            "original": "vsphere_host_port_group"
        },
        {
            "con": {
                "smart": "hostVirtualSwitchResource",
                "name": "HostVirtualSwitchResource'"
            },
            "arguments": [
                {
                    "default": "_activeNics",
                    "computed": false,
                    "required": true,
                    "help": [
                        "List of active network adapters used for load balancing."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"active_nics\" <$> TF.attribute",
                    "name": "_activeNics",
                    "method": "activeNics",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasActiveNics",
                    "validate": false,
                    "optional": false,
                    "original": "active_nics"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Controls whether or not the virtual network adapter is allowed to send",
                        "network traffic with a different MAC address than that of its own."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_forged_transmits\" <$> TF.attribute",
                    "name": "_allowForgedTransmits",
                    "method": "allowForgedTransmits",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasAllowForgedTransmits",
                    "validate": false,
                    "optional": true,
                    "original": "allow_forged_transmits"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Controls whether or not the Media Access Control (MAC) address can be",
                        "changed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_mac_changes\" <$> TF.attribute",
                    "name": "_allowMacChanges",
                    "method": "allowMacChanges",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasAllowMacChanges",
                    "validate": false,
                    "optional": true,
                    "original": "allow_mac_changes"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable promiscuous mode on the network. This flag indicates whether or not",
                        "all traffic is seen on a given port."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"allow_promiscuous\" <$> TF.attribute",
                    "name": "_allowPromiscuous",
                    "method": "allowPromiscuous",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasAllowPromiscuous",
                    "validate": false,
                    "optional": true,
                    "original": "allow_promiscuous"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Determines how often, in seconds, a beacon should be sent to probe for the",
                        "validity of a link."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"beacon_interval\" <$> TF.attribute",
                    "name": "_beaconInterval",
                    "method": "beaconInterval",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasBeaconInterval",
                    "validate": false,
                    "optional": true,
                    "original": "beacon_interval"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable beacon probing. Requires that the vSwitch has been configured to use",
                        "a beacon. If disabled, link status is used only."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"check_beacon\" <$> TF.attribute",
                    "name": "_checkBeacon",
                    "method": "checkBeacon",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasCheckBeacon",
                    "validate": false,
                    "optional": true,
                    "original": "check_beacon"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If true, the teaming policy will re-activate failed interfaces higher in",
                        "precedence when they come back up."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"failback\" <$> TF.attribute",
                    "name": "_failback",
                    "method": "failback",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasFailback",
                    "validate": false,
                    "optional": true,
                    "original": "failback"
                },
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host to set the virtual switch up on."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "_hostSystemId",
                    "method": "hostSystemId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "validate": false,
                    "optional": false,
                    "original": "host_system_id"
                },
                {
                    "default": "TF.value \"listen\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Whether to advertise or listen for link discovery. Valid values are",
                        "advertise, both, listen, and none."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"link_discovery_operation\" <$> TF.attribute",
                    "name": "_linkDiscoveryOperation",
                    "method": "linkDiscoveryOperation",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLinkDiscoveryOperation",
                    "validate": false,
                    "optional": true,
                    "original": "link_discovery_operation"
                },
                {
                    "default": "TF.value \"cdp\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The discovery protocol type. Valid values are cdp and lldp."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"link_discovery_protocol\" <$> TF.attribute",
                    "name": "_linkDiscoveryProtocol",
                    "method": "linkDiscoveryProtocol",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLinkDiscoveryProtocol",
                    "validate": false,
                    "optional": true,
                    "original": "link_discovery_protocol"
                },
                {
                    "default": "TF.value 1500",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The maximum transmission unit (MTU) of the virtual switch in bytes."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"mtu\" <$> TF.attribute",
                    "name": "_mtu",
                    "method": "mtu",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMtu",
                    "validate": false,
                    "optional": true,
                    "original": "mtu"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the virtual switch."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "_networkAdapters",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The list of network adapters to bind to this virtual switch."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_adapters\" <$> TF.attribute",
                    "name": "_networkAdapters",
                    "method": "networkAdapters",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasNetworkAdapters",
                    "validate": false,
                    "optional": false,
                    "original": "network_adapters"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If true, the teaming policy will notify the broadcast network of a NIC",
                        "failover, triggering cache updates."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"notify_switches\" <$> TF.attribute",
                    "name": "_notifySwitches",
                    "method": "notifySwitches",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasNotifySwitches",
                    "validate": false,
                    "optional": true,
                    "original": "notify_switches"
                },
                {
                    "default": "TF.value 128",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The number of ports that this virtual switch is configured to use."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"number_of_ports\" <$> TF.attribute",
                    "name": "_numberOfPorts",
                    "method": "numberOfPorts",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasNumberOfPorts",
                    "validate": false,
                    "optional": true,
                    "original": "number_of_ports"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The average bandwidth in bits per second if traffic shaping is enabled."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"shaping_average_bandwidth\" <$> TF.attribute",
                    "name": "_shapingAverageBandwidth",
                    "method": "shapingAverageBandwidth",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasShapingAverageBandwidth",
                    "validate": false,
                    "optional": true,
                    "original": "shaping_average_bandwidth"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The maximum burst size allowed in bytes if traffic shaping is enabled."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"shaping_burst_size\" <$> TF.attribute",
                    "name": "_shapingBurstSize",
                    "method": "shapingBurstSize",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasShapingBurstSize",
                    "validate": false,
                    "optional": true,
                    "original": "shaping_burst_size"
                },
                {
                    "default": "TF.value P.False",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable traffic shaping on this virtual switch or port group."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"shaping_enabled\" <$> TF.attribute",
                    "name": "_shapingEnabled",
                    "method": "shapingEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasShapingEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "shaping_enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The peak bandwidth during bursts in bits per second if traffic shaping is",
                        "enabled."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"shaping_peak_bandwidth\" <$> TF.attribute",
                    "name": "_shapingPeakBandwidth",
                    "method": "shapingPeakBandwidth",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasShapingPeakBandwidth",
                    "validate": false,
                    "optional": true,
                    "original": "shaping_peak_bandwidth"
                },
                {
                    "default": "_standbyNics",
                    "computed": false,
                    "required": true,
                    "help": [
                        "List of standby network adapters used for failover."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"standby_nics\" <$> TF.attribute",
                    "name": "_standbyNics",
                    "method": "standbyNics",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasStandbyNics",
                    "validate": false,
                    "optional": false,
                    "original": "standby_nics"
                },
                {
                    "default": "TF.value \"loadbalance_srcid\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The network adapter teaming policy. Can be one of loadbalance_ip,",
                        "loadbalance_srcmac, loadbalance_srcid, or failover_explicit."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"teaming_policy\" <$> TF.attribute",
                    "name": "_teamingPolicy",
                    "method": "teamingPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasTeamingPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "teaming_policy"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/host_virtual_switch.html",
            "key": "vsphere_host_virtual_switch",
            "name": "HostVirtualSwitchResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_networkAdapters",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The list of network adapters to bind to this virtual switch."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_adapters\" <$> TF.attribute",
                    "name": "_networkAdapters",
                    "method": "networkAdapters",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasNetworkAdapters",
                    "validate": false,
                    "optional": false,
                    "original": "network_adapters"
                },
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host to set the virtual switch up on."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "_hostSystemId",
                    "method": "hostSystemId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "validate": false,
                    "optional": false,
                    "original": "host_system_id"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the virtual switch."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "_activeNics",
                    "computed": false,
                    "required": true,
                    "help": [
                        "List of active network adapters used for load balancing."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"active_nics\" <$> TF.attribute",
                    "name": "_activeNics",
                    "method": "activeNics",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasActiveNics",
                    "validate": false,
                    "optional": false,
                    "original": "active_nics"
                },
                {
                    "default": "_standbyNics",
                    "computed": false,
                    "required": true,
                    "help": [
                        "List of standby network adapters used for failover."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"standby_nics\" <$> TF.attribute",
                    "name": "_standbyNics",
                    "method": "standbyNics",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasStandbyNics",
                    "validate": false,
                    "optional": false,
                    "original": "standby_nics"
                }
            ],
            "conflicts": [],
            "type": "HostVirtualSwitchResource s",
            "original": "vsphere_host_virtual_switch"
        },
        {
            "con": {
                "smart": "licenseResource",
                "name": "LicenseResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"labels\" <$> TF.attribute",
                    "name": "_labels",
                    "method": "labels",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasLabels",
                    "validate": false,
                    "optional": true,
                    "original": "labels"
                },
                {
                    "default": "_licenseKey",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"license_key\" <$> TF.attribute",
                    "name": "_licenseKey",
                    "method": "licenseKey",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLicenseKey",
                    "validate": false,
                    "optional": false,
                    "original": "license_key"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/license.html",
            "key": "vsphere_license",
            "name": "LicenseResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"edition_key\" <$> TF.attribute",
                    "name": "_computedEditionKey",
                    "method": "computedEditionKey",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedEditionKey",
                    "validate": false,
                    "optional": false,
                    "original": "edition_key"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_computedName",
                    "method": "computedName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"total\" <$> TF.attribute",
                    "name": "_computedTotal",
                    "method": "computedTotal",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedTotal",
                    "validate": false,
                    "optional": false,
                    "original": "total"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [],
                    "forceNew": false,
                    "encoder": "TF.assign \"used\" <$> TF.attribute",
                    "name": "_computedUsed",
                    "method": "computedUsed",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedUsed",
                    "validate": false,
                    "optional": false,
                    "original": "used"
                }
            ],
            "parameters": [
                {
                    "default": "_licenseKey",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"license_key\" <$> TF.attribute",
                    "name": "_licenseKey",
                    "method": "licenseKey",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLicenseKey",
                    "validate": false,
                    "optional": false,
                    "original": "license_key"
                }
            ],
            "conflicts": [],
            "type": "LicenseResource s",
            "original": "vsphere_license"
        },
        {
            "con": {
                "smart": "nasDatastoreResource",
                "name": "NasDatastoreResource'"
            },
            "arguments": [
                {
                    "default": "TF.value \"readWrite\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Access mode for the mount point. Can be one of readOnly or readWrite."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"access_mode\" <$> TF.attribute",
                    "name": "_accessMode",
                    "method": "accessMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasAccessMode",
                    "validate": false,
                    "optional": true,
                    "original": "access_mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of custom attributes to set on this resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"custom_attributes\" <$> TF.attribute",
                    "name": "_customAttributes",
                    "method": "customAttributes",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasCustomAttributes",
                    "validate": false,
                    "optional": true,
                    "original": "custom_attributes"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object ID of the datastore cluster to place the datastore in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datastore_cluster_id\" <$> TF.attribute",
                    "name": "_datastoreClusterId",
                    "method": "datastoreClusterId",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_folder",
                            "method": "folder"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastoreClusterId",
                    "validate": false,
                    "optional": true,
                    "original": "datastore_cluster_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The path to the datastore folder to put the datastore in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"folder\" <$> TF.attribute",
                    "name": "_folder",
                    "method": "folder",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_datastoreClusterId",
                            "method": "datastoreClusterId"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFolder",
                    "validate": false,
                    "optional": true,
                    "original": "folder"
                },
                {
                    "default": "_hostSystemIds",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object IDs of the hosts to mount the datastore on."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_system_ids\" <$> TF.attribute",
                    "name": "_hostSystemIds",
                    "method": "hostSystemIds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (TF.Attr s P.Text))",
                    "class": "HasHostSystemIds",
                    "validate": false,
                    "optional": false,
                    "original": "host_system_ids"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "_remoteHosts",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The hostnames or IP addresses of the remote server or servers. Only one",
                        "element should be present for NFS v3 but multiple can be present for NFS",
                        "v4.1."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"remote_hosts\" <$> TF.attribute",
                    "name": "_remoteHosts",
                    "method": "remoteHosts",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (TF.Attr s P.Text))",
                    "class": "HasRemoteHosts",
                    "validate": false,
                    "optional": false,
                    "original": "remote_hosts"
                },
                {
                    "default": "_remotePath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The remote path of the mount point."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"remote_path\" <$> TF.attribute",
                    "name": "_remotePath",
                    "method": "remotePath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRemotePath",
                    "validate": false,
                    "optional": false,
                    "original": "remote_path"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The security type to use."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"security_type\" <$> TF.attribute",
                    "name": "_securityType",
                    "method": "securityType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSecurityType",
                    "validate": false,
                    "optional": true,
                    "original": "security_type"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of tag IDs to apply to this object."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tags\" <$> TF.attribute",
                    "name": "_tags",
                    "method": "tags",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTags",
                    "validate": false,
                    "optional": true,
                    "original": "tags"
                },
                {
                    "default": "TF.value \"NFS\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The type of NAS volume. Can be one of NFS (to denote v3) or NFS41 (to denote",
                        "NFS v4.1)."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": true,
                    "original": "type"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/nas_datastore.html",
            "key": "vsphere_nas_datastore",
            "name": "NasDatastoreResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The connectivity status of the datastore. If this is false, some other",
                        "computed attributes may be out of date."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"accessible\" <$> TF.attribute",
                    "name": "_computedAccessible",
                    "method": "computedAccessible",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedAccessible",
                    "validate": false,
                    "optional": false,
                    "original": "accessible"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Maximum capacity of the datastore, in MB."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"capacity\" <$> TF.attribute",
                    "name": "_computedCapacity",
                    "method": "computedCapacity",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedCapacity",
                    "validate": false,
                    "optional": false,
                    "original": "capacity"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Available space of this datastore, in MB."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"free_space\" <$> TF.attribute",
                    "name": "_computedFreeSpace",
                    "method": "computedFreeSpace",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedFreeSpace",
                    "validate": false,
                    "optional": false,
                    "original": "free_space"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The current maintenance mode state of the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"maintenance_mode\" <$> TF.attribute",
                    "name": "_computedMaintenanceMode",
                    "method": "computedMaintenanceMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMaintenanceMode",
                    "validate": false,
                    "optional": false,
                    "original": "maintenance_mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "If true, more than one host in the datacenter has been configured with",
                        "access to the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"multiple_host_access\" <$> TF.attribute",
                    "name": "_computedMultipleHostAccess",
                    "method": "computedMultipleHostAccess",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedMultipleHostAccess",
                    "validate": false,
                    "optional": false,
                    "original": "multiple_host_access"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Indicates that this NAS volume is a protocol endpoint. This field is only",
                        "populated if the host supports virtual datastores."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"protocol_endpoint\" <$> TF.attribute",
                    "name": "_computedProtocolEndpoint",
                    "method": "computedProtocolEndpoint",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedProtocolEndpoint",
                    "validate": false,
                    "optional": false,
                    "original": "protocol_endpoint"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Total additional storage space, in MB, potentially used by all virtual",
                        "machines on this datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uncommitted_space\" <$> TF.attribute",
                    "name": "_computedUncommittedSpace",
                    "method": "computedUncommittedSpace",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedUncommittedSpace",
                    "validate": false,
                    "optional": false,
                    "original": "uncommitted_space"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique locator for the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"url\" <$> TF.attribute",
                    "name": "_computedUrl",
                    "method": "computedUrl",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUrl",
                    "validate": false,
                    "optional": false,
                    "original": "url"
                }
            ],
            "parameters": [
                {
                    "default": "_remoteHosts",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The hostnames or IP addresses of the remote server or servers. Only one",
                        "element should be present for NFS v3 but multiple can be present for NFS",
                        "v4.1."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"remote_hosts\" <$> TF.attribute",
                    "name": "_remoteHosts",
                    "method": "remoteHosts",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (TF.Attr s P.Text))",
                    "class": "HasRemoteHosts",
                    "validate": false,
                    "optional": false,
                    "original": "remote_hosts"
                },
                {
                    "default": "_hostSystemIds",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object IDs of the hosts to mount the datastore on."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_system_ids\" <$> TF.attribute",
                    "name": "_hostSystemIds",
                    "method": "hostSystemIds",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (TF.Attr s P.Text))",
                    "class": "HasHostSystemIds",
                    "validate": false,
                    "optional": false,
                    "original": "host_system_ids"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "_remotePath",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The remote path of the mount point."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"remote_path\" <$> TF.attribute",
                    "name": "_remotePath",
                    "method": "remotePath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasRemotePath",
                    "validate": false,
                    "optional": false,
                    "original": "remote_path"
                }
            ],
            "conflicts": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object ID of the datastore cluster to place the datastore in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datastore_cluster_id\" <$> TF.attribute",
                    "name": "_datastoreClusterId",
                    "method": "datastoreClusterId",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_folder",
                            "method": "folder"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastoreClusterId",
                    "validate": false,
                    "optional": true,
                    "original": "datastore_cluster_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The path to the datastore folder to put the datastore in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"folder\" <$> TF.attribute",
                    "name": "_folder",
                    "method": "folder",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_datastoreClusterId",
                            "method": "datastoreClusterId"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFolder",
                    "validate": false,
                    "optional": true,
                    "original": "folder"
                }
            ],
            "type": "NasDatastoreResource s",
            "original": "vsphere_nas_datastore"
        },
        {
            "con": {
                "smart": "resourcePoolResource",
                "name": "ResourcePoolResource'"
            },
            "arguments": [
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Determines if the reservation on a resource pool can grow beyond the",
                        "specified value, if the parent resource pool has unreserved resources."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_expandable\" <$> TF.attribute",
                    "name": "_cpuExpandable",
                    "method": "cpuExpandable",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasCpuExpandable",
                    "validate": false,
                    "optional": true,
                    "original": "cpu_expandable"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The utilization of a resource pool will not exceed this limit, even if there",
                        "are available resources. Set to -1 for unlimited."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_limit\" <$> TF.attribute",
                    "name": "_cpuLimit",
                    "method": "cpuLimit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasCpuLimit",
                    "validate": false,
                    "optional": true,
                    "original": "cpu_limit"
                },
                {
                    "default": "TF.value 0",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Amount of CPU (MHz) that is guaranteed available to the resource pool."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_reservation\" <$> TF.attribute",
                    "name": "_cpuReservation",
                    "method": "cpuReservation",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasCpuReservation",
                    "validate": false,
                    "optional": true,
                    "original": "cpu_reservation"
                },
                {
                    "default": "TF.value \"normal\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The allocation level. The level is a simplified view of shares. Levels map",
                        "to a pre-determined set of numeric values for shares. Can be one of low,",
                        "normal, high, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_share_level\" <$> TF.attribute",
                    "name": "_cpuShareLevel",
                    "method": "cpuShareLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCpuShareLevel",
                    "validate": false,
                    "optional": true,
                    "original": "cpu_share_level"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of custom attributes to set on this resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"custom_attributes\" <$> TF.attribute",
                    "name": "_customAttributes",
                    "method": "customAttributes",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasCustomAttributes",
                    "validate": false,
                    "optional": true,
                    "original": "custom_attributes"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Determines if the reservation on a resource pool can grow beyond the",
                        "specified value, if the parent resource pool has unreserved resources."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_expandable\" <$> TF.attribute",
                    "name": "_memoryExpandable",
                    "method": "memoryExpandable",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasMemoryExpandable",
                    "validate": false,
                    "optional": true,
                    "original": "memory_expandable"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The utilization of a resource pool will not exceed this limit, even if there",
                        "are available resources. Set to -1 for unlimited."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_limit\" <$> TF.attribute",
                    "name": "_memoryLimit",
                    "method": "memoryLimit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMemoryLimit",
                    "validate": false,
                    "optional": true,
                    "original": "memory_limit"
                },
                {
                    "default": "TF.value 0",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Amount of memory (MB) that is guaranteed available to the resource pool."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_reservation\" <$> TF.attribute",
                    "name": "_memoryReservation",
                    "method": "memoryReservation",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMemoryReservation",
                    "validate": false,
                    "optional": true,
                    "original": "memory_reservation"
                },
                {
                    "default": "TF.value \"normal\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The allocation level. The level is a simplified view of shares. Levels map",
                        "to a pre-determined set of numeric values for shares. Can be one of low,",
                        "normal, high, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_share_level\" <$> TF.attribute",
                    "name": "_memoryShareLevel",
                    "method": "memoryShareLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMemoryShareLevel",
                    "validate": false,
                    "optional": true,
                    "original": "memory_share_level"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of resource pool."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "_parentResourcePoolId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The ID of the root resource pool of the compute resource the resource pool",
                        "is in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"parent_resource_pool_id\" <$> TF.attribute",
                    "name": "_parentResourcePoolId",
                    "method": "parentResourcePoolId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasParentResourcePoolId",
                    "validate": false,
                    "optional": false,
                    "original": "parent_resource_pool_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of tag IDs to apply to this object."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tags\" <$> TF.attribute",
                    "name": "_tags",
                    "method": "tags",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTags",
                    "validate": false,
                    "optional": true,
                    "original": "tags"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/resource_pool.html",
            "key": "vsphere_resource_pool",
            "name": "ResourcePoolResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The number of shares allocated. Used to determine resource allocation in",
                        "case of resource contention. If this is set, cpu_share_level must be custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_shares\" <$> TF.attribute",
                    "name": "_computedCpuShares",
                    "method": "computedCpuShares",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedCpuShares",
                    "validate": false,
                    "optional": true,
                    "original": "cpu_shares"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The number of shares allocated. Used to determine resource allocation in",
                        "case of resource contention. If this is set, memory_share_level must be",
                        "custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_shares\" <$> TF.attribute",
                    "name": "_computedMemoryShares",
                    "method": "computedMemoryShares",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedMemoryShares",
                    "validate": false,
                    "optional": true,
                    "original": "memory_shares"
                }
            ],
            "parameters": [
                {
                    "default": "_parentResourcePoolId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The ID of the root resource pool of the compute resource the resource pool",
                        "is in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"parent_resource_pool_id\" <$> TF.attribute",
                    "name": "_parentResourcePoolId",
                    "method": "parentResourcePoolId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasParentResourcePoolId",
                    "validate": false,
                    "optional": false,
                    "original": "parent_resource_pool_id"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Name of resource pool."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "ResourcePoolResource s",
            "original": "vsphere_resource_pool"
        },
        {
            "con": {
                "smart": "storageDrsVmOverrideResource",
                "name": "StorageDrsVmOverrideResource'"
            },
            "arguments": [
                {
                    "default": "_datastoreClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the datastore cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"datastore_cluster_id\" <$> TF.attribute",
                    "name": "_datastoreClusterId",
                    "method": "datastoreClusterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastoreClusterId",
                    "validate": false,
                    "optional": false,
                    "original": "datastore_cluster_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Overrides any Storage DRS automation levels for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_automation_level\" <$> TF.attribute",
                    "name": "_sdrsAutomationLevel",
                    "method": "sdrsAutomationLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSdrsAutomationLevel",
                    "validate": false,
                    "optional": true,
                    "original": "sdrs_automation_level"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Overrides the default Storage DRS setting for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_enabled\" <$> TF.attribute",
                    "name": "_sdrsEnabled",
                    "method": "sdrsEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSdrsEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "sdrs_enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Overrides the intra-VM affinity setting for this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sdrs_intra_vm_affinity\" <$> TF.attribute",
                    "name": "_sdrsIntraVmAffinity",
                    "method": "sdrsIntraVmAffinity",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSdrsIntraVmAffinity",
                    "validate": false,
                    "optional": true,
                    "original": "sdrs_intra_vm_affinity"
                },
                {
                    "default": "_virtualMachineId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the virtual machine."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"virtual_machine_id\" <$> TF.attribute",
                    "name": "_virtualMachineId",
                    "method": "virtualMachineId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVirtualMachineId",
                    "validate": false,
                    "optional": false,
                    "original": "virtual_machine_id"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/storage_drs_vm_override.html",
            "key": "vsphere_storage_drs_vm_override",
            "name": "StorageDrsVmOverrideResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_datastoreClusterId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the datastore cluster."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"datastore_cluster_id\" <$> TF.attribute",
                    "name": "_datastoreClusterId",
                    "method": "datastoreClusterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastoreClusterId",
                    "validate": false,
                    "optional": false,
                    "original": "datastore_cluster_id"
                },
                {
                    "default": "_virtualMachineId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the virtual machine."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"virtual_machine_id\" <$> TF.attribute",
                    "name": "_virtualMachineId",
                    "method": "virtualMachineId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVirtualMachineId",
                    "validate": false,
                    "optional": false,
                    "original": "virtual_machine_id"
                }
            ],
            "conflicts": [],
            "type": "StorageDrsVmOverrideResource s",
            "original": "vsphere_storage_drs_vm_override"
        },
        {
            "con": {
                "smart": "tagResource",
                "name": "TagResource'"
            },
            "arguments": [
                {
                    "default": "_categoryId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique identifier of the parent category in which this tag will be",
                        "created."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"category_id\" <$> TF.attribute",
                    "name": "_categoryId",
                    "method": "categoryId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCategoryId",
                    "validate": false,
                    "optional": false,
                    "original": "category_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The description of the tag."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"description\" <$> TF.attribute",
                    "name": "_description",
                    "method": "description",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDescription",
                    "validate": false,
                    "optional": true,
                    "original": "description"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the tag. The name must be unique within its category."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/tag.html",
            "key": "vsphere_tag",
            "name": "TagResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_categoryId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The unique identifier of the parent category in which this tag will be",
                        "created."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"category_id\" <$> TF.attribute",
                    "name": "_categoryId",
                    "method": "categoryId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCategoryId",
                    "validate": false,
                    "optional": false,
                    "original": "category_id"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the tag. The name must be unique within its category."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "TagResource s",
            "original": "vsphere_tag"
        },
        {
            "con": {
                "smart": "tagCategoryResource",
                "name": "TagCategoryResource'"
            },
            "arguments": [
                {
                    "default": "_associableTypes",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Object types to which this category's tags can be attached."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"associable_types\" <$> TF.attribute",
                    "name": "_associableTypes",
                    "method": "associableTypes",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasAssociableTypes",
                    "validate": false,
                    "optional": false,
                    "original": "associable_types"
                },
                {
                    "default": "_cardinality",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The associated cardinality of the category. Can be one of SINGLE (object can",
                        "only be assigned one tag in this category) or MULTIPLE (object can be",
                        "assigned multiple tags in this category)."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"cardinality\" <$> TF.attribute",
                    "name": "_cardinality",
                    "method": "cardinality",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCardinality",
                    "validate": false,
                    "optional": false,
                    "original": "cardinality"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The description of the category."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"description\" <$> TF.attribute",
                    "name": "_description",
                    "method": "description",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDescription",
                    "validate": false,
                    "optional": true,
                    "original": "description"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the category."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/tag_category.html",
            "key": "vsphere_tag_category",
            "name": "TagCategoryResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_cardinality",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The associated cardinality of the category. Can be one of SINGLE (object can",
                        "only be assigned one tag in this category) or MULTIPLE (object can be",
                        "assigned multiple tags in this category)."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"cardinality\" <$> TF.attribute",
                    "name": "_cardinality",
                    "method": "cardinality",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCardinality",
                    "validate": false,
                    "optional": false,
                    "original": "cardinality"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The display name of the category."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "_associableTypes",
                    "computed": false,
                    "required": true,
                    "help": [
                        "Object types to which this category's tags can be attached."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"associable_types\" <$> TF.attribute",
                    "name": "_associableTypes",
                    "method": "associableTypes",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasAssociableTypes",
                    "validate": false,
                    "optional": false,
                    "original": "associable_types"
                }
            ],
            "conflicts": [],
            "type": "TagCategoryResource s",
            "original": "vsphere_tag_category"
        },
        {
            "con": {
                "smart": "vappContainerResource",
                "name": "VappContainerResource'"
            },
            "arguments": [
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Determines if the reservation on a vApp container can grow beyond the",
                        "specified value, if the parent resource pool has unreserved resources."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_expandable\" <$> TF.attribute",
                    "name": "_cpuExpandable",
                    "method": "cpuExpandable",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasCpuExpandable",
                    "validate": false,
                    "optional": true,
                    "original": "cpu_expandable"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The utilization of a vApp container will not exceed this limit, even if",
                        "there are available resources. Set to -1 for unlimited."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_limit\" <$> TF.attribute",
                    "name": "_cpuLimit",
                    "method": "cpuLimit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasCpuLimit",
                    "validate": false,
                    "optional": true,
                    "original": "cpu_limit"
                },
                {
                    "default": "TF.value 0",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Amount of CPU (MHz) that is guaranteed available to the vApp container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_reservation\" <$> TF.attribute",
                    "name": "_cpuReservation",
                    "method": "cpuReservation",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasCpuReservation",
                    "validate": false,
                    "optional": true,
                    "original": "cpu_reservation"
                },
                {
                    "default": "TF.value \"normal\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The allocation level. The level is a simplified view of shares. Levels map",
                        "to a pre-determined set of numeric values for shares. Can be one of low,",
                        "normal, high, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_share_level\" <$> TF.attribute",
                    "name": "_cpuShareLevel",
                    "method": "cpuShareLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCpuShareLevel",
                    "validate": false,
                    "optional": true,
                    "original": "cpu_share_level"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of custom attributes to set on this resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"custom_attributes\" <$> TF.attribute",
                    "name": "_customAttributes",
                    "method": "customAttributes",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasCustomAttributes",
                    "validate": false,
                    "optional": true,
                    "original": "custom_attributes"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Determines if the reservation on a vApp container can grow beyond the",
                        "specified value, if the parent resource pool has unreserved resources."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_expandable\" <$> TF.attribute",
                    "name": "_memoryExpandable",
                    "method": "memoryExpandable",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasMemoryExpandable",
                    "validate": false,
                    "optional": true,
                    "original": "memory_expandable"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The utilization of a vApp container will not exceed this limit, even if",
                        "there are available resources. Set to -1 for unlimited."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_limit\" <$> TF.attribute",
                    "name": "_memoryLimit",
                    "method": "memoryLimit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMemoryLimit",
                    "validate": false,
                    "optional": true,
                    "original": "memory_limit"
                },
                {
                    "default": "TF.value 0",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Amount of memory (MB) that is guaranteed available to the vApp container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_reservation\" <$> TF.attribute",
                    "name": "_memoryReservation",
                    "method": "memoryReservation",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMemoryReservation",
                    "validate": false,
                    "optional": true,
                    "original": "memory_reservation"
                },
                {
                    "default": "TF.value \"normal\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The allocation level. The level is a simplified view of shares. Levels map",
                        "to a pre-determined set of numeric values for shares. Can be one of low,",
                        "normal, high, or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_share_level\" <$> TF.attribute",
                    "name": "_memoryShareLevel",
                    "method": "memoryShareLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMemoryShareLevel",
                    "validate": false,
                    "optional": true,
                    "original": "memory_share_level"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the vApp container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The ID of the parent VM folder."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"parent_folder_id\" <$> TF.attribute",
                    "name": "_parentFolderId",
                    "method": "parentFolderId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasParentFolderId",
                    "validate": false,
                    "optional": true,
                    "original": "parent_folder_id"
                },
                {
                    "default": "_parentResourcePoolId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the parent resource pool or the compute resource",
                        "the vApp container is in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"parent_resource_pool_id\" <$> TF.attribute",
                    "name": "_parentResourcePoolId",
                    "method": "parentResourcePoolId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasParentResourcePoolId",
                    "validate": false,
                    "optional": false,
                    "original": "parent_resource_pool_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of tag IDs to apply to this object."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tags\" <$> TF.attribute",
                    "name": "_tags",
                    "method": "tags",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTags",
                    "validate": false,
                    "optional": true,
                    "original": "tags"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/vapp_container.html",
            "key": "vsphere_vapp_container",
            "name": "VappContainerResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The number of shares allocated. Used to determine resource allocation in",
                        "case of resource contention. If this is set, cpu_share_level must be custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_shares\" <$> TF.attribute",
                    "name": "_computedCpuShares",
                    "method": "computedCpuShares",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedCpuShares",
                    "validate": false,
                    "optional": true,
                    "original": "cpu_shares"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The number of shares allocated. Used to determine resource allocation in",
                        "case of resource contention. If this is set, memory_share_level must be",
                        "custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_shares\" <$> TF.attribute",
                    "name": "_computedMemoryShares",
                    "method": "computedMemoryShares",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedMemoryShares",
                    "validate": false,
                    "optional": true,
                    "original": "memory_shares"
                }
            ],
            "parameters": [
                {
                    "default": "_parentResourcePoolId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the parent resource pool or the compute resource",
                        "the vApp container is in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"parent_resource_pool_id\" <$> TF.attribute",
                    "name": "_parentResourcePoolId",
                    "method": "parentResourcePoolId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasParentResourcePoolId",
                    "validate": false,
                    "optional": false,
                    "original": "parent_resource_pool_id"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the vApp container."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "VappContainerResource s",
            "original": "vsphere_vapp_container"
        },
        {
            "con": {
                "smart": "virtualDiskResource",
                "name": "VirtualDiskResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"create_directories\" <$> TF.attribute",
                    "name": "_createDirectories",
                    "method": "createDirectories",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasCreateDirectories",
                    "validate": false,
                    "optional": true,
                    "original": "create_directories"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"datacenter\" <$> TF.attribute",
                    "name": "_datacenter",
                    "method": "datacenter",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatacenter",
                    "validate": false,
                    "optional": true,
                    "original": "datacenter"
                },
                {
                    "default": "_datastore",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"datastore\" <$> TF.attribute",
                    "name": "_datastore",
                    "method": "datastore",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastore",
                    "validate": false,
                    "optional": false,
                    "original": "datastore"
                },
                {
                    "default": "_size",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"size\" <$> TF.attribute",
                    "name": "_size",
                    "method": "size",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasSize",
                    "validate": false,
                    "optional": false,
                    "original": "size"
                },
                {
                    "default": "TF.value \"eagerZeroedThick\"",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"type\" <$> TF.attribute",
                    "name": "_type'",
                    "method": "type'",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasType'",
                    "validate": false,
                    "optional": true,
                    "original": "type"
                },
                {
                    "default": "_vmdkPath",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"vmdk_path\" <$> TF.attribute",
                    "name": "_vmdkPath",
                    "method": "vmdkPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVmdkPath",
                    "validate": false,
                    "optional": false,
                    "original": "vmdk_path"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/virtual_disk.html",
            "key": "vsphere_virtual_disk",
            "name": "VirtualDiskResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_datastore",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"datastore\" <$> TF.attribute",
                    "name": "_datastore",
                    "method": "datastore",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastore",
                    "validate": false,
                    "optional": false,
                    "original": "datastore"
                },
                {
                    "default": "_vmdkPath",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"vmdk_path\" <$> TF.attribute",
                    "name": "_vmdkPath",
                    "method": "vmdkPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVmdkPath",
                    "validate": false,
                    "optional": false,
                    "original": "vmdk_path"
                },
                {
                    "default": "_size",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"size\" <$> TF.attribute",
                    "name": "_size",
                    "method": "size",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasSize",
                    "validate": false,
                    "optional": false,
                    "original": "size"
                }
            ],
            "conflicts": [],
            "type": "VirtualDiskResource s",
            "original": "vsphere_virtual_disk"
        },
        {
            "con": {
                "smart": "virtualMachineResource",
                "name": "VirtualMachineResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The guest name for the operating system when guest_id is other or other-64."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"alternate_guest_name\" <$> TF.attribute",
                    "name": "_alternateGuestName",
                    "method": "alternateGuestName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasAlternateGuestName",
                    "validate": false,
                    "optional": true,
                    "original": "alternate_guest_name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "User-provided description of the virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"annotation\" <$> TF.attribute",
                    "name": "_annotation",
                    "method": "annotation",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasAnnotation",
                    "validate": false,
                    "optional": true,
                    "original": "annotation"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The number of milliseconds to wait before starting the boot sequence."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"boot_delay\" <$> TF.attribute",
                    "name": "_bootDelay",
                    "method": "bootDelay",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasBootDelay",
                    "validate": false,
                    "optional": true,
                    "original": "boot_delay"
                },
                {
                    "default": "TF.value 10000",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The number of milliseconds to wait before retrying the boot sequence. This",
                        "only valid if boot_retry_enabled is true."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"boot_retry_delay\" <$> TF.attribute",
                    "name": "_bootRetryDelay",
                    "method": "bootRetryDelay",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasBootRetryDelay",
                    "validate": false,
                    "optional": true,
                    "original": "boot_retry_delay"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "If set to true, a virtual machine that fails to boot will try again after",
                        "the delay defined in boot_retry_delay."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"boot_retry_enabled\" <$> TF.attribute",
                    "name": "_bootRetryEnabled",
                    "method": "bootRetryEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasBootRetryEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "boot_retry_enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A specification for a CDROM device on this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cdrom\" <$> TF.attribute",
                    "name": "_cdrom",
                    "method": "cdrom",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (CdromSetting s)",
                    "class": "HasCdrom",
                    "validate": true,
                    "optional": true,
                    "original": "cdrom"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A specification for cloning a virtual machine from template."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"clone\" <$> TF.attribute",
                    "name": "_clone",
                    "method": "clone",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (CloneSetting s)",
                    "class": "HasClone",
                    "validate": true,
                    "optional": true,
                    "original": "clone"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow CPUs to be added to this virtual machine while it is running."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_hot_add_enabled\" <$> TF.attribute",
                    "name": "_cpuHotAddEnabled",
                    "method": "cpuHotAddEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasCpuHotAddEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "cpu_hot_add_enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow CPUs to be added to this virtual machine while it is running."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_hot_remove_enabled\" <$> TF.attribute",
                    "name": "_cpuHotRemoveEnabled",
                    "method": "cpuHotRemoveEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasCpuHotRemoveEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "cpu_hot_remove_enabled"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The maximum amount of memory (in MB) or CPU (in MHz) that this virtual",
                        "machine can consume, regardless of available resources.%!(EXTRA string=cpu)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_limit\" <$> TF.attribute",
                    "name": "_cpuLimit",
                    "method": "cpuLimit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasCpuLimit",
                    "validate": false,
                    "optional": true,
                    "original": "cpu_limit"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable CPU performance counters on this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_performance_counters_enabled\" <$> TF.attribute",
                    "name": "_cpuPerformanceCountersEnabled",
                    "method": "cpuPerformanceCountersEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasCpuPerformanceCountersEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "cpu_performance_counters_enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The amount of memory (in MB) or CPU (in MHz) that this virtual machine is",
                        "guaranteed.%!(EXTRA string=cpu)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_reservation\" <$> TF.attribute",
                    "name": "_cpuReservation",
                    "method": "cpuReservation",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasCpuReservation",
                    "validate": false,
                    "optional": true,
                    "original": "cpu_reservation"
                },
                {
                    "default": "TF.value \"normal\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The allocation level for cpu resources. Can be one of high, low, normal, or",
                        "custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_share_level\" <$> TF.attribute",
                    "name": "_cpuShareLevel",
                    "method": "cpuShareLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasCpuShareLevel",
                    "validate": false,
                    "optional": true,
                    "original": "cpu_share_level"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of custom attributes to set on this resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"custom_attributes\" <$> TF.attribute",
                    "name": "_customAttributes",
                    "method": "customAttributes",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasCustomAttributes",
                    "validate": false,
                    "optional": true,
                    "original": "custom_attributes"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The ID of a datastore cluster to put the virtual machine in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datastore_cluster_id\" <$> TF.attribute",
                    "name": "_datastoreClusterId",
                    "method": "datastoreClusterId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastoreClusterId",
                    "validate": false,
                    "optional": true,
                    "original": "datastore_cluster_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "When the boot type set in firmware is efi, this enables EFI secure boot."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"efi_secure_boot_enabled\" <$> TF.attribute",
                    "name": "_efiSecureBootEnabled",
                    "method": "efiSecureBootEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasEfiSecureBootEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "efi_secure_boot_enabled"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Expose the UUIDs of attached virtual disks to the virtual machine, allowing",
                        "access to them in the guest."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"enable_disk_uuid\" <$> TF.attribute",
                    "name": "_enableDiskUuid",
                    "method": "enableDiskUuid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasEnableDiskUuid",
                    "validate": false,
                    "optional": true,
                    "original": "enable_disk_uuid"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable logging on this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"enable_logging\" <$> TF.attribute",
                    "name": "_enableLogging",
                    "method": "enableLogging",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasEnableLogging",
                    "validate": false,
                    "optional": true,
                    "original": "enable_logging"
                },
                {
                    "default": "TF.value \"automatic\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The EPT/RVI (hardware memory virtualization) setting for this virtual",
                        "machine. Can be one of automatic, on, or off."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"ept_rvi_mode\" <$> TF.attribute",
                    "name": "_eptRviMode",
                    "method": "eptRviMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasEptRviMode",
                    "validate": false,
                    "optional": true,
                    "original": "ept_rvi_mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Extra configuration data for this virtual machine. Can be used to supply",
                        "advanced parameters not normally in configuration, such as data for",
                        "cloud-config (under the guestinfo namespace), or configuration data for OVF",
                        "images."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"extra_config\" <$> TF.attribute",
                    "name": "_extraConfig",
                    "method": "extraConfig",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasExtraConfig",
                    "validate": false,
                    "optional": true,
                    "original": "extra_config"
                },
                {
                    "default": "TF.value \"bios\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The firmware interface to use on the virtual machine. Can be one of bios or",
                        "EFI."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"firmware\" <$> TF.attribute",
                    "name": "_firmware",
                    "method": "firmware",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFirmware",
                    "validate": false,
                    "optional": true,
                    "original": "firmware"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The name of the folder to locate the virtual machine in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"folder\" <$> TF.attribute",
                    "name": "_folder",
                    "method": "folder",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFolder",
                    "validate": false,
                    "optional": true,
                    "original": "folder"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Set to true to force power-off a virtual machine if a graceful guest",
                        "shutdown failed for a necessary operation."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"force_power_off\" <$> TF.attribute",
                    "name": "_forcePowerOff",
                    "method": "forcePowerOff",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasForcePowerOff",
                    "validate": false,
                    "optional": true,
                    "original": "force_power_off"
                },
                {
                    "default": "TF.value \"other-64\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The guest ID for the operating system."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"guest_id\" <$> TF.attribute",
                    "name": "_guestId",
                    "method": "guestId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasGuestId",
                    "validate": false,
                    "optional": true,
                    "original": "guest_id"
                },
                {
                    "default": "TF.value \"hvAuto\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The (non-nested) hardware virtualization setting for this virtual machine.",
                        "Can be one of hvAuto, hvOn, or hvOff."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"hv_mode\" <$> TF.attribute",
                    "name": "_hvMode",
                    "method": "hvMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHvMode",
                    "validate": false,
                    "optional": true,
                    "original": "hv_mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Controls the scheduling delay of the virtual machine. Use a higher",
                        "sensitivity for applications that require lower latency, such as VOIP, media",
                        "player applications, or applications that require frequent access to mouse",
                        "or keyboard devices. Can be one of low, normal, medium, or high."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"latency_sensitivity\" <$> TF.attribute",
                    "name": "_latencySensitivity",
                    "method": "latencySensitivity",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasLatencySensitivity",
                    "validate": false,
                    "optional": true,
                    "original": "latency_sensitivity"
                },
                {
                    "default": "TF.value 1024",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The size of the virtual machine's memory, in MB."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_memory",
                    "method": "memory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMemory",
                    "validate": false,
                    "optional": true,
                    "original": "memory"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Allow memory to be added to this virtual machine while it is running."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_hot_add_enabled\" <$> TF.attribute",
                    "name": "_memoryHotAddEnabled",
                    "method": "memoryHotAddEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasMemoryHotAddEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "memory_hot_add_enabled"
                },
                {
                    "default": "TF.value (-1)",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The maximum amount of memory (in MB) or CPU (in MHz) that this virtual",
                        "machine can consume, regardless of available resources.%!(EXTRA",
                        "string=memory)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_limit\" <$> TF.attribute",
                    "name": "_memoryLimit",
                    "method": "memoryLimit",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMemoryLimit",
                    "validate": false,
                    "optional": true,
                    "original": "memory_limit"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The amount of memory (in MB) or CPU (in MHz) that this virtual machine is",
                        "guaranteed.%!(EXTRA string=memory)"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_reservation\" <$> TF.attribute",
                    "name": "_memoryReservation",
                    "method": "memoryReservation",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMemoryReservation",
                    "validate": false,
                    "optional": true,
                    "original": "memory_reservation"
                },
                {
                    "default": "TF.value \"normal\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The allocation level for memory resources. Can be one of high, low, normal,",
                        "or custom."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_share_level\" <$> TF.attribute",
                    "name": "_memoryShareLevel",
                    "method": "memoryShareLevel",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasMemoryShareLevel",
                    "validate": false,
                    "optional": true,
                    "original": "memory_share_level"
                },
                {
                    "default": "TF.value 30",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The amount of time, in minutes, to wait for a vMotion operation to complete",
                        "before failing."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"migrate_wait_timeout\" <$> TF.attribute",
                    "name": "_migrateWaitTimeout",
                    "method": "migrateWaitTimeout",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasMigrateWaitTimeout",
                    "validate": false,
                    "optional": true,
                    "original": "migrate_wait_timeout"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable nested hardware virtualization on this virtual machine, facilitating",
                        "nested virtualization in the guest."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"nested_hv_enabled\" <$> TF.attribute",
                    "name": "_nestedHvEnabled",
                    "method": "nestedHvEnabled",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasNestedHvEnabled",
                    "validate": false,
                    "optional": true,
                    "original": "nested_hv_enabled"
                },
                {
                    "default": "_networkInterface",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A specification for a virtual NIC on this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_interface\" <$> TF.attribute",
                    "name": "_networkInterface",
                    "method": "networkInterface",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (NetworkInterfaceSetting s)]",
                    "class": "HasNetworkInterface",
                    "validate": false,
                    "optional": false,
                    "original": "network_interface"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The number of cores to distribute amongst the CPUs in this virtual machine.",
                        "If specified, the value supplied to num_cpus must be evenly divisible by",
                        "this value."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"num_cores_per_socket\" <$> TF.attribute",
                    "name": "_numCoresPerSocket",
                    "method": "numCoresPerSocket",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasNumCoresPerSocket",
                    "validate": false,
                    "optional": true,
                    "original": "num_cores_per_socket"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The number of virtual processors to assign to this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"num_cpus\" <$> TF.attribute",
                    "name": "_numCpus",
                    "method": "numCpus",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasNumCpus",
                    "validate": false,
                    "optional": true,
                    "original": "num_cpus"
                },
                {
                    "default": "_resourcePoolId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The ID of a resource pool to put the virtual machine in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_pool_id\" <$> TF.attribute",
                    "name": "_resourcePoolId",
                    "method": "resourcePoolId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResourcePoolId",
                    "validate": false,
                    "optional": false,
                    "original": "resource_pool_id"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable the execution of post-power-on scripts when VMware tools is",
                        "installed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_tools_scripts_after_power_on\" <$> TF.attribute",
                    "name": "_runToolsScriptsAfterPowerOn",
                    "method": "runToolsScriptsAfterPowerOn",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRunToolsScriptsAfterPowerOn",
                    "validate": false,
                    "optional": true,
                    "original": "run_tools_scripts_after_power_on"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable the execution of post-resume scripts when VMware tools is installed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_tools_scripts_after_resume\" <$> TF.attribute",
                    "name": "_runToolsScriptsAfterResume",
                    "method": "runToolsScriptsAfterResume",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRunToolsScriptsAfterResume",
                    "validate": false,
                    "optional": true,
                    "original": "run_tools_scripts_after_resume"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable the execution of pre-reboot scripts when VMware tools is installed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_tools_scripts_before_guest_reboot\" <$> TF.attribute",
                    "name": "_runToolsScriptsBeforeGuestReboot",
                    "method": "runToolsScriptsBeforeGuestReboot",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRunToolsScriptsBeforeGuestReboot",
                    "validate": false,
                    "optional": true,
                    "original": "run_tools_scripts_before_guest_reboot"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable the execution of pre-shutdown scripts when VMware tools is installed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_tools_scripts_before_guest_shutdown\" <$> TF.attribute",
                    "name": "_runToolsScriptsBeforeGuestShutdown",
                    "method": "runToolsScriptsBeforeGuestShutdown",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRunToolsScriptsBeforeGuestShutdown",
                    "validate": false,
                    "optional": true,
                    "original": "run_tools_scripts_before_guest_shutdown"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable the execution of pre-standby scripts when VMware tools is installed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"run_tools_scripts_before_guest_standby\" <$> TF.attribute",
                    "name": "_runToolsScriptsBeforeGuestStandby",
                    "method": "runToolsScriptsBeforeGuestStandby",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRunToolsScriptsBeforeGuestStandby",
                    "validate": false,
                    "optional": true,
                    "original": "run_tools_scripts_before_guest_standby"
                },
                {
                    "default": "TF.value \"noSharing\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Mode for sharing the SCSI bus. The modes are physicalSharing,",
                        "virtualSharing, and noSharing."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scsi_bus_sharing\" <$> TF.attribute",
                    "name": "_scsiBusSharing",
                    "method": "scsiBusSharing",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScsiBusSharing",
                    "validate": false,
                    "optional": true,
                    "original": "scsi_bus_sharing"
                },
                {
                    "default": "TF.value 1",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The number of SCSI controllers that Terraform manages on this virtual",
                        "machine. This directly affects the amount of disks you can add to the",
                        "virtual machine and the maximum disk unit number. Note that lowering this",
                        "value does not remove controllers."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scsi_controller_count\" <$> TF.attribute",
                    "name": "_scsiControllerCount",
                    "method": "scsiControllerCount",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasScsiControllerCount",
                    "validate": false,
                    "optional": true,
                    "original": "scsi_controller_count"
                },
                {
                    "default": "TF.value \"pvscsi\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The type of SCSI bus this virtual machine will have. Can be one of lsilogic,",
                        "lsilogic-sas or pvscsi."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"scsi_type\" <$> TF.attribute",
                    "name": "_scsiType",
                    "method": "scsiType",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasScsiType",
                    "validate": false,
                    "optional": true,
                    "original": "scsi_type"
                },
                {
                    "default": "TF.value 3",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The amount of time, in minutes, to wait for shutdown when making necessary",
                        "updates to the virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"shutdown_wait_timeout\" <$> TF.attribute",
                    "name": "_shutdownWaitTimeout",
                    "method": "shutdownWaitTimeout",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasShutdownWaitTimeout",
                    "validate": false,
                    "optional": true,
                    "original": "shutdown_wait_timeout"
                },
                {
                    "default": "TF.value \"inherit\"",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The swap file placement policy for this virtual machine. Can be one of",
                        "inherit, hostLocal, or vmDirectory."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"swap_placement_policy\" <$> TF.attribute",
                    "name": "_swapPlacementPolicy",
                    "method": "swapPlacementPolicy",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSwapPlacementPolicy",
                    "validate": false,
                    "optional": true,
                    "original": "swap_placement_policy"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Enable guest clock synchronization with the host. Requires VMware tools to",
                        "be installed."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"sync_time_with_host\" <$> TF.attribute",
                    "name": "_syncTimeWithHost",
                    "method": "syncTimeWithHost",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasSyncTimeWithHost",
                    "validate": false,
                    "optional": true,
                    "original": "sync_time_with_host"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of tag IDs to apply to this object."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tags\" <$> TF.attribute",
                    "name": "_tags",
                    "method": "tags",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTags",
                    "validate": false,
                    "optional": true,
                    "original": "tags"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "VApp configuration data for this virtual machine. Can be used to provide",
                        "configuration data for OVF images."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vapp\" <$> TF.attribute",
                    "name": "_vapp",
                    "method": "vapp",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (VappSetting s)",
                    "class": "HasVapp",
                    "validate": true,
                    "optional": true,
                    "original": "vapp"
                },
                {
                    "default": "TF.value P.True",
                    "computed": false,
                    "required": false,
                    "help": [
                        "Controls whether or not the guest network waiter waits for a routable",
                        "address. When false, the waiter does not wait for a default gateway, nor are",
                        "IP addresses checked against any discovered default gateways as part of its",
                        "success criteria."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"wait_for_guest_net_routable\" <$> TF.attribute",
                    "name": "_waitForGuestNetRoutable",
                    "method": "waitForGuestNetRoutable",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasWaitForGuestNetRoutable",
                    "validate": false,
                    "optional": true,
                    "original": "wait_for_guest_net_routable"
                },
                {
                    "default": "TF.value 5",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The amount of time, in minutes, to wait for an available IP address on this",
                        "virtual machine. A value less than 1 disables the waiter."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"wait_for_guest_net_timeout\" <$> TF.attribute",
                    "name": "_waitForGuestNetTimeout",
                    "method": "waitForGuestNetTimeout",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasWaitForGuestNetTimeout",
                    "validate": false,
                    "optional": true,
                    "original": "wait_for_guest_net_timeout"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/virtual_machine.html",
            "key": "vsphere_virtual_machine",
            "name": "VirtualMachineResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A unique identifier for a given version of the last configuration applied,",
                        "such the timestamp of the last update to the configuration."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"change_version\" <$> TF.attribute",
                    "name": "_computedChangeVersion",
                    "method": "computedChangeVersion",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedChangeVersion",
                    "validate": false,
                    "optional": false,
                    "original": "change_version"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of shares to allocate to cpu for a custom share level."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"cpu_share_count\" <$> TF.attribute",
                    "name": "_computedCpuShareCount",
                    "method": "computedCpuShareCount",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedCpuShareCount",
                    "validate": false,
                    "optional": true,
                    "original": "cpu_share_count"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The ID of the virtual machine's datastore. The virtual machine configuration",
                        "is placed here, along with any virtual disks that are created without",
                        "datastores."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datastore_id\" <$> TF.attribute",
                    "name": "_computedDatastoreId",
                    "method": "computedDatastoreId",
                    "threaded": true,
                    "conflicts": [
                        "_datastoreClusterId"
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedDatastoreId",
                    "validate": false,
                    "optional": true,
                    "original": "datastore_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The IP address selected by Terraform to be used for the provisioner."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"default_ip_address\" <$> TF.attribute",
                    "name": "_computedDefaultIpAddress",
                    "method": "computedDefaultIpAddress",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedDefaultIpAddress",
                    "validate": false,
                    "optional": false,
                    "original": "default_ip_address"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A specification for a virtual disk device on this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disk\" <$> TF.attribute",
                    "name": "_computedDisk",
                    "method": "computedDisk",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (DiskSetting s)]",
                    "class": "HasComputedDisk",
                    "validate": false,
                    "optional": true,
                    "original": "disk"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The current list of IP addresses on this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"guest_ip_addresses\" <$> TF.attribute",
                    "name": "_computedGuestIpAddresses",
                    "method": "computedGuestIpAddresses",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedGuestIpAddresses",
                    "validate": false,
                    "optional": false,
                    "original": "guest_ip_addresses"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The ID of an optional host system to pin the virtual machine to."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "_computedHostSystemId",
                    "method": "computedHostSystemId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedHostSystemId",
                    "validate": false,
                    "optional": true,
                    "original": "host_system_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "A flag internal to Terraform that indicates that this resource was either",
                        "imported or came from a earlier major version of this resource. Reset after",
                        "the first post-import or post-upgrade apply."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"imported\" <$> TF.attribute",
                    "name": "_computedImported",
                    "method": "computedImported",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedImported",
                    "validate": false,
                    "optional": false,
                    "original": "imported"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The amount of shares to allocate to memory for a custom share level."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"memory_share_count\" <$> TF.attribute",
                    "name": "_computedMemoryShareCount",
                    "method": "computedMemoryShareCount",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedMemoryShareCount",
                    "validate": false,
                    "optional": true,
                    "original": "memory_share_count"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The machine object ID from VMWare"
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"moid\" <$> TF.attribute",
                    "name": "_computedMoid",
                    "method": "computedMoid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMoid",
                    "validate": false,
                    "optional": false,
                    "original": "moid"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Value internal to Terraform used to determine if a configuration set change",
                        "requires a reboot."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"reboot_required\" <$> TF.attribute",
                    "name": "_computedRebootRequired",
                    "method": "computedRebootRequired",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedRebootRequired",
                    "validate": false,
                    "optional": false,
                    "original": "reboot_required"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The UUID of the virtual machine. Also exposed as the ID of the resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uuid\" <$> TF.attribute",
                    "name": "_computedUuid",
                    "method": "computedUuid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUuid",
                    "validate": false,
                    "optional": false,
                    "original": "uuid"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "VApp transport methods supported by virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vapp_transport\" <$> TF.attribute",
                    "name": "_computedVappTransport",
                    "method": "computedVappTransport",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasComputedVappTransport",
                    "validate": false,
                    "optional": false,
                    "original": "vapp_transport"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The state of VMware tools in the guest. This will determine the proper",
                        "course of action for some device operations."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vmware_tools_status\" <$> TF.attribute",
                    "name": "_computedVmwareToolsStatus",
                    "method": "computedVmwareToolsStatus",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedVmwareToolsStatus",
                    "validate": false,
                    "optional": false,
                    "original": "vmware_tools_status"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The path of the virtual machine's configuration file in the VM's datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"vmx_path\" <$> TF.attribute",
                    "name": "_computedVmxPath",
                    "method": "computedVmxPath",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedVmxPath",
                    "validate": false,
                    "optional": false,
                    "original": "vmx_path"
                }
            ],
            "parameters": [
                {
                    "default": "_resourcePoolId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The ID of a resource pool to put the virtual machine in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"resource_pool_id\" <$> TF.attribute",
                    "name": "_resourcePoolId",
                    "method": "resourcePoolId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasResourcePoolId",
                    "validate": false,
                    "optional": false,
                    "original": "resource_pool_id"
                },
                {
                    "default": "_networkInterface",
                    "computed": false,
                    "required": true,
                    "help": [
                        "A specification for a virtual NIC on this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"network_interface\" <$> TF.attribute",
                    "name": "_networkInterface",
                    "method": "networkInterface",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s (NetworkInterfaceSetting s)]",
                    "class": "HasNetworkInterface",
                    "validate": false,
                    "optional": false,
                    "original": "network_interface"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of this virtual machine."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [],
            "type": "VirtualMachineResource s",
            "original": "vsphere_virtual_machine"
        },
        {
            "con": {
                "smart": "virtualMachineSnapshotResource",
                "name": "VirtualMachineSnapshotResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"consolidate\" <$> TF.attribute",
                    "name": "_consolidate",
                    "method": "consolidate",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasConsolidate",
                    "validate": false,
                    "optional": true,
                    "original": "consolidate"
                },
                {
                    "default": "_description",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"description\" <$> TF.attribute",
                    "name": "_description",
                    "method": "description",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDescription",
                    "validate": false,
                    "optional": false,
                    "original": "description"
                },
                {
                    "default": "_memory",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_memory",
                    "method": "memory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasMemory",
                    "validate": false,
                    "optional": false,
                    "original": "memory"
                },
                {
                    "default": "_quiesce",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"quiesce\" <$> TF.attribute",
                    "name": "_quiesce",
                    "method": "quiesce",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasQuiesce",
                    "validate": false,
                    "optional": false,
                    "original": "quiesce"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"remove_children\" <$> TF.attribute",
                    "name": "_removeChildren",
                    "method": "removeChildren",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasRemoveChildren",
                    "validate": false,
                    "optional": true,
                    "original": "remove_children"
                },
                {
                    "default": "_snapshotName",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"snapshot_name\" <$> TF.attribute",
                    "name": "_snapshotName",
                    "method": "snapshotName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSnapshotName",
                    "validate": false,
                    "optional": false,
                    "original": "snapshot_name"
                },
                {
                    "default": "_virtualMachineUuid",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"virtual_machine_uuid\" <$> TF.attribute",
                    "name": "_virtualMachineUuid",
                    "method": "virtualMachineUuid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVirtualMachineUuid",
                    "validate": false,
                    "optional": false,
                    "original": "virtual_machine_uuid"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/virtual_machine_snapshot.html",
            "key": "vsphere_virtual_machine_snapshot",
            "name": "VirtualMachineSnapshotResource",
            "threaded": true,
            "attributes": [],
            "parameters": [
                {
                    "default": "_description",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"description\" <$> TF.attribute",
                    "name": "_description",
                    "method": "description",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDescription",
                    "validate": false,
                    "optional": false,
                    "original": "description"
                },
                {
                    "default": "_memory",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"memory\" <$> TF.attribute",
                    "name": "_memory",
                    "method": "memory",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasMemory",
                    "validate": false,
                    "optional": false,
                    "original": "memory"
                },
                {
                    "default": "_snapshotName",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"snapshot_name\" <$> TF.attribute",
                    "name": "_snapshotName",
                    "method": "snapshotName",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasSnapshotName",
                    "validate": false,
                    "optional": false,
                    "original": "snapshot_name"
                },
                {
                    "default": "_quiesce",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"quiesce\" <$> TF.attribute",
                    "name": "_quiesce",
                    "method": "quiesce",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasQuiesce",
                    "validate": false,
                    "optional": false,
                    "original": "quiesce"
                },
                {
                    "default": "_virtualMachineUuid",
                    "computed": false,
                    "required": true,
                    "help": [],
                    "forceNew": true,
                    "encoder": "TF.assign \"virtual_machine_uuid\" <$> TF.attribute",
                    "name": "_virtualMachineUuid",
                    "method": "virtualMachineUuid",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasVirtualMachineUuid",
                    "validate": false,
                    "optional": false,
                    "original": "virtual_machine_uuid"
                }
            ],
            "conflicts": [],
            "type": "VirtualMachineSnapshotResource s",
            "original": "vsphere_virtual_machine_snapshot"
        },
        {
            "con": {
                "smart": "vmfsDatastoreResource",
                "name": "VmfsDatastoreResource'"
            },
            "arguments": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of custom attributes to set on this resource."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"custom_attributes\" <$> TF.attribute",
                    "name": "_customAttributes",
                    "method": "customAttributes",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.Map P.Text (TF.Attr s P.Text))",
                    "class": "HasCustomAttributes",
                    "validate": false,
                    "optional": true,
                    "original": "custom_attributes"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object ID of the datastore cluster to place the datastore in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datastore_cluster_id\" <$> TF.attribute",
                    "name": "_datastoreClusterId",
                    "method": "datastoreClusterId",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_folder",
                            "method": "folder"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastoreClusterId",
                    "validate": false,
                    "optional": true,
                    "original": "datastore_cluster_id"
                },
                {
                    "default": "_disks",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The disks to add to the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disks\" <$> TF.attribute",
                    "name": "_disks",
                    "method": "disks",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (TF.Attr s P.Text))",
                    "class": "HasDisks",
                    "validate": false,
                    "optional": false,
                    "original": "disks"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The path to the datastore folder to put the datastore in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"folder\" <$> TF.attribute",
                    "name": "_folder",
                    "method": "folder",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_datastoreClusterId",
                            "method": "datastoreClusterId"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFolder",
                    "validate": false,
                    "optional": true,
                    "original": "folder"
                },
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host to set up the datastore on."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "_hostSystemId",
                    "method": "hostSystemId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "validate": false,
                    "optional": false,
                    "original": "host_system_id"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "A list of tag IDs to apply to this object."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"tags\" <$> TF.attribute",
                    "name": "_tags",
                    "method": "tags",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s [TF.Attr s P.Text]",
                    "class": "HasTags",
                    "validate": false,
                    "optional": true,
                    "original": "tags"
                }
            ],
            "url": "https://www.terraform.io/docs/providers/vsphere/r/vmfs_datastore.html",
            "key": "vsphere_vmfs_datastore",
            "name": "VmfsDatastoreResource",
            "threaded": true,
            "attributes": [
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The connectivity status of the datastore. If this is false, some other",
                        "computed attributes may be out of date."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"accessible\" <$> TF.attribute",
                    "name": "_computedAccessible",
                    "method": "computedAccessible",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedAccessible",
                    "validate": false,
                    "optional": false,
                    "original": "accessible"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Maximum capacity of the datastore, in MB."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"capacity\" <$> TF.attribute",
                    "name": "_computedCapacity",
                    "method": "computedCapacity",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedCapacity",
                    "validate": false,
                    "optional": false,
                    "original": "capacity"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Available space of this datastore, in MB."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"free_space\" <$> TF.attribute",
                    "name": "_computedFreeSpace",
                    "method": "computedFreeSpace",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedFreeSpace",
                    "validate": false,
                    "optional": false,
                    "original": "free_space"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The current maintenance mode state of the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"maintenance_mode\" <$> TF.attribute",
                    "name": "_computedMaintenanceMode",
                    "method": "computedMaintenanceMode",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedMaintenanceMode",
                    "validate": false,
                    "optional": false,
                    "original": "maintenance_mode"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "If true, more than one host in the datacenter has been configured with",
                        "access to the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"multiple_host_access\" <$> TF.attribute",
                    "name": "_computedMultipleHostAccess",
                    "method": "computedMultipleHostAccess",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Bool",
                    "class": "HasComputedMultipleHostAccess",
                    "validate": false,
                    "optional": false,
                    "original": "multiple_host_access"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "Total additional storage space, in MB, potentially used by all virtual",
                        "machines on this datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"uncommitted_space\" <$> TF.attribute",
                    "name": "_computedUncommittedSpace",
                    "method": "computedUncommittedSpace",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Int",
                    "class": "HasComputedUncommittedSpace",
                    "validate": false,
                    "optional": false,
                    "original": "uncommitted_space"
                },
                {
                    "default": "TF.Nil",
                    "computed": true,
                    "required": false,
                    "help": [
                        "The unique locator for the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"url\" <$> TF.attribute",
                    "name": "_computedUrl",
                    "method": "computedUrl",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasComputedUrl",
                    "validate": false,
                    "optional": false,
                    "original": "url"
                }
            ],
            "parameters": [
                {
                    "default": "_disks",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The disks to add to the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"disks\" <$> TF.attribute",
                    "name": "_disks",
                    "method": "disks",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s (P.NonEmpty (TF.Attr s P.Text))",
                    "class": "HasDisks",
                    "validate": false,
                    "optional": false,
                    "original": "disks"
                },
                {
                    "default": "_hostSystemId",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The managed object ID of the host to set up the datastore on."
                    ],
                    "forceNew": true,
                    "encoder": "TF.assign \"host_system_id\" <$> TF.attribute",
                    "name": "_hostSystemId",
                    "method": "hostSystemId",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasHostSystemId",
                    "validate": false,
                    "optional": false,
                    "original": "host_system_id"
                },
                {
                    "default": "_name",
                    "computed": false,
                    "required": true,
                    "help": [
                        "The name of the datastore."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"name\" <$> TF.attribute",
                    "name": "_name",
                    "method": "name",
                    "threaded": true,
                    "conflicts": [],
                    "type": "TF.Attr s P.Text",
                    "class": "HasName",
                    "validate": false,
                    "optional": false,
                    "original": "name"
                }
            ],
            "conflicts": [
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The managed object ID of the datastore cluster to place the datastore in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"datastore_cluster_id\" <$> TF.attribute",
                    "name": "_datastoreClusterId",
                    "method": "datastoreClusterId",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_folder",
                            "method": "folder"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasDatastoreClusterId",
                    "validate": false,
                    "optional": true,
                    "original": "datastore_cluster_id"
                },
                {
                    "default": "TF.Nil",
                    "computed": false,
                    "required": false,
                    "help": [
                        "The path to the datastore folder to put the datastore in."
                    ],
                    "forceNew": false,
                    "encoder": "TF.assign \"folder\" <$> TF.attribute",
                    "name": "_folder",
                    "method": "folder",
                    "threaded": true,
                    "conflicts": [
                        {
                            "default": "TF.Nil",
                            "name": "_datastoreClusterId",
                            "method": "datastoreClusterId"
                        }
                    ],
                    "type": "TF.Attr s P.Text",
                    "class": "HasFolder",
                    "validate": false,
                    "optional": true,
                    "original": "folder"
                }
            ],
            "type": "VmfsDatastoreResource s",
            "original": "vsphere_vmfs_datastore"
        }
    ],
    "schema": {
        "con": {
            "smart": "newProvider",
            "name": "Provider'"
        },
        "arguments": [
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "If set, VMware vSphere client will permit unverifiable SSL certificates."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"allow_unverified_ssl\" <$>",
                "name": "_allowUnverifiedSsl",
                "method": "allowUnverifiedSsl",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Bool",
                "class": "HasAllowUnverifiedSsl",
                "validate": false,
                "optional": true,
                "original": "allow_unverified_ssl"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "Govmomi debug"
                ],
                "forceNew": false,
                "encoder": "TF.assign \"client_debug\" <$>",
                "name": "_clientDebug",
                "method": "clientDebug",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Bool",
                "class": "HasClientDebug",
                "validate": false,
                "optional": true,
                "original": "client_debug"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "Govmomi debug path for debug"
                ],
                "forceNew": false,
                "encoder": "TF.assign \"client_debug_path\" <$>",
                "name": "_clientDebugPath",
                "method": "clientDebugPath",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasClientDebugPath",
                "validate": false,
                "optional": true,
                "original": "client_debug_path"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "Govmomi debug path for a single run"
                ],
                "forceNew": false,
                "encoder": "TF.assign \"client_debug_path_run\" <$>",
                "name": "_clientDebugPathRun",
                "method": "clientDebugPathRun",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasClientDebugPathRun",
                "validate": false,
                "optional": true,
                "original": "client_debug_path_run"
            },
            {
                "default": "_password",
                "computed": false,
                "required": true,
                "help": [
                    "The user password for vSphere API operations."
                ],
                "forceNew": false,
                "encoder": "P.Just $ TF.assign \"password\"",
                "name": "_password",
                "method": "password",
                "threaded": false,
                "conflicts": [],
                "type": "P.Text",
                "class": "HasPassword",
                "validate": false,
                "optional": false,
                "original": "password"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "Persist vSphere client sessions to disk"
                ],
                "forceNew": false,
                "encoder": "TF.assign \"persist_session\" <$>",
                "name": "_persistSession",
                "method": "persistSession",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Bool",
                "class": "HasPersistSession",
                "validate": false,
                "optional": true,
                "original": "persist_session"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "The directory to save vSphere REST API sessions to"
                ],
                "forceNew": false,
                "encoder": "TF.assign \"rest_session_path\" <$>",
                "name": "_restSessionPath",
                "method": "restSessionPath",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasRestSessionPath",
                "validate": false,
                "optional": true,
                "original": "rest_session_path"
            },
            {
                "default": "_user",
                "computed": false,
                "required": true,
                "help": [
                    "The user name for vSphere API operations."
                ],
                "forceNew": false,
                "encoder": "P.Just $ TF.assign \"user\"",
                "name": "_user",
                "method": "user",
                "threaded": false,
                "conflicts": [],
                "type": "P.Text",
                "class": "HasUser",
                "validate": false,
                "optional": false,
                "original": "user"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "The directory to save vSphere SOAP API sessions to"
                ],
                "forceNew": false,
                "encoder": "TF.assign \"vim_session_path\" <$>",
                "name": "_vimSessionPath",
                "method": "vimSessionPath",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasVimSessionPath",
                "validate": false,
                "optional": true,
                "original": "vim_session_path"
            },
            {
                "default": "P.Nothing",
                "computed": false,
                "required": false,
                "help": [
                    "The vSphere Server name for vSphere API operations."
                ],
                "forceNew": false,
                "encoder": "TF.assign \"vsphere_server\" <$>",
                "name": "_vsphereServer",
                "method": "vsphereServer",
                "threaded": false,
                "conflicts": [],
                "type": "P.Maybe P.Text",
                "class": "HasVsphereServer",
                "validate": false,
                "optional": true,
                "original": "vsphere_server"
            }
        ],
        "key": "provider",
        "name": "Provider",
        "threaded": false,
        "attributes": [],
        "parameters": [
            {
                "default": "_password",
                "computed": false,
                "required": true,
                "help": [
                    "The user password for vSphere API operations."
                ],
                "forceNew": false,
                "encoder": "P.Just $ TF.assign \"password\"",
                "name": "_password",
                "method": "password",
                "threaded": false,
                "conflicts": [],
                "type": "P.Text",
                "class": "HasPassword",
                "validate": false,
                "optional": false,
                "original": "password"
            },
            {
                "default": "_user",
                "computed": false,
                "required": true,
                "help": [
                    "The user name for vSphere API operations."
                ],
                "forceNew": false,
                "encoder": "P.Just $ TF.assign \"user\"",
                "name": "_user",
                "method": "user",
                "threaded": false,
                "conflicts": [],
                "type": "P.Text",
                "class": "HasUser",
                "validate": false,
                "optional": false,
                "original": "user"
            }
        ],
        "conflicts": [],
        "type": "Provider",
        "original": "provider"
    },
    "dependencies": [
        "aeson",
        "base",
        "containers",
        "microlens",
        "terrafomo",
        "text"
    ],
    "name": "VSphere",
    "package": "terrafomo-vsphere",
    "primitives": [],
    "original": "vsphere"
}