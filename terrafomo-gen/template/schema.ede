-- This module is auto-generated.

{-# LANGUAGE DuplicateRecordFields  #-}
{-# LANGUAGE FlexibleInstances      #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE MultiParamTypeClasses  #-}
{-# LANGUAGE NoImplicitPrelude      #-}
{-# LANGUAGE OverloadedStrings      #-}
{-# LANGUAGE RecordWildCards        #-}
{-# LANGUAGE UndecidableInstances   #-}

{-# OPTIONS_GHC -fno-warn-unused-imports #-}

{% include "_include/license.ede" %}
--
module {{ namespace }}
    (
    -- * Types
  {% for schema in schemas %}
    {% if schema.first %} {% else %},{% endif %} {{ schema.key }} (..)
    , {{ schema.key | lowerHead }}

  {% endfor %}
    -- * Overloaded Fields
  {% for class in classes %}
    , {{ class.key }} (..)
  {% endfor %}
    ) where

import Data.Functor (Functor, (<$>))
import Data.Maybe   (catMaybes)
import Data.Text    (Text)

import GHC.Base (Eq, ($), (.))
import GHC.Show (Show)

{% for import in imports %}
import qualified {{ import.value }} as TF
{% endfor %}
import qualified Terrafomo.Syntax.HCL      as TF
import qualified Terrafomo.Syntax.IP       as TF
import qualified Terrafomo.Syntax.Meta     as TF (configuration)
import qualified Terrafomo.Syntax.Resource as TF
import qualified Terrafomo.Syntax.Variable as TF
{% for schema in schemas %}

{% let original = schema.value.name %}
{- | The @{{ original }}@ {{ provider.name }} {{ type | toLower }}.
{% if schema.value.about %}

{{ schema.value.about | wrap }}
{% endif %}
{% for example in schema.value.examples %}

{% if example.value.title %}
{{ example.value.title }}

{% endif %}
@
{% for line in example.value.code %}
{{ line.value }}
{% endfor %}
@
{% endfor %}
-}
data {{ schema.key }} = {{ schema.key }} {
  {% for arg in schema.value.arguments %}
    {% if arg.first %}  {% else %}, {% endif %}{{ arg.key }} :: !(TF.Argument {{ arg.value.type }})
    {- ^ {{ arg.value.help }} -}
  {% endfor %}
  {% for attr in schema.value.attributes %}
    {% if (schema.value.arguments | empty) && attr.first %}  {% else %}, {% endif %}{{ attr.key }} :: !(TF.Attribute {{ attr.value.type }})
    {- ^ {{ attr.value.help }} -}
  {% endfor %}
    } deriving (Show, Eq)

instance TF.ToHCL {{ schema.key }} where
  {% for arg in schema.value.arguments %}
    {% if arg.first %}toHCL {{ schema.key }}{..} = TF.block $ catMaybes
        [{% else %}    ,{% endif %} TF.assign "{{ arg.value.name }}" <$> TF.argument {{ arg.key }}{% if arg.last %}
        ]{% endif %}
  {% else %}
    toHCL _ = TF.block []
  {% endfor %}
  {% for field in schema.value.fields %}

instance {{ field.value.class }} {{ schema.key }} {{ field.value.type }} where
    {{ field.value.method }} f s@{{ schema.key }}{..} =
        (\a -> s { {{ field.value.label }} = a } :: {{ schema.key }})
             <$> f {{ field.value.label }}
  {% endfor %}

{% let constructor = schema.key | lowerHead %}
{{ constructor }} :: TF.{{ type }} TF.{{ provider.name }} {{ schema.key }}
{{ constructor }} =
    TF.new{{ type }} "{{ original }}" $
        {{ schema.key }} {
          {% for arg in schema.value.arguments %}
            {% if !arg.first %}, {% endif %}{{ arg.key }} = TF.Nil
          {% endfor %}
          {% for attr in schema.value.attributes %}
            {% if (schema.value.arguments | empty) && attr.first %}  {% else %}, {% endif %}{{ attr.key }} = TF.Compute "{{ attr.value.name }}"
          {% endfor %}
            }
{% endlet %}
{% endlet %}
{% endfor %}
{% for class in classes %}

class {{ class.key }} s a | s -> a where
    {{ class.value }} :: Functor f => (a -> f a) -> s -> f s

instance {{ class.key }} s a => {{ class.key}} (TF.{{ type }} p s) a where
    {{ class.value }} = TF.configuration . {{ class.value }}
{% endfor %}
