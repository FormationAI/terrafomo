{-# LANGUAGE LambdaCase        #-}
{-# LANGUAGE NamedFieldPuns    #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards   #-}
{-# LANGUAGE TupleSections     #-}

module Main (main) where

import Control.Applicative (many, optional)
import Control.Error       (Script, hoistEither, runScript, scriptIO, (??))
import Control.Monad       (when, (>=>))
import Data.Aeson          (FromJSON, ToJSON)

import Data.Bifunctor   (first)
import Data.Foldable    (for_, traverse_)
import Data.Function    ((&))
import Data.Semigroup   (Semigroup ((<>)))
import Data.Text        (Text)
import Data.Traversable (for)

import System.FilePath ((<.>), (</>))

import Terrafomo.Gen.Parser   (Parser)
import Terrafomo.Gen.Provider
import Terrafomo.Gen.Schema
import Terrafomo.Gen.Template (Templates (Templates))

import qualified Control.Error          as Error
import qualified Data.Map.Strict        as Map
import qualified Data.Text              as Text
import qualified Data.Text.IO           as Text
import qualified Data.Text.Lazy         as LText
import qualified Data.Text.Lazy.IO      as LText
import qualified Data.Yaml              as YAML
import qualified Options.Applicative    as Option
import qualified System.Directory       as Dir
import qualified System.Exit            as Exit
import qualified System.FilePath        as Path
import qualified System.IO              as IO
import qualified System.Process         as Process
import qualified Terrafomo.Gen.Parser   as Parser
import qualified Terrafomo.Gen.Template as Template
import qualified Text.EDE               as EDE

-- TODO:
-- * Switch to using Megaparsec.Char to parse Required/Optional and add Haddockisms.
-- * Continue investigating having a Dhall frontend
-- * Extract all the usage examples and write out tests
--     - convert to DSL/Haskell and have as examples too
--     - ! just write them out as doctests
-- * Provide an 'Unsafe' constructor/lens for 'Attr' which allows arbitrary
--   insertion of HCL as 'Text'.
-- * Re-enable usage example parser.
-- * Have the TH.makeResource/DataSource take a defaultProvider only.
-- * Provide config to control which dir generated files end up in,
--   this would allow template, random, local, etc. to be housed in the main
--   terraform package.
-- * Generate providers from the index.html.markdown file.
-- * Merge contents and resource/datasource if only 1 module is needed?

-- Options Parsing

data Options = Options
    { schemaDir       :: !FilePath
    , patchDir        :: !FilePath
    , templateDir     :: !FilePath
    , providerName    :: !String
    , providerFile    :: !FilePath
    , resourceFiles   :: ![FilePath]
    , dataSourceFiles :: ![FilePath]
    } deriving (Show)

optionsParser :: Option.Parser Options
optionsParser = Options
    <$> Option.strOption
         ( Option.long "schema-dir"
        <> Option.help "The directory to read/write user modifiable schemas."
        <> Option.metavar "DIR"
         )

    <*> Option.strOption
         ( Option.long "patch-dir"
        <> Option.help "The directory containing files generated by 'diff -u'."
        <> Option.metavar "DIR"
         )

    <*> Option.strOption
         ( Option.long "template-dir"
        <> Option.help "The directory containing EDE templates for rendering."
        <> Option.metavar "DIR"
         )

    <*> Option.strOption
         ( Option.long "provider-name"
        <> Option.help "The Terraform provider name."
        <> Option.metavar "NAME"
         )

    <*> Option.strOption
         ( Option.long "provider-file"
        <> Option.help "The markdown file containing provider information."
        <> Option.metavar "FILE"
         )

    <*> many (Option.strOption
         ( Option.long "resource-file"
        <> Option.help "A markdown file containing resource information."
        <> Option.metavar "FILE"
         ))

    <*> many (Option.strOption
         ( Option.long "datasource-file"
        <> Option.help "A markdown file containing datasource information."
        <> Option.metavar "FILE"
         ))

parserInfo :: Option.ParserInfo Options
parserInfo =
     ( Option.header "Terraform Haskell Types Generator"
    <> Option.fullDesc
          & Option.info
              ( Option.helper
            <*> optionsParser
              )
     )

-- Main

main :: IO ()
main = do
    let prefs = Option.prefs Option.showHelpOnError

    opts <- Option.customExecParser prefs parserInfo

    runScript $ do
        echo "Starting ..."

        tmpls <- loadTemplates opts
        p     <- loadProvider  opts

        renderProvider tmpls p
        renderSchemas  tmpls p Resource   =<< loadResources   opts
        renderSchemas  tmpls p DataSource =<< loadDataSources opts

        echo "Done."

-- Provider

loadProvider :: Options -> Script Provider
loadProvider opts = do
    let path@Path{markdownFile, schemaFile} = providerPath opts

    exists <- scriptIO (Dir.doesFileExist markdownFile)
    echo ("Provider " ++ markdownFile ++ " == " ++ show exists)

    -- FIXME: Current semigroup associativity won't make sense for a provider.
    if exists
        then loadSchema Parser.providerParser path
        else parseYAML schemaFile >>= updateSchema path

loadResources :: Options -> Script [Schema]
loadResources = traverse (loadSchema Parser.schemaParser) . resourcePaths

loadDataSources :: Options -> Script [Schema]
loadDataSources = traverse (loadSchema Parser.schemaParser) . dataSourcePaths

-- Schema

loadSchema :: (ToJSON a, FromJSON a, Semigroup a) => Parser a -> Path -> Script a
loadSchema parser path =
    patchSchema path
        >> parseSchema parser path
            >>= updateSchema path

updateSchema :: (ToJSON a, FromJSON a, Semigroup a) => Path -> a -> Script a
updateSchema Path{schemaFile} input = do
    exists <- scriptIO (Dir.doesFileExist schemaFile)
    echo ("Schema " ++ schemaFile ++ " == " ++ show exists)

    output <-
        if not exists
            then pure input
            else do
                echo ("Reading " ++ schemaFile)
                (input <>) <$> parseYAML schemaFile

    echo ("Writing " ++ schemaFile)
    scriptIO $ do
        Dir.createDirectoryIfMissing True (Path.takeDirectory schemaFile)
        YAML.encodeFile schemaFile output

    pure output

patchSchema :: Path -> Script ()
patchSchema Path{markdownFile, patchFile} = do
    exists <- scriptIO (Dir.doesFileExist patchFile)
    echo ("Patch " ++ patchFile ++ " == " ++ show exists)

    when exists $ do
        echo ("Patching " ++ markdownFile)
        code <- scriptIO . Process.system $
            unwords [ "patch -N -r"
                    , patchFile <.> "rej"
                    , markdownFile
                    , patchFile
                    , "1>&2"
                    ]

        when (code /= Exit.ExitSuccess) $
            echo ("Failure applying patch " ++ patchFile)

parseSchema :: Parser a -> Path -> Script a
parseSchema parser Path{markdownFile} = do
    echo ("Parsing " ++ markdownFile)
    scriptIO (Text.readFile markdownFile)
        >>= hoistEither . Parser.runParser parser markdownFile

-- Rendering

renderProvider
    :: Templates EDE.Template
    -> Provider
    -> Script ()
renderProvider tmpls p =
    hoistEither (Template.renderProvider tmpls p)
        >>= maybe (pure ()) (writeNamespace (providerDir p))

renderSchemas
    :: Templates EDE.Template
    -> Provider
    -> SchemaType
    -> [Schema]
    -> Script ()
renderSchemas tmpls p typ xs = do
    let writeModule         = writeNamespace (providerDir p)
        (contents, modules) = schemaNamespaces p typ xs

    hoistEither (Template.renderSchemas tmpls p Resource modules)
        >>= traverse_ writeModule . Map.toList

    hoistEither (Template.renderContents tmpls Resource contents modules)
        >>= writeModule

writeNamespace :: FilePath -> (NS, LText.Text) -> Script ()
writeNamespace dir (ns, text) = do
    let moduleFile = dir </> fromNamespace '/' ns <.> "hs"

    echo ("Writing " ++ moduleFile)
    scriptIO $ do
        Dir.createDirectoryIfMissing True (Path.takeDirectory moduleFile)
        LText.writeFile moduleFile text

-- Paths

data Path = Path
    { markdownFile :: !FilePath
    , schemaFile   :: !FilePath
    , patchFile    :: !FilePath
    }

providerPath :: Options -> Path
providerPath Options{..} =
    let markdownFile = providerFile
        schemaFile   = schemaDir </> providerName <.> "yaml"
        patchFile    = patchDir  </> providerName <.> "patch"
     in Path{..}

resourcePaths :: Options -> [Path]
resourcePaths opts = map (schemaPath opts) (resourceFiles opts)

dataSourcePaths :: Options -> [Path]
dataSourcePaths opts = map (schemaPath opts) (dataSourceFiles opts)

schemaPath :: Options -> FilePath -> Path
schemaPath Options{providerName, schemaDir, patchDir} file =
    let name         = Path.dropExtensions (Path.takeBaseName file)
        markdownFile = file
        schemaFile   = schemaDir </> providerName </> name <.> "yaml"
        patchFile    = patchDir  </> providerName </> name <.> "patch"
     in Path{..}

-- EDE Templating

loadTemplates :: Options -> Script (Templates EDE.Template)
loadTemplates Options{templateDir} =
    traverse (parseEDE . Path.combine templateDir) $
        Templates
            { providerTemplate   = "provider.ede"
            , contentsTemplate   = "contents.ede"
            , resourceTemplate   = "resource.ede"
            , dataSourceTemplate = "datasource.ede"
            }

parseEDE :: FilePath -> Script EDE.Template
parseEDE file = do
    echo ("Parsing EDE from " ++ file)
    first Text.pack
        <$> scriptIO (EDE.eitherParseFile file)
        >>= hoistEither

-- YAML

parseYAML :: FromJSON a => FilePath -> Script a
parseYAML file = do
    echo ("Parsing YAML from " ++ file)
    first (Text.pack . YAML.prettyPrintParseException)
        <$> scriptIO (YAML.decodeFileEither file)
        >>= hoistEither

-- Standard IO

echo :: String -> Script ()
echo = Error.scriptIO . IO.putStrLn


--     let total = length inputPaths :: Int

--     schemas <- for (zip [1..] inputPaths) $ \(n, inputPath) -> do
--         let name    = Path.dropExtensions (Path.takeBaseName inputPath)
--             current = "[" ++ show (n :: Int) ++ " of " ++ show total ++ "] "
--             step x  = say (current ++ x)

--         let patchPath  = patchDir  </> name <.> "patch"
--             rejectPath = patchDir  </> name <.> "rej"
--             schemaPath = schemaDir </> name <.> "yaml"

--         patchExists <- Dir.doesFileExist patchPath
--         step ("Checking for " ++ patchPath ++ " == " ++ show patchExists)

--         when patchExists $ do
--             step ("Patching " ++ inputPath)
--             code <- Process.system $
--                 unwords [ "patch -N -r"
--                         , rejectPath
--                         , inputPath
--                         , patchPath
--                         , "1>&2"
--                         ]
--             when (code /= Exit.ExitSuccess) $
--                 step ("Failure applying patch " ++ patchPath)

--         step ("Parsing " ++ inputPath)
--         schema <-
--             Text.readFile inputPath
--                 >>= handleError inputPath
--                   . Parser.runParser Parser.schemaParser inputPath

--         configExists <- Dir.doesFileExist schemaPath
--         step ("Checking for " ++ schemaPath ++ " == " ++ show configExists)

--         newSchema <-
--             if not configExists
--                 then pure schema
--                 else do
--                     step ("Reading " ++ schemaPath)
--                     (schema <>) <$> readYAML schemaPath

--         step ("Writing " ++ schemaPath)
--         Dir.createDirectoryIfMissing True (Path.takeDirectory schemaPath)
--         YAML.encodeFile schemaPath newSchema

--         pure newSchema

--     let contentsNS = contentsNamespace provider schemaType
--         schemaNS   = schemaNamespaces  provider schemaType schemas

--     say ("Rendering " ++ schemaTmplPath)
--     rendered <-
--         handleError schemaTmplPath $
--             Template.renderSchemas schemaTmpl provider schemaType schemaNS

--     say ("Rendering " ++ contentsTmplPath)
--     contents <-
--         handleError contentsTmplPath $
--             Template.renderContents contentsTmpl schemaType contentsNS schemaNS

--     let outputDir = providerDir provider </> "gen"

--     for_ ((contentsNS, contents) : Map.toList rendered) $ \(ns, txt) -> do
--         let modulePath = outputDir </> namespace '/' ns <.> "hs"

--         say ("Writing " ++ modulePath)
--         Dir.createDirectoryIfMissing True (Path.takeDirectory modulePath)
--         LText.writeFile modulePath txt

-- readYAML :: YAML.FromJSON a => FilePath -> IO a
-- readYAML path =
--     YAML.decodeFileEither path
--         >>= handleError path . first YAML.prettyPrintParseException

-- handleError :: FilePath -> Either String a -> IO a
-- handleError path = \case
--     Right x   -> pure x
--     Left  err -> do
--         say err
--         say ("Error: " ++ path)
--         Exit.exitFailure

-- say :: String -> IO ()
-- say = IO.hPutStrLn IO.stderr
