{-# LANGUAGE LambdaCase        #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards   #-}

module Main (main) where

import Control.Applicative (many)
import Control.Monad       (when)

import Data.Bifunctor   (first)
import Data.Foldable    (for_)
import Data.Function    ((&))
import Data.Semigroup   ((<>))
import Data.Traversable (for)

import System.FilePath ((<.>), (</>))

import Terraform.Gen.Provider
import Terraform.Gen.Schema

import qualified Data.Map.Strict        as Map
import qualified Data.Text.IO           as Text
import qualified Data.Text.Lazy.IO      as LText
import qualified Data.Yaml              as YAML
import qualified Options.Applicative    as Option
import qualified System.Directory       as Dir
import qualified System.Exit            as Exit
import qualified System.FilePath        as Path
import qualified System.IO              as IO
import qualified System.Process         as Process
import qualified Terraform.Gen.Parser   as Parser
import qualified Terraform.Gen.Template as Template
import qualified Text.EDE               as EDE

-- TODO:
-- * Switch to using Megaparsec.Char to parse Required/Optional and add Haddockisms.
-- * Continue investigating having a Dhall frontend
-- * Extract all the usage examples and write out tests
--     - convert to DSL/Haskell and have as examples too
--     - ! just write them out as doctests
-- * Provide an 'Unsafe' constructor/lens for 'Attr' which allows arbitrary
--   insertion of HCL as 'Text'.
-- * Re-enable usage example parser.
-- * Have the TH.makeResource/DataSource take a defaultProvider only.

-- Options Parsing

data Options = Options
    { configPath       :: !FilePath
    , schemaType       :: !SchemaType
    , schemaDir        :: !FilePath
    , patchDir         :: !FilePath
    , schemaTmplPath   :: !FilePath
    , contentsTmplPath :: !FilePath
    , inputPaths       :: ![FilePath]
    } deriving (Show)

optionsParser :: Option.Parser Options
optionsParser = Options
    <$> Option.strOption
         ( Option.long "config-file"
        <> Option.help "Terraform provider configuration file."
        <> Option.metavar "FILE"
         )

    <*> Option.option Option.auto
         ( Option.long "schema-type"
        <> Option.help "Resource or DataSource."
        <> Option.metavar "Resource|DataSource"
         )

    <*> Option.strOption
         ( Option.long "schema-dir"
        <> Option.help "The directory to read/write type schemas."
        <> Option.metavar "DIR"
         )

    <*> Option.strOption
         ( Option.long "patch-dir"
        <> Option.help "The directory containing files generated by 'diff -u'."
        <> Option.metavar "DIR"
         )

    <*> Option.strOption
         ( Option.long "schema-template"
        <> Option.help "EDE template to render schema configurations."
        <> Option.metavar "FILE"
         )

    <*> Option.strOption
         ( Option.long "contents-template"
        <> Option.help "EDE template to render a schema table of contents."
        <> Option.metavar "FILE"
         )

    <*> many (Option.strArgument
         ( Option.help "Input markdown file to parse schema information from."
        <> Option.metavar "FILE"
         ))

parserInfo :: Option.ParserInfo Options
parserInfo =
     ( Option.header "Terraform Haskell Types Generator"
    <> Option.fullDesc
          & Option.info
              ( Option.helper
            <*> optionsParser
              )
     )

-- Main

main :: IO ()
main = do
    let prefs = Option.prefs Option.showHelpOnError

    Options{..} <- Option.customExecParser prefs parserInfo

    say ("Parsing " ++ configPath)
    provider <- readYAML configPath

    say ("Parsing " ++ schemaTmplPath)
    schemaTmpl   <-
        EDE.eitherParseFile schemaTmplPath
            >>= handleError schemaTmplPath

    say ("Parsing " ++ contentsTmplPath)
    contentsTmpl <-
        EDE.eitherParseFile contentsTmplPath
            >>= handleError contentsTmplPath

    let total = length inputPaths :: Int

    schemas <- for (zip [1..] inputPaths) $ \(n, inputPath) -> do
        let name    = Path.dropExtensions (Path.takeBaseName inputPath)
            current = "[" ++ show (n :: Int) ++ " of " ++ show total ++ "] "
            step x  = say (current ++ x)

        let patchPath  = patchDir  </> name <.> "patch"
            rejectPath = patchDir  </> name <.> "rej"
            schemaPath = schemaDir </> name <.> "yaml"

        patchExists <- Dir.doesFileExist patchPath
        step ("Checking for " ++ patchPath ++ " == " ++ show patchExists)

        when patchExists $ do
            step ("Patching " ++ inputPath)
            code <- Process.system $
                unwords [ "patch -N -r"
                        , rejectPath
                        , inputPath
                        , patchPath
                        , "1>&2"
                        ]
            when (code /= Exit.ExitSuccess) $
                step ("Failure applying patch " ++ patchPath)

        step ("Parsing " ++ inputPath)
        schema <-
            Text.readFile inputPath
                >>= handleError inputPath
                  . Parser.runParser Parser.schemaParser inputPath

        configExists <- Dir.doesFileExist schemaPath
        step ("Checking for " ++ schemaPath ++ " == " ++ show configExists)

        newSchema <-
            if not configExists
                then pure schema
                else do
                    step ("Reading " ++ schemaPath)
                    (schema <>) <$> readYAML schemaPath

        step ("Writing " ++ schemaPath)
        Dir.createDirectoryIfMissing True (Path.takeDirectory schemaPath)
        YAML.encodeFile schemaPath newSchema

        pure newSchema

    let contentsNS = contentsNamespace provider schemaType
        schemaNS   = schemaNamespaces  provider schemaType schemas

    say ("Rendering " ++ schemaTmplPath)
    rendered <-
        handleError schemaTmplPath $
            Template.renderSchemas schemaTmpl provider schemaType schemaNS

    say ("Rendering " ++ contentsTmplPath)
    contents <-
        handleError contentsTmplPath $
            Template.renderContents contentsTmpl schemaType contentsNS schemaNS

    let outputDir = providerDir provider </> "gen"

    for_ ((contentsNS, contents) : Map.toList rendered) $ \(ns, txt) -> do
        let modulePath = outputDir </> namespace '/' ns <.> "hs"

        say ("Writing " ++ modulePath)
        Dir.createDirectoryIfMissing True (Path.takeDirectory modulePath)
        LText.writeFile modulePath txt

readYAML :: YAML.FromJSON a => FilePath -> IO a
readYAML path =
    YAML.decodeFileEither path
        >>= handleError path . first YAML.prettyPrintParseException

handleError :: FilePath -> Either String a -> IO a
handleError path = \case
    Right x   -> pure x
    Left  err -> do
        say err
        say ("Error: " ++ path)
        Exit.exitFailure

say :: String -> IO ()
say = IO.hPutStrLn IO.stderr
