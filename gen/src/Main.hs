{-# LANGUAGE LambdaCase        #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards   #-}

module Main (main) where

import Control.Applicative (some)
import Control.Monad       (when)

import Data.Bifunctor   (bimap)
import Data.Foldable    (for_)
import Data.Function    ((&))
import Data.Semigroup   ((<>))
import Data.Traversable (for)

import System.FilePath ((<.>), (</>))

import Terraform.Gen.Provider
import Terraform.Gen.Schema

import qualified Data.Map.Strict        as Map
import qualified Data.Text.IO           as Text
import qualified Data.Text.Lazy.IO      as LText
import qualified Data.Yaml              as YAML
import qualified Options.Applicative    as Option
import qualified System.Directory       as Dir
import qualified System.Exit            as Exit
import qualified System.FilePath        as Path
import qualified System.IO              as IO
import qualified System.Process         as Process
import qualified Terraform.Gen.Parser   as Parser
import qualified Terraform.Gen.Template as Template
import qualified Text.EDE               as EDE

-- TODO:
-- * Switch to using Megaparsec.Char to parse Required/Optional and add Haddockisms.
-- * Continue investigating having a Dhall frontend
-- * Extract all the usage examples and write out tests
--     - convert to DSL/Haskell and have as examples too

-- Options Parsing

data Options = Options
    { optionsProvider     :: !Provider
    , optionsSchemaType   :: !SchemaType
    , optionsSchemaDir    :: !FilePath
    , optionsPatchDir     :: !FilePath
    , optionsSchemaTmpl   :: !FilePath
    , optionsContentsTmpl :: !FilePath
    , optionsOutputDir    :: !FilePath
    , optionsFiles        :: ![FilePath]
    } deriving (Show)

optionsParser :: Option.Parser Options
optionsParser = Options
    <$> Option.option Option.auto
         ( Option.long "provider"
        <> Option.help "Terraform provider."
        <> Option.metavar "PROVIDER"
         )

    <*> Option.option Option.auto
         ( Option.long "schema-type"
        <> Option.help "Resource or DataSource."
        <> Option.metavar "Resource|DataSource"
         )

    <*> Option.strOption
         ( Option.long "schema-dir"
        <> Option.help "The directory to read/write type schemas."
        <> Option.metavar "DIR"
         )

    <*> Option.strOption
         ( Option.long "patch-dir"
        <> Option.help "The directory containing files generated by 'diff -u'."
        <> Option.metavar "DIR"
         )

    <*> Option.strOption
         ( Option.long "schema-template"
        <> Option.help "EDE template to render schema configurations."
        <> Option.metavar "FILE"
         )

    <*> Option.strOption
         ( Option.long "contents-template"
        <> Option.help "EDE template to render a schema table of contents."
        <> Option.metavar "FILE"
         )

    <*> Option.strOption
         ( Option.long "output-dir"
        <> Option.help "Output directory."
        <> Option.metavar "DIR"
         )

    <*> some (Option.strArgument
         ( Option.help "Input markdown file to parse schema information from."
        <> Option.metavar "FILE"
         ))

parserInfo :: Option.ParserInfo Options
parserInfo =
     ( Option.header "Terraform Haskell Types Generator"
    <> Option.fullDesc
          & Option.info
              ( Option.helper
            <*> optionsParser
              )
     )

-- Main

main :: IO ()
main = do
    let prefs = Option.prefs Option.showHelpOnError

    opts <- Option.customExecParser prefs parserInfo

    let schemaTmplPath   = optionsSchemaTmpl opts
        contentsTmplPath = optionsContentsTmpl opts
        total            = length (optionsFiles opts) :: Int

    say ("Parsing " ++ schemaTmplPath)
    schemaTmpl   <-
        EDE.eitherParseFile schemaTmplPath
            >>= handleError schemaTmplPath

    say ("Parsing " ++ contentsTmplPath)
    contentsTmpl <-
        EDE.eitherParseFile contentsTmplPath
            >>= handleError contentsTmplPath

    configs <- for (zip [1..] (optionsFiles opts)) $ \(n, inputPath) -> do
        let name    = Path.dropExtensions (Path.takeBaseName inputPath)
            current = "[" ++ show (n :: Int) ++ " of " ++ show total ++ "] "
            step x  = say (current ++ x)

        let patchPath  = optionsPatchDir  opts </> name <.> "patch"
            rejectPath = optionsPatchDir  opts </> name <.> "rej"
            schemaPath = optionsSchemaDir opts </> name <.> "yaml"

        patchExists <- Dir.doesFileExist patchPath
        step ("Checking for " ++ patchPath ++ " == " ++ show patchExists)

        when patchExists $ do
            step ("Patching " ++ inputPath)
            code <- Process.system $
                unwords [ "patch -N -r"
                        , rejectPath
                        , inputPath
                        , patchPath
                        , "1>&2"
                        ]

            when (code /= Exit.ExitSuccess) $
                step ("Failure applying patch " ++ patchPath)

        step ("Parsing " ++ inputPath)
        schema <-
            Text.readFile inputPath
                >>= handleError inputPath
                  . Parser.runParser Parser.schemaParser inputPath

        configExists <- Dir.doesFileExist schemaPath
        step ("Checking for " ++ schemaPath ++ " == " ++ show configExists)

        config <-
            if not configExists
                then pure schema
                else do
                    step ("Reading " ++ schemaPath)
                    YAML.decodeFileEither schemaPath
                        >>= handleError schemaPath
                          . bimap YAML.prettyPrintParseException (schema <>)

        step ("Writing " ++ schemaPath)
        Dir.createDirectoryIfMissing True (Path.takeDirectory schemaPath)
        YAML.encodeFile schemaPath config

        pure config

    let contentsNS = contentsNamespace (optionsProvider opts)
                                       (optionsSchemaType opts)
        schemaNS   = schemaNamespaces  (optionsProvider opts)
                                       (optionsSchemaType opts)
                                       configs

    say ("Rendering " ++ schemaTmplPath)
    rendered <-
        handleError schemaTmplPath $
            Template.renderSchemas schemaTmpl (optionsProvider opts) schemaNS

    say ("Rendering " ++ contentsTmplPath)
    contents <-
        handleError contentsTmplPath $
            Template.renderContents contentsTmpl contentsNS schemaNS

    for_ ((contentsNS, contents) : Map.toList rendered) $ \(ns, txt) -> do
        let modulePath = optionsOutputDir opts </> namespace '/' ns <.> "hs"

        say ("Writing " ++ modulePath)
        Dir.createDirectoryIfMissing True (Path.takeDirectory modulePath)
        LText.writeFile modulePath txt

handleError :: FilePath -> Either String a -> IO a
handleError path = \case
    Right x   -> pure x
    Left  err -> do
        say err
        say ("Error: " ++ path)
        Exit.exitFailure

say :: String -> IO ()
say = IO.hPutStrLn IO.stderr
