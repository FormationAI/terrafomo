{-# LANGUAGE LambdaCase        #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards   #-}

module Main (main) where

import Control.Applicative (some)
import Control.Monad       (when)

import Data.Bifunctor   (first)
import Data.Foldable    (for_)
import Data.Function    ((&))
import Data.Monoid      ((<>))
import Data.Traversable (for)

import System.FilePath ((<.>), (</>))

import Terraform.Gen.Config

import qualified Data.Map.Strict        as Map
import qualified Data.Text.IO           as Text
import qualified Data.Text.Lazy.IO      as LText
import qualified Data.Yaml              as YAML
import qualified Options.Applicative    as Option
import qualified System.Directory       as Dir
import qualified System.Exit            as Exit
import qualified System.FilePath        as Path
import qualified System.IO              as IO
import qualified System.Process         as Process
import qualified Terraform.Gen.Parser   as Parser
import qualified Terraform.Gen.Template as Template
import qualified Text.EDE               as EDE

-- TODO:
-- * Switch to using Megaparsec.Char to parse Required/Optional and add Haddockisms.
-- * Continue investigating having a Dhall frontend

-- Options Parsing

data Options = Options
    { optionsConfigDir  :: !FilePath
    , optionsPatchDir   :: !FilePath
    , optionsTemplate   :: !FilePath
    , optionsProvider   :: !Provider
    , optionsSchemaType :: !SchemaType
    , optionsOutputDir  :: !FilePath
    , optionsFiles      :: ![FilePath]
    } deriving (Show)

optionsParser :: Option.Parser Options
optionsParser = Options
    <$> Option.strOption
         ( Option.long "config-dir"
        <> Option.help "The directory to read/write type configuration."
        <> Option.metavar "DIR"
         )

    <*> Option.strOption
         ( Option.long "patch-dir"
        <> Option.help "The directory containing files generated by 'diff -u'."
        <> Option.metavar "DIR"
         )

    <*> Option.strOption
         ( Option.long "template"
        <> Option.help "EDE template to render on stdout."
        <> Option.metavar "FILE"
         )

    <*> Option.option Option.auto
         ( Option.long "provider"
        <> Option.help "Terraform provider."
        <> Option.metavar "PROVIDER"
         )

    <*> Option.option Option.auto
         ( Option.long "schema-type"
        <> Option.help "Resource or DataSource."
        <> Option.metavar "Resource|DataSource"
         )

    <*> Option.strOption
         ( Option.long "output-dir"
        <> Option.help "Output directory."
        <> Option.metavar "DIR"
         )

    <*> some (Option.strArgument
         ( Option.help "Input markdown file to parse."
        <> Option.metavar "FILE"
         ))

parserInfo :: Option.ParserInfo Options
parserInfo =
     ( Option.header "Terraform Haskell Types Generator"
    <> Option.fullDesc
          & Option.info
              ( Option.helper
            <*> optionsParser
              )
     )

-- Main

main :: IO ()
main = do
    let prefs = Option.prefs Option.showHelpOnError

    opts <- Option.customExecParser prefs parserInfo

    let templatePath = optionsTemplate opts
        total        = length (optionsFiles opts) :: Int

    say ("Parsing " ++ templatePath)
    template <- EDE.eitherParseFile templatePath
            >>= handleError templatePath

    configs <- for (zip [1..] (optionsFiles opts)) $ \(n, inputPath) -> do
        let name    = Path.dropExtensions (Path.takeBaseName inputPath)
            current = "[" ++ show (n :: Int) ++ " of " ++ show total ++ "] "
            step x  = say (current ++ x)

        let patchPath  = optionsPatchDir  opts </> name <.> "patch"
            rejectPath = optionsPatchDir  opts </> name <.> "rej"
            configPath = optionsConfigDir opts </> name <.> "yaml"

        patchExists <- Dir.doesFileExist patchPath
        step ("Checking for " ++ patchPath ++ " == " ++ show patchExists)

        when patchExists $ do
            step ("Patching " ++ inputPath)
            code <- Process.system $
                unwords [ "patch -N -r"
                        , rejectPath
                        , inputPath
                        , patchPath
                        , "1>&2"
                        ]

            when (code /= Exit.ExitSuccess) $
                step ("Failure applying patch " ++ patchPath)

        step ("Parsing " ++ inputPath)
        schema <- Text.readFile inputPath
              >>= handleError inputPath
                . Parser.runParser Parser.schemaParser inputPath

        configExists <- Dir.doesFileExist configPath
        step ("Checking for " ++ configPath ++ " == " ++ show configExists)

        config <- fmap (uncurry schemaToConfig schema <>) $
            if not configExists
                then pure mempty
                else do
                    step ("Reading " ++ configPath)
                    YAML.decodeFileEither configPath
                        >>= handleError configPath
                          . first YAML.prettyPrintParseException

        step ("Writing " ++ configPath)
        Dir.createDirectoryIfMissing True (Path.takeDirectory configPath)
        YAML.encodeFile configPath config

        pure config

    say ("Rendering " ++ templatePath)
    rendered <- handleError templatePath
              . Template.renderConfigs template (optionsProvider opts)
              $ groupConfigs (optionsProvider opts)
                             (optionsSchemaType opts)
                             configs

    for_ (Map.toList rendered) $ \(ns, contents) -> do
        let modulePath = optionsOutputDir opts </> namespace '/' ns <.> "hs"

        say ("Writing " ++ modulePath)
        Dir.createDirectoryIfMissing True (Path.takeDirectory modulePath)
        LText.writeFile modulePath contents

handleError :: FilePath -> Either String a -> IO a
handleError path = \case
    Right x   -> pure x
    Left  err -> do
        say err
        say ("Error: " ++ path)
        Exit.exitFailure

say :: String -> IO ()
say = IO.hPutStrLn IO.stderr
