{-# LANGUAGE LambdaCase        #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards   #-}

module Main (main) where

import Control.Applicative (some)
import Control.Monad       (when)

import Data.Bifunctor   (first)
import Data.Function    ((&))
import Data.Monoid      ((<>))
import Data.Traversable (for)

import System.FilePath ((<.>), (</>))

import Terraform.Gen.Config

import qualified Data.Text.IO           as Text
import qualified Data.Text.Lazy         as LText
import qualified Data.Text.Lazy.IO      as LText
import qualified Data.Yaml              as YAML
import qualified Options.Applicative    as Option
import qualified System.Directory       as Dir
import qualified System.Exit            as Exit
import qualified System.FilePath        as Path
import qualified System.IO              as IO
import qualified System.Process         as Process
import qualified Terraform.Gen.Parser   as Parser
import qualified Terraform.Gen.Template as Template
import qualified Text.EDE               as EDE

-- Options Parsing

data Options = Options
    { optionsConfigDir :: !FilePath
    , optionsPatchDir  :: !FilePath
    , optionsTemplate  :: !FilePath
    , optionsFiles     :: ![FilePath]
    } deriving (Show)

optionsParser :: Option.Parser Options
optionsParser = Options
    <$> Option.strOption
         ( Option.long "config-dir"
        <> Option.help "The directory to read/write type configuration."
        <> Option.metavar "DIR"
         )

    <*> Option.strOption
         ( Option.long "patch-dir"
        <> Option.help "The directory containing files generated by 'diff -u'."
        <> Option.metavar "DIR"
         )

    <*> Option.strOption
         ( Option.long "template"
        <> Option.help "EDE template to render on stdout."
        <> Option.metavar "FILE"
         )

    <*> some (Option.strArgument
         ( Option.help "Input markdown file to parse."
        <> Option.metavar "FILE"
         ))

parserInfo :: Option.ParserInfo Options
parserInfo =
     ( Option.header "Terraform Haskell Types Generator"
    <> Option.fullDesc
          & Option.info
              ( Option.helper
            <*> optionsParser
              )
     )

-- Main

main :: IO ()
main = do
    let prefs = Option.prefs Option.showHelpOnError

    opts <- Option.customExecParser prefs parserInfo

    let templatePath = optionsTemplate opts
        total        = length (optionsFiles opts) :: Int

    say ("Parsing " ++ templatePath)
    template <- EDE.eitherParseFile templatePath
            >>= handleError templatePath

    configs <- for (zip [1..] (optionsFiles opts)) $ \(n, inputPath) -> do
        let name    = Path.dropExtensions (Path.takeBaseName inputPath)
            current = "[" ++ show (n :: Int) ++ " of " ++ show total ++ "] "
            step x  = say (current ++ x)

        let patchPath  = optionsPatchDir  opts </> name <.> "patch"
            rejectPath = optionsPatchDir  opts </> name <.> "rej"
            configPath = optionsConfigDir opts </> name <.> "yaml"

        patchExists <- Dir.doesFileExist patchPath
        step ("Checking for " ++ patchPath ++ " == " ++ show patchExists)

        when patchExists $ do
            step ("Patching " ++ inputPath)
            code <- Process.system $
                unwords [ "patch -N -r"
                        , rejectPath
                        , inputPath
                        , patchPath
                        , "1>&2"
                        ]

            when (code /= Exit.ExitSuccess) $
                step ("Failure applying patch " ++ patchPath)

        step ("Parsing " ++ inputPath)
        schema <- Text.readFile inputPath
              >>= handleError inputPath
                . Parser.runParser Parser.schemaParser inputPath

        configExists <- Dir.doesFileExist configPath
        step ("Checking for " ++ configPath ++ " == " ++ show configExists)

        config <- fmap (uncurry schemaToConfig schema <>) $
            if not configExists
                then pure mempty
                else do
                    step ("Reading " ++ configPath)
                    YAML.decodeFileEither configPath
                        >>= handleError configPath
                          . first YAML.prettyPrintParseException

        step ("Writing " ++ configPath)
        Dir.createDirectoryIfMissing True (Path.takeDirectory configPath)
        YAML.encodeFile configPath config

        pure config

    say ("Rendering " ++ templatePath)
    handleError templatePath (Template.render template configs)
        >>= emit

handleError :: FilePath -> Either String a -> IO a
handleError path = \case
    Right x   -> pure x
    Left  err -> do
        say err
        say ("Error: " ++ path)
        Exit.exitFailure

say :: String -> IO ()
say = IO.hPutStrLn IO.stderr

emit :: LText.Text -> IO ()
emit = LText.hPutStrLn IO.stdout
