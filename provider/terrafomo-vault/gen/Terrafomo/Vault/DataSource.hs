-- This module is auto-generated.

{-# LANGUAGE DuplicateRecordFields  #-}
{-# LANGUAGE FlexibleInstances      #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE MultiParamTypeClasses  #-}
{-# LANGUAGE NoImplicitPrelude      #-}
{-# LANGUAGE OverloadedStrings      #-}
{-# LANGUAGE RecordWildCards        #-}
{-# LANGUAGE ScopedTypeVariables    #-}
{-# LANGUAGE TypeFamilies           #-}
{-# LANGUAGE UndecidableInstances   #-}

{-# OPTIONS_GHC -fno-warn-unused-imports #-}

-- |
-- Module      : Terrafomo.Vault.DataSource
-- Copyright   : (c) 2017-2018 Brendan Hay
-- License     : Mozilla Public License, v. 2.0.
-- Maintainer  : Brendan Hay <brendan.g.hay+terrafomo@gmail.com>
-- Stability   : auto-generated
-- Portability : non-portable (GHC extensions)
--
module Terrafomo.Vault.DataSource
    (
    -- * Types
      ApproleAuthBackendRoleData (..)
    , approleAuthBackendRoleData

    , AwsAccessCredentialsData (..)
    , awsAccessCredentialsData

    , GenericSecretData (..)
    , genericSecretData

    -- * Overloaded Fields
    -- ** Arguments
    , P.HasBackend (..)
    , P.HasPath (..)
    , P.HasRole (..)
    , P.HasRoleName (..)
    , P.HasType' (..)

    -- ** Computed Attributes
    , P.HasComputedAccessKey (..)
    , P.HasComputedBackend (..)
    , P.HasComputedData' (..)
    , P.HasComputedDataJson (..)
    , P.HasComputedLeaseDuration (..)
    , P.HasComputedLeaseId (..)
    , P.HasComputedLeaseRenewable (..)
    , P.HasComputedLeaseStartTime (..)
    , P.HasComputedPath (..)
    , P.HasComputedRole (..)
    , P.HasComputedRoleId (..)
    , P.HasComputedRoleName (..)
    , P.HasComputedSecretKey (..)
    , P.HasComputedSecurityToken (..)
    , P.HasComputedType' (..)

    -- * Re-exported Types
    , module P
    ) where

import Data.Functor ((<$>))
import Data.Maybe   (catMaybes)

import GHC.Base (Eq, ($), (.))
import GHC.Show (Show)

import Lens.Micro (lens)

import Terrafomo.Vault.Types as P

import qualified Data.Text                as P
import qualified Data.Word                as P
import qualified GHC.Base                 as P
import qualified Numeric.Natural          as P
import qualified Terrafomo.Vault.Lens     as P
import qualified Terrafomo.Vault.Provider as P

import qualified Terrafomo.Attribute as TF
import qualified Terrafomo.HCL       as TF
import qualified Terrafomo.Name      as TF
import qualified Terrafomo.Provider  as TF
import qualified Terrafomo.Schema    as TF

{- | The @vault_approle_auth_backend_role@ Vault datasource.

Reads the Role ID of an AppRole from a Vault server.
-}
data ApproleAuthBackendRoleData s = ApproleAuthBackendRoleData {
      _backend   :: !(TF.Attr s P.Text)
    {- ^ (Optional) The unique name for the AppRole backend the role to retrieve a RoleID for resides in. Defaults to "approle". -}
    , _role_name :: !(TF.Attr s P.Text)
    {- ^ (Required) The name of the role to retrieve the Role ID for. -}
    } deriving (Show, Eq)

instance TF.ToHCL (ApproleAuthBackendRoleData s) where
    toHCL ApproleAuthBackendRoleData{..} = TF.inline $ catMaybes
        [ TF.assign "backend" <$> TF.attribute _backend
        , TF.assign "role_name" <$> TF.attribute _role_name
        ]

instance P.HasBackend (ApproleAuthBackendRoleData s) (TF.Attr s P.Text) where
    backend =
        lens (_backend :: ApproleAuthBackendRoleData s -> TF.Attr s P.Text)
             (\s a -> s { _backend = a } :: ApproleAuthBackendRoleData s)

instance P.HasRoleName (ApproleAuthBackendRoleData s) (TF.Attr s P.Text) where
    roleName =
        lens (_role_name :: ApproleAuthBackendRoleData s -> TF.Attr s P.Text)
             (\s a -> s { _role_name = a } :: ApproleAuthBackendRoleData s)

instance s ~ s' => P.HasComputedBackend (TF.Ref s' (ApproleAuthBackendRoleData s)) (TF.Attr s P.Text) where
    computedBackend =
        (_backend :: ApproleAuthBackendRoleData s -> TF.Attr s P.Text)
            . TF.refValue

instance s ~ s' => P.HasComputedRoleId (TF.Ref s' (ApproleAuthBackendRoleData s)) (TF.Attr s P.Text) where
    computedRoleId x = TF.compute (TF.refKey x) "role_id"

instance s ~ s' => P.HasComputedRoleName (TF.Ref s' (ApproleAuthBackendRoleData s)) (TF.Attr s P.Text) where
    computedRoleName =
        (_role_name :: ApproleAuthBackendRoleData s -> TF.Attr s P.Text)
            . TF.refValue

approleAuthBackendRoleData :: TF.DataSource P.Vault (ApproleAuthBackendRoleData s)
approleAuthBackendRoleData =
    TF.newDataSource "vault_approle_auth_backend_role" $
        ApproleAuthBackendRoleData {
              _backend = TF.Nil
            , _role_name = TF.Nil
            }

{- | The @vault_aws_access_credentials@ Vault datasource.

Reads AWS credentials from an AWS secret backend in Vault. ~> Important All
data retrieved from Vault will be written in cleartext to state file
generated by Terraform, will appear in the console output when Terraform
runs, and may be included in plan files if secrets are interpolated into any
resource attributes. Protect these artifacts accordingly. See
<../index.html> for more details.
-}
data AwsAccessCredentialsData s = AwsAccessCredentialsData {
      _backend :: !(TF.Attr s P.Text)
    {- ^ (Required) The path to the AWS secret backend to read credentials from, with no leading or trailing @/@ s. -}
    , _role    :: !(TF.Attr s P.Text)
    {- ^ (Required) The name of the AWS secret backend role to read credentials from, with no leading or trailing @/@ s. -}
    , _type'   :: !(TF.Attr s P.Text)
    {- ^ (Optional) The type of credentials to read. Defaults to @"creds"@ , which just returns an AWS Access Key ID and Secret Key. Can also be set to @"sts"@ , which will return a security token in addition to the keys. -}
    } deriving (Show, Eq)

instance TF.ToHCL (AwsAccessCredentialsData s) where
    toHCL AwsAccessCredentialsData{..} = TF.inline $ catMaybes
        [ TF.assign "backend" <$> TF.attribute _backend
        , TF.assign "role" <$> TF.attribute _role
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance P.HasBackend (AwsAccessCredentialsData s) (TF.Attr s P.Text) where
    backend =
        lens (_backend :: AwsAccessCredentialsData s -> TF.Attr s P.Text)
             (\s a -> s { _backend = a } :: AwsAccessCredentialsData s)

instance P.HasRole (AwsAccessCredentialsData s) (TF.Attr s P.Text) where
    role =
        lens (_role :: AwsAccessCredentialsData s -> TF.Attr s P.Text)
             (\s a -> s { _role = a } :: AwsAccessCredentialsData s)

instance P.HasType' (AwsAccessCredentialsData s) (TF.Attr s P.Text) where
    type' =
        lens (_type' :: AwsAccessCredentialsData s -> TF.Attr s P.Text)
             (\s a -> s { _type' = a } :: AwsAccessCredentialsData s)

instance s ~ s' => P.HasComputedAccessKey (TF.Ref s' (AwsAccessCredentialsData s)) (TF.Attr s P.Text) where
    computedAccessKey x = TF.compute (TF.refKey x) "access_key"

instance s ~ s' => P.HasComputedBackend (TF.Ref s' (AwsAccessCredentialsData s)) (TF.Attr s P.Text) where
    computedBackend =
        (_backend :: AwsAccessCredentialsData s -> TF.Attr s P.Text)
            . TF.refValue

instance s ~ s' => P.HasComputedLeaseDuration (TF.Ref s' (AwsAccessCredentialsData s)) (TF.Attr s P.Text) where
    computedLeaseDuration x = TF.compute (TF.refKey x) "lease_duration"

instance s ~ s' => P.HasComputedLeaseId (TF.Ref s' (AwsAccessCredentialsData s)) (TF.Attr s P.Text) where
    computedLeaseId x = TF.compute (TF.refKey x) "lease_id"

instance s ~ s' => P.HasComputedLeaseRenewable (TF.Ref s' (AwsAccessCredentialsData s)) (TF.Attr s P.Text) where
    computedLeaseRenewable x = TF.compute (TF.refKey x) "lease_renewable"

instance s ~ s' => P.HasComputedLeaseStartTime (TF.Ref s' (AwsAccessCredentialsData s)) (TF.Attr s P.Text) where
    computedLeaseStartTime x = TF.compute (TF.refKey x) "lease_start_time"

instance s ~ s' => P.HasComputedRole (TF.Ref s' (AwsAccessCredentialsData s)) (TF.Attr s P.Text) where
    computedRole =
        (_role :: AwsAccessCredentialsData s -> TF.Attr s P.Text)
            . TF.refValue

instance s ~ s' => P.HasComputedSecretKey (TF.Ref s' (AwsAccessCredentialsData s)) (TF.Attr s P.Text) where
    computedSecretKey x = TF.compute (TF.refKey x) "secret_key"

instance s ~ s' => P.HasComputedSecurityToken (TF.Ref s' (AwsAccessCredentialsData s)) (TF.Attr s P.Text) where
    computedSecurityToken x = TF.compute (TF.refKey x) "security_token"

instance s ~ s' => P.HasComputedType' (TF.Ref s' (AwsAccessCredentialsData s)) (TF.Attr s P.Text) where
    computedType' =
        (_type' :: AwsAccessCredentialsData s -> TF.Attr s P.Text)
            . TF.refValue

awsAccessCredentialsData :: TF.DataSource P.Vault (AwsAccessCredentialsData s)
awsAccessCredentialsData =
    TF.newDataSource "vault_aws_access_credentials" $
        AwsAccessCredentialsData {
              _backend = TF.Nil
            , _role = TF.Nil
            , _type' = TF.Nil
            }

{- | The @vault_generic_secret@ Vault datasource.

Reads arbitrary data from a given path in Vault. This resource is primarily
intended to be used with
<https://www.vaultproject.io/docs/secrets/generic/index.html> , but it is
also compatible with any other Vault endpoint that supports the @vault read@
command. ~> Important All data retrieved from Vault will be written in
cleartext to state file generated by Terraform, will appear in the console
output when Terraform runs, and may be included in plan files if secrets are
interpolated into any resource attributes. Protect these artifacts
accordingly. See <../index.html> for more details.
-}
data GenericSecretData s = GenericSecretData {
      _path :: !(TF.Attr s P.Text)
    {- ^ (Required) The full logical path from which to request data. To read data from the "generic" secret backend mounted in Vault by default, this should be prefixed with @secret/@ . Reading from other backends with this data source is possible; consult each backend's documentation to see which endpoints support the @GET@ method. -}
    } deriving (Show, Eq)

instance TF.ToHCL (GenericSecretData s) where
    toHCL GenericSecretData{..} = TF.inline $ catMaybes
        [ TF.assign "path" <$> TF.attribute _path
        ]

instance P.HasPath (GenericSecretData s) (TF.Attr s P.Text) where
    path =
        lens (_path :: GenericSecretData s -> TF.Attr s P.Text)
             (\s a -> s { _path = a } :: GenericSecretData s)

instance s ~ s' => P.HasComputedData' (TF.Ref s' (GenericSecretData s)) (TF.Attr s P.Text) where
    computedData' x = TF.compute (TF.refKey x) "data"

instance s ~ s' => P.HasComputedDataJson (TF.Ref s' (GenericSecretData s)) (TF.Attr s P.Text) where
    computedDataJson x = TF.compute (TF.refKey x) "data_json"

instance s ~ s' => P.HasComputedLeaseDuration (TF.Ref s' (GenericSecretData s)) (TF.Attr s P.Text) where
    computedLeaseDuration x = TF.compute (TF.refKey x) "lease_duration"

instance s ~ s' => P.HasComputedLeaseId (TF.Ref s' (GenericSecretData s)) (TF.Attr s P.Text) where
    computedLeaseId x = TF.compute (TF.refKey x) "lease_id"

instance s ~ s' => P.HasComputedLeaseRenewable (TF.Ref s' (GenericSecretData s)) (TF.Attr s P.Text) where
    computedLeaseRenewable x = TF.compute (TF.refKey x) "lease_renewable"

instance s ~ s' => P.HasComputedLeaseStartTime (TF.Ref s' (GenericSecretData s)) (TF.Attr s P.Text) where
    computedLeaseStartTime x = TF.compute (TF.refKey x) "lease_start_time"

instance s ~ s' => P.HasComputedPath (TF.Ref s' (GenericSecretData s)) (TF.Attr s P.Text) where
    computedPath =
        (_path :: GenericSecretData s -> TF.Attr s P.Text)
            . TF.refValue

genericSecretData :: TF.DataSource P.Vault (GenericSecretData s)
genericSecretData =
    TF.newDataSource "vault_generic_secret" $
        GenericSecretData {
              _path = TF.Nil
            }
