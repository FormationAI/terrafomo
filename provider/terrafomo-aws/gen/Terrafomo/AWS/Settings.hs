-- This module is auto-generated.

{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE OverloadedLists   #-}
{-# LANGUAGE RecordWildCards   #-}
{-# LANGUAGE StrictData        #-}

{-# OPTIONS_GHC -fno-warn-unused-imports #-}

-- |
-- Module      : Terrafomo.AWS.Settings
-- Copyright   : (c) 2017-2018 Brendan Hay
-- License     : Mozilla Public License, v. 2.0.
-- Maintainer  : Brendan Hay <brendan.g.hay+terrafomo@gmail.com>
-- Stability   : auto-generated
-- Portability : non-portable (GHC extensions)
--
module Terrafomo.AWS.Settings
    (
    -- * Settings Datatypes
    -- ** opsworks_stack_custom_cookbooks_source
      OpsworksStackCustomCookbooksSource (..)
    , newOpsworksStackCustomCookbooksSource

    -- ** waf_web_acl_rules
    , WafWebAclRules (..)
    , newWafWebAclRules

    -- ** rules_source_selection_criteria
    , RulesSourceSelectionCriteria (..)
    , newRulesSourceSelectionCriteria

    -- ** extended_s3_configuration_processing_configuration
    , ExtendedS3ConfigurationProcessingConfiguration (..)
    , newExtendedS3ConfigurationProcessingConfiguration

    -- ** glue_catalog_table_storage_descriptor
    , GlueCatalogTableStorageDescriptor (..)
    , newGlueCatalogTableStorageDescriptor

    -- ** config_config_rule_source
    , ConfigConfigRuleSource (..)
    , newConfigConfigRuleSource

    -- ** codecommit_trigger_trigger
    , CodecommitTriggerTrigger (..)
    , newCodecommitTriggerTrigger

    -- ** ordered_cache_behavior_lambda_function_association
    , OrderedCacheBehaviorLambdaFunctionAssociation (..)
    , newOrderedCacheBehaviorLambdaFunctionAssociation

    -- ** launch_template_placement
    , LaunchTemplatePlacement (..)
    , newLaunchTemplatePlacement

    -- ** cloudfront_distribution_logging_config
    , CloudfrontDistributionLoggingConfig (..)
    , newCloudfrontDistributionLoggingConfig

    -- ** vpc_endpoint_dns_entry
    , VpcEndpointDnsEntry (..)
    , newVpcEndpointDnsEntry

    -- ** codepipeline_stage
    , CodepipelineStage (..)
    , newCodepipelineStage

    -- ** route_tables_filter
    , RouteTablesFilter (..)
    , newRouteTablesFilter

    -- ** config_configuration_aggregator_account_aggregation_source
    , ConfigConfigurationAggregatorAccountAggregationSource (..)
    , newConfigConfigurationAggregatorAccountAggregationSource

    -- ** s3_bucket_versioning
    , S3BucketVersioning (..)
    , newS3BucketVersioning

    -- ** kinesis_firehose_delivery_stream_kinesis_source_configuration
    , KinesisFirehoseDeliveryStreamKinesisSourceConfiguration (..)
    , newKinesisFirehoseDeliveryStreamKinesisSourceConfiguration

    -- ** iot_topic_rule_republish
    , IotTopicRuleRepublish (..)
    , newIotTopicRuleRepublish

    -- ** elastictranscoder_pipeline_notifications
    , ElastictranscoderPipelineNotifications (..)
    , newElastictranscoderPipelineNotifications

    -- ** elastictranscoder_pipeline_thumbnail_config_permissions
    , ElastictranscoderPipelineThumbnailConfigPermissions (..)
    , newElastictranscoderPipelineThumbnailConfigPermissions

    -- ** api_gateway_usage_plan_throttle_settings
    , ApiGatewayUsagePlanThrottleSettings (..)
    , newApiGatewayUsagePlanThrottleSettings

    -- ** target_tracking_scaling_policy_configuration_customized_metric_specification
    , TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification (..)
    , newTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification

    -- ** ami_ephemeral_block_device
    , AmiEphemeralBlockDevice (..)
    , newAmiEphemeralBlockDevice

    -- ** extended_s3_configuration_data_format_conversion_configuration
    , ExtendedS3ConfigurationDataFormatConversionConfiguration (..)
    , newExtendedS3ConfigurationDataFormatConversionConfiguration

    -- ** gamelift_fleet_runtime_configuration
    , GameliftFleetRuntimeConfiguration (..)
    , newGameliftFleetRuntimeConfiguration

    -- ** dax_cluster_nodes
    , DaxClusterNodes (..)
    , newDaxClusterNodes

    -- ** security_group_egress
    , SecurityGroupEgress (..)
    , newSecurityGroupEgress

    -- ** launch_template_elastic_gpu_specifications
    , LaunchTemplateElasticGpuSpecifications (..)
    , newLaunchTemplateElasticGpuSpecifications

    -- ** budgets_budget_cost_types
    , BudgetsBudgetCostTypes (..)
    , newBudgetsBudgetCostTypes

    -- ** elastictranscoder_preset_video
    , ElastictranscoderPresetVideo (..)
    , newElastictranscoderPresetVideo

    -- ** rule_override_action
    , RuleOverrideAction (..)
    , newRuleOverrideAction

    -- ** network_acl_ingress
    , NetworkAclIngress (..)
    , newNetworkAclIngress

    -- ** input_format_configuration_deserializer
    , InputFormatConfigurationDeserializer (..)
    , newInputFormatConfigurationDeserializer

    -- ** ssm_maintenance_window_target_targets
    , SsmMaintenanceWindowTargetTargets (..)
    , newSsmMaintenanceWindowTargetTargets

    -- ** autoscaling_group_tag
    , AutoscalingGroupTag (..)
    , newAutoscalingGroupTag

    -- ** s3_bucket_inventory_destination
    , S3BucketInventoryDestination (..)
    , newS3BucketInventoryDestination

    -- ** route_table_filter
    , RouteTableFilter (..)
    , newRouteTableFilter

    -- ** data_format_conversion_configuration_output_format_configuration
    , DataFormatConversionConfigurationOutputFormatConfiguration (..)
    , newDataFormatConversionConfigurationOutputFormatConfiguration

    -- ** ami_ebs_block_device
    , AmiEbsBlockDevice (..)
    , newAmiEbsBlockDevice

    -- ** schema_number_attribute_constraints
    , SchemaNumberAttributeConstraints (..)
    , newSchemaNumberAttributeConstraints

    -- ** db_security_group_ingress
    , DbSecurityGroupIngress (..)
    , newDbSecurityGroupIngress

    -- ** mq_broker_configuration
    , MqBrokerConfiguration (..)
    , newMqBrokerConfiguration

    -- ** blue_green_deployment_config_terminate_blue_instances_on_deployment_success
    , BlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess (..)
    , newBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess

    -- ** wafregional_rule_group_activated_rule
    , WafregionalRuleGroupActivatedRule (..)
    , newWafregionalRuleGroupActivatedRule

    -- ** opsworks_application_app_source
    , OpsworksApplicationAppSource (..)
    , newOpsworksApplicationAppSource

    -- ** storage_descriptor_columns
    , StorageDescriptorColumns (..)
    , newStorageDescriptorColumns

    -- ** dynamodb_table_global_secondary_index
    , DynamodbTableGlobalSecondaryIndex (..)
    , newDynamodbTableGlobalSecondaryIndex

    -- ** cognito_user_pool_sms_configuration
    , CognitoUserPoolSmsConfiguration (..)
    , newCognitoUserPoolSmsConfiguration

    -- ** server_side_encryption_configuration_rule
    , ServerSideEncryptionConfigurationRule (..)
    , newServerSideEncryptionConfigurationRule

    -- ** waf_geo_match_set_geo_match_constraint
    , WafGeoMatchSetGeoMatchConstraint (..)
    , newWafGeoMatchSetGeoMatchConstraint

    -- ** byte_match_tuples_field_to_match
    , ByteMatchTuplesFieldToMatch (..)
    , newByteMatchTuplesFieldToMatch

    -- ** route53_record_weighted_routing_policy
    , Route53RecordWeightedRoutingPolicy (..)
    , newRoute53RecordWeightedRoutingPolicy

    -- ** api_gateway_method_settings_settings
    , ApiGatewayMethodSettingsSettings (..)
    , newApiGatewayMethodSettingsSettings

    -- ** redshift_cluster_snapshot_copy
    , RedshiftClusterSnapshotCopy (..)
    , newRedshiftClusterSnapshotCopy

    -- ** output_format_configuration_serializer
    , OutputFormatConfigurationSerializer (..)
    , newOutputFormatConfigurationSerializer

    -- ** vpc_peering_connection_options_requester
    , VpcPeeringConnectionOptionsRequester (..)
    , newVpcPeeringConnectionOptionsRequester

    -- ** revocation_configuration_crl_configuration
    , RevocationConfigurationCrlConfiguration (..)
    , newRevocationConfigurationCrlConfiguration

    -- ** cloudfront_distribution_viewer_certificate
    , CloudfrontDistributionViewerCertificate (..)
    , newCloudfrontDistributionViewerCertificate

    -- ** dynamodb_table_point_in_time_recovery
    , DynamodbTablePointInTimeRecovery (..)
    , newDynamodbTablePointInTimeRecovery

    -- ** cloudfront_distribution_custom_error_response
    , CloudfrontDistributionCustomErrorResponse (..)
    , newCloudfrontDistributionCustomErrorResponse

    -- ** glue_script_dag_edge
    , GlueScriptDagEdge (..)
    , newGlueScriptDagEdge

    -- ** emr_cluster_step
    , EmrClusterStep (..)
    , newEmrClusterStep

    -- ** default_route_table_route
    , DefaultRouteTableRoute (..)
    , newDefaultRouteTableRoute

    -- ** lb_target_group_health_check
    , LbTargetGroupHealthCheck (..)
    , newLbTargetGroupHealthCheck

    -- ** launch_template_credit_specification
    , LaunchTemplateCreditSpecification (..)
    , newLaunchTemplateCreditSpecification

    -- ** emr_instance_group_ebs_config
    , EmrInstanceGroupEbsConfig (..)
    , newEmrInstanceGroupEbsConfig

    -- ** acmpca_certificate_authority_certificate_authority_configuration
    , AcmpcaCertificateAuthorityCertificateAuthorityConfiguration (..)
    , newAcmpcaCertificateAuthorityCertificateAuthorityConfiguration

    -- ** encryption_sse_s3
    , EncryptionSseS3 (..)
    , newEncryptionSseS3

    -- ** security_groups_filter
    , SecurityGroupsFilter (..)
    , newSecurityGroupsFilter

    -- ** redshift_cluster_logging
    , RedshiftClusterLogging (..)
    , newRedshiftClusterLogging

    -- ** wafregional_rule_predicate
    , WafregionalRulePredicate (..)
    , newWafregionalRulePredicate

    -- ** vpc_filter
    , VpcFilter (..)
    , newVpcFilter

    -- ** redshift_security_group_ingress
    , RedshiftSecurityGroupIngress (..)
    , newRedshiftSecurityGroupIngress

    -- ** opsworks_instance_ebs_block_device
    , OpsworksInstanceEbsBlockDevice (..)
    , newOpsworksInstanceEbsBlockDevice

    -- ** elb_listener
    , ElbListener (..)
    , newElbListener

    -- ** codedeploy_deployment_config_minimum_healthy_hosts
    , CodedeployDeploymentConfigMinimumHealthyHosts (..)
    , newCodedeployDeploymentConfigMinimumHealthyHosts

    -- ** glue_connection_physical_connection_requirements
    , GlueConnectionPhysicalConnectionRequirements (..)
    , newGlueConnectionPhysicalConnectionRequirements

    -- ** opsworks_ganglia_layer_ebs_volume
    , OpsworksGangliaLayerEbsVolume (..)
    , newOpsworksGangliaLayerEbsVolume

    -- ** lb_listener_rule_condition
    , LbListenerRuleCondition (..)
    , newLbListenerRuleCondition

    -- ** cognito_user_pool_admin_create_user_config
    , CognitoUserPoolAdminCreateUserConfig (..)
    , newCognitoUserPoolAdminCreateUserConfig

    -- ** opsworks_custom_layer_ebs_volume
    , OpsworksCustomLayerEbsVolume (..)
    , newOpsworksCustomLayerEbsVolume

    -- ** codebuild_project_cache
    , CodebuildProjectCache (..)
    , newCodebuildProjectCache

    -- ** deserializer_hive_json_ser_de
    , DeserializerHiveJsonSerDe (..)
    , newDeserializerHiveJsonSerDe

    -- ** cognito_user_pool_device_configuration
    , CognitoUserPoolDeviceConfiguration (..)
    , newCognitoUserPoolDeviceConfiguration

    -- ** s3_backup_configuration_cloudwatch_logging_options
    , S3BackupConfigurationCloudwatchLoggingOptions (..)
    , newS3BackupConfigurationCloudwatchLoggingOptions

    -- ** waf_rule_group_activated_rule
    , WafRuleGroupActivatedRule (..)
    , newWafRuleGroupActivatedRule

    -- ** elastictranscoder_preset_thumbnails
    , ElastictranscoderPresetThumbnails (..)
    , newElastictranscoderPresetThumbnails

    -- ** option_option_settings
    , OptionOptionSettings (..)
    , newOptionOptionSettings

    -- ** destination_bucket
    , DestinationBucket (..)
    , newDestinationBucket

    -- ** service_discovery_service_health_check_config
    , ServiceDiscoveryServiceHealthCheckConfig (..)
    , newServiceDiscoveryServiceHealthCheckConfig

    -- ** redshift_configuration_s3_backup_configuration
    , RedshiftConfigurationS3BackupConfiguration (..)
    , newRedshiftConfigurationS3BackupConfiguration

    -- ** ami_copy_ebs_block_device
    , AmiCopyEbsBlockDevice (..)
    , newAmiCopyEbsBlockDevice

    -- ** batch_job_definition_retry_strategy
    , BatchJobDefinitionRetryStrategy (..)
    , newBatchJobDefinitionRetryStrategy

    -- ** block_device_mappings_ebs
    , BlockDeviceMappingsEbs (..)
    , newBlockDeviceMappingsEbs

    -- ** ecs_service_ordered_placement_strategy
    , EcsServiceOrderedPlacementStrategy (..)
    , newEcsServiceOrderedPlacementStrategy

    -- ** gamelift_fleet_ec2_inbound_permission
    , GameliftFleetEc2InboundPermission (..)
    , newGameliftFleetEc2InboundPermission

    -- ** ordered_cache_behavior_forwarded_values
    , OrderedCacheBehaviorForwardedValues (..)
    , newOrderedCacheBehaviorForwardedValues

    -- ** stage_action
    , StageAction (..)
    , newStageAction

    -- ** xss_match_tuples_field_to_match
    , XssMatchTuplesFieldToMatch (..)
    , newXssMatchTuplesFieldToMatch

    -- ** elastictranscoder_preset_audio_codec_options
    , ElastictranscoderPresetAudioCodecOptions (..)
    , newElastictranscoderPresetAudioCodecOptions

    -- ** lb_ssl_negotiation_policy_attribute
    , LbSslNegotiationPolicyAttribute (..)
    , newLbSslNegotiationPolicyAttribute

    -- ** kms_grant_constraints
    , KmsGrantConstraints (..)
    , newKmsGrantConstraints

    -- ** ecs_service_load_balancer
    , EcsServiceLoadBalancer (..)
    , newEcsServiceLoadBalancer

    -- ** runtime_configuration_server_process
    , RuntimeConfigurationServerProcess (..)
    , newRuntimeConfigurationServerProcess

    -- ** glue_classifier_xml_classifier
    , GlueClassifierXmlClassifier (..)
    , newGlueClassifierXmlClassifier

    -- ** vpc_cidr_block_associations
    , VpcCidrBlockAssociations (..)
    , newVpcCidrBlockAssociations

    -- ** glue_classifier_grok_classifier
    , GlueClassifierGrokClassifier (..)
    , newGlueClassifierGrokClassifier

    -- ** network_acl_egress
    , NetworkAclEgress (..)
    , newNetworkAclEgress

    -- ** vpc_dhcp_options_filter
    , VpcDhcpOptionsFilter (..)
    , newVpcDhcpOptionsFilter

    -- ** s3_bucket_metric_filter
    , S3BucketMetricFilter (..)
    , newS3BucketMetricFilter

    -- ** ec2_tag_set_ec2_tag_filter
    , Ec2TagSetEc2TagFilter (..)
    , newEc2TagSetEc2TagFilter

    -- ** macie_s3_bucket_association_classification_type
    , MacieS3BucketAssociationClassificationType (..)
    , newMacieS3BucketAssociationClassificationType

    -- ** emr_cluster_kerberos_attributes
    , EmrClusterKerberosAttributes (..)
    , newEmrClusterKerberosAttributes

    -- ** route_table_associations
    , RouteTableAssociations (..)
    , newRouteTableAssociations

    -- ** rds_cluster_s3_import
    , RdsClusterS3Import (..)
    , newRdsClusterS3Import

    -- ** cognito_user_pool_password_policy
    , CognitoUserPoolPasswordPolicy (..)
    , newCognitoUserPoolPasswordPolicy

    -- ** kinesis_firehose_delivery_stream_redshift_configuration
    , KinesisFirehoseDeliveryStreamRedshiftConfiguration (..)
    , newKinesisFirehoseDeliveryStreamRedshiftConfiguration

    -- ** cloudfront_distribution_restrictions
    , CloudfrontDistributionRestrictions (..)
    , newCloudfrontDistributionRestrictions

    -- ** s3_bucket_logging
    , S3BucketLogging (..)
    , newS3BucketLogging

    -- ** data_format_conversion_configuration_schema_configuration
    , DataFormatConversionConfigurationSchemaConfiguration (..)
    , newDataFormatConversionConfigurationSchemaConfiguration

    -- ** mq_broker_instances
    , MqBrokerInstances (..)
    , newMqBrokerInstances

    -- ** cloudwatch_event_target_sqs_target
    , CloudwatchEventTargetSqsTarget (..)
    , newCloudwatchEventTargetSqsTarget

    -- ** spot_instance_request_root_block_device
    , SpotInstanceRequestRootBlockDevice (..)
    , newSpotInstanceRequestRootBlockDevice

    -- ** glacier_vault_notification
    , GlacierVaultNotification (..)
    , newGlacierVaultNotification

    -- ** vpn_connection_vgw_telemetry
    , VpnConnectionVgwTelemetry (..)
    , newVpnConnectionVgwTelemetry

    -- ** waf_ipset_ip_set_descriptors
    , WafIpsetIpSetDescriptors (..)
    , newWafIpsetIpSetDescriptors

    -- ** launch_configuration_ebs_block_device
    , LaunchConfigurationEbsBlockDevice (..)
    , newLaunchConfigurationEbsBlockDevice

    -- ** appautoscaling_policy_target_tracking_scaling_policy_configuration
    , AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration (..)
    , newAppautoscalingPolicyTargetTrackingScalingPolicyConfiguration

    -- ** approval_rule_patch_filter
    , ApprovalRulePatchFilter (..)
    , newApprovalRulePatchFilter

    -- ** elb_access_logs
    , ElbAccessLogs (..)
    , newElbAccessLogs

    -- ** ecs_service_placement_constraints
    , EcsServicePlacementConstraints (..)
    , newEcsServicePlacementConstraints

    -- ** redshift_configuration_cloudwatch_logging_options
    , RedshiftConfigurationCloudwatchLoggingOptions (..)
    , newRedshiftConfigurationCloudwatchLoggingOptions

    -- ** alb_subnet_mapping
    , AlbSubnetMapping (..)
    , newAlbSubnetMapping

    -- ** autoscaling_policy_step_adjustment
    , AutoscalingPolicyStepAdjustment (..)
    , newAutoscalingPolicyStepAdjustment

    -- ** ami_from_instance_ebs_block_device
    , AmiFromInstanceEbsBlockDevice (..)
    , newAmiFromInstanceEbsBlockDevice

    -- ** default_security_group_egress
    , DefaultSecurityGroupEgress (..)
    , newDefaultSecurityGroupEgress

    -- ** api_gateway_documentation_part_location
    , ApiGatewayDocumentationPartLocation (..)
    , newApiGatewayDocumentationPartLocation

    -- ** glue_catalog_table_partition_keys
    , GlueCatalogTablePartitionKeys (..)
    , newGlueCatalogTablePartitionKeys

    -- ** codedeploy_deployment_group_trigger_configuration
    , CodedeployDeploymentGroupTriggerConfiguration (..)
    , newCodedeployDeploymentGroupTriggerConfiguration

    -- ** elasticsearch_configuration_cloudwatch_logging_options
    , ElasticsearchConfigurationCloudwatchLoggingOptions (..)
    , newElasticsearchConfigurationCloudwatchLoggingOptions

    -- ** batch_compute_environment_compute_resources
    , BatchComputeEnvironmentComputeResources (..)
    , newBatchComputeEnvironmentComputeResources

    -- ** storage_descriptor_skewed_info
    , StorageDescriptorSkewedInfo (..)
    , newStorageDescriptorSkewedInfo

    -- ** launch_template_instance_market_options
    , LaunchTemplateInstanceMarketOptions (..)
    , newLaunchTemplateInstanceMarketOptions

    -- ** vpc_peering_connection_accepter_requester
    , VpcPeeringConnectionAccepterRequester (..)
    , newVpcPeeringConnectionAccepterRequester

    -- ** network_interfaces_filter
    , NetworkInterfacesFilter (..)
    , newNetworkInterfacesFilter

    -- ** cloudwatch_event_target_batch_target
    , CloudwatchEventTargetBatchTarget (..)
    , newCloudwatchEventTargetBatchTarget

    -- ** vpn_gateway_filter
    , VpnGatewayFilter (..)
    , newVpnGatewayFilter

    -- ** ses_receipt_rule_add_header_action
    , SesReceiptRuleAddHeaderAction (..)
    , newSesReceiptRuleAddHeaderAction

    -- ** cloudwatch_event_target_input_transformer
    , CloudwatchEventTargetInputTransformer (..)
    , newCloudwatchEventTargetInputTransformer

    -- ** glue_crawler_schema_change_policy
    , GlueCrawlerSchemaChangePolicy (..)
    , newGlueCrawlerSchemaChangePolicy

    -- ** elastic_beanstalk_environment_setting
    , ElasticBeanstalkEnvironmentSetting (..)
    , newElasticBeanstalkEnvironmentSetting

    -- ** ami_product_codes
    , AmiProductCodes (..)
    , newAmiProductCodes

    -- ** iot_topic_rule_firehose
    , IotTopicRuleFirehose (..)
    , newIotTopicRuleFirehose

    -- ** default_network_acl_ingress
    , DefaultNetworkAclIngress (..)
    , newDefaultNetworkAclIngress

    -- ** codedeploy_deployment_group_alarm_configuration
    , CodedeployDeploymentGroupAlarmConfiguration (..)
    , newCodedeployDeploymentGroupAlarmConfiguration

    -- ** codedeploy_deployment_group_ec2_tag_set
    , CodedeployDeploymentGroupEc2TagSet (..)
    , newCodedeployDeploymentGroupEc2TagSet

    -- ** appautoscaling_scheduled_action_scalable_target_action
    , AppautoscalingScheduledActionScalableTargetAction (..)
    , newAppautoscalingScheduledActionScalableTargetAction

    -- ** regex_match_tuple_field_to_match
    , RegexMatchTupleFieldToMatch (..)
    , newRegexMatchTupleFieldToMatch

    -- ** launch_template_block_device_mappings
    , LaunchTemplateBlockDeviceMappings (..)
    , newLaunchTemplateBlockDeviceMappings

    -- ** network_interface_filter
    , NetworkInterfaceFilter (..)
    , newNetworkInterfaceFilter

    -- ** wafregional_size_constraint_set_size_constraints
    , WafregionalSizeConstraintSetSizeConstraints (..)
    , newWafregionalSizeConstraintSetSizeConstraints

    -- ** api_gateway_domain_name_endpoint_configuration
    , ApiGatewayDomainNameEndpointConfiguration (..)
    , newApiGatewayDomainNameEndpointConfiguration

    -- ** ami_from_instance_ephemeral_block_device
    , AmiFromInstanceEphemeralBlockDevice (..)
    , newAmiFromInstanceEphemeralBlockDevice

    -- ** target_tracking_scaling_policy_configuration_predefined_metric_specification
    , TargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification (..)
    , newTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification

    -- ** alb_listener_rule_condition
    , AlbListenerRuleCondition (..)
    , newAlbListenerRuleCondition

    -- ** elastictranscoder_preset_audio
    , ElastictranscoderPresetAudio (..)
    , newElastictranscoderPresetAudio

    -- ** statement_principals
    , StatementPrincipals (..)
    , newStatementPrincipals

    -- ** internet_gateway_filter
    , InternetGatewayFilter (..)
    , newInternetGatewayFilter

    -- ** alb_target_group_health_check
    , AlbTargetGroupHealthCheck (..)
    , newAlbTargetGroupHealthCheck

    -- ** emr_cluster_bootstrap_action
    , EmrClusterBootstrapAction (..)
    , newEmrClusterBootstrapAction

    -- ** waf_web_acl_default_action
    , WafWebAclDefaultAction (..)
    , newWafWebAclDefaultAction

    -- ** opsworks_mysql_layer_ebs_volume
    , OpsworksMysqlLayerEbsVolume (..)
    , newOpsworksMysqlLayerEbsVolume

    -- ** ssm_patch_baseline_global_filter
    , SsmPatchBaselineGlobalFilter (..)
    , newSsmPatchBaselineGlobalFilter

    -- ** s3_bucket_inventory_filter
    , S3BucketInventoryFilter (..)
    , newS3BucketInventoryFilter

    -- ** splunk_configuration_processing_configuration
    , SplunkConfigurationProcessingConfiguration (..)
    , newSplunkConfigurationProcessingConfiguration

    -- ** ssm_maintenance_window_task_targets
    , SsmMaintenanceWindowTaskTargets (..)
    , newSsmMaintenanceWindowTaskTargets

    -- ** spot_instance_request_network_interface
    , SpotInstanceRequestNetworkInterface (..)
    , newSpotInstanceRequestNetworkInterface

    -- ** launch_configuration_ephemeral_block_device
    , LaunchConfigurationEphemeralBlockDevice (..)
    , newLaunchConfigurationEphemeralBlockDevice

    -- ** codebuild_project_source
    , CodebuildProjectSource (..)
    , newCodebuildProjectSource

    -- ** sql_injection_match_tuples_field_to_match
    , SqlInjectionMatchTuplesFieldToMatch (..)
    , newSqlInjectionMatchTuplesFieldToMatch

    -- ** wafregional_web_acl_default_action
    , WafregionalWebAclDefaultAction (..)
    , newWafregionalWebAclDefaultAction

    -- ** security_group_ingress
    , SecurityGroupIngress (..)
    , newSecurityGroupIngress

    -- ** codedeploy_deployment_group_blue_green_deployment_config
    , CodedeployDeploymentGroupBlueGreenDeploymentConfig (..)
    , newCodedeployDeploymentGroupBlueGreenDeploymentConfig

    -- ** dax_parameter_group_parameters
    , DaxParameterGroupParameters (..)
    , newDaxParameterGroupParameters

    -- ** opsworks_static_web_layer_ebs_volume
    , OpsworksStaticWebLayerEbsVolume (..)
    , newOpsworksStaticWebLayerEbsVolume

    -- ** processing_configuration_processors
    , ProcessingConfigurationProcessors (..)
    , newProcessingConfigurationProcessors

    -- ** gamelift_fleet_resource_creation_limit_policy
    , GameliftFleetResourceCreationLimitPolicy (..)
    , newGameliftFleetResourceCreationLimitPolicy

    -- ** s3_bucket_inventory_schedule
    , S3BucketInventorySchedule (..)
    , newS3BucketInventorySchedule

    -- ** ssm_association_targets
    , SsmAssociationTargets (..)
    , newSsmAssociationTargets

    -- ** config_configuration_aggregator_organization_aggregation_source
    , ConfigConfigurationAggregatorOrganizationAggregationSource (..)
    , newConfigConfigurationAggregatorOrganizationAggregationSource

    -- ** bucket_encryption
    , BucketEncryption (..)
    , newBucketEncryption

    -- ** waf_size_constraint_set_size_constraints
    , WafSizeConstraintSetSizeConstraints (..)
    , newWafSizeConstraintSetSizeConstraints

    -- ** cloudfront_distribution_origin
    , CloudfrontDistributionOrigin (..)
    , newCloudfrontDistributionOrigin

    -- ** xss_match_tuple_field_to_match
    , XssMatchTupleFieldToMatch (..)
    , newXssMatchTupleFieldToMatch

    -- ** launch_specification_ephemeral_block_device
    , LaunchSpecificationEphemeralBlockDevice (..)
    , newLaunchSpecificationEphemeralBlockDevice

    -- ** kinesis_firehose_delivery_stream_extended_s3_configuration
    , KinesisFirehoseDeliveryStreamExtendedS3Configuration (..)
    , newKinesisFirehoseDeliveryStreamExtendedS3Configuration

    -- ** secretsmanager_secret_rotation_rules
    , SecretsmanagerSecretRotationRules (..)
    , newSecretsmanagerSecretRotationRules

    -- ** load_balancer_policy_policy_attribute
    , LoadBalancerPolicyPolicyAttribute (..)
    , newLoadBalancerPolicyPolicyAttribute

    -- ** api_gateway_stage_access_log_settings
    , ApiGatewayStageAccessLogSettings (..)
    , newApiGatewayStageAccessLogSettings

    -- ** api_gateway_usage_plan_api_stages
    , ApiGatewayUsagePlanApiStages (..)
    , newApiGatewayUsagePlanApiStages

    -- ** kms_secrets_secret
    , KmsSecretsSecret (..)
    , newKmsSecretsSecret

    -- ** glue_trigger_actions
    , GlueTriggerActions (..)
    , newGlueTriggerActions

    -- ** glue_job_execution_property
    , GlueJobExecutionProperty (..)
    , newGlueJobExecutionProperty

    -- ** artifact_store_encryption_key
    , ArtifactStoreEncryptionKey (..)
    , newArtifactStoreEncryptionKey

    -- ** route53_record_geolocation_routing_policy
    , Route53RecordGeolocationRoutingPolicy (..)
    , newRoute53RecordGeolocationRoutingPolicy

    -- ** cognito_user_pool_email_configuration
    , CognitoUserPoolEmailConfiguration (..)
    , newCognitoUserPoolEmailConfiguration

    -- ** cloudwatch_event_target_run_command_targets
    , CloudwatchEventTargetRunCommandTargets (..)
    , newCloudwatchEventTargetRunCommandTargets

    -- ** predicate_conditions
    , PredicateConditions (..)
    , newPredicateConditions

    -- ** environment_environment_variable
    , EnvironmentEnvironmentVariable (..)
    , newEnvironmentEnvironmentVariable

    -- ** opsworks_nodejs_app_layer_ebs_volume
    , OpsworksNodejsAppLayerEbsVolume (..)
    , newOpsworksNodejsAppLayerEbsVolume

    -- ** default_network_acl_egress
    , DefaultNetworkAclEgress (..)
    , newDefaultNetworkAclEgress

    -- ** acmpca_certificate_authority_revocation_configuration
    , AcmpcaCertificateAuthorityRevocationConfiguration (..)
    , newAcmpcaCertificateAuthorityRevocationConfiguration

    -- ** waf_xss_match_set_xss_match_tuples
    , WafXssMatchSetXssMatchTuples (..)
    , newWafXssMatchSetXssMatchTuples

    -- ** replication_configuration_rules
    , ReplicationConfigurationRules (..)
    , newReplicationConfigurationRules

    -- ** appsync_datasource_lambda_config
    , AppsyncDatasourceLambdaConfig (..)
    , newAppsyncDatasourceLambdaConfig

    -- ** dynamodb_table_server_side_encryption
    , DynamodbTableServerSideEncryption (..)
    , newDynamodbTableServerSideEncryption

    -- ** ses_receipt_rule_bounce_action
    , SesReceiptRuleBounceAction (..)
    , newSesReceiptRuleBounceAction

    -- ** target_tracking_configuration_customized_metric_specification
    , TargetTrackingConfigurationCustomizedMetricSpecification (..)
    , newTargetTrackingConfigurationCustomizedMetricSpecification

    -- ** acm_certificate_domain_validation_options
    , AcmCertificateDomainValidationOptions (..)
    , newAcmCertificateDomainValidationOptions

    -- ** internet_gateway_attachments
    , InternetGatewayAttachments (..)
    , newInternetGatewayAttachments

    -- ** dms_endpoint_mongodb_settings
    , DmsEndpointMongodbSettings (..)
    , newDmsEndpointMongodbSettings

    -- ** codedeploy_deployment_group_ec2_tag_filter
    , CodedeployDeploymentGroupEc2TagFilter (..)
    , newCodedeployDeploymentGroupEc2TagFilter

    -- ** ses_receipt_rule_workmail_action
    , SesReceiptRuleWorkmailAction (..)
    , newSesReceiptRuleWorkmailAction

    -- ** waf_byte_match_set_byte_match_tuples
    , WafByteMatchSetByteMatchTuples (..)
    , newWafByteMatchSetByteMatchTuples

    -- ** statement_not_principals
    , StatementNotPrincipals (..)
    , newStatementNotPrincipals

    -- ** size_constraints_field_to_match
    , SizeConstraintsFieldToMatch (..)
    , newSizeConstraintsFieldToMatch

    -- ** elasticsearch_domain_encrypt_at_rest
    , ElasticsearchDomainEncryptAtRest (..)
    , newElasticsearchDomainEncryptAtRest

    -- ** security_group_filter
    , SecurityGroupFilter (..)
    , newSecurityGroupFilter

    -- ** ssm_patch_baseline_approval_rule
    , SsmPatchBaselineApprovalRule (..)
    , newSsmPatchBaselineApprovalRule

    -- ** ecs_service_service_registries
    , EcsServiceServiceRegistries (..)
    , newEcsServiceServiceRegistries

    -- ** waf_sql_injection_match_set_sql_injection_match_tuples
    , WafSqlInjectionMatchSetSqlInjectionMatchTuples (..)
    , newWafSqlInjectionMatchSetSqlInjectionMatchTuples

    -- ** elb_health_check
    , ElbHealthCheck (..)
    , newElbHealthCheck

    -- ** vpc_peering_connection_accepter
    , VpcPeeringConnectionAccepter (..)
    , newVpcPeeringConnectionAccepter

    -- ** ecs_service_network_configuration
    , EcsServiceNetworkConfiguration (..)
    , newEcsServiceNetworkConfiguration

    -- ** service_discovery_service_dns_config
    , ServiceDiscoveryServiceDnsConfig (..)
    , newServiceDiscoveryServiceDnsConfig

    -- ** cloudfront_distribution_default_cache_behavior
    , CloudfrontDistributionDefaultCacheBehavior (..)
    , newCloudfrontDistributionDefaultCacheBehavior

    -- ** emr_cluster_instance_group
    , EmrClusterInstanceGroup (..)
    , newEmrClusterInstanceGroup

    -- ** s3_bucket_lifecycle_rule
    , S3BucketLifecycleRule (..)
    , newS3BucketLifecycleRule

    -- ** opsworks_instance_ephemeral_block_device
    , OpsworksInstanceEphemeralBlockDevice (..)
    , newOpsworksInstanceEphemeralBlockDevice

    -- ** wafregional_rate_based_rule_predicate
    , WafregionalRateBasedRulePredicate (..)
    , newWafregionalRateBasedRulePredicate

    -- ** eks_cluster_certificate_authority
    , EksClusterCertificateAuthority (..)
    , newEksClusterCertificateAuthority

    -- ** vpn_connection_routes
    , VpnConnectionRoutes (..)
    , newVpnConnectionRoutes

    -- ** cloudwatch_event_target_kinesis_target
    , CloudwatchEventTargetKinesisTarget (..)
    , newCloudwatchEventTargetKinesisTarget

    -- ** event_selector_data_resource
    , EventSelectorDataResource (..)
    , newEventSelectorDataResource

    -- ** dynamodb_table_ttl
    , DynamodbTableTtl (..)
    , newDynamodbTableTtl

    -- ** rules_action
    , RulesAction (..)
    , newRulesAction

    -- ** waf_rule_predicates
    , WafRulePredicates (..)
    , newWafRulePredicates

    -- ** ebs_volume_filter
    , EbsVolumeFilter (..)
    , newEbsVolumeFilter

    -- ** alb_access_logs
    , AlbAccessLogs (..)
    , newAlbAccessLogs

    -- ** customized_metric_specification_metric_dimension
    , CustomizedMetricSpecificationMetricDimension (..)
    , newCustomizedMetricSpecificationMetricDimension

    -- ** api_gateway_account_throttle_settings
    , ApiGatewayAccountThrottleSettings (..)
    , newApiGatewayAccountThrottleSettings

    -- ** mq_broker_maintenance_window_start_time
    , MqBrokerMaintenanceWindowStartTime (..)
    , newMqBrokerMaintenanceWindowStartTime

    -- ** emr_cluster_ec2_attributes
    , EmrClusterEc2Attributes (..)
    , newEmrClusterEc2Attributes

    -- ** autoscaling_policy_target_tracking_configuration
    , AutoscalingPolicyTargetTrackingConfiguration (..)
    , newAutoscalingPolicyTargetTrackingConfiguration

    -- ** route53_record_alias
    , Route53RecordAlias (..)
    , newRoute53RecordAlias

    -- ** opsworks_haproxy_layer_ebs_volume
    , OpsworksHaproxyLayerEbsVolume (..)
    , newOpsworksHaproxyLayerEbsVolume

    -- ** api_gateway_rest_api_endpoint_configuration
    , ApiGatewayRestApiEndpointConfiguration (..)
    , newApiGatewayRestApiEndpointConfiguration

    -- ** lambda_function_tracing_config
    , LambdaFunctionTracingConfig (..)
    , newLambdaFunctionTracingConfig

    -- ** ami_block_device_mappings
    , AmiBlockDeviceMappings (..)
    , newAmiBlockDeviceMappings

    -- ** splunk_configuration_cloudwatch_logging_options
    , SplunkConfigurationCloudwatchLoggingOptions (..)
    , newSplunkConfigurationCloudwatchLoggingOptions

    -- ** dynamodb_table_attribute
    , DynamodbTableAttribute (..)
    , newDynamodbTableAttribute

    -- ** gamelift_build_storage_location
    , GameliftBuildStorageLocation (..)
    , newGameliftBuildStorageLocation

    -- ** customized_metric_specification_dimensions
    , CustomizedMetricSpecificationDimensions (..)
    , newCustomizedMetricSpecificationDimensions

    -- ** dynamodb_global_table_replica
    , DynamodbGlobalTableReplica (..)
    , newDynamodbGlobalTableReplica

    -- ** neptune_cluster_parameter_group_parameter
    , NeptuneClusterParameterGroupParameter (..)
    , newNeptuneClusterParameterGroupParameter

    -- ** glue_classifier_json_classifier
    , GlueClassifierJsonClassifier (..)
    , newGlueClassifierJsonClassifier

    -- ** elasticsearch_domain_cluster_config
    , ElasticsearchDomainClusterConfig (..)
    , newElasticsearchDomainClusterConfig

    -- ** wafregional_byte_match_set_byte_match_tuples
    , WafregionalByteMatchSetByteMatchTuples (..)
    , newWafregionalByteMatchSetByteMatchTuples

    -- ** cognito_user_pool_schema
    , CognitoUserPoolSchema (..)
    , newCognitoUserPoolSchema

    -- ** iot_topic_rule_sns
    , IotTopicRuleSns (..)
    , newIotTopicRuleSns

    -- ** opsworks_memcached_layer_ebs_volume
    , OpsworksMemcachedLayerEbsVolume (..)
    , newOpsworksMemcachedLayerEbsVolume

    -- ** iot_topic_rule_dynamodb
    , IotTopicRuleDynamodb (..)
    , newIotTopicRuleDynamodb

    -- ** subnet_filter
    , SubnetFilter (..)
    , newSubnetFilter

    -- ** cognito_user_pool_lambda_config
    , CognitoUserPoolLambdaConfig (..)
    , newCognitoUserPoolLambdaConfig

    -- ** ses_event_destination_sns_destination
    , SesEventDestinationSnsDestination (..)
    , newSesEventDestinationSnsDestination

    -- ** assume_role
    , AssumeRole (..)
    , newAssumeRole

    -- ** elasticsearch_configuration_processing_configuration
    , ElasticsearchConfigurationProcessingConfiguration (..)
    , newElasticsearchConfigurationProcessingConfiguration

    -- ** appsync_graphql_api_user_pool_config
    , AppsyncGraphqlApiUserPoolConfig (..)
    , newAppsyncGraphqlApiUserPoolConfig

    -- ** ses_receipt_rule_sns_action
    , SesReceiptRuleSnsAction (..)
    , newSesReceiptRuleSnsAction

    -- ** instance_group_ebs_config
    , InstanceGroupEbsConfig (..)
    , newInstanceGroupEbsConfig

    -- ** autoscaling_group_launch_template
    , AutoscalingGroupLaunchTemplate (..)
    , newAutoscalingGroupLaunchTemplate

    -- ** launch_specification_root_block_device
    , LaunchSpecificationRootBlockDevice (..)
    , newLaunchSpecificationRootBlockDevice

    -- ** lb_listener_rule_action
    , LbListenerRuleAction (..)
    , newLbListenerRuleAction

    -- ** glue_crawler_dynamodb_target
    , GlueCrawlerDynamodbTarget (..)
    , newGlueCrawlerDynamodbTarget

    -- ** encryption_sse_kms
    , EncryptionSseKms (..)
    , newEncryptionSseKms

    -- ** opsworks_php_app_layer_ebs_volume
    , OpsworksPhpAppLayerEbsVolume (..)
    , newOpsworksPhpAppLayerEbsVolume

    -- ** gamelift_alias_routing_strategy
    , GameliftAliasRoutingStrategy (..)
    , newGameliftAliasRoutingStrategy

    -- ** rule_action
    , RuleAction (..)
    , newRuleAction

    -- ** blue_green_deployment_config_deployment_ready_option
    , BlueGreenDeploymentConfigDeploymentReadyOption (..)
    , newBlueGreenDeploymentConfigDeploymentReadyOption

    -- ** cognito_user_pool_verification_message_template
    , CognitoUserPoolVerificationMessageTemplate (..)
    , newCognitoUserPoolVerificationMessageTemplate

    -- ** redshift_configuration_processing_configuration
    , RedshiftConfigurationProcessingConfiguration (..)
    , newRedshiftConfigurationProcessingConfiguration

    -- ** eks_cluster_vpc_config
    , EksClusterVpcConfig (..)
    , newEksClusterVpcConfig

    -- ** wafregional_xss_match_set_xss_match_tuple
    , WafregionalXssMatchSetXssMatchTuple (..)
    , newWafregionalXssMatchSetXssMatchTuple

    -- ** lifecycle_rule_noncurrent_version_expiration
    , LifecycleRuleNoncurrentVersionExpiration (..)
    , newLifecycleRuleNoncurrentVersionExpiration

    -- ** lifecycle_rule_transition
    , LifecycleRuleTransition (..)
    , newLifecycleRuleTransition

    -- ** rules_override_action
    , RulesOverrideAction (..)
    , newRulesOverrideAction

    -- ** spot_fleet_request_launch_specification
    , SpotFleetRequestLaunchSpecification (..)
    , newSpotFleetRequestLaunchSpecification

    -- ** wafregional_regex_match_set_regex_match_tuple
    , WafregionalRegexMatchSetRegexMatchTuple (..)
    , newWafregionalRegexMatchSetRegexMatchTuple

    -- ** waf_rate_based_rule_predicates
    , WafRateBasedRulePredicates (..)
    , newWafRateBasedRulePredicates

    -- ** wafregional_sql_injection_match_set_sql_injection_match_tuple
    , WafregionalSqlInjectionMatchSetSqlInjectionMatchTuple (..)
    , newWafregionalSqlInjectionMatchSetSqlInjectionMatchTuple

    -- ** opsworks_application_ssl_configuration
    , OpsworksApplicationSslConfiguration (..)
    , newOpsworksApplicationSslConfiguration

    -- ** certificate_authority_configuration_subject
    , CertificateAuthorityConfigurationSubject (..)
    , newCertificateAuthorityConfigurationSubject

    -- ** elasticache_parameter_group_parameter
    , ElasticacheParameterGroupParameter (..)
    , newElasticacheParameterGroupParameter

    -- ** iot_topic_rule_s3
    , IotTopicRuleS3 (..)
    , newIotTopicRuleS3

    -- ** source_auth
    , SourceAuth (..)
    , newSourceAuth

    -- ** ecs_task_definition_placement_constraints
    , EcsTaskDefinitionPlacementConstraints (..)
    , newEcsTaskDefinitionPlacementConstraints

    -- ** storage_descriptor_sort_columns
    , StorageDescriptorSortColumns (..)
    , newStorageDescriptorSortColumns

    -- ** iot_topic_rule_kinesis
    , IotTopicRuleKinesis (..)
    , newIotTopicRuleKinesis

    -- ** waf_regex_match_set_regex_match_tuple
    , WafRegexMatchSetRegexMatchTuple (..)
    , newWafRegexMatchSetRegexMatchTuple

    -- ** api_gateway_usage_plan_quota_settings
    , ApiGatewayUsagePlanQuotaSettings (..)
    , newApiGatewayUsagePlanQuotaSettings

    -- ** config_configuration_recorder_recording_group
    , ConfigConfigurationRecorderRecordingGroup (..)
    , newConfigConfigurationRecorderRecordingGroup

    -- ** instance_network_interface
    , InstanceNetworkInterface (..)
    , newInstanceNetworkInterface

    -- ** ssm_document_permissions
    , SsmDocumentPermissions (..)
    , newSsmDocumentPermissions

    -- ** launch_template_network_interfaces
    , LaunchTemplateNetworkInterfaces (..)
    , newLaunchTemplateNetworkInterfaces

    -- ** network_interface_attachment
    , NetworkInterfaceAttachment (..)
    , newNetworkInterfaceAttachment

    -- ** route53_record_failover_routing_policy
    , Route53RecordFailoverRoutingPolicy (..)
    , newRoute53RecordFailoverRoutingPolicy

    -- ** wafregional_geo_match_set_geo_match_constraint
    , WafregionalGeoMatchSetGeoMatchConstraint (..)
    , newWafregionalGeoMatchSetGeoMatchConstraint

    -- ** s3_bucket_cors_rule
    , S3BucketCorsRule (..)
    , newS3BucketCorsRule

    -- ** default_security_group_ingress
    , DefaultSecurityGroupIngress (..)
    , newDefaultSecurityGroupIngress

    -- ** cloudwatch_log_metric_filter_metric_transformation
    , CloudwatchLogMetricFilterMetricTransformation (..)
    , newCloudwatchLogMetricFilterMetricTransformation

    -- ** launch_configuration_root_block_device
    , LaunchConfigurationRootBlockDevice (..)
    , newLaunchConfigurationRootBlockDevice

    -- ** batch_job_definition_timeout
    , BatchJobDefinitionTimeout (..)
    , newBatchJobDefinitionTimeout

    -- ** glue_trigger_predicate
    , GlueTriggerPredicate (..)
    , newGlueTriggerPredicate

    -- ** opsworks_rails_app_layer_ebs_volume
    , OpsworksRailsAppLayerEbsVolume (..)
    , newOpsworksRailsAppLayerEbsVolume

    -- ** elastic_beanstalk_configuration_template_setting
    , ElasticBeanstalkConfigurationTemplateSetting (..)
    , newElasticBeanstalkConfigurationTemplateSetting

    -- ** cloudtrail_event_selector
    , CloudtrailEventSelector (..)
    , newCloudtrailEventSelector

    -- ** storagegateway_gateway_smb_active_directory_settings
    , StoragegatewayGatewaySmbActiveDirectorySettings (..)
    , newStoragegatewayGatewaySmbActiveDirectorySettings

    -- ** ecs_task_definition_volume
    , EcsTaskDefinitionVolume (..)
    , newEcsTaskDefinitionVolume

    -- ** wafregional_web_acl_rule
    , WafregionalWebAclRule (..)
    , newWafregionalWebAclRule

    -- ** network_interface_association
    , NetworkInterfaceAssociation (..)
    , newNetworkInterfaceAssociation

    -- ** spot_instance_request_ebs_block_device
    , SpotInstanceRequestEbsBlockDevice (..)
    , newSpotInstanceRequestEbsBlockDevice

    -- ** admin_create_user_config_invite_message_template
    , AdminCreateUserConfigInviteMessageTemplate (..)
    , newAdminCreateUserConfigInviteMessageTemplate

    -- ** alb_target_group_stickiness
    , AlbTargetGroupStickiness (..)
    , newAlbTargetGroupStickiness

    -- ** lb_listener_default_action
    , LbListenerDefaultAction (..)
    , newLbListenerDefaultAction

    -- ** ami_filter
    , AmiFilter (..)
    , newAmiFilter

    -- ** launch_template_iam_instance_profile
    , LaunchTemplateIamInstanceProfile (..)
    , newLaunchTemplateIamInstanceProfile

    -- ** instances_filter
    , InstancesFilter (..)
    , newInstancesFilter

    -- ** cloudfront_distribution_ordered_cache_behavior
    , CloudfrontDistributionOrderedCacheBehavior (..)
    , newCloudfrontDistributionOrderedCacheBehavior

    -- ** directory_service_directory_vpc_settings
    , DirectoryServiceDirectoryVpcSettings (..)
    , newDirectoryServiceDirectoryVpcSettings

    -- ** s3_bucket_notification_topic
    , S3BucketNotificationTopic (..)
    , newS3BucketNotificationTopic

    -- ** lb_access_logs
    , LbAccessLogs (..)
    , newLbAccessLogs

    -- ** elastic_beanstalk_environment_all_settings
    , ElasticBeanstalkEnvironmentAllSettings (..)
    , newElasticBeanstalkEnvironmentAllSettings

    -- ** s3_bucket_website
    , S3BucketWebsite (..)
    , newS3BucketWebsite

    -- ** cognito_resource_server_scope
    , CognitoResourceServerScope (..)
    , newCognitoResourceServerScope

    -- ** instance_market_options_spot_options
    , InstanceMarketOptionsSpotOptions (..)
    , newInstanceMarketOptionsSpotOptions

    -- ** appsync_datasource_elasticsearch_config
    , AppsyncDatasourceElasticsearchConfig (..)
    , newAppsyncDatasourceElasticsearchConfig

    -- ** kms_secret_secret
    , KmsSecretSecret (..)
    , newKmsSecretSecret

    -- ** s3_bucket_notification_queue
    , S3BucketNotificationQueue (..)
    , newS3BucketNotificationQueue

    -- ** db_instance_s3_import
    , DbInstanceS3Import (..)
    , newDbInstanceS3Import

    -- ** iot_topic_rule_lambda
    , IotTopicRuleLambda (..)
    , newIotTopicRuleLambda

    -- ** route_table_routes
    , RouteTableRoutes (..)
    , newRouteTableRoutes

    -- ** lambda_function_vpc_config
    , LambdaFunctionVpcConfig (..)
    , newLambdaFunctionVpcConfig

    -- ** activated_rule_action
    , ActivatedRuleAction (..)
    , newActivatedRuleAction

    -- ** dag_node_args
    , DagNodeArgs (..)
    , newDagNodeArgs

    -- ** origin_s3_origin_config
    , OriginS3OriginConfig (..)
    , newOriginS3OriginConfig

    -- ** s3_bucket_replication_configuration
    , S3BucketReplicationConfiguration (..)
    , newS3BucketReplicationConfiguration

    -- ** lambda_function_dead_letter_config
    , LambdaFunctionDeadLetterConfig (..)
    , newLambdaFunctionDeadLetterConfig

    -- ** forwarded_values_cookies
    , ForwardedValuesCookies (..)
    , newForwardedValuesCookies

    -- ** step_scaling_policy_configuration_step_adjustment
    , StepScalingPolicyConfigurationStepAdjustment (..)
    , newStepScalingPolicyConfigurationStepAdjustment

    -- ** role_mapping_mapping_rule
    , RoleMappingMappingRule (..)
    , newRoleMappingMappingRule

    -- ** subnet_ids_filter
    , SubnetIdsFilter (..)
    , newSubnetIdsFilter

    -- ** kinesis_firehose_delivery_stream_elasticsearch_configuration
    , KinesisFirehoseDeliveryStreamElasticsearchConfiguration (..)
    , newKinesisFirehoseDeliveryStreamElasticsearchConfiguration

    -- ** launch_specification_ebs_block_device
    , LaunchSpecificationEbsBlockDevice (..)
    , newLaunchSpecificationEbsBlockDevice

    -- ** lambda_alias_routing_config
    , LambdaAliasRoutingConfig (..)
    , newLambdaAliasRoutingConfig

    -- ** instance_ephemeral_block_device
    , InstanceEphemeralBlockDevice (..)
    , newInstanceEphemeralBlockDevice

    -- ** elasticache_replication_group_cluster_mode
    , ElasticacheReplicationGroupClusterMode (..)
    , newElasticacheReplicationGroupClusterMode

    -- ** elastictranscoder_preset_video_watermarks
    , ElastictranscoderPresetVideoWatermarks (..)
    , newElastictranscoderPresetVideoWatermarks

    -- ** rds_cluster_parameter_group_parameter
    , RdsClusterParameterGroupParameter (..)
    , newRdsClusterParameterGroupParameter

    -- ** ebs_snapshot_filter
    , EbsSnapshotFilter (..)
    , newEbsSnapshotFilter

    -- ** sql_injection_match_tuple_field_to_match
    , SqlInjectionMatchTupleFieldToMatch (..)
    , newSqlInjectionMatchTupleFieldToMatch

    -- ** elasticache_cluster_cache_nodes
    , ElasticacheClusterCacheNodes (..)
    , newElasticacheClusterCacheNodes

    -- ** endpoints
    , Endpoints (..)
    , newEndpoints

    -- ** opsworks_instance_root_block_device
    , OpsworksInstanceRootBlockDevice (..)
    , newOpsworksInstanceRootBlockDevice

    -- ** s3_bucket_server_side_encryption_configuration
    , S3BucketServerSideEncryptionConfiguration (..)
    , newS3BucketServerSideEncryptionConfiguration

    -- ** processors_parameters
    , ProcessorsParameters (..)
    , newProcessorsParameters

    -- ** pricing_product_filters
    , PricingProductFilters (..)
    , newPricingProductFilters

    -- ** elasticsearch_domain_snapshot_options
    , ElasticsearchDomainSnapshotOptions (..)
    , newElasticsearchDomainSnapshotOptions

    -- ** appsync_datasource_dynamodb_config
    , AppsyncDatasourceDynamodbConfig (..)
    , newAppsyncDatasourceDynamodbConfig

    -- ** serializer_orc_ser_de
    , SerializerOrcSerDe (..)
    , newSerializerOrcSerDe

    -- ** default_cache_behavior_lambda_function_association
    , DefaultCacheBehaviorLambdaFunctionAssociation (..)
    , newDefaultCacheBehaviorLambdaFunctionAssociation

    -- ** iam_policy_document_statement
    , IamPolicyDocumentStatement (..)
    , newIamPolicyDocumentStatement

    -- ** spot_instance_request_credit_specification
    , SpotInstanceRequestCreditSpecification (..)
    , newSpotInstanceRequestCreditSpecification

    -- ** origin_custom_header
    , OriginCustomHeader (..)
    , newOriginCustomHeader

    -- ** vpc_peering_connection_requester
    , VpcPeeringConnectionRequester (..)
    , newVpcPeeringConnectionRequester

    -- ** lambda_function_environment
    , LambdaFunctionEnvironment (..)
    , newLambdaFunctionEnvironment

    -- ** serializer_parquet_ser_de
    , SerializerParquetSerDe (..)
    , newSerializerParquetSerDe

    -- ** elasticsearch_domain_ebs_options
    , ElasticsearchDomainEbsOptions (..)
    , newElasticsearchDomainEbsOptions

    -- ** iot_thing_type_properties
    , IotThingTypeProperties (..)
    , newIotThingTypeProperties

    -- ** dms_endpoint_s3_settings
    , DmsEndpointS3Settings (..)
    , newDmsEndpointS3Settings

    -- ** extended_s3_configuration_cloudwatch_logging_options
    , ExtendedS3ConfigurationCloudwatchLoggingOptions (..)
    , newExtendedS3ConfigurationCloudwatchLoggingOptions

    -- ** config_config_rule_scope
    , ConfigConfigRuleScope (..)
    , newConfigConfigRuleScope

    -- ** deserializer_open_x_json_ser_de
    , DeserializerOpenXJsonSerDe (..)
    , newDeserializerOpenXJsonSerDe

    -- ** codedeploy_deployment_group_on_premises_instance_tag_filter
    , CodedeployDeploymentGroupOnPremisesInstanceTagFilter (..)
    , newCodedeployDeploymentGroupOnPremisesInstanceTagFilter

    -- ** cognito_identity_pool_roles_attachment_role_mapping
    , CognitoIdentityPoolRolesAttachmentRoleMapping (..)
    , newCognitoIdentityPoolRolesAttachmentRoleMapping

    -- ** ssm_document_parameter
    , SsmDocumentParameter (..)
    , newSsmDocumentParameter

    -- ** opsworks_java_app_layer_ebs_volume
    , OpsworksJavaAppLayerEbsVolume (..)
    , newOpsworksJavaAppLayerEbsVolume

    -- ** instance_ebs_block_device
    , InstanceEbsBlockDevice (..)
    , newInstanceEbsBlockDevice

    -- ** cognito_identity_pool_roles_attachment_roles
    , CognitoIdentityPoolRolesAttachmentRoles (..)
    , newCognitoIdentityPoolRolesAttachmentRoles

    -- ** rule_apply_server_side_encryption_by_default
    , RuleApplyServerSideEncryptionByDefault (..)
    , newRuleApplyServerSideEncryptionByDefault

    -- ** step_hadoop_jar_step
    , StepHadoopJarStep (..)
    , newStepHadoopJarStep

    -- ** lifecycle_rule_noncurrent_version_transition
    , LifecycleRuleNoncurrentVersionTransition (..)
    , newLifecycleRuleNoncurrentVersionTransition

    -- ** ssm_resource_data_sync_s3_destination
    , SsmResourceDataSyncS3Destination (..)
    , newSsmResourceDataSyncS3Destination

    -- ** appautoscaling_policy_step_scaling_policy_configuration
    , AppautoscalingPolicyStepScalingPolicyConfiguration (..)
    , newAppautoscalingPolicyStepScalingPolicyConfiguration

    -- ** alb_listener_default_action
    , AlbListenerDefaultAction (..)
    , newAlbListenerDefaultAction

    -- ** elasticsearch_domain_cognito_options
    , ElasticsearchDomainCognitoOptions (..)
    , newElasticsearchDomainCognitoOptions

    -- ** lb_target_group_stickiness
    , LbTargetGroupStickiness (..)
    , newLbTargetGroupStickiness

    -- ** codebuild_project_environment
    , CodebuildProjectEnvironment (..)
    , newCodebuildProjectEnvironment

    -- ** ssm_maintenance_window_task_logging_info
    , SsmMaintenanceWindowTaskLoggingInfo (..)
    , newSsmMaintenanceWindowTaskLoggingInfo

    -- ** config_delivery_channel_snapshot_delivery_properties
    , ConfigDeliveryChannelSnapshotDeliveryProperties (..)
    , newConfigDeliveryChannelSnapshotDeliveryProperties

    -- ** elastictranscoder_pipeline_thumbnail_config
    , ElastictranscoderPipelineThumbnailConfig (..)
    , newElastictranscoderPipelineThumbnailConfig

    -- ** ami_ids_filter
    , AmiIdsFilter (..)
    , newAmiIdsFilter

    -- ** codedeploy_deployment_group_load_balancer_info
    , CodedeployDeploymentGroupLoadBalancerInfo (..)
    , newCodedeployDeploymentGroupLoadBalancerInfo

    -- ** iot_topic_rule_sqs
    , IotTopicRuleSqs (..)
    , newIotTopicRuleSqs

    -- ** redshift_parameter_group_parameter
    , RedshiftParameterGroupParameter (..)
    , newRedshiftParameterGroupParameter

    -- ** lifecycle_rule_expiration
    , LifecycleRuleExpiration (..)
    , newLifecycleRuleExpiration

    -- ** batch_job_queue_compute_environment_order
    , BatchJobQueueComputeEnvironmentOrder (..)
    , newBatchJobQueueComputeEnvironmentOrder

    -- ** load_balancer_info_target_group_info
    , LoadBalancerInfoTargetGroupInfo (..)
    , newLoadBalancerInfoTargetGroupInfo

    -- ** elastic_beanstalk_application_appversion_lifecycle
    , ElasticBeanstalkApplicationAppversionLifecycle (..)
    , newElasticBeanstalkApplicationAppversionLifecycle

    -- ** glue_job_command
    , GlueJobCommand (..)
    , newGlueJobCommand

    -- ** dns_config_dns_records
    , DnsConfigDnsRecords (..)
    , newDnsConfigDnsRecords

    -- ** nat_gateway_filter
    , NatGatewayFilter (..)
    , newNatGatewayFilter

    -- ** codebuild_project_artifacts
    , CodebuildProjectArtifacts (..)
    , newCodebuildProjectArtifacts

    -- ** s3_configuration_cloudwatch_logging_options
    , S3ConfigurationCloudwatchLoggingOptions (..)
    , newS3ConfigurationCloudwatchLoggingOptions

    -- ** network_acls_filter
    , NetworkAclsFilter (..)
    , newNetworkAclsFilter

    -- ** extended_s3_configuration_s3_backup_configuration
    , ExtendedS3ConfigurationS3BackupConfiguration (..)
    , newExtendedS3ConfigurationS3BackupConfiguration

    -- ** target_tracking_configuration_predefined_metric_specification
    , TargetTrackingConfigurationPredefinedMetricSpecification (..)
    , newTargetTrackingConfigurationPredefinedMetricSpecification

    -- ** codepipeline_artifact_store
    , CodepipelineArtifactStore (..)
    , newCodepipelineArtifactStore

    -- ** ses_receipt_rule_lambda_action
    , SesReceiptRuleLambdaAction (..)
    , newSesReceiptRuleLambdaAction

    -- ** rules_destination
    , RulesDestination (..)
    , newRulesDestination

    -- ** origin_custom_origin_config
    , OriginCustomOriginConfig (..)
    , newOriginCustomOriginConfig

    -- ** glue_crawler_jdbc_target
    , GlueCrawlerJdbcTarget (..)
    , newGlueCrawlerJdbcTarget

    -- ** alb_listener_rule_action
    , AlbListenerRuleAction (..)
    , newAlbListenerRuleAction

    -- ** directory_service_directory_connect_settings
    , DirectoryServiceDirectoryConnectSettings (..)
    , newDirectoryServiceDirectoryConnectSettings

    -- ** blue_green_deployment_config_green_fleet_provisioning_option
    , BlueGreenDeploymentConfigGreenFleetProvisioningOption (..)
    , newBlueGreenDeploymentConfigGreenFleetProvisioningOption

    -- ** db_parameter_group_parameter
    , DbParameterGroupParameter (..)
    , newDbParameterGroupParameter

    -- ** wafregional_ipset_ip_set_descriptor
    , WafregionalIpsetIpSetDescriptor (..)
    , newWafregionalIpsetIpSetDescriptor

    -- ** codedeploy_deployment_group_auto_rollback_configuration
    , CodedeployDeploymentGroupAutoRollbackConfiguration (..)
    , newCodedeployDeploymentGroupAutoRollbackConfiguration

    -- ** codebuild_project_vpc_config
    , CodebuildProjectVpcConfig (..)
    , newCodebuildProjectVpcConfig

    -- ** autoscaling_groups_filter
    , AutoscalingGroupsFilter (..)
    , newAutoscalingGroupsFilter

    -- ** mq_broker_user
    , MqBrokerUser (..)
    , newMqBrokerUser

    -- ** data_format_conversion_configuration_input_format_configuration
    , DataFormatConversionConfigurationInputFormatConfiguration (..)
    , newDataFormatConversionConfigurationInputFormatConfiguration

    -- ** ami_copy_ephemeral_block_device
    , AmiCopyEphemeralBlockDevice (..)
    , newAmiCopyEphemeralBlockDevice

    -- ** elastictranscoder_pipeline_content_config
    , ElastictranscoderPipelineContentConfig (..)
    , newElastictranscoderPipelineContentConfig

    -- ** storagegateway_nfs_file_share_nfs_file_share_defaults
    , StoragegatewayNfsFileShareNfsFileShareDefaults (..)
    , newStoragegatewayNfsFileShareNfsFileShareDefaults

    -- ** iot_topic_rule_cloudwatch_alarm
    , IotTopicRuleCloudwatchAlarm (..)
    , newIotTopicRuleCloudwatchAlarm

    -- ** kinesis_firehose_delivery_stream_s3_configuration
    , KinesisFirehoseDeliveryStreamS3Configuration (..)
    , newKinesisFirehoseDeliveryStreamS3Configuration

    -- ** launch_template_tag_specifications
    , LaunchTemplateTagSpecifications (..)
    , newLaunchTemplateTagSpecifications

    -- ** restrictions_geo_restriction
    , RestrictionsGeoRestriction (..)
    , newRestrictionsGeoRestriction

    -- ** vpc_peering_connection_filter
    , VpcPeeringConnectionFilter (..)
    , newVpcPeeringConnectionFilter

    -- ** db_option_group_option
    , DbOptionGroupOption (..)
    , newDbOptionGroupOption

    -- ** route53_record_latency_routing_policy
    , Route53RecordLatencyRoutingPolicy (..)
    , newRoute53RecordLatencyRoutingPolicy

    -- ** elasticsearch_domain_log_publishing_options
    , ElasticsearchDomainLogPublishingOptions (..)
    , newElasticsearchDomainLogPublishingOptions

    -- ** codedeploy_deployment_group_deployment_style
    , CodedeployDeploymentGroupDeploymentStyle (..)
    , newCodedeployDeploymentGroupDeploymentStyle

    -- ** autoscaling_group_initial_lifecycle_hook
    , AutoscalingGroupInitialLifecycleHook (..)
    , newAutoscalingGroupInitialLifecycleHook

    -- ** s3_bucket_notification_lambda_function
    , S3BucketNotificationLambdaFunction (..)
    , newS3BucketNotificationLambdaFunction

    -- ** source_selection_criteria_sse_kms_encrypted_objects
    , SourceSelectionCriteriaSseKmsEncryptedObjects (..)
    , newSourceSelectionCriteriaSseKmsEncryptedObjects

    -- ** route_table_route
    , RouteTableRoute (..)
    , newRouteTableRoute

    -- ** instance_filter
    , InstanceFilter (..)
    , newInstanceFilter

    -- ** vpc_peering_connection_options_accepter
    , VpcPeeringConnectionOptionsAccepter (..)
    , newVpcPeeringConnectionOptionsAccepter

    -- ** iot_topic_rule_elasticsearch
    , IotTopicRuleElasticsearch (..)
    , newIotTopicRuleElasticsearch

    -- ** instance_root_block_device
    , InstanceRootBlockDevice (..)
    , newInstanceRootBlockDevice

    -- ** kinesis_firehose_delivery_stream_splunk_configuration
    , KinesisFirehoseDeliveryStreamSplunkConfiguration (..)
    , newKinesisFirehoseDeliveryStreamSplunkConfiguration

    -- ** opsworks_application_environment
    , OpsworksApplicationEnvironment (..)
    , newOpsworksApplicationEnvironment

    -- ** glue_script_dag_node
    , GlueScriptDagNode (..)
    , newGlueScriptDagNode

    -- ** ses_event_destination_cloudwatch_destination
    , SesEventDestinationCloudwatchDestination (..)
    , newSesEventDestinationCloudwatchDestination

    -- ** elastictranscoder_pipeline_content_config_permissions
    , ElastictranscoderPipelineContentConfigPermissions (..)
    , newElastictranscoderPipelineContentConfigPermissions

    -- ** lb_subnet_mapping
    , LbSubnetMapping (..)
    , newLbSubnetMapping

    -- ** ses_event_destination_kinesis_destination
    , SesEventDestinationKinesisDestination (..)
    , newSesEventDestinationKinesisDestination

    -- ** ses_receipt_rule_stop_action
    , SesReceiptRuleStopAction (..)
    , newSesReceiptRuleStopAction

    -- ** statement_condition
    , StatementCondition (..)
    , newStatementCondition

    -- ** ebs_snapshot_ids_filter
    , EbsSnapshotIdsFilter (..)
    , newEbsSnapshotIdsFilter

    -- ** cloudwatch_event_target_ecs_target
    , CloudwatchEventTargetEcsTarget (..)
    , newCloudwatchEventTargetEcsTarget

    -- ** source_source_detail
    , SourceSourceDetail (..)
    , newSourceSourceDetail

    -- ** ssm_association_output_location
    , SsmAssociationOutputLocation (..)
    , newSsmAssociationOutputLocation

    -- ** service_discovery_service_health_check_custom_config
    , ServiceDiscoveryServiceHealthCheckCustomConfig (..)
    , newServiceDiscoveryServiceHealthCheckCustomConfig

    -- ** default_cache_behavior_forwarded_values
    , DefaultCacheBehaviorForwardedValues (..)
    , newDefaultCacheBehaviorForwardedValues

    -- ** vpcs_filter
    , VpcsFilter (..)
    , newVpcsFilter

    -- ** ses_receipt_rule_s3_action
    , SesReceiptRuleS3Action (..)
    , newSesReceiptRuleS3Action

    -- ** instance_credit_specification
    , InstanceCreditSpecification (..)
    , newInstanceCreditSpecification

    -- ** neptune_parameter_group_parameter
    , NeptuneParameterGroupParameter (..)
    , newNeptuneParameterGroupParameter

    -- ** ssm_maintenance_window_task_task_parameters
    , SsmMaintenanceWindowTaskTaskParameters (..)
    , newSsmMaintenanceWindowTaskTaskParameters

    -- ** elasticsearch_domain_vpc_options
    , ElasticsearchDomainVpcOptions (..)
    , newElasticsearchDomainVpcOptions

    -- ** dynamodb_table_local_secondary_index
    , DynamodbTableLocalSecondaryIndex (..)
    , newDynamodbTableLocalSecondaryIndex

    -- ** load_balancer_info_elb_info
    , LoadBalancerInfoElbInfo (..)
    , newLoadBalancerInfoElbInfo

    -- ** glue_crawler_s3_target
    , GlueCrawlerS3Target (..)
    , newGlueCrawlerS3Target

    -- ** iot_topic_rule_cloudwatch_metric
    , IotTopicRuleCloudwatchMetric (..)
    , newIotTopicRuleCloudwatchMetric

    -- ** launch_template_monitoring
    , LaunchTemplateMonitoring (..)
    , newLaunchTemplateMonitoring

    -- ** storage_descriptor_ser_de_info
    , StorageDescriptorSerDeInfo (..)
    , newStorageDescriptorSerDeInfo

    -- ** schema_string_attribute_constraints
    , SchemaStringAttributeConstraints (..)
    , newSchemaStringAttributeConstraints

    -- ** cognito_identity_pool_cognito_identity_providers
    , CognitoIdentityPoolCognitoIdentityProviders (..)
    , newCognitoIdentityPoolCognitoIdentityProviders

    -- ** spot_instance_request_ephemeral_block_device
    , SpotInstanceRequestEphemeralBlockDevice (..)
    , newSpotInstanceRequestEphemeralBlockDevice

    -- ** vpc_peering_connection_accepter_accepter
    , VpcPeeringConnectionAccepterAccepter (..)
    , newVpcPeeringConnectionAccepterAccepter

    ) where

import Data.Functor ((<$>))

import GHC.Base (($))

import qualified Data.Hashable       as P
import qualified Data.HashMap.Strict as P
import qualified Data.HashMap.Strict as Map
import qualified Data.List.NonEmpty  as P
import qualified Data.Maybe          as P
import qualified Data.Monoid         as P
import qualified Data.Text           as P
import qualified GHC.Generics        as P
import qualified Lens.Micro          as P
import qualified Prelude             as P
import qualified Terrafomo.Attribute as TF
import qualified Terrafomo.AWS.Lens  as P
import qualified Terrafomo.AWS.Types as P
import qualified Terrafomo.HCL       as TF
import qualified Terrafomo.Name      as TF
import qualified Terrafomo.Validator as TF

-- | @opsworks_stack_custom_cookbooks_source@ nested settings.
data OpsworksStackCustomCookbooksSource s = OpsworksStackCustomCookbooksSource'
    { _password :: TF.Attr s P.Text
    -- ^ @password@ - (Optional)
    --
    , _revision :: TF.Attr s P.Text
    -- ^ @revision@ - (Optional)
    --
    , _sshKey   :: TF.Attr s P.Text
    -- ^ @ssh_key@ - (Optional)
    --
    , _type'    :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    , _url      :: TF.Attr s P.Text
    -- ^ @url@ - (Required)
    --
    , _username :: TF.Attr s P.Text
    -- ^ @username@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newOpsworksStackCustomCookbooksSource
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> TF.Attr s P.Text -- ^ @url@ - 'P.url'
    -> OpsworksStackCustomCookbooksSource s
newOpsworksStackCustomCookbooksSource _type' _url =
    OpsworksStackCustomCookbooksSource'
        { _password = TF.Nil
        , _revision = TF.Nil
        , _sshKey = TF.Nil
        , _type' = _type'
        , _url = _url
        , _username = TF.Nil
        }

instance P.Hashable  (OpsworksStackCustomCookbooksSource s)
instance TF.IsValue  (OpsworksStackCustomCookbooksSource s)
instance TF.IsObject (OpsworksStackCustomCookbooksSource s) where
    toObject OpsworksStackCustomCookbooksSource'{..} = P.catMaybes
        [ TF.assign "password" <$> TF.attribute _password
        , TF.assign "revision" <$> TF.attribute _revision
        , TF.assign "ssh_key" <$> TF.attribute _sshKey
        , TF.assign "type" <$> TF.attribute _type'
        , TF.assign "url" <$> TF.attribute _url
        , TF.assign "username" <$> TF.attribute _username
        ]

instance TF.IsValid (OpsworksStackCustomCookbooksSource s) where
    validator = P.mempty

instance P.HasPassword (OpsworksStackCustomCookbooksSource s) (TF.Attr s P.Text) where
    password =
        P.lens (_password :: OpsworksStackCustomCookbooksSource s -> TF.Attr s P.Text)
               (\s a -> s { _password = a } :: OpsworksStackCustomCookbooksSource s)

instance P.HasRevision (OpsworksStackCustomCookbooksSource s) (TF.Attr s P.Text) where
    revision =
        P.lens (_revision :: OpsworksStackCustomCookbooksSource s -> TF.Attr s P.Text)
               (\s a -> s { _revision = a } :: OpsworksStackCustomCookbooksSource s)

instance P.HasSshKey (OpsworksStackCustomCookbooksSource s) (TF.Attr s P.Text) where
    sshKey =
        P.lens (_sshKey :: OpsworksStackCustomCookbooksSource s -> TF.Attr s P.Text)
               (\s a -> s { _sshKey = a } :: OpsworksStackCustomCookbooksSource s)

instance P.HasType' (OpsworksStackCustomCookbooksSource s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: OpsworksStackCustomCookbooksSource s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: OpsworksStackCustomCookbooksSource s)

instance P.HasUrl (OpsworksStackCustomCookbooksSource s) (TF.Attr s P.Text) where
    url =
        P.lens (_url :: OpsworksStackCustomCookbooksSource s -> TF.Attr s P.Text)
               (\s a -> s { _url = a } :: OpsworksStackCustomCookbooksSource s)

instance P.HasUsername (OpsworksStackCustomCookbooksSource s) (TF.Attr s P.Text) where
    username =
        P.lens (_username :: OpsworksStackCustomCookbooksSource s -> TF.Attr s P.Text)
               (\s a -> s { _username = a } :: OpsworksStackCustomCookbooksSource s)

-- | @waf_web_acl_rules@ nested settings.
data WafWebAclRules s = WafWebAclRules'
    { _action         :: TF.Attr s (RulesAction s)
    -- ^ @action@ - (Optional)
    --
    , _overrideAction :: TF.Attr s (RulesOverrideAction s)
    -- ^ @override_action@ - (Optional)
    --
    , _priority       :: TF.Attr s P.Integer
    -- ^ @priority@ - (Required)
    --
    , _ruleId         :: TF.Attr s P.Text
    -- ^ @rule_id@ - (Required)
    --
    , _type'          :: TF.Attr s P.Text
    -- ^ @type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafWebAclRules
    :: TF.Attr s P.Integer -- ^ @priority@ - 'P.priority'
    -> TF.Attr s P.Text -- ^ @rule_id@ - 'P.ruleId'
    -> WafWebAclRules s
newWafWebAclRules _priority _ruleId =
    WafWebAclRules'
        { _action = TF.Nil
        , _overrideAction = TF.Nil
        , _priority = _priority
        , _ruleId = _ruleId
        , _type' = TF.value "REGULAR"
        }

instance P.Hashable  (WafWebAclRules s)
instance TF.IsValue  (WafWebAclRules s)
instance TF.IsObject (WafWebAclRules s) where
    toObject WafWebAclRules'{..} = P.catMaybes
        [ TF.assign "action" <$> TF.attribute _action
        , TF.assign "override_action" <$> TF.attribute _overrideAction
        , TF.assign "priority" <$> TF.attribute _priority
        , TF.assign "rule_id" <$> TF.attribute _ruleId
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (WafWebAclRules s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_action"
                  (_action
                      :: WafWebAclRules s -> TF.Attr s (RulesAction s))
                  TF.validator
           P.<> TF.settingsValidator "_overrideAction"
                  (_overrideAction
                      :: WafWebAclRules s -> TF.Attr s (RulesOverrideAction s))
                  TF.validator

instance P.HasAction (WafWebAclRules s) (TF.Attr s (RulesAction s)) where
    action =
        P.lens (_action :: WafWebAclRules s -> TF.Attr s (RulesAction s))
               (\s a -> s { _action = a } :: WafWebAclRules s)

instance P.HasOverrideAction (WafWebAclRules s) (TF.Attr s (RulesOverrideAction s)) where
    overrideAction =
        P.lens (_overrideAction :: WafWebAclRules s -> TF.Attr s (RulesOverrideAction s))
               (\s a -> s { _overrideAction = a } :: WafWebAclRules s)

instance P.HasPriority (WafWebAclRules s) (TF.Attr s P.Integer) where
    priority =
        P.lens (_priority :: WafWebAclRules s -> TF.Attr s P.Integer)
               (\s a -> s { _priority = a } :: WafWebAclRules s)

instance P.HasRuleId (WafWebAclRules s) (TF.Attr s P.Text) where
    ruleId =
        P.lens (_ruleId :: WafWebAclRules s -> TF.Attr s P.Text)
               (\s a -> s { _ruleId = a } :: WafWebAclRules s)

instance P.HasType' (WafWebAclRules s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: WafWebAclRules s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: WafWebAclRules s)

-- | @rules_source_selection_criteria@ nested settings.
data RulesSourceSelectionCriteria s = RulesSourceSelectionCriteria'
    { _sseKmsEncryptedObjects :: TF.Attr s (SourceSelectionCriteriaSseKmsEncryptedObjects s)
    -- ^ @sse_kms_encrypted_objects@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRulesSourceSelectionCriteria
    :: RulesSourceSelectionCriteria s
newRulesSourceSelectionCriteria =
    RulesSourceSelectionCriteria'
        { _sseKmsEncryptedObjects = TF.Nil
        }

instance P.Hashable  (RulesSourceSelectionCriteria s)
instance TF.IsValue  (RulesSourceSelectionCriteria s)
instance TF.IsObject (RulesSourceSelectionCriteria s) where
    toObject RulesSourceSelectionCriteria'{..} = P.catMaybes
        [ TF.assign "sse_kms_encrypted_objects" <$> TF.attribute _sseKmsEncryptedObjects
        ]

instance TF.IsValid (RulesSourceSelectionCriteria s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_sseKmsEncryptedObjects"
                  (_sseKmsEncryptedObjects
                      :: RulesSourceSelectionCriteria s -> TF.Attr s (SourceSelectionCriteriaSseKmsEncryptedObjects s))
                  TF.validator

instance P.HasSseKmsEncryptedObjects (RulesSourceSelectionCriteria s) (TF.Attr s (SourceSelectionCriteriaSseKmsEncryptedObjects s)) where
    sseKmsEncryptedObjects =
        P.lens (_sseKmsEncryptedObjects :: RulesSourceSelectionCriteria s -> TF.Attr s (SourceSelectionCriteriaSseKmsEncryptedObjects s))
               (\s a -> s { _sseKmsEncryptedObjects = a } :: RulesSourceSelectionCriteria s)

-- | @extended_s3_configuration_processing_configuration@ nested settings.
data ExtendedS3ConfigurationProcessingConfiguration s = ExtendedS3ConfigurationProcessingConfiguration'
    { _enabled    :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Optional)
    --
    , _processors :: TF.Attr s [TF.Attr s (ProcessingConfigurationProcessors s)]
    -- ^ @processors@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newExtendedS3ConfigurationProcessingConfiguration
    :: ExtendedS3ConfigurationProcessingConfiguration s
newExtendedS3ConfigurationProcessingConfiguration =
    ExtendedS3ConfigurationProcessingConfiguration'
        { _enabled = TF.Nil
        , _processors = TF.Nil
        }

instance P.Hashable  (ExtendedS3ConfigurationProcessingConfiguration s)
instance TF.IsValue  (ExtendedS3ConfigurationProcessingConfiguration s)
instance TF.IsObject (ExtendedS3ConfigurationProcessingConfiguration s) where
    toObject ExtendedS3ConfigurationProcessingConfiguration'{..} = P.catMaybes
        [ TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "processors" <$> TF.attribute _processors
        ]

instance TF.IsValid (ExtendedS3ConfigurationProcessingConfiguration s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_processors"
                  (_processors
                      :: ExtendedS3ConfigurationProcessingConfiguration s -> TF.Attr s [TF.Attr s (ProcessingConfigurationProcessors s)])
                  TF.validator

instance P.HasEnabled (ExtendedS3ConfigurationProcessingConfiguration s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: ExtendedS3ConfigurationProcessingConfiguration s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: ExtendedS3ConfigurationProcessingConfiguration s)

instance P.HasProcessors (ExtendedS3ConfigurationProcessingConfiguration s) (TF.Attr s [TF.Attr s (ProcessingConfigurationProcessors s)]) where
    processors =
        P.lens (_processors :: ExtendedS3ConfigurationProcessingConfiguration s -> TF.Attr s [TF.Attr s (ProcessingConfigurationProcessors s)])
               (\s a -> s { _processors = a } :: ExtendedS3ConfigurationProcessingConfiguration s)

-- | @glue_catalog_table_storage_descriptor@ nested settings.
data GlueCatalogTableStorageDescriptor s = GlueCatalogTableStorageDescriptor'
    { _bucketColumns :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @bucket_columns@ - (Optional)
    --
    , _columns :: TF.Attr s [TF.Attr s (StorageDescriptorColumns s)]
    -- ^ @columns@ - (Optional)
    --
    , _compressed :: TF.Attr s P.Bool
    -- ^ @compressed@ - (Optional)
    --
    , _inputFormat :: TF.Attr s P.Text
    -- ^ @input_format@ - (Optional)
    --
    , _location :: TF.Attr s P.Text
    -- ^ @location@ - (Optional)
    --
    , _numberOfBuckets :: TF.Attr s P.Integer
    -- ^ @number_of_buckets@ - (Optional)
    --
    , _outputFormat :: TF.Attr s P.Text
    -- ^ @output_format@ - (Optional)
    --
    , _parameters :: TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))
    -- ^ @parameters@ - (Optional)
    --
    , _serDeInfo :: TF.Attr s (StorageDescriptorSerDeInfo s)
    -- ^ @ser_de_info@ - (Optional)
    --
    , _skewedInfo :: TF.Attr s (StorageDescriptorSkewedInfo s)
    -- ^ @skewed_info@ - (Optional)
    --
    , _sortColumns :: TF.Attr s [TF.Attr s (StorageDescriptorSortColumns s)]
    -- ^ @sort_columns@ - (Optional)
    --
    , _storedAsSubDirectories :: TF.Attr s P.Bool
    -- ^ @stored_as_sub_directories@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newGlueCatalogTableStorageDescriptor
    :: GlueCatalogTableStorageDescriptor s
newGlueCatalogTableStorageDescriptor =
    GlueCatalogTableStorageDescriptor'
        { _bucketColumns = TF.Nil
        , _columns = TF.Nil
        , _compressed = TF.Nil
        , _inputFormat = TF.Nil
        , _location = TF.Nil
        , _numberOfBuckets = TF.Nil
        , _outputFormat = TF.Nil
        , _parameters = TF.Nil
        , _serDeInfo = TF.Nil
        , _skewedInfo = TF.Nil
        , _sortColumns = TF.Nil
        , _storedAsSubDirectories = TF.Nil
        }

instance P.Hashable  (GlueCatalogTableStorageDescriptor s)
instance TF.IsValue  (GlueCatalogTableStorageDescriptor s)
instance TF.IsObject (GlueCatalogTableStorageDescriptor s) where
    toObject GlueCatalogTableStorageDescriptor'{..} = P.catMaybes
        [ TF.assign "bucket_columns" <$> TF.attribute _bucketColumns
        , TF.assign "columns" <$> TF.attribute _columns
        , TF.assign "compressed" <$> TF.attribute _compressed
        , TF.assign "input_format" <$> TF.attribute _inputFormat
        , TF.assign "location" <$> TF.attribute _location
        , TF.assign "number_of_buckets" <$> TF.attribute _numberOfBuckets
        , TF.assign "output_format" <$> TF.attribute _outputFormat
        , TF.assign "parameters" <$> TF.attribute _parameters
        , TF.assign "ser_de_info" <$> TF.attribute _serDeInfo
        , TF.assign "skewed_info" <$> TF.attribute _skewedInfo
        , TF.assign "sort_columns" <$> TF.attribute _sortColumns
        , TF.assign "stored_as_sub_directories" <$> TF.attribute _storedAsSubDirectories
        ]

instance TF.IsValid (GlueCatalogTableStorageDescriptor s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_columns"
                  (_columns
                      :: GlueCatalogTableStorageDescriptor s -> TF.Attr s [TF.Attr s (StorageDescriptorColumns s)])
                  TF.validator
           P.<> TF.settingsValidator "_serDeInfo"
                  (_serDeInfo
                      :: GlueCatalogTableStorageDescriptor s -> TF.Attr s (StorageDescriptorSerDeInfo s))
                  TF.validator
           P.<> TF.settingsValidator "_skewedInfo"
                  (_skewedInfo
                      :: GlueCatalogTableStorageDescriptor s -> TF.Attr s (StorageDescriptorSkewedInfo s))
                  TF.validator
           P.<> TF.settingsValidator "_sortColumns"
                  (_sortColumns
                      :: GlueCatalogTableStorageDescriptor s -> TF.Attr s [TF.Attr s (StorageDescriptorSortColumns s)])
                  TF.validator

instance P.HasBucketColumns (GlueCatalogTableStorageDescriptor s) (TF.Attr s [TF.Attr s P.Text]) where
    bucketColumns =
        P.lens (_bucketColumns :: GlueCatalogTableStorageDescriptor s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _bucketColumns = a } :: GlueCatalogTableStorageDescriptor s)

instance P.HasColumns (GlueCatalogTableStorageDescriptor s) (TF.Attr s [TF.Attr s (StorageDescriptorColumns s)]) where
    columns =
        P.lens (_columns :: GlueCatalogTableStorageDescriptor s -> TF.Attr s [TF.Attr s (StorageDescriptorColumns s)])
               (\s a -> s { _columns = a } :: GlueCatalogTableStorageDescriptor s)

instance P.HasCompressed (GlueCatalogTableStorageDescriptor s) (TF.Attr s P.Bool) where
    compressed =
        P.lens (_compressed :: GlueCatalogTableStorageDescriptor s -> TF.Attr s P.Bool)
               (\s a -> s { _compressed = a } :: GlueCatalogTableStorageDescriptor s)

instance P.HasInputFormat (GlueCatalogTableStorageDescriptor s) (TF.Attr s P.Text) where
    inputFormat =
        P.lens (_inputFormat :: GlueCatalogTableStorageDescriptor s -> TF.Attr s P.Text)
               (\s a -> s { _inputFormat = a } :: GlueCatalogTableStorageDescriptor s)

instance P.HasLocation (GlueCatalogTableStorageDescriptor s) (TF.Attr s P.Text) where
    location =
        P.lens (_location :: GlueCatalogTableStorageDescriptor s -> TF.Attr s P.Text)
               (\s a -> s { _location = a } :: GlueCatalogTableStorageDescriptor s)

instance P.HasNumberOfBuckets (GlueCatalogTableStorageDescriptor s) (TF.Attr s P.Integer) where
    numberOfBuckets =
        P.lens (_numberOfBuckets :: GlueCatalogTableStorageDescriptor s -> TF.Attr s P.Integer)
               (\s a -> s { _numberOfBuckets = a } :: GlueCatalogTableStorageDescriptor s)

instance P.HasOutputFormat (GlueCatalogTableStorageDescriptor s) (TF.Attr s P.Text) where
    outputFormat =
        P.lens (_outputFormat :: GlueCatalogTableStorageDescriptor s -> TF.Attr s P.Text)
               (\s a -> s { _outputFormat = a } :: GlueCatalogTableStorageDescriptor s)

instance P.HasParameters (GlueCatalogTableStorageDescriptor s) (TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))) where
    parameters =
        P.lens (_parameters :: GlueCatalogTableStorageDescriptor s -> TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text)))
               (\s a -> s { _parameters = a } :: GlueCatalogTableStorageDescriptor s)

instance P.HasSerDeInfo (GlueCatalogTableStorageDescriptor s) (TF.Attr s (StorageDescriptorSerDeInfo s)) where
    serDeInfo =
        P.lens (_serDeInfo :: GlueCatalogTableStorageDescriptor s -> TF.Attr s (StorageDescriptorSerDeInfo s))
               (\s a -> s { _serDeInfo = a } :: GlueCatalogTableStorageDescriptor s)

instance P.HasSkewedInfo (GlueCatalogTableStorageDescriptor s) (TF.Attr s (StorageDescriptorSkewedInfo s)) where
    skewedInfo =
        P.lens (_skewedInfo :: GlueCatalogTableStorageDescriptor s -> TF.Attr s (StorageDescriptorSkewedInfo s))
               (\s a -> s { _skewedInfo = a } :: GlueCatalogTableStorageDescriptor s)

instance P.HasSortColumns (GlueCatalogTableStorageDescriptor s) (TF.Attr s [TF.Attr s (StorageDescriptorSortColumns s)]) where
    sortColumns =
        P.lens (_sortColumns :: GlueCatalogTableStorageDescriptor s -> TF.Attr s [TF.Attr s (StorageDescriptorSortColumns s)])
               (\s a -> s { _sortColumns = a } :: GlueCatalogTableStorageDescriptor s)

instance P.HasStoredAsSubDirectories (GlueCatalogTableStorageDescriptor s) (TF.Attr s P.Bool) where
    storedAsSubDirectories =
        P.lens (_storedAsSubDirectories :: GlueCatalogTableStorageDescriptor s -> TF.Attr s P.Bool)
               (\s a -> s { _storedAsSubDirectories = a } :: GlueCatalogTableStorageDescriptor s)

-- | @config_config_rule_source@ nested settings.
data ConfigConfigRuleSource s = ConfigConfigRuleSource'
    { _owner            :: TF.Attr s P.Text
    -- ^ @owner@ - (Required)
    --
    , _sourceDetail     :: TF.Attr s [TF.Attr s (SourceSourceDetail s)]
    -- ^ @source_detail@ - (Optional)
    --
    , _sourceIdentifier :: TF.Attr s P.Text
    -- ^ @source_identifier@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newConfigConfigRuleSource
    :: TF.Attr s P.Text -- ^ @owner@ - 'P.owner'
    -> TF.Attr s P.Text -- ^ @source_identifier@ - 'P.sourceIdentifier'
    -> ConfigConfigRuleSource s
newConfigConfigRuleSource _owner _sourceIdentifier =
    ConfigConfigRuleSource'
        { _owner = _owner
        , _sourceDetail = TF.Nil
        , _sourceIdentifier = _sourceIdentifier
        }

instance P.Hashable  (ConfigConfigRuleSource s)
instance TF.IsValue  (ConfigConfigRuleSource s)
instance TF.IsObject (ConfigConfigRuleSource s) where
    toObject ConfigConfigRuleSource'{..} = P.catMaybes
        [ TF.assign "owner" <$> TF.attribute _owner
        , TF.assign "source_detail" <$> TF.attribute _sourceDetail
        , TF.assign "source_identifier" <$> TF.attribute _sourceIdentifier
        ]

instance TF.IsValid (ConfigConfigRuleSource s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_sourceDetail"
                  (_sourceDetail
                      :: ConfigConfigRuleSource s -> TF.Attr s [TF.Attr s (SourceSourceDetail s)])
                  TF.validator

instance P.HasOwner (ConfigConfigRuleSource s) (TF.Attr s P.Text) where
    owner =
        P.lens (_owner :: ConfigConfigRuleSource s -> TF.Attr s P.Text)
               (\s a -> s { _owner = a } :: ConfigConfigRuleSource s)

instance P.HasSourceDetail (ConfigConfigRuleSource s) (TF.Attr s [TF.Attr s (SourceSourceDetail s)]) where
    sourceDetail =
        P.lens (_sourceDetail :: ConfigConfigRuleSource s -> TF.Attr s [TF.Attr s (SourceSourceDetail s)])
               (\s a -> s { _sourceDetail = a } :: ConfigConfigRuleSource s)

instance P.HasSourceIdentifier (ConfigConfigRuleSource s) (TF.Attr s P.Text) where
    sourceIdentifier =
        P.lens (_sourceIdentifier :: ConfigConfigRuleSource s -> TF.Attr s P.Text)
               (\s a -> s { _sourceIdentifier = a } :: ConfigConfigRuleSource s)

-- | @codecommit_trigger_trigger@ nested settings.
data CodecommitTriggerTrigger s = CodecommitTriggerTrigger'
    { _branches       :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @branches@ - (Optional, Forces New)
    --
    , _customData     :: TF.Attr s P.Text
    -- ^ @custom_data@ - (Optional, Forces New)
    --
    , _destinationArn :: TF.Attr s P.Text
    -- ^ @destination_arn@ - (Required, Forces New)
    --
    , _events         :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @events@ - (Required, Forces New)
    --
    , _name           :: TF.Attr s P.Text
    -- ^ @name@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCodecommitTriggerTrigger
    :: TF.Attr s P.Text -- ^ @destination_arn@ - 'P.destinationArn'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @events@ - 'P.events'
    -> TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> CodecommitTriggerTrigger s
newCodecommitTriggerTrigger _destinationArn _events _name =
    CodecommitTriggerTrigger'
        { _branches = TF.Nil
        , _customData = TF.Nil
        , _destinationArn = _destinationArn
        , _events = _events
        , _name = _name
        }

instance P.Hashable  (CodecommitTriggerTrigger s)
instance TF.IsValue  (CodecommitTriggerTrigger s)
instance TF.IsObject (CodecommitTriggerTrigger s) where
    toObject CodecommitTriggerTrigger'{..} = P.catMaybes
        [ TF.assign "branches" <$> TF.attribute _branches
        , TF.assign "custom_data" <$> TF.attribute _customData
        , TF.assign "destination_arn" <$> TF.attribute _destinationArn
        , TF.assign "events" <$> TF.attribute _events
        , TF.assign "name" <$> TF.attribute _name
        ]

instance TF.IsValid (CodecommitTriggerTrigger s) where
    validator = P.mempty

instance P.HasBranches (CodecommitTriggerTrigger s) (TF.Attr s [TF.Attr s P.Text]) where
    branches =
        P.lens (_branches :: CodecommitTriggerTrigger s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _branches = a } :: CodecommitTriggerTrigger s)

instance P.HasCustomData (CodecommitTriggerTrigger s) (TF.Attr s P.Text) where
    customData =
        P.lens (_customData :: CodecommitTriggerTrigger s -> TF.Attr s P.Text)
               (\s a -> s { _customData = a } :: CodecommitTriggerTrigger s)

instance P.HasDestinationArn (CodecommitTriggerTrigger s) (TF.Attr s P.Text) where
    destinationArn =
        P.lens (_destinationArn :: CodecommitTriggerTrigger s -> TF.Attr s P.Text)
               (\s a -> s { _destinationArn = a } :: CodecommitTriggerTrigger s)

instance P.HasEvents (CodecommitTriggerTrigger s) (TF.Attr s [TF.Attr s P.Text]) where
    events =
        P.lens (_events :: CodecommitTriggerTrigger s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _events = a } :: CodecommitTriggerTrigger s)

instance P.HasName (CodecommitTriggerTrigger s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: CodecommitTriggerTrigger s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: CodecommitTriggerTrigger s)

-- | @ordered_cache_behavior_lambda_function_association@ nested settings.
data OrderedCacheBehaviorLambdaFunctionAssociation s = OrderedCacheBehaviorLambdaFunctionAssociation'
    { _eventType :: TF.Attr s P.Text
    -- ^ @event_type@ - (Required)
    --
    , _lambdaArn :: TF.Attr s P.Text
    -- ^ @lambda_arn@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newOrderedCacheBehaviorLambdaFunctionAssociation
    :: TF.Attr s P.Text -- ^ @event_type@ - 'P.eventType'
    -> TF.Attr s P.Text -- ^ @lambda_arn@ - 'P.lambdaArn'
    -> OrderedCacheBehaviorLambdaFunctionAssociation s
newOrderedCacheBehaviorLambdaFunctionAssociation _eventType _lambdaArn =
    OrderedCacheBehaviorLambdaFunctionAssociation'
        { _eventType = _eventType
        , _lambdaArn = _lambdaArn
        }

instance P.Hashable  (OrderedCacheBehaviorLambdaFunctionAssociation s)
instance TF.IsValue  (OrderedCacheBehaviorLambdaFunctionAssociation s)
instance TF.IsObject (OrderedCacheBehaviorLambdaFunctionAssociation s) where
    toObject OrderedCacheBehaviorLambdaFunctionAssociation'{..} = P.catMaybes
        [ TF.assign "event_type" <$> TF.attribute _eventType
        , TF.assign "lambda_arn" <$> TF.attribute _lambdaArn
        ]

instance TF.IsValid (OrderedCacheBehaviorLambdaFunctionAssociation s) where
    validator = P.mempty

instance P.HasEventType (OrderedCacheBehaviorLambdaFunctionAssociation s) (TF.Attr s P.Text) where
    eventType =
        P.lens (_eventType :: OrderedCacheBehaviorLambdaFunctionAssociation s -> TF.Attr s P.Text)
               (\s a -> s { _eventType = a } :: OrderedCacheBehaviorLambdaFunctionAssociation s)

instance P.HasLambdaArn (OrderedCacheBehaviorLambdaFunctionAssociation s) (TF.Attr s P.Text) where
    lambdaArn =
        P.lens (_lambdaArn :: OrderedCacheBehaviorLambdaFunctionAssociation s -> TF.Attr s P.Text)
               (\s a -> s { _lambdaArn = a } :: OrderedCacheBehaviorLambdaFunctionAssociation s)

-- | @launch_template_placement@ nested settings.
data LaunchTemplatePlacement s = LaunchTemplatePlacement'
    { _affinity         :: TF.Attr s P.Text
    -- ^ @affinity@ - (Optional)
    --
    , _availabilityZone :: TF.Attr s P.Zone
    -- ^ @availability_zone@ - (Optional)
    --
    , _groupName        :: TF.Attr s P.Text
    -- ^ @group_name@ - (Optional)
    --
    , _hostId           :: TF.Attr s P.Text
    -- ^ @host_id@ - (Optional)
    --
    , _spreadDomain     :: TF.Attr s P.Text
    -- ^ @spread_domain@ - (Optional)
    --
    , _tenancy          :: TF.Attr s P.Text
    -- ^ @tenancy@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLaunchTemplatePlacement
    :: LaunchTemplatePlacement s
newLaunchTemplatePlacement =
    LaunchTemplatePlacement'
        { _affinity = TF.Nil
        , _availabilityZone = TF.Nil
        , _groupName = TF.Nil
        , _hostId = TF.Nil
        , _spreadDomain = TF.Nil
        , _tenancy = TF.Nil
        }

instance P.Hashable  (LaunchTemplatePlacement s)
instance TF.IsValue  (LaunchTemplatePlacement s)
instance TF.IsObject (LaunchTemplatePlacement s) where
    toObject LaunchTemplatePlacement'{..} = P.catMaybes
        [ TF.assign "affinity" <$> TF.attribute _affinity
        , TF.assign "availability_zone" <$> TF.attribute _availabilityZone
        , TF.assign "group_name" <$> TF.attribute _groupName
        , TF.assign "host_id" <$> TF.attribute _hostId
        , TF.assign "spread_domain" <$> TF.attribute _spreadDomain
        , TF.assign "tenancy" <$> TF.attribute _tenancy
        ]

instance TF.IsValid (LaunchTemplatePlacement s) where
    validator = P.mempty

instance P.HasAffinity (LaunchTemplatePlacement s) (TF.Attr s P.Text) where
    affinity =
        P.lens (_affinity :: LaunchTemplatePlacement s -> TF.Attr s P.Text)
               (\s a -> s { _affinity = a } :: LaunchTemplatePlacement s)

instance P.HasAvailabilityZone (LaunchTemplatePlacement s) (TF.Attr s P.Zone) where
    availabilityZone =
        P.lens (_availabilityZone :: LaunchTemplatePlacement s -> TF.Attr s P.Zone)
               (\s a -> s { _availabilityZone = a } :: LaunchTemplatePlacement s)

instance P.HasGroupName (LaunchTemplatePlacement s) (TF.Attr s P.Text) where
    groupName =
        P.lens (_groupName :: LaunchTemplatePlacement s -> TF.Attr s P.Text)
               (\s a -> s { _groupName = a } :: LaunchTemplatePlacement s)

instance P.HasHostId (LaunchTemplatePlacement s) (TF.Attr s P.Text) where
    hostId =
        P.lens (_hostId :: LaunchTemplatePlacement s -> TF.Attr s P.Text)
               (\s a -> s { _hostId = a } :: LaunchTemplatePlacement s)

instance P.HasSpreadDomain (LaunchTemplatePlacement s) (TF.Attr s P.Text) where
    spreadDomain =
        P.lens (_spreadDomain :: LaunchTemplatePlacement s -> TF.Attr s P.Text)
               (\s a -> s { _spreadDomain = a } :: LaunchTemplatePlacement s)

instance P.HasTenancy (LaunchTemplatePlacement s) (TF.Attr s P.Text) where
    tenancy =
        P.lens (_tenancy :: LaunchTemplatePlacement s -> TF.Attr s P.Text)
               (\s a -> s { _tenancy = a } :: LaunchTemplatePlacement s)

-- | @cloudfront_distribution_logging_config@ nested settings.
data CloudfrontDistributionLoggingConfig s = CloudfrontDistributionLoggingConfig'
    { _bucket         :: TF.Attr s P.Text
    -- ^ @bucket@ - (Required)
    --
    , _includeCookies :: TF.Attr s P.Bool
    -- ^ @include_cookies@ - (Optional)
    --
    , _prefix         :: TF.Attr s P.Text
    -- ^ @prefix@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCloudfrontDistributionLoggingConfig
    :: TF.Attr s P.Text -- ^ @bucket@ - 'P.bucket'
    -> CloudfrontDistributionLoggingConfig s
newCloudfrontDistributionLoggingConfig _bucket =
    CloudfrontDistributionLoggingConfig'
        { _bucket = _bucket
        , _includeCookies = TF.value P.False
        , _prefix = TF.Nil
        }

instance P.Hashable  (CloudfrontDistributionLoggingConfig s)
instance TF.IsValue  (CloudfrontDistributionLoggingConfig s)
instance TF.IsObject (CloudfrontDistributionLoggingConfig s) where
    toObject CloudfrontDistributionLoggingConfig'{..} = P.catMaybes
        [ TF.assign "bucket" <$> TF.attribute _bucket
        , TF.assign "include_cookies" <$> TF.attribute _includeCookies
        , TF.assign "prefix" <$> TF.attribute _prefix
        ]

instance TF.IsValid (CloudfrontDistributionLoggingConfig s) where
    validator = P.mempty

instance P.HasBucket (CloudfrontDistributionLoggingConfig s) (TF.Attr s P.Text) where
    bucket =
        P.lens (_bucket :: CloudfrontDistributionLoggingConfig s -> TF.Attr s P.Text)
               (\s a -> s { _bucket = a } :: CloudfrontDistributionLoggingConfig s)

instance P.HasIncludeCookies (CloudfrontDistributionLoggingConfig s) (TF.Attr s P.Bool) where
    includeCookies =
        P.lens (_includeCookies :: CloudfrontDistributionLoggingConfig s -> TF.Attr s P.Bool)
               (\s a -> s { _includeCookies = a } :: CloudfrontDistributionLoggingConfig s)

instance P.HasPrefix (CloudfrontDistributionLoggingConfig s) (TF.Attr s P.Text) where
    prefix =
        P.lens (_prefix :: CloudfrontDistributionLoggingConfig s -> TF.Attr s P.Text)
               (\s a -> s { _prefix = a } :: CloudfrontDistributionLoggingConfig s)

-- | @vpc_endpoint_dns_entry@ nested settings.
data VpcEndpointDnsEntry s = VpcEndpointDnsEntry'
    deriving (P.Show, P.Eq, P.Generic)

newVpcEndpointDnsEntry
    :: VpcEndpointDnsEntry s
newVpcEndpointDnsEntry =
    VpcEndpointDnsEntry'

instance P.Hashable  (VpcEndpointDnsEntry s)
instance TF.IsValue  (VpcEndpointDnsEntry s)
instance TF.IsObject (VpcEndpointDnsEntry s) where
    toObject VpcEndpointDnsEntry' = []

instance TF.IsValid (VpcEndpointDnsEntry s) where
    validator = P.mempty

instance s ~ s' => P.HasComputedDnsName (TF.Ref s' (VpcEndpointDnsEntry s)) (TF.Attr s P.Text) where
    computedDnsName x = TF.compute (TF.refKey x) "dns_name"

instance s ~ s' => P.HasComputedHostedZoneId (TF.Ref s' (VpcEndpointDnsEntry s)) (TF.Attr s P.Text) where
    computedHostedZoneId x = TF.compute (TF.refKey x) "hosted_zone_id"

-- | @codepipeline_stage@ nested settings.
data CodepipelineStage s = CodepipelineStage'
    { _action :: TF.Attr s [TF.Attr s (StageAction s)]
    -- ^ @action@ - (Required)
    --
    , _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCodepipelineStage
    :: TF.Attr s [TF.Attr s (StageAction s)] -- ^ @action@ - 'P.action'
    -> TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> CodepipelineStage s
newCodepipelineStage _action _name =
    CodepipelineStage'
        { _action = _action
        , _name = _name
        }

instance P.Hashable  (CodepipelineStage s)
instance TF.IsValue  (CodepipelineStage s)
instance TF.IsObject (CodepipelineStage s) where
    toObject CodepipelineStage'{..} = P.catMaybes
        [ TF.assign "action" <$> TF.attribute _action
        , TF.assign "name" <$> TF.attribute _name
        ]

instance TF.IsValid (CodepipelineStage s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_action"
                  (_action
                      :: CodepipelineStage s -> TF.Attr s [TF.Attr s (StageAction s)])
                  TF.validator

instance P.HasAction (CodepipelineStage s) (TF.Attr s [TF.Attr s (StageAction s)]) where
    action =
        P.lens (_action :: CodepipelineStage s -> TF.Attr s [TF.Attr s (StageAction s)])
               (\s a -> s { _action = a } :: CodepipelineStage s)

instance P.HasName (CodepipelineStage s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: CodepipelineStage s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: CodepipelineStage s)

-- | @route_tables_filter@ nested settings.
data RouteTablesFilter s = RouteTablesFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRouteTablesFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> RouteTablesFilter s
newRouteTablesFilter _name _values =
    RouteTablesFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (RouteTablesFilter s)
instance TF.IsValue  (RouteTablesFilter s)
instance TF.IsObject (RouteTablesFilter s) where
    toObject RouteTablesFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (RouteTablesFilter s) where
    validator = P.mempty

instance P.HasName (RouteTablesFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: RouteTablesFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: RouteTablesFilter s)

instance P.HasValues (RouteTablesFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: RouteTablesFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: RouteTablesFilter s)

-- | @config_configuration_aggregator_account_aggregation_source@ nested settings.
data ConfigConfigurationAggregatorAccountAggregationSource s = ConfigConfigurationAggregatorAccountAggregationSource'
    { _accountIds :: TF.Attr s (P.NonEmpty (TF.Attr s P.Text))
    -- ^ @account_ids@ - (Required)
    --
    , _allRegions :: TF.Attr s P.Bool
    -- ^ @all_regions@ - (Optional)
    --
    , _regions    :: TF.Attr s (P.NonEmpty (TF.Attr s P.Text))
    -- ^ @regions@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newConfigConfigurationAggregatorAccountAggregationSource
    :: TF.Attr s (P.NonEmpty (TF.Attr s P.Text)) -- ^ @account_ids@ - 'P.accountIds'
    -> ConfigConfigurationAggregatorAccountAggregationSource s
newConfigConfigurationAggregatorAccountAggregationSource _accountIds =
    ConfigConfigurationAggregatorAccountAggregationSource'
        { _accountIds = _accountIds
        , _allRegions = TF.value P.False
        , _regions = TF.Nil
        }

instance P.Hashable  (ConfigConfigurationAggregatorAccountAggregationSource s)
instance TF.IsValue  (ConfigConfigurationAggregatorAccountAggregationSource s)
instance TF.IsObject (ConfigConfigurationAggregatorAccountAggregationSource s) where
    toObject ConfigConfigurationAggregatorAccountAggregationSource'{..} = P.catMaybes
        [ TF.assign "account_ids" <$> TF.attribute _accountIds
        , TF.assign "all_regions" <$> TF.attribute _allRegions
        , TF.assign "regions" <$> TF.attribute _regions
        ]

instance TF.IsValid (ConfigConfigurationAggregatorAccountAggregationSource s) where
    validator = P.mempty

instance P.HasAccountIds (ConfigConfigurationAggregatorAccountAggregationSource s) (TF.Attr s (P.NonEmpty (TF.Attr s P.Text))) where
    accountIds =
        P.lens (_accountIds :: ConfigConfigurationAggregatorAccountAggregationSource s -> TF.Attr s (P.NonEmpty (TF.Attr s P.Text)))
               (\s a -> s { _accountIds = a } :: ConfigConfigurationAggregatorAccountAggregationSource s)

instance P.HasAllRegions (ConfigConfigurationAggregatorAccountAggregationSource s) (TF.Attr s P.Bool) where
    allRegions =
        P.lens (_allRegions :: ConfigConfigurationAggregatorAccountAggregationSource s -> TF.Attr s P.Bool)
               (\s a -> s { _allRegions = a } :: ConfigConfigurationAggregatorAccountAggregationSource s)

instance P.HasRegions (ConfigConfigurationAggregatorAccountAggregationSource s) (TF.Attr s (P.NonEmpty (TF.Attr s P.Text))) where
    regions =
        P.lens (_regions :: ConfigConfigurationAggregatorAccountAggregationSource s -> TF.Attr s (P.NonEmpty (TF.Attr s P.Text)))
               (\s a -> s { _regions = a } :: ConfigConfigurationAggregatorAccountAggregationSource s)

-- | @s3_bucket_versioning@ nested settings.
data S3BucketVersioning s = S3BucketVersioning'
    { _enabled   :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Optional)
    --
    , _mfaDelete :: TF.Attr s P.Bool
    -- ^ @mfa_delete@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newS3BucketVersioning
    :: S3BucketVersioning s
newS3BucketVersioning =
    S3BucketVersioning'
        { _enabled = TF.value P.False
        , _mfaDelete = TF.value P.False
        }

instance P.Hashable  (S3BucketVersioning s)
instance TF.IsValue  (S3BucketVersioning s)
instance TF.IsObject (S3BucketVersioning s) where
    toObject S3BucketVersioning'{..} = P.catMaybes
        [ TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "mfa_delete" <$> TF.attribute _mfaDelete
        ]

instance TF.IsValid (S3BucketVersioning s) where
    validator = P.mempty

instance P.HasEnabled (S3BucketVersioning s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: S3BucketVersioning s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: S3BucketVersioning s)

instance P.HasMfaDelete (S3BucketVersioning s) (TF.Attr s P.Bool) where
    mfaDelete =
        P.lens (_mfaDelete :: S3BucketVersioning s -> TF.Attr s P.Bool)
               (\s a -> s { _mfaDelete = a } :: S3BucketVersioning s)

-- | @kinesis_firehose_delivery_stream_kinesis_source_configuration@ nested settings.
data KinesisFirehoseDeliveryStreamKinesisSourceConfiguration s = KinesisFirehoseDeliveryStreamKinesisSourceConfiguration'
    { _kinesisStreamArn :: TF.Attr s P.Text
    -- ^ @kinesis_stream_arn@ - (Required, Forces New)
    --
    , _roleArn          :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newKinesisFirehoseDeliveryStreamKinesisSourceConfiguration
    :: TF.Attr s P.Text -- ^ @kinesis_stream_arn@ - 'P.kinesisStreamArn'
    -> TF.Attr s P.Text -- ^ @role_arn@ - 'P.roleArn'
    -> KinesisFirehoseDeliveryStreamKinesisSourceConfiguration s
newKinesisFirehoseDeliveryStreamKinesisSourceConfiguration _kinesisStreamArn _roleArn =
    KinesisFirehoseDeliveryStreamKinesisSourceConfiguration'
        { _kinesisStreamArn = _kinesisStreamArn
        , _roleArn = _roleArn
        }

instance P.Hashable  (KinesisFirehoseDeliveryStreamKinesisSourceConfiguration s)
instance TF.IsValue  (KinesisFirehoseDeliveryStreamKinesisSourceConfiguration s)
instance TF.IsObject (KinesisFirehoseDeliveryStreamKinesisSourceConfiguration s) where
    toObject KinesisFirehoseDeliveryStreamKinesisSourceConfiguration'{..} = P.catMaybes
        [ TF.assign "kinesis_stream_arn" <$> TF.attribute _kinesisStreamArn
        , TF.assign "role_arn" <$> TF.attribute _roleArn
        ]

instance TF.IsValid (KinesisFirehoseDeliveryStreamKinesisSourceConfiguration s) where
    validator = P.mempty

instance P.HasKinesisStreamArn (KinesisFirehoseDeliveryStreamKinesisSourceConfiguration s) (TF.Attr s P.Text) where
    kinesisStreamArn =
        P.lens (_kinesisStreamArn :: KinesisFirehoseDeliveryStreamKinesisSourceConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _kinesisStreamArn = a } :: KinesisFirehoseDeliveryStreamKinesisSourceConfiguration s)

instance P.HasRoleArn (KinesisFirehoseDeliveryStreamKinesisSourceConfiguration s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: KinesisFirehoseDeliveryStreamKinesisSourceConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: KinesisFirehoseDeliveryStreamKinesisSourceConfiguration s)

-- | @iot_topic_rule_republish@ nested settings.
data IotTopicRuleRepublish s = IotTopicRuleRepublish'
    { _roleArn :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Required)
    --
    , _topic   :: TF.Attr s P.Text
    -- ^ @topic@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newIotTopicRuleRepublish
    :: TF.Attr s P.Text -- ^ @role_arn@ - 'P.roleArn'
    -> TF.Attr s P.Text -- ^ @topic@ - 'P.topic'
    -> IotTopicRuleRepublish s
newIotTopicRuleRepublish _roleArn _topic =
    IotTopicRuleRepublish'
        { _roleArn = _roleArn
        , _topic = _topic
        }

instance P.Hashable  (IotTopicRuleRepublish s)
instance TF.IsValue  (IotTopicRuleRepublish s)
instance TF.IsObject (IotTopicRuleRepublish s) where
    toObject IotTopicRuleRepublish'{..} = P.catMaybes
        [ TF.assign "role_arn" <$> TF.attribute _roleArn
        , TF.assign "topic" <$> TF.attribute _topic
        ]

instance TF.IsValid (IotTopicRuleRepublish s) where
    validator = P.mempty

instance P.HasRoleArn (IotTopicRuleRepublish s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: IotTopicRuleRepublish s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: IotTopicRuleRepublish s)

instance P.HasTopic (IotTopicRuleRepublish s) (TF.Attr s P.Text) where
    topic =
        P.lens (_topic :: IotTopicRuleRepublish s -> TF.Attr s P.Text)
               (\s a -> s { _topic = a } :: IotTopicRuleRepublish s)

-- | @elastictranscoder_pipeline_notifications@ nested settings.
data ElastictranscoderPipelineNotifications s = ElastictranscoderPipelineNotifications'
    { _completed   :: TF.Attr s P.Text
    -- ^ @completed@ - (Optional)
    --
    , _error       :: TF.Attr s P.Text
    -- ^ @error@ - (Optional)
    --
    , _progressing :: TF.Attr s P.Text
    -- ^ @progressing@ - (Optional)
    --
    , _warning     :: TF.Attr s P.Text
    -- ^ @warning@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElastictranscoderPipelineNotifications
    :: ElastictranscoderPipelineNotifications s
newElastictranscoderPipelineNotifications =
    ElastictranscoderPipelineNotifications'
        { _completed = TF.Nil
        , _error = TF.Nil
        , _progressing = TF.Nil
        , _warning = TF.Nil
        }

instance P.Hashable  (ElastictranscoderPipelineNotifications s)
instance TF.IsValue  (ElastictranscoderPipelineNotifications s)
instance TF.IsObject (ElastictranscoderPipelineNotifications s) where
    toObject ElastictranscoderPipelineNotifications'{..} = P.catMaybes
        [ TF.assign "completed" <$> TF.attribute _completed
        , TF.assign "error" <$> TF.attribute _error
        , TF.assign "progressing" <$> TF.attribute _progressing
        , TF.assign "warning" <$> TF.attribute _warning
        ]

instance TF.IsValid (ElastictranscoderPipelineNotifications s) where
    validator = P.mempty

instance P.HasCompleted (ElastictranscoderPipelineNotifications s) (TF.Attr s P.Text) where
    completed =
        P.lens (_completed :: ElastictranscoderPipelineNotifications s -> TF.Attr s P.Text)
               (\s a -> s { _completed = a } :: ElastictranscoderPipelineNotifications s)

instance P.HasError (ElastictranscoderPipelineNotifications s) (TF.Attr s P.Text) where
    error =
        P.lens (_error :: ElastictranscoderPipelineNotifications s -> TF.Attr s P.Text)
               (\s a -> s { _error = a } :: ElastictranscoderPipelineNotifications s)

instance P.HasProgressing (ElastictranscoderPipelineNotifications s) (TF.Attr s P.Text) where
    progressing =
        P.lens (_progressing :: ElastictranscoderPipelineNotifications s -> TF.Attr s P.Text)
               (\s a -> s { _progressing = a } :: ElastictranscoderPipelineNotifications s)

instance P.HasWarning (ElastictranscoderPipelineNotifications s) (TF.Attr s P.Text) where
    warning =
        P.lens (_warning :: ElastictranscoderPipelineNotifications s -> TF.Attr s P.Text)
               (\s a -> s { _warning = a } :: ElastictranscoderPipelineNotifications s)

-- | @elastictranscoder_pipeline_thumbnail_config_permissions@ nested settings.
data ElastictranscoderPipelineThumbnailConfigPermissions s = ElastictranscoderPipelineThumbnailConfigPermissions'
    { _access      :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @access@ - (Optional)
    --
    , _grantee     :: TF.Attr s P.Text
    -- ^ @grantee@ - (Optional)
    --
    , _granteeType :: TF.Attr s P.Text
    -- ^ @grantee_type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElastictranscoderPipelineThumbnailConfigPermissions
    :: ElastictranscoderPipelineThumbnailConfigPermissions s
newElastictranscoderPipelineThumbnailConfigPermissions =
    ElastictranscoderPipelineThumbnailConfigPermissions'
        { _access = TF.Nil
        , _grantee = TF.Nil
        , _granteeType = TF.Nil
        }

instance P.Hashable  (ElastictranscoderPipelineThumbnailConfigPermissions s)
instance TF.IsValue  (ElastictranscoderPipelineThumbnailConfigPermissions s)
instance TF.IsObject (ElastictranscoderPipelineThumbnailConfigPermissions s) where
    toObject ElastictranscoderPipelineThumbnailConfigPermissions'{..} = P.catMaybes
        [ TF.assign "access" <$> TF.attribute _access
        , TF.assign "grantee" <$> TF.attribute _grantee
        , TF.assign "grantee_type" <$> TF.attribute _granteeType
        ]

instance TF.IsValid (ElastictranscoderPipelineThumbnailConfigPermissions s) where
    validator = P.mempty

instance P.HasAccess (ElastictranscoderPipelineThumbnailConfigPermissions s) (TF.Attr s [TF.Attr s P.Text]) where
    access =
        P.lens (_access :: ElastictranscoderPipelineThumbnailConfigPermissions s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _access = a } :: ElastictranscoderPipelineThumbnailConfigPermissions s)

instance P.HasGrantee (ElastictranscoderPipelineThumbnailConfigPermissions s) (TF.Attr s P.Text) where
    grantee =
        P.lens (_grantee :: ElastictranscoderPipelineThumbnailConfigPermissions s -> TF.Attr s P.Text)
               (\s a -> s { _grantee = a } :: ElastictranscoderPipelineThumbnailConfigPermissions s)

instance P.HasGranteeType (ElastictranscoderPipelineThumbnailConfigPermissions s) (TF.Attr s P.Text) where
    granteeType =
        P.lens (_granteeType :: ElastictranscoderPipelineThumbnailConfigPermissions s -> TF.Attr s P.Text)
               (\s a -> s { _granteeType = a } :: ElastictranscoderPipelineThumbnailConfigPermissions s)

-- | @api_gateway_usage_plan_throttle_settings@ nested settings.
data ApiGatewayUsagePlanThrottleSettings s = ApiGatewayUsagePlanThrottleSettings'
    { _burstLimit :: TF.Attr s P.Integer
    -- ^ @burst_limit@ - (Optional)
    --
    , _rateLimit  :: TF.Attr s P.Double
    -- ^ @rate_limit@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newApiGatewayUsagePlanThrottleSettings
    :: ApiGatewayUsagePlanThrottleSettings s
newApiGatewayUsagePlanThrottleSettings =
    ApiGatewayUsagePlanThrottleSettings'
        { _burstLimit = TF.value 0
        , _rateLimit = TF.value 0.0
        }

instance P.Hashable  (ApiGatewayUsagePlanThrottleSettings s)
instance TF.IsValue  (ApiGatewayUsagePlanThrottleSettings s)
instance TF.IsObject (ApiGatewayUsagePlanThrottleSettings s) where
    toObject ApiGatewayUsagePlanThrottleSettings'{..} = P.catMaybes
        [ TF.assign "burst_limit" <$> TF.attribute _burstLimit
        , TF.assign "rate_limit" <$> TF.attribute _rateLimit
        ]

instance TF.IsValid (ApiGatewayUsagePlanThrottleSettings s) where
    validator = P.mempty

instance P.HasBurstLimit (ApiGatewayUsagePlanThrottleSettings s) (TF.Attr s P.Integer) where
    burstLimit =
        P.lens (_burstLimit :: ApiGatewayUsagePlanThrottleSettings s -> TF.Attr s P.Integer)
               (\s a -> s { _burstLimit = a } :: ApiGatewayUsagePlanThrottleSettings s)

instance P.HasRateLimit (ApiGatewayUsagePlanThrottleSettings s) (TF.Attr s P.Double) where
    rateLimit =
        P.lens (_rateLimit :: ApiGatewayUsagePlanThrottleSettings s -> TF.Attr s P.Double)
               (\s a -> s { _rateLimit = a } :: ApiGatewayUsagePlanThrottleSettings s)

-- | @target_tracking_scaling_policy_configuration_customized_metric_specification@ nested settings.
data TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s = TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification'
    { _dimensions :: TF.Attr s [TF.Attr s (CustomizedMetricSpecificationDimensions s)]
    -- ^ @dimensions@ - (Optional)
    --
    , _metricName :: TF.Attr s P.Text
    -- ^ @metric_name@ - (Required)
    --
    , _namespace :: TF.Attr s P.Text
    -- ^ @namespace@ - (Required)
    --
    , _statistic :: TF.Attr s P.Text
    -- ^ @statistic@ - (Required)
    --
    , _unit :: TF.Attr s P.Text
    -- ^ @unit@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification
    :: TF.Attr s P.Text -- ^ @metric_name@ - 'P.metricName'
    -> TF.Attr s P.Text -- ^ @namespace@ - 'P.namespace'
    -> TF.Attr s P.Text -- ^ @statistic@ - 'P.statistic'
    -> TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s
newTargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification _metricName _namespace _statistic =
    TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification'
        { _dimensions = TF.Nil
        , _metricName = _metricName
        , _namespace = _namespace
        , _statistic = _statistic
        , _unit = TF.Nil
        }

instance P.Hashable  (TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s)
instance TF.IsValue  (TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s)
instance TF.IsObject (TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s) where
    toObject TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification'{..} = P.catMaybes
        [ TF.assign "dimensions" <$> TF.attribute _dimensions
        , TF.assign "metric_name" <$> TF.attribute _metricName
        , TF.assign "namespace" <$> TF.attribute _namespace
        , TF.assign "statistic" <$> TF.attribute _statistic
        , TF.assign "unit" <$> TF.attribute _unit
        ]

instance TF.IsValid (TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_dimensions"
                  (_dimensions
                      :: TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s -> TF.Attr s [TF.Attr s (CustomizedMetricSpecificationDimensions s)])
                  TF.validator

instance P.HasDimensions (TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s) (TF.Attr s [TF.Attr s (CustomizedMetricSpecificationDimensions s)]) where
    dimensions =
        P.lens (_dimensions :: TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s -> TF.Attr s [TF.Attr s (CustomizedMetricSpecificationDimensions s)])
               (\s a -> s { _dimensions = a } :: TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s)

instance P.HasMetricName (TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s) (TF.Attr s P.Text) where
    metricName =
        P.lens (_metricName :: TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s -> TF.Attr s P.Text)
               (\s a -> s { _metricName = a } :: TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s)

instance P.HasNamespace (TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s) (TF.Attr s P.Text) where
    namespace =
        P.lens (_namespace :: TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s -> TF.Attr s P.Text)
               (\s a -> s { _namespace = a } :: TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s)

instance P.HasStatistic (TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s) (TF.Attr s P.Text) where
    statistic =
        P.lens (_statistic :: TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s -> TF.Attr s P.Text)
               (\s a -> s { _statistic = a } :: TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s)

instance P.HasUnit (TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s) (TF.Attr s P.Text) where
    unit =
        P.lens (_unit :: TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s -> TF.Attr s P.Text)
               (\s a -> s { _unit = a } :: TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s)

-- | @ami_ephemeral_block_device@ nested settings.
data AmiEphemeralBlockDevice s = AmiEphemeralBlockDevice'
    { _deviceName  :: TF.Attr s P.Text
    -- ^ @device_name@ - (Required)
    --
    , _virtualName :: TF.Attr s P.Text
    -- ^ @virtual_name@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAmiEphemeralBlockDevice
    :: TF.Attr s P.Text -- ^ @device_name@ - 'P.deviceName'
    -> TF.Attr s P.Text -- ^ @virtual_name@ - 'P.virtualName'
    -> AmiEphemeralBlockDevice s
newAmiEphemeralBlockDevice _deviceName _virtualName =
    AmiEphemeralBlockDevice'
        { _deviceName = _deviceName
        , _virtualName = _virtualName
        }

instance P.Hashable  (AmiEphemeralBlockDevice s)
instance TF.IsValue  (AmiEphemeralBlockDevice s)
instance TF.IsObject (AmiEphemeralBlockDevice s) where
    toObject AmiEphemeralBlockDevice'{..} = P.catMaybes
        [ TF.assign "device_name" <$> TF.attribute _deviceName
        , TF.assign "virtual_name" <$> TF.attribute _virtualName
        ]

instance TF.IsValid (AmiEphemeralBlockDevice s) where
    validator = P.mempty

instance P.HasDeviceName (AmiEphemeralBlockDevice s) (TF.Attr s P.Text) where
    deviceName =
        P.lens (_deviceName :: AmiEphemeralBlockDevice s -> TF.Attr s P.Text)
               (\s a -> s { _deviceName = a } :: AmiEphemeralBlockDevice s)

instance P.HasVirtualName (AmiEphemeralBlockDevice s) (TF.Attr s P.Text) where
    virtualName =
        P.lens (_virtualName :: AmiEphemeralBlockDevice s -> TF.Attr s P.Text)
               (\s a -> s { _virtualName = a } :: AmiEphemeralBlockDevice s)

-- | @extended_s3_configuration_data_format_conversion_configuration@ nested settings.
data ExtendedS3ConfigurationDataFormatConversionConfiguration s = ExtendedS3ConfigurationDataFormatConversionConfiguration'
    { _enabled :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Optional)
    --
    , _inputFormatConfiguration :: TF.Attr s (DataFormatConversionConfigurationInputFormatConfiguration s)
    -- ^ @input_format_configuration@ - (Required)
    --
    , _outputFormatConfiguration :: TF.Attr s (DataFormatConversionConfigurationOutputFormatConfiguration s)
    -- ^ @output_format_configuration@ - (Required)
    --
    , _schemaConfiguration :: TF.Attr s (DataFormatConversionConfigurationSchemaConfiguration s)
    -- ^ @schema_configuration@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newExtendedS3ConfigurationDataFormatConversionConfiguration
    :: TF.Attr s (DataFormatConversionConfigurationInputFormatConfiguration s) -- ^ @input_format_configuration@ - 'P.inputFormatConfiguration'
    -> TF.Attr s (DataFormatConversionConfigurationOutputFormatConfiguration s) -- ^ @output_format_configuration@ - 'P.outputFormatConfiguration'
    -> TF.Attr s (DataFormatConversionConfigurationSchemaConfiguration s) -- ^ @schema_configuration@ - 'P.schemaConfiguration'
    -> ExtendedS3ConfigurationDataFormatConversionConfiguration s
newExtendedS3ConfigurationDataFormatConversionConfiguration _inputFormatConfiguration _outputFormatConfiguration _schemaConfiguration =
    ExtendedS3ConfigurationDataFormatConversionConfiguration'
        { _enabled = TF.value P.True
        , _inputFormatConfiguration = _inputFormatConfiguration
        , _outputFormatConfiguration = _outputFormatConfiguration
        , _schemaConfiguration = _schemaConfiguration
        }

instance P.Hashable  (ExtendedS3ConfigurationDataFormatConversionConfiguration s)
instance TF.IsValue  (ExtendedS3ConfigurationDataFormatConversionConfiguration s)
instance TF.IsObject (ExtendedS3ConfigurationDataFormatConversionConfiguration s) where
    toObject ExtendedS3ConfigurationDataFormatConversionConfiguration'{..} = P.catMaybes
        [ TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "input_format_configuration" <$> TF.attribute _inputFormatConfiguration
        , TF.assign "output_format_configuration" <$> TF.attribute _outputFormatConfiguration
        , TF.assign "schema_configuration" <$> TF.attribute _schemaConfiguration
        ]

instance TF.IsValid (ExtendedS3ConfigurationDataFormatConversionConfiguration s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_inputFormatConfiguration"
                  (_inputFormatConfiguration
                      :: ExtendedS3ConfigurationDataFormatConversionConfiguration s -> TF.Attr s (DataFormatConversionConfigurationInputFormatConfiguration s))
                  TF.validator
           P.<> TF.settingsValidator "_outputFormatConfiguration"
                  (_outputFormatConfiguration
                      :: ExtendedS3ConfigurationDataFormatConversionConfiguration s -> TF.Attr s (DataFormatConversionConfigurationOutputFormatConfiguration s))
                  TF.validator
           P.<> TF.settingsValidator "_schemaConfiguration"
                  (_schemaConfiguration
                      :: ExtendedS3ConfigurationDataFormatConversionConfiguration s -> TF.Attr s (DataFormatConversionConfigurationSchemaConfiguration s))
                  TF.validator

instance P.HasEnabled (ExtendedS3ConfigurationDataFormatConversionConfiguration s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: ExtendedS3ConfigurationDataFormatConversionConfiguration s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: ExtendedS3ConfigurationDataFormatConversionConfiguration s)

instance P.HasInputFormatConfiguration (ExtendedS3ConfigurationDataFormatConversionConfiguration s) (TF.Attr s (DataFormatConversionConfigurationInputFormatConfiguration s)) where
    inputFormatConfiguration =
        P.lens (_inputFormatConfiguration :: ExtendedS3ConfigurationDataFormatConversionConfiguration s -> TF.Attr s (DataFormatConversionConfigurationInputFormatConfiguration s))
               (\s a -> s { _inputFormatConfiguration = a } :: ExtendedS3ConfigurationDataFormatConversionConfiguration s)

instance P.HasOutputFormatConfiguration (ExtendedS3ConfigurationDataFormatConversionConfiguration s) (TF.Attr s (DataFormatConversionConfigurationOutputFormatConfiguration s)) where
    outputFormatConfiguration =
        P.lens (_outputFormatConfiguration :: ExtendedS3ConfigurationDataFormatConversionConfiguration s -> TF.Attr s (DataFormatConversionConfigurationOutputFormatConfiguration s))
               (\s a -> s { _outputFormatConfiguration = a } :: ExtendedS3ConfigurationDataFormatConversionConfiguration s)

instance P.HasSchemaConfiguration (ExtendedS3ConfigurationDataFormatConversionConfiguration s) (TF.Attr s (DataFormatConversionConfigurationSchemaConfiguration s)) where
    schemaConfiguration =
        P.lens (_schemaConfiguration :: ExtendedS3ConfigurationDataFormatConversionConfiguration s -> TF.Attr s (DataFormatConversionConfigurationSchemaConfiguration s))
               (\s a -> s { _schemaConfiguration = a } :: ExtendedS3ConfigurationDataFormatConversionConfiguration s)

-- | @gamelift_fleet_runtime_configuration@ nested settings.
data GameliftFleetRuntimeConfiguration s = GameliftFleetRuntimeConfiguration'
    { _gameSessionActivationTimeoutSeconds :: TF.Attr s P.Integer
    -- ^ @game_session_activation_timeout_seconds@ - (Optional)
    --
    , _maxConcurrentGameSessionActivations :: TF.Attr s P.Integer
    -- ^ @max_concurrent_game_session_activations@ - (Optional)
    --
    , _serverProcess :: TF.Attr s [TF.Attr s (RuntimeConfigurationServerProcess s)]
    -- ^ @server_process@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newGameliftFleetRuntimeConfiguration
    :: GameliftFleetRuntimeConfiguration s
newGameliftFleetRuntimeConfiguration =
    GameliftFleetRuntimeConfiguration'
        { _gameSessionActivationTimeoutSeconds = TF.Nil
        , _maxConcurrentGameSessionActivations = TF.Nil
        , _serverProcess = TF.Nil
        }

instance P.Hashable  (GameliftFleetRuntimeConfiguration s)
instance TF.IsValue  (GameliftFleetRuntimeConfiguration s)
instance TF.IsObject (GameliftFleetRuntimeConfiguration s) where
    toObject GameliftFleetRuntimeConfiguration'{..} = P.catMaybes
        [ TF.assign "game_session_activation_timeout_seconds" <$> TF.attribute _gameSessionActivationTimeoutSeconds
        , TF.assign "max_concurrent_game_session_activations" <$> TF.attribute _maxConcurrentGameSessionActivations
        , TF.assign "server_process" <$> TF.attribute _serverProcess
        ]

instance TF.IsValid (GameliftFleetRuntimeConfiguration s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_serverProcess"
                  (_serverProcess
                      :: GameliftFleetRuntimeConfiguration s -> TF.Attr s [TF.Attr s (RuntimeConfigurationServerProcess s)])
                  TF.validator

instance P.HasGameSessionActivationTimeoutSeconds (GameliftFleetRuntimeConfiguration s) (TF.Attr s P.Integer) where
    gameSessionActivationTimeoutSeconds =
        P.lens (_gameSessionActivationTimeoutSeconds :: GameliftFleetRuntimeConfiguration s -> TF.Attr s P.Integer)
               (\s a -> s { _gameSessionActivationTimeoutSeconds = a } :: GameliftFleetRuntimeConfiguration s)

instance P.HasMaxConcurrentGameSessionActivations (GameliftFleetRuntimeConfiguration s) (TF.Attr s P.Integer) where
    maxConcurrentGameSessionActivations =
        P.lens (_maxConcurrentGameSessionActivations :: GameliftFleetRuntimeConfiguration s -> TF.Attr s P.Integer)
               (\s a -> s { _maxConcurrentGameSessionActivations = a } :: GameliftFleetRuntimeConfiguration s)

instance P.HasServerProcess (GameliftFleetRuntimeConfiguration s) (TF.Attr s [TF.Attr s (RuntimeConfigurationServerProcess s)]) where
    serverProcess =
        P.lens (_serverProcess :: GameliftFleetRuntimeConfiguration s -> TF.Attr s [TF.Attr s (RuntimeConfigurationServerProcess s)])
               (\s a -> s { _serverProcess = a } :: GameliftFleetRuntimeConfiguration s)

-- | @dax_cluster_nodes@ nested settings.
data DaxClusterNodes s = DaxClusterNodes'
    deriving (P.Show, P.Eq, P.Generic)

newDaxClusterNodes
    :: DaxClusterNodes s
newDaxClusterNodes =
    DaxClusterNodes'

instance P.Hashable  (DaxClusterNodes s)
instance TF.IsValue  (DaxClusterNodes s)
instance TF.IsObject (DaxClusterNodes s) where
    toObject DaxClusterNodes' = []

instance TF.IsValid (DaxClusterNodes s) where
    validator = P.mempty

instance s ~ s' => P.HasComputedAddress (TF.Ref s' (DaxClusterNodes s)) (TF.Attr s P.Text) where
    computedAddress x = TF.compute (TF.refKey x) "address"

instance s ~ s' => P.HasComputedAvailabilityZone (TF.Ref s' (DaxClusterNodes s)) (TF.Attr s P.Zone) where
    computedAvailabilityZone x = TF.compute (TF.refKey x) "availability_zone"

instance s ~ s' => P.HasComputedId (TF.Ref s' (DaxClusterNodes s)) (TF.Attr s P.Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance s ~ s' => P.HasComputedPort (TF.Ref s' (DaxClusterNodes s)) (TF.Attr s P.Integer) where
    computedPort x = TF.compute (TF.refKey x) "port"

-- | @security_group_egress@ nested settings.
data SecurityGroupEgress s = SecurityGroupEgress'
    { _cidrBlocks     :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @cidr_blocks@ - (Optional)
    --
    , _description    :: TF.Attr s P.Text
    -- ^ @description@ - (Optional)
    --
    , _fromPort       :: TF.Attr s P.Integer
    -- ^ @from_port@ - (Required)
    --
    , _ipv6CidrBlocks :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @ipv6_cidr_blocks@ - (Optional)
    --
    , _prefixListIds  :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @prefix_list_ids@ - (Optional)
    --
    , _protocol       :: TF.Attr s P.Text
    -- ^ @protocol@ - (Required)
    --
    , _securityGroups :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @security_groups@ - (Optional)
    --
    , _self           :: TF.Attr s P.Bool
    -- ^ @self@ - (Optional)
    --
    , _toPort         :: TF.Attr s P.Integer
    -- ^ @to_port@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSecurityGroupEgress
    :: TF.Attr s P.Integer -- ^ @from_port@ - 'P.fromPort'
    -> TF.Attr s P.Text -- ^ @protocol@ - 'P.protocol'
    -> TF.Attr s P.Integer -- ^ @to_port@ - 'P.toPort'
    -> SecurityGroupEgress s
newSecurityGroupEgress _fromPort _protocol _toPort =
    SecurityGroupEgress'
        { _cidrBlocks = TF.Nil
        , _description = TF.Nil
        , _fromPort = _fromPort
        , _ipv6CidrBlocks = TF.Nil
        , _prefixListIds = TF.Nil
        , _protocol = _protocol
        , _securityGroups = TF.Nil
        , _self = TF.value P.False
        , _toPort = _toPort
        }

instance P.Hashable  (SecurityGroupEgress s)
instance TF.IsValue  (SecurityGroupEgress s)
instance TF.IsObject (SecurityGroupEgress s) where
    toObject SecurityGroupEgress'{..} = P.catMaybes
        [ TF.assign "cidr_blocks" <$> TF.attribute _cidrBlocks
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "from_port" <$> TF.attribute _fromPort
        , TF.assign "ipv6_cidr_blocks" <$> TF.attribute _ipv6CidrBlocks
        , TF.assign "prefix_list_ids" <$> TF.attribute _prefixListIds
        , TF.assign "protocol" <$> TF.attribute _protocol
        , TF.assign "security_groups" <$> TF.attribute _securityGroups
        , TF.assign "self" <$> TF.attribute _self
        , TF.assign "to_port" <$> TF.attribute _toPort
        ]

instance TF.IsValid (SecurityGroupEgress s) where
    validator = P.mempty

instance P.HasCidrBlocks (SecurityGroupEgress s) (TF.Attr s [TF.Attr s P.Text]) where
    cidrBlocks =
        P.lens (_cidrBlocks :: SecurityGroupEgress s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _cidrBlocks = a } :: SecurityGroupEgress s)

instance P.HasDescription (SecurityGroupEgress s) (TF.Attr s P.Text) where
    description =
        P.lens (_description :: SecurityGroupEgress s -> TF.Attr s P.Text)
               (\s a -> s { _description = a } :: SecurityGroupEgress s)

instance P.HasFromPort (SecurityGroupEgress s) (TF.Attr s P.Integer) where
    fromPort =
        P.lens (_fromPort :: SecurityGroupEgress s -> TF.Attr s P.Integer)
               (\s a -> s { _fromPort = a } :: SecurityGroupEgress s)

instance P.HasIpv6CidrBlocks (SecurityGroupEgress s) (TF.Attr s [TF.Attr s P.Text]) where
    ipv6CidrBlocks =
        P.lens (_ipv6CidrBlocks :: SecurityGroupEgress s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _ipv6CidrBlocks = a } :: SecurityGroupEgress s)

instance P.HasPrefixListIds (SecurityGroupEgress s) (TF.Attr s [TF.Attr s P.Text]) where
    prefixListIds =
        P.lens (_prefixListIds :: SecurityGroupEgress s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _prefixListIds = a } :: SecurityGroupEgress s)

instance P.HasProtocol (SecurityGroupEgress s) (TF.Attr s P.Text) where
    protocol =
        P.lens (_protocol :: SecurityGroupEgress s -> TF.Attr s P.Text)
               (\s a -> s { _protocol = a } :: SecurityGroupEgress s)

instance P.HasSecurityGroups (SecurityGroupEgress s) (TF.Attr s [TF.Attr s P.Text]) where
    securityGroups =
        P.lens (_securityGroups :: SecurityGroupEgress s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _securityGroups = a } :: SecurityGroupEgress s)

instance P.HasSelf (SecurityGroupEgress s) (TF.Attr s P.Bool) where
    self =
        P.lens (_self :: SecurityGroupEgress s -> TF.Attr s P.Bool)
               (\s a -> s { _self = a } :: SecurityGroupEgress s)

instance P.HasToPort (SecurityGroupEgress s) (TF.Attr s P.Integer) where
    toPort =
        P.lens (_toPort :: SecurityGroupEgress s -> TF.Attr s P.Integer)
               (\s a -> s { _toPort = a } :: SecurityGroupEgress s)

-- | @launch_template_elastic_gpu_specifications@ nested settings.
data LaunchTemplateElasticGpuSpecifications s = LaunchTemplateElasticGpuSpecifications'
    { _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLaunchTemplateElasticGpuSpecifications
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> LaunchTemplateElasticGpuSpecifications s
newLaunchTemplateElasticGpuSpecifications _type' =
    LaunchTemplateElasticGpuSpecifications'
        { _type' = _type'
        }

instance P.Hashable  (LaunchTemplateElasticGpuSpecifications s)
instance TF.IsValue  (LaunchTemplateElasticGpuSpecifications s)
instance TF.IsObject (LaunchTemplateElasticGpuSpecifications s) where
    toObject LaunchTemplateElasticGpuSpecifications'{..} = P.catMaybes
        [ TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (LaunchTemplateElasticGpuSpecifications s) where
    validator = P.mempty

instance P.HasType' (LaunchTemplateElasticGpuSpecifications s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: LaunchTemplateElasticGpuSpecifications s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: LaunchTemplateElasticGpuSpecifications s)

-- | @budgets_budget_cost_types@ nested settings.
data BudgetsBudgetCostTypes s = BudgetsBudgetCostTypes'
    { _includeCredit            :: TF.Attr s P.Bool
    -- ^ @include_credit@ - (Optional)
    --
    , _includeDiscount          :: TF.Attr s P.Bool
    -- ^ @include_discount@ - (Optional)
    --
    , _includeOtherSubscription :: TF.Attr s P.Bool
    -- ^ @include_other_subscription@ - (Optional)
    --
    , _includeRecurring         :: TF.Attr s P.Bool
    -- ^ @include_recurring@ - (Optional)
    --
    , _includeRefund            :: TF.Attr s P.Bool
    -- ^ @include_refund@ - (Optional)
    --
    , _includeSubscription      :: TF.Attr s P.Bool
    -- ^ @include_subscription@ - (Optional)
    --
    , _includeSupport           :: TF.Attr s P.Bool
    -- ^ @include_support@ - (Optional)
    --
    , _includeTax               :: TF.Attr s P.Bool
    -- ^ @include_tax@ - (Optional)
    --
    , _includeUpfront           :: TF.Attr s P.Bool
    -- ^ @include_upfront@ - (Optional)
    --
    , _useAmortized             :: TF.Attr s P.Bool
    -- ^ @use_amortized@ - (Optional)
    --
    , _useBlended               :: TF.Attr s P.Bool
    -- ^ @use_blended@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newBudgetsBudgetCostTypes
    :: BudgetsBudgetCostTypes s
newBudgetsBudgetCostTypes =
    BudgetsBudgetCostTypes'
        { _includeCredit = TF.value P.True
        , _includeDiscount = TF.value P.True
        , _includeOtherSubscription = TF.value P.True
        , _includeRecurring = TF.value P.True
        , _includeRefund = TF.value P.True
        , _includeSubscription = TF.value P.True
        , _includeSupport = TF.value P.True
        , _includeTax = TF.value P.True
        , _includeUpfront = TF.value P.True
        , _useAmortized = TF.value P.False
        , _useBlended = TF.value P.False
        }

instance P.Hashable  (BudgetsBudgetCostTypes s)
instance TF.IsValue  (BudgetsBudgetCostTypes s)
instance TF.IsObject (BudgetsBudgetCostTypes s) where
    toObject BudgetsBudgetCostTypes'{..} = P.catMaybes
        [ TF.assign "include_credit" <$> TF.attribute _includeCredit
        , TF.assign "include_discount" <$> TF.attribute _includeDiscount
        , TF.assign "include_other_subscription" <$> TF.attribute _includeOtherSubscription
        , TF.assign "include_recurring" <$> TF.attribute _includeRecurring
        , TF.assign "include_refund" <$> TF.attribute _includeRefund
        , TF.assign "include_subscription" <$> TF.attribute _includeSubscription
        , TF.assign "include_support" <$> TF.attribute _includeSupport
        , TF.assign "include_tax" <$> TF.attribute _includeTax
        , TF.assign "include_upfront" <$> TF.attribute _includeUpfront
        , TF.assign "use_amortized" <$> TF.attribute _useAmortized
        , TF.assign "use_blended" <$> TF.attribute _useBlended
        ]

instance TF.IsValid (BudgetsBudgetCostTypes s) where
    validator = P.mempty

instance P.HasIncludeCredit (BudgetsBudgetCostTypes s) (TF.Attr s P.Bool) where
    includeCredit =
        P.lens (_includeCredit :: BudgetsBudgetCostTypes s -> TF.Attr s P.Bool)
               (\s a -> s { _includeCredit = a } :: BudgetsBudgetCostTypes s)

instance P.HasIncludeDiscount (BudgetsBudgetCostTypes s) (TF.Attr s P.Bool) where
    includeDiscount =
        P.lens (_includeDiscount :: BudgetsBudgetCostTypes s -> TF.Attr s P.Bool)
               (\s a -> s { _includeDiscount = a } :: BudgetsBudgetCostTypes s)

instance P.HasIncludeOtherSubscription (BudgetsBudgetCostTypes s) (TF.Attr s P.Bool) where
    includeOtherSubscription =
        P.lens (_includeOtherSubscription :: BudgetsBudgetCostTypes s -> TF.Attr s P.Bool)
               (\s a -> s { _includeOtherSubscription = a } :: BudgetsBudgetCostTypes s)

instance P.HasIncludeRecurring (BudgetsBudgetCostTypes s) (TF.Attr s P.Bool) where
    includeRecurring =
        P.lens (_includeRecurring :: BudgetsBudgetCostTypes s -> TF.Attr s P.Bool)
               (\s a -> s { _includeRecurring = a } :: BudgetsBudgetCostTypes s)

instance P.HasIncludeRefund (BudgetsBudgetCostTypes s) (TF.Attr s P.Bool) where
    includeRefund =
        P.lens (_includeRefund :: BudgetsBudgetCostTypes s -> TF.Attr s P.Bool)
               (\s a -> s { _includeRefund = a } :: BudgetsBudgetCostTypes s)

instance P.HasIncludeSubscription (BudgetsBudgetCostTypes s) (TF.Attr s P.Bool) where
    includeSubscription =
        P.lens (_includeSubscription :: BudgetsBudgetCostTypes s -> TF.Attr s P.Bool)
               (\s a -> s { _includeSubscription = a } :: BudgetsBudgetCostTypes s)

instance P.HasIncludeSupport (BudgetsBudgetCostTypes s) (TF.Attr s P.Bool) where
    includeSupport =
        P.lens (_includeSupport :: BudgetsBudgetCostTypes s -> TF.Attr s P.Bool)
               (\s a -> s { _includeSupport = a } :: BudgetsBudgetCostTypes s)

instance P.HasIncludeTax (BudgetsBudgetCostTypes s) (TF.Attr s P.Bool) where
    includeTax =
        P.lens (_includeTax :: BudgetsBudgetCostTypes s -> TF.Attr s P.Bool)
               (\s a -> s { _includeTax = a } :: BudgetsBudgetCostTypes s)

instance P.HasIncludeUpfront (BudgetsBudgetCostTypes s) (TF.Attr s P.Bool) where
    includeUpfront =
        P.lens (_includeUpfront :: BudgetsBudgetCostTypes s -> TF.Attr s P.Bool)
               (\s a -> s { _includeUpfront = a } :: BudgetsBudgetCostTypes s)

instance P.HasUseAmortized (BudgetsBudgetCostTypes s) (TF.Attr s P.Bool) where
    useAmortized =
        P.lens (_useAmortized :: BudgetsBudgetCostTypes s -> TF.Attr s P.Bool)
               (\s a -> s { _useAmortized = a } :: BudgetsBudgetCostTypes s)

instance P.HasUseBlended (BudgetsBudgetCostTypes s) (TF.Attr s P.Bool) where
    useBlended =
        P.lens (_useBlended :: BudgetsBudgetCostTypes s -> TF.Attr s P.Bool)
               (\s a -> s { _useBlended = a } :: BudgetsBudgetCostTypes s)

-- | @elastictranscoder_preset_video@ nested settings.
data ElastictranscoderPresetVideo s = ElastictranscoderPresetVideo'
    { _aspectRatio        :: TF.Attr s P.Text
    -- ^ @aspect_ratio@ - (Optional, Forces New)
    --
    , _bitRate            :: TF.Attr s P.Text
    -- ^ @bit_rate@ - (Optional, Forces New)
    --
    , _codec              :: TF.Attr s P.Text
    -- ^ @codec@ - (Optional, Forces New)
    --
    , _displayAspectRatio :: TF.Attr s P.Text
    -- ^ @display_aspect_ratio@ - (Optional, Forces New)
    --
    , _fixedGop           :: TF.Attr s P.Text
    -- ^ @fixed_gop@ - (Optional, Forces New)
    --
    , _frameRate          :: TF.Attr s P.Text
    -- ^ @frame_rate@ - (Optional, Forces New)
    --
    , _keyframesMaxDist   :: TF.Attr s P.Text
    -- ^ @keyframes_max_dist@ - (Optional, Forces New)
    --
    , _maxFrameRate       :: TF.Attr s P.Text
    -- ^ @max_frame_rate@ - (Optional, Forces New)
    --
    , _maxHeight          :: TF.Attr s P.Text
    -- ^ @max_height@ - (Optional, Forces New)
    --
    , _maxWidth           :: TF.Attr s P.Text
    -- ^ @max_width@ - (Optional, Forces New)
    --
    , _paddingPolicy      :: TF.Attr s P.Text
    -- ^ @padding_policy@ - (Optional, Forces New)
    --
    , _resolution         :: TF.Attr s P.Text
    -- ^ @resolution@ - (Optional, Forces New)
    --
    , _sizingPolicy       :: TF.Attr s P.Text
    -- ^ @sizing_policy@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElastictranscoderPresetVideo
    :: ElastictranscoderPresetVideo s
newElastictranscoderPresetVideo =
    ElastictranscoderPresetVideo'
        { _aspectRatio = TF.Nil
        , _bitRate = TF.Nil
        , _codec = TF.Nil
        , _displayAspectRatio = TF.Nil
        , _fixedGop = TF.Nil
        , _frameRate = TF.Nil
        , _keyframesMaxDist = TF.Nil
        , _maxFrameRate = TF.value "30"
        , _maxHeight = TF.Nil
        , _maxWidth = TF.Nil
        , _paddingPolicy = TF.Nil
        , _resolution = TF.Nil
        , _sizingPolicy = TF.value "Fit"
        }

instance P.Hashable  (ElastictranscoderPresetVideo s)
instance TF.IsValue  (ElastictranscoderPresetVideo s)
instance TF.IsObject (ElastictranscoderPresetVideo s) where
    toObject ElastictranscoderPresetVideo'{..} = P.catMaybes
        [ TF.assign "aspect_ratio" <$> TF.attribute _aspectRatio
        , TF.assign "bit_rate" <$> TF.attribute _bitRate
        , TF.assign "codec" <$> TF.attribute _codec
        , TF.assign "display_aspect_ratio" <$> TF.attribute _displayAspectRatio
        , TF.assign "fixed_gop" <$> TF.attribute _fixedGop
        , TF.assign "frame_rate" <$> TF.attribute _frameRate
        , TF.assign "keyframes_max_dist" <$> TF.attribute _keyframesMaxDist
        , TF.assign "max_frame_rate" <$> TF.attribute _maxFrameRate
        , TF.assign "max_height" <$> TF.attribute _maxHeight
        , TF.assign "max_width" <$> TF.attribute _maxWidth
        , TF.assign "padding_policy" <$> TF.attribute _paddingPolicy
        , TF.assign "resolution" <$> TF.attribute _resolution
        , TF.assign "sizing_policy" <$> TF.attribute _sizingPolicy
        ]

instance TF.IsValid (ElastictranscoderPresetVideo s) where
    validator = P.mempty

instance P.HasAspectRatio (ElastictranscoderPresetVideo s) (TF.Attr s P.Text) where
    aspectRatio =
        P.lens (_aspectRatio :: ElastictranscoderPresetVideo s -> TF.Attr s P.Text)
               (\s a -> s { _aspectRatio = a } :: ElastictranscoderPresetVideo s)

instance P.HasBitRate (ElastictranscoderPresetVideo s) (TF.Attr s P.Text) where
    bitRate =
        P.lens (_bitRate :: ElastictranscoderPresetVideo s -> TF.Attr s P.Text)
               (\s a -> s { _bitRate = a } :: ElastictranscoderPresetVideo s)

instance P.HasCodec (ElastictranscoderPresetVideo s) (TF.Attr s P.Text) where
    codec =
        P.lens (_codec :: ElastictranscoderPresetVideo s -> TF.Attr s P.Text)
               (\s a -> s { _codec = a } :: ElastictranscoderPresetVideo s)

instance P.HasDisplayAspectRatio (ElastictranscoderPresetVideo s) (TF.Attr s P.Text) where
    displayAspectRatio =
        P.lens (_displayAspectRatio :: ElastictranscoderPresetVideo s -> TF.Attr s P.Text)
               (\s a -> s { _displayAspectRatio = a } :: ElastictranscoderPresetVideo s)

instance P.HasFixedGop (ElastictranscoderPresetVideo s) (TF.Attr s P.Text) where
    fixedGop =
        P.lens (_fixedGop :: ElastictranscoderPresetVideo s -> TF.Attr s P.Text)
               (\s a -> s { _fixedGop = a } :: ElastictranscoderPresetVideo s)

instance P.HasFrameRate (ElastictranscoderPresetVideo s) (TF.Attr s P.Text) where
    frameRate =
        P.lens (_frameRate :: ElastictranscoderPresetVideo s -> TF.Attr s P.Text)
               (\s a -> s { _frameRate = a } :: ElastictranscoderPresetVideo s)

instance P.HasKeyframesMaxDist (ElastictranscoderPresetVideo s) (TF.Attr s P.Text) where
    keyframesMaxDist =
        P.lens (_keyframesMaxDist :: ElastictranscoderPresetVideo s -> TF.Attr s P.Text)
               (\s a -> s { _keyframesMaxDist = a } :: ElastictranscoderPresetVideo s)

instance P.HasMaxFrameRate (ElastictranscoderPresetVideo s) (TF.Attr s P.Text) where
    maxFrameRate =
        P.lens (_maxFrameRate :: ElastictranscoderPresetVideo s -> TF.Attr s P.Text)
               (\s a -> s { _maxFrameRate = a } :: ElastictranscoderPresetVideo s)

instance P.HasMaxHeight (ElastictranscoderPresetVideo s) (TF.Attr s P.Text) where
    maxHeight =
        P.lens (_maxHeight :: ElastictranscoderPresetVideo s -> TF.Attr s P.Text)
               (\s a -> s { _maxHeight = a } :: ElastictranscoderPresetVideo s)

instance P.HasMaxWidth (ElastictranscoderPresetVideo s) (TF.Attr s P.Text) where
    maxWidth =
        P.lens (_maxWidth :: ElastictranscoderPresetVideo s -> TF.Attr s P.Text)
               (\s a -> s { _maxWidth = a } :: ElastictranscoderPresetVideo s)

instance P.HasPaddingPolicy (ElastictranscoderPresetVideo s) (TF.Attr s P.Text) where
    paddingPolicy =
        P.lens (_paddingPolicy :: ElastictranscoderPresetVideo s -> TF.Attr s P.Text)
               (\s a -> s { _paddingPolicy = a } :: ElastictranscoderPresetVideo s)

instance P.HasResolution (ElastictranscoderPresetVideo s) (TF.Attr s P.Text) where
    resolution =
        P.lens (_resolution :: ElastictranscoderPresetVideo s -> TF.Attr s P.Text)
               (\s a -> s { _resolution = a } :: ElastictranscoderPresetVideo s)

instance P.HasSizingPolicy (ElastictranscoderPresetVideo s) (TF.Attr s P.Text) where
    sizingPolicy =
        P.lens (_sizingPolicy :: ElastictranscoderPresetVideo s -> TF.Attr s P.Text)
               (\s a -> s { _sizingPolicy = a } :: ElastictranscoderPresetVideo s)

-- | @rule_override_action@ nested settings.
data RuleOverrideAction s = RuleOverrideAction'
    { _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRuleOverrideAction
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> RuleOverrideAction s
newRuleOverrideAction _type' =
    RuleOverrideAction'
        { _type' = _type'
        }

instance P.Hashable  (RuleOverrideAction s)
instance TF.IsValue  (RuleOverrideAction s)
instance TF.IsObject (RuleOverrideAction s) where
    toObject RuleOverrideAction'{..} = P.catMaybes
        [ TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (RuleOverrideAction s) where
    validator = P.mempty

instance P.HasType' (RuleOverrideAction s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: RuleOverrideAction s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: RuleOverrideAction s)

-- | @network_acl_ingress@ nested settings.
data NetworkAclIngress s = NetworkAclIngress'
    { _action        :: TF.Attr s P.Text
    -- ^ @action@ - (Required)
    --
    , _cidrBlock     :: TF.Attr s P.Text
    -- ^ @cidr_block@ - (Optional)
    --
    , _fromPort      :: TF.Attr s P.Integer
    -- ^ @from_port@ - (Required)
    --
    , _icmpCode      :: TF.Attr s P.Integer
    -- ^ @icmp_code@ - (Optional)
    --
    , _icmpType      :: TF.Attr s P.Integer
    -- ^ @icmp_type@ - (Optional)
    --
    , _ipv6CidrBlock :: TF.Attr s P.Text
    -- ^ @ipv6_cidr_block@ - (Optional)
    --
    , _protocol      :: TF.Attr s P.Text
    -- ^ @protocol@ - (Required)
    --
    , _ruleNo        :: TF.Attr s P.Integer
    -- ^ @rule_no@ - (Required)
    --
    , _toPort        :: TF.Attr s P.Integer
    -- ^ @to_port@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newNetworkAclIngress
    :: TF.Attr s P.Text -- ^ @action@ - 'P.action'
    -> TF.Attr s P.Integer -- ^ @from_port@ - 'P.fromPort'
    -> TF.Attr s P.Text -- ^ @protocol@ - 'P.protocol'
    -> TF.Attr s P.Integer -- ^ @rule_no@ - 'P.ruleNo'
    -> TF.Attr s P.Integer -- ^ @to_port@ - 'P.toPort'
    -> NetworkAclIngress s
newNetworkAclIngress _action _fromPort _protocol _ruleNo _toPort =
    NetworkAclIngress'
        { _action = _action
        , _cidrBlock = TF.Nil
        , _fromPort = _fromPort
        , _icmpCode = TF.Nil
        , _icmpType = TF.Nil
        , _ipv6CidrBlock = TF.Nil
        , _protocol = _protocol
        , _ruleNo = _ruleNo
        , _toPort = _toPort
        }

instance P.Hashable  (NetworkAclIngress s)
instance TF.IsValue  (NetworkAclIngress s)
instance TF.IsObject (NetworkAclIngress s) where
    toObject NetworkAclIngress'{..} = P.catMaybes
        [ TF.assign "action" <$> TF.attribute _action
        , TF.assign "cidr_block" <$> TF.attribute _cidrBlock
        , TF.assign "from_port" <$> TF.attribute _fromPort
        , TF.assign "icmp_code" <$> TF.attribute _icmpCode
        , TF.assign "icmp_type" <$> TF.attribute _icmpType
        , TF.assign "ipv6_cidr_block" <$> TF.attribute _ipv6CidrBlock
        , TF.assign "protocol" <$> TF.attribute _protocol
        , TF.assign "rule_no" <$> TF.attribute _ruleNo
        , TF.assign "to_port" <$> TF.attribute _toPort
        ]

instance TF.IsValid (NetworkAclIngress s) where
    validator = P.mempty

instance P.HasAction (NetworkAclIngress s) (TF.Attr s P.Text) where
    action =
        P.lens (_action :: NetworkAclIngress s -> TF.Attr s P.Text)
               (\s a -> s { _action = a } :: NetworkAclIngress s)

instance P.HasCidrBlock (NetworkAclIngress s) (TF.Attr s P.Text) where
    cidrBlock =
        P.lens (_cidrBlock :: NetworkAclIngress s -> TF.Attr s P.Text)
               (\s a -> s { _cidrBlock = a } :: NetworkAclIngress s)

instance P.HasFromPort (NetworkAclIngress s) (TF.Attr s P.Integer) where
    fromPort =
        P.lens (_fromPort :: NetworkAclIngress s -> TF.Attr s P.Integer)
               (\s a -> s { _fromPort = a } :: NetworkAclIngress s)

instance P.HasIcmpCode (NetworkAclIngress s) (TF.Attr s P.Integer) where
    icmpCode =
        P.lens (_icmpCode :: NetworkAclIngress s -> TF.Attr s P.Integer)
               (\s a -> s { _icmpCode = a } :: NetworkAclIngress s)

instance P.HasIcmpType (NetworkAclIngress s) (TF.Attr s P.Integer) where
    icmpType =
        P.lens (_icmpType :: NetworkAclIngress s -> TF.Attr s P.Integer)
               (\s a -> s { _icmpType = a } :: NetworkAclIngress s)

instance P.HasIpv6CidrBlock (NetworkAclIngress s) (TF.Attr s P.Text) where
    ipv6CidrBlock =
        P.lens (_ipv6CidrBlock :: NetworkAclIngress s -> TF.Attr s P.Text)
               (\s a -> s { _ipv6CidrBlock = a } :: NetworkAclIngress s)

instance P.HasProtocol (NetworkAclIngress s) (TF.Attr s P.Text) where
    protocol =
        P.lens (_protocol :: NetworkAclIngress s -> TF.Attr s P.Text)
               (\s a -> s { _protocol = a } :: NetworkAclIngress s)

instance P.HasRuleNo (NetworkAclIngress s) (TF.Attr s P.Integer) where
    ruleNo =
        P.lens (_ruleNo :: NetworkAclIngress s -> TF.Attr s P.Integer)
               (\s a -> s { _ruleNo = a } :: NetworkAclIngress s)

instance P.HasToPort (NetworkAclIngress s) (TF.Attr s P.Integer) where
    toPort =
        P.lens (_toPort :: NetworkAclIngress s -> TF.Attr s P.Integer)
               (\s a -> s { _toPort = a } :: NetworkAclIngress s)

-- | @input_format_configuration_deserializer@ nested settings.
data InputFormatConfigurationDeserializer s = InputFormatConfigurationDeserializer'
    { _hiveJsonSerDe  :: TF.Attr s (DeserializerHiveJsonSerDe s)
    -- ^ @hive_json_ser_de@ - (Optional)
    --
    -- Conflicts with:
    --
    -- * 'openXJsonSerDe'
    , _openXJsonSerDe :: TF.Attr s (DeserializerOpenXJsonSerDe s)
    -- ^ @open_x_json_ser_de@ - (Optional)
    --
    -- Conflicts with:
    --
    -- * 'hiveJsonSerDe'
    } deriving (P.Show, P.Eq, P.Generic)

newInputFormatConfigurationDeserializer
    :: InputFormatConfigurationDeserializer s
newInputFormatConfigurationDeserializer =
    InputFormatConfigurationDeserializer'
        { _hiveJsonSerDe = TF.Nil
        , _openXJsonSerDe = TF.Nil
        }

instance P.Hashable  (InputFormatConfigurationDeserializer s)
instance TF.IsValue  (InputFormatConfigurationDeserializer s)
instance TF.IsObject (InputFormatConfigurationDeserializer s) where
    toObject InputFormatConfigurationDeserializer'{..} = P.catMaybes
        [ TF.assign "hive_json_ser_de" <$> TF.attribute _hiveJsonSerDe
        , TF.assign "open_x_json_ser_de" <$> TF.attribute _openXJsonSerDe
        ]

instance TF.IsValid (InputFormatConfigurationDeserializer s) where
    validator = TF.fieldsValidator (\InputFormatConfigurationDeserializer'{..} -> Map.fromList $ P.catMaybes
        [ if (_hiveJsonSerDe P.== TF.Nil)
              then P.Nothing
              else P.Just ("_hiveJsonSerDe",
                            [ "_openXJsonSerDe"
                            ])
        , if (_openXJsonSerDe P.== TF.Nil)
              then P.Nothing
              else P.Just ("_openXJsonSerDe",
                            [ "_hiveJsonSerDe"
                            ])
        ])
           P.<> TF.settingsValidator "_hiveJsonSerDe"
                  (_hiveJsonSerDe
                      :: InputFormatConfigurationDeserializer s -> TF.Attr s (DeserializerHiveJsonSerDe s))
                  TF.validator
           P.<> TF.settingsValidator "_openXJsonSerDe"
                  (_openXJsonSerDe
                      :: InputFormatConfigurationDeserializer s -> TF.Attr s (DeserializerOpenXJsonSerDe s))
                  TF.validator

instance P.HasHiveJsonSerDe (InputFormatConfigurationDeserializer s) (TF.Attr s (DeserializerHiveJsonSerDe s)) where
    hiveJsonSerDe =
        P.lens (_hiveJsonSerDe :: InputFormatConfigurationDeserializer s -> TF.Attr s (DeserializerHiveJsonSerDe s))
               (\s a -> s { _hiveJsonSerDe = a } :: InputFormatConfigurationDeserializer s)

instance P.HasOpenXJsonSerDe (InputFormatConfigurationDeserializer s) (TF.Attr s (DeserializerOpenXJsonSerDe s)) where
    openXJsonSerDe =
        P.lens (_openXJsonSerDe :: InputFormatConfigurationDeserializer s -> TF.Attr s (DeserializerOpenXJsonSerDe s))
               (\s a -> s { _openXJsonSerDe = a } :: InputFormatConfigurationDeserializer s)

-- | @ssm_maintenance_window_target_targets@ nested settings.
data SsmMaintenanceWindowTargetTargets s = SsmMaintenanceWindowTargetTargets'
    { _key    :: TF.Attr s P.Text
    -- ^ @key@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSsmMaintenanceWindowTargetTargets
    :: TF.Attr s P.Text -- ^ @key@ - 'P.key'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> SsmMaintenanceWindowTargetTargets s
newSsmMaintenanceWindowTargetTargets _key _values =
    SsmMaintenanceWindowTargetTargets'
        { _key = _key
        , _values = _values
        }

instance P.Hashable  (SsmMaintenanceWindowTargetTargets s)
instance TF.IsValue  (SsmMaintenanceWindowTargetTargets s)
instance TF.IsObject (SsmMaintenanceWindowTargetTargets s) where
    toObject SsmMaintenanceWindowTargetTargets'{..} = P.catMaybes
        [ TF.assign "key" <$> TF.attribute _key
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (SsmMaintenanceWindowTargetTargets s) where
    validator = P.mempty

instance P.HasKey (SsmMaintenanceWindowTargetTargets s) (TF.Attr s P.Text) where
    key =
        P.lens (_key :: SsmMaintenanceWindowTargetTargets s -> TF.Attr s P.Text)
               (\s a -> s { _key = a } :: SsmMaintenanceWindowTargetTargets s)

instance P.HasValues (SsmMaintenanceWindowTargetTargets s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: SsmMaintenanceWindowTargetTargets s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: SsmMaintenanceWindowTargetTargets s)

-- | @autoscaling_group_tag@ nested settings.
data AutoscalingGroupTag s = AutoscalingGroupTag'
    { _key               :: TF.Attr s P.Text
    -- ^ @key@ - (Required)
    --
    , _propagateAtLaunch :: TF.Attr s P.Bool
    -- ^ @propagate_at_launch@ - (Required)
    --
    , _value             :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAutoscalingGroupTag
    :: TF.Attr s P.Text -- ^ @key@ - 'P.key'
    -> TF.Attr s P.Bool -- ^ @propagate_at_launch@ - 'P.propagateAtLaunch'
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> AutoscalingGroupTag s
newAutoscalingGroupTag _key _propagateAtLaunch _value =
    AutoscalingGroupTag'
        { _key = _key
        , _propagateAtLaunch = _propagateAtLaunch
        , _value = _value
        }

instance P.Hashable  (AutoscalingGroupTag s)
instance TF.IsValue  (AutoscalingGroupTag s)
instance TF.IsObject (AutoscalingGroupTag s) where
    toObject AutoscalingGroupTag'{..} = P.catMaybes
        [ TF.assign "key" <$> TF.attribute _key
        , TF.assign "propagate_at_launch" <$> TF.attribute _propagateAtLaunch
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (AutoscalingGroupTag s) where
    validator = P.mempty

instance P.HasKey (AutoscalingGroupTag s) (TF.Attr s P.Text) where
    key =
        P.lens (_key :: AutoscalingGroupTag s -> TF.Attr s P.Text)
               (\s a -> s { _key = a } :: AutoscalingGroupTag s)

instance P.HasPropagateAtLaunch (AutoscalingGroupTag s) (TF.Attr s P.Bool) where
    propagateAtLaunch =
        P.lens (_propagateAtLaunch :: AutoscalingGroupTag s -> TF.Attr s P.Bool)
               (\s a -> s { _propagateAtLaunch = a } :: AutoscalingGroupTag s)

instance P.HasValue (AutoscalingGroupTag s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: AutoscalingGroupTag s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: AutoscalingGroupTag s)

-- | @s3_bucket_inventory_destination@ nested settings.
data S3BucketInventoryDestination s = S3BucketInventoryDestination'
    { _bucket :: TF.Attr s (DestinationBucket s)
    -- ^ @bucket@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newS3BucketInventoryDestination
    :: TF.Attr s (DestinationBucket s) -- ^ @bucket@ - 'P.bucket'
    -> S3BucketInventoryDestination s
newS3BucketInventoryDestination _bucket =
    S3BucketInventoryDestination'
        { _bucket = _bucket
        }

instance P.Hashable  (S3BucketInventoryDestination s)
instance TF.IsValue  (S3BucketInventoryDestination s)
instance TF.IsObject (S3BucketInventoryDestination s) where
    toObject S3BucketInventoryDestination'{..} = P.catMaybes
        [ TF.assign "bucket" <$> TF.attribute _bucket
        ]

instance TF.IsValid (S3BucketInventoryDestination s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_bucket"
                  (_bucket
                      :: S3BucketInventoryDestination s -> TF.Attr s (DestinationBucket s))
                  TF.validator

instance P.HasBucket (S3BucketInventoryDestination s) (TF.Attr s (DestinationBucket s)) where
    bucket =
        P.lens (_bucket :: S3BucketInventoryDestination s -> TF.Attr s (DestinationBucket s))
               (\s a -> s { _bucket = a } :: S3BucketInventoryDestination s)

-- | @route_table_filter@ nested settings.
data RouteTableFilter s = RouteTableFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRouteTableFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> RouteTableFilter s
newRouteTableFilter _name _values =
    RouteTableFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (RouteTableFilter s)
instance TF.IsValue  (RouteTableFilter s)
instance TF.IsObject (RouteTableFilter s) where
    toObject RouteTableFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (RouteTableFilter s) where
    validator = P.mempty

instance P.HasName (RouteTableFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: RouteTableFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: RouteTableFilter s)

instance P.HasValues (RouteTableFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: RouteTableFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: RouteTableFilter s)

-- | @data_format_conversion_configuration_output_format_configuration@ nested settings.
data DataFormatConversionConfigurationOutputFormatConfiguration s = DataFormatConversionConfigurationOutputFormatConfiguration'
    { _serializer :: TF.Attr s (OutputFormatConfigurationSerializer s)
    -- ^ @serializer@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDataFormatConversionConfigurationOutputFormatConfiguration
    :: TF.Attr s (OutputFormatConfigurationSerializer s) -- ^ @serializer@ - 'P.serializer'
    -> DataFormatConversionConfigurationOutputFormatConfiguration s
newDataFormatConversionConfigurationOutputFormatConfiguration _serializer =
    DataFormatConversionConfigurationOutputFormatConfiguration'
        { _serializer = _serializer
        }

instance P.Hashable  (DataFormatConversionConfigurationOutputFormatConfiguration s)
instance TF.IsValue  (DataFormatConversionConfigurationOutputFormatConfiguration s)
instance TF.IsObject (DataFormatConversionConfigurationOutputFormatConfiguration s) where
    toObject DataFormatConversionConfigurationOutputFormatConfiguration'{..} = P.catMaybes
        [ TF.assign "serializer" <$> TF.attribute _serializer
        ]

instance TF.IsValid (DataFormatConversionConfigurationOutputFormatConfiguration s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_serializer"
                  (_serializer
                      :: DataFormatConversionConfigurationOutputFormatConfiguration s -> TF.Attr s (OutputFormatConfigurationSerializer s))
                  TF.validator

instance P.HasSerializer (DataFormatConversionConfigurationOutputFormatConfiguration s) (TF.Attr s (OutputFormatConfigurationSerializer s)) where
    serializer =
        P.lens (_serializer :: DataFormatConversionConfigurationOutputFormatConfiguration s -> TF.Attr s (OutputFormatConfigurationSerializer s))
               (\s a -> s { _serializer = a } :: DataFormatConversionConfigurationOutputFormatConfiguration s)

-- | @ami_ebs_block_device@ nested settings.
data AmiEbsBlockDevice s = AmiEbsBlockDevice'
    { _deleteOnTermination :: TF.Attr s P.Bool
    -- ^ @delete_on_termination@ - (Optional, Forces New)
    --
    , _deviceName          :: TF.Attr s P.Text
    -- ^ @device_name@ - (Required, Forces New)
    --
    , _encrypted           :: TF.Attr s P.Bool
    -- ^ @encrypted@ - (Optional, Forces New)
    --
    , _iops                :: TF.Attr s P.Integer
    -- ^ @iops@ - (Optional, Forces New)
    --
    , _snapshotId          :: TF.Attr s P.Text
    -- ^ @snapshot_id@ - (Optional, Forces New)
    --
    , _volumeType          :: TF.Attr s P.Text
    -- ^ @volume_type@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAmiEbsBlockDevice
    :: TF.Attr s P.Text -- ^ @device_name@ - 'P.deviceName'
    -> AmiEbsBlockDevice s
newAmiEbsBlockDevice _deviceName =
    AmiEbsBlockDevice'
        { _deleteOnTermination = TF.value P.True
        , _deviceName = _deviceName
        , _encrypted = TF.Nil
        , _iops = TF.Nil
        , _snapshotId = TF.Nil
        , _volumeType = TF.value "standard"
        }

instance P.Hashable  (AmiEbsBlockDevice s)
instance TF.IsValue  (AmiEbsBlockDevice s)
instance TF.IsObject (AmiEbsBlockDevice s) where
    toObject AmiEbsBlockDevice'{..} = P.catMaybes
        [ TF.assign "delete_on_termination" <$> TF.attribute _deleteOnTermination
        , TF.assign "device_name" <$> TF.attribute _deviceName
        , TF.assign "encrypted" <$> TF.attribute _encrypted
        , TF.assign "iops" <$> TF.attribute _iops
        , TF.assign "snapshot_id" <$> TF.attribute _snapshotId
        , TF.assign "volume_type" <$> TF.attribute _volumeType
        ]

instance TF.IsValid (AmiEbsBlockDevice s) where
    validator = P.mempty

instance P.HasDeleteOnTermination (AmiEbsBlockDevice s) (TF.Attr s P.Bool) where
    deleteOnTermination =
        P.lens (_deleteOnTermination :: AmiEbsBlockDevice s -> TF.Attr s P.Bool)
               (\s a -> s { _deleteOnTermination = a } :: AmiEbsBlockDevice s)

instance P.HasDeviceName (AmiEbsBlockDevice s) (TF.Attr s P.Text) where
    deviceName =
        P.lens (_deviceName :: AmiEbsBlockDevice s -> TF.Attr s P.Text)
               (\s a -> s { _deviceName = a } :: AmiEbsBlockDevice s)

instance P.HasEncrypted (AmiEbsBlockDevice s) (TF.Attr s P.Bool) where
    encrypted =
        P.lens (_encrypted :: AmiEbsBlockDevice s -> TF.Attr s P.Bool)
               (\s a -> s { _encrypted = a } :: AmiEbsBlockDevice s)

instance P.HasIops (AmiEbsBlockDevice s) (TF.Attr s P.Integer) where
    iops =
        P.lens (_iops :: AmiEbsBlockDevice s -> TF.Attr s P.Integer)
               (\s a -> s { _iops = a } :: AmiEbsBlockDevice s)

instance P.HasSnapshotId (AmiEbsBlockDevice s) (TF.Attr s P.Text) where
    snapshotId =
        P.lens (_snapshotId :: AmiEbsBlockDevice s -> TF.Attr s P.Text)
               (\s a -> s { _snapshotId = a } :: AmiEbsBlockDevice s)

instance P.HasVolumeType (AmiEbsBlockDevice s) (TF.Attr s P.Text) where
    volumeType =
        P.lens (_volumeType :: AmiEbsBlockDevice s -> TF.Attr s P.Text)
               (\s a -> s { _volumeType = a } :: AmiEbsBlockDevice s)

instance s ~ s' => P.HasComputedVolumeSize (TF.Ref s' (AmiEbsBlockDevice s)) (TF.Attr s P.Integer) where
    computedVolumeSize x = TF.compute (TF.refKey x) "volume_size"

-- | @schema_number_attribute_constraints@ nested settings.
data SchemaNumberAttributeConstraints s = SchemaNumberAttributeConstraints'
    { _maxValue :: TF.Attr s P.Text
    -- ^ @max_value@ - (Optional, Forces New)
    --
    , _minValue :: TF.Attr s P.Text
    -- ^ @min_value@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSchemaNumberAttributeConstraints
    :: SchemaNumberAttributeConstraints s
newSchemaNumberAttributeConstraints =
    SchemaNumberAttributeConstraints'
        { _maxValue = TF.Nil
        , _minValue = TF.Nil
        }

instance P.Hashable  (SchemaNumberAttributeConstraints s)
instance TF.IsValue  (SchemaNumberAttributeConstraints s)
instance TF.IsObject (SchemaNumberAttributeConstraints s) where
    toObject SchemaNumberAttributeConstraints'{..} = P.catMaybes
        [ TF.assign "max_value" <$> TF.attribute _maxValue
        , TF.assign "min_value" <$> TF.attribute _minValue
        ]

instance TF.IsValid (SchemaNumberAttributeConstraints s) where
    validator = P.mempty

instance P.HasMaxValue (SchemaNumberAttributeConstraints s) (TF.Attr s P.Text) where
    maxValue =
        P.lens (_maxValue :: SchemaNumberAttributeConstraints s -> TF.Attr s P.Text)
               (\s a -> s { _maxValue = a } :: SchemaNumberAttributeConstraints s)

instance P.HasMinValue (SchemaNumberAttributeConstraints s) (TF.Attr s P.Text) where
    minValue =
        P.lens (_minValue :: SchemaNumberAttributeConstraints s -> TF.Attr s P.Text)
               (\s a -> s { _minValue = a } :: SchemaNumberAttributeConstraints s)

-- | @db_security_group_ingress@ nested settings.
data DbSecurityGroupIngress s = DbSecurityGroupIngress'
    { _cidr :: TF.Attr s P.Text
    -- ^ @cidr@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDbSecurityGroupIngress
    :: DbSecurityGroupIngress s
newDbSecurityGroupIngress =
    DbSecurityGroupIngress'
        { _cidr = TF.Nil
        }

instance P.Hashable  (DbSecurityGroupIngress s)
instance TF.IsValue  (DbSecurityGroupIngress s)
instance TF.IsObject (DbSecurityGroupIngress s) where
    toObject DbSecurityGroupIngress'{..} = P.catMaybes
        [ TF.assign "cidr" <$> TF.attribute _cidr
        ]

instance TF.IsValid (DbSecurityGroupIngress s) where
    validator = P.mempty

instance P.HasCidr (DbSecurityGroupIngress s) (TF.Attr s P.Text) where
    cidr =
        P.lens (_cidr :: DbSecurityGroupIngress s -> TF.Attr s P.Text)
               (\s a -> s { _cidr = a } :: DbSecurityGroupIngress s)

instance s ~ s' => P.HasComputedSecurityGroupId (TF.Ref s' (DbSecurityGroupIngress s)) (TF.Attr s P.Text) where
    computedSecurityGroupId x = TF.compute (TF.refKey x) "security_group_id"

instance s ~ s' => P.HasComputedSecurityGroupName (TF.Ref s' (DbSecurityGroupIngress s)) (TF.Attr s P.Text) where
    computedSecurityGroupName x = TF.compute (TF.refKey x) "security_group_name"

instance s ~ s' => P.HasComputedSecurityGroupOwnerId (TF.Ref s' (DbSecurityGroupIngress s)) (TF.Attr s P.Text) where
    computedSecurityGroupOwnerId x = TF.compute (TF.refKey x) "security_group_owner_id"

-- | @mq_broker_configuration@ nested settings.
data MqBrokerConfiguration s = MqBrokerConfiguration'
    deriving (P.Show, P.Eq, P.Generic)

newMqBrokerConfiguration
    :: MqBrokerConfiguration s
newMqBrokerConfiguration =
    MqBrokerConfiguration'

instance P.Hashable  (MqBrokerConfiguration s)
instance TF.IsValue  (MqBrokerConfiguration s)
instance TF.IsObject (MqBrokerConfiguration s) where
    toObject MqBrokerConfiguration' = []

instance TF.IsValid (MqBrokerConfiguration s) where
    validator = P.mempty

instance s ~ s' => P.HasComputedId (TF.Ref s' (MqBrokerConfiguration s)) (TF.Attr s P.Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance s ~ s' => P.HasComputedRevision (TF.Ref s' (MqBrokerConfiguration s)) (TF.Attr s P.Integer) where
    computedRevision x = TF.compute (TF.refKey x) "revision"

-- | @blue_green_deployment_config_terminate_blue_instances_on_deployment_success@ nested settings.
data BlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess s = BlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess'
    { _action                       :: TF.Attr s P.Text
    -- ^ @action@ - (Optional)
    --
    , _terminationWaitTimeInMinutes :: TF.Attr s P.Integer
    -- ^ @termination_wait_time_in_minutes@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess
    :: BlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess s
newBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess =
    BlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess'
        { _action = TF.Nil
        , _terminationWaitTimeInMinutes = TF.Nil
        }

instance P.Hashable  (BlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess s)
instance TF.IsValue  (BlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess s)
instance TF.IsObject (BlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess s) where
    toObject BlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess'{..} = P.catMaybes
        [ TF.assign "action" <$> TF.attribute _action
        , TF.assign "termination_wait_time_in_minutes" <$> TF.attribute _terminationWaitTimeInMinutes
        ]

instance TF.IsValid (BlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess s) where
    validator = P.mempty

instance P.HasAction (BlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess s) (TF.Attr s P.Text) where
    action =
        P.lens (_action :: BlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess s -> TF.Attr s P.Text)
               (\s a -> s { _action = a } :: BlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess s)

instance P.HasTerminationWaitTimeInMinutes (BlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess s) (TF.Attr s P.Integer) where
    terminationWaitTimeInMinutes =
        P.lens (_terminationWaitTimeInMinutes :: BlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess s -> TF.Attr s P.Integer)
               (\s a -> s { _terminationWaitTimeInMinutes = a } :: BlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess s)

-- | @wafregional_rule_group_activated_rule@ nested settings.
data WafregionalRuleGroupActivatedRule s = WafregionalRuleGroupActivatedRule'
    { _action   :: TF.Attr s (ActivatedRuleAction s)
    -- ^ @action@ - (Required)
    --
    , _priority :: TF.Attr s P.Integer
    -- ^ @priority@ - (Required)
    --
    , _ruleId   :: TF.Attr s P.Text
    -- ^ @rule_id@ - (Required)
    --
    , _type'    :: TF.Attr s P.Text
    -- ^ @type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafregionalRuleGroupActivatedRule
    :: TF.Attr s (ActivatedRuleAction s) -- ^ @action@ - 'P.action'
    -> TF.Attr s P.Integer -- ^ @priority@ - 'P.priority'
    -> TF.Attr s P.Text -- ^ @rule_id@ - 'P.ruleId'
    -> WafregionalRuleGroupActivatedRule s
newWafregionalRuleGroupActivatedRule _action _priority _ruleId =
    WafregionalRuleGroupActivatedRule'
        { _action = _action
        , _priority = _priority
        , _ruleId = _ruleId
        , _type' = TF.value "REGULAR"
        }

instance P.Hashable  (WafregionalRuleGroupActivatedRule s)
instance TF.IsValue  (WafregionalRuleGroupActivatedRule s)
instance TF.IsObject (WafregionalRuleGroupActivatedRule s) where
    toObject WafregionalRuleGroupActivatedRule'{..} = P.catMaybes
        [ TF.assign "action" <$> TF.attribute _action
        , TF.assign "priority" <$> TF.attribute _priority
        , TF.assign "rule_id" <$> TF.attribute _ruleId
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (WafregionalRuleGroupActivatedRule s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_action"
                  (_action
                      :: WafregionalRuleGroupActivatedRule s -> TF.Attr s (ActivatedRuleAction s))
                  TF.validator

instance P.HasAction (WafregionalRuleGroupActivatedRule s) (TF.Attr s (ActivatedRuleAction s)) where
    action =
        P.lens (_action :: WafregionalRuleGroupActivatedRule s -> TF.Attr s (ActivatedRuleAction s))
               (\s a -> s { _action = a } :: WafregionalRuleGroupActivatedRule s)

instance P.HasPriority (WafregionalRuleGroupActivatedRule s) (TF.Attr s P.Integer) where
    priority =
        P.lens (_priority :: WafregionalRuleGroupActivatedRule s -> TF.Attr s P.Integer)
               (\s a -> s { _priority = a } :: WafregionalRuleGroupActivatedRule s)

instance P.HasRuleId (WafregionalRuleGroupActivatedRule s) (TF.Attr s P.Text) where
    ruleId =
        P.lens (_ruleId :: WafregionalRuleGroupActivatedRule s -> TF.Attr s P.Text)
               (\s a -> s { _ruleId = a } :: WafregionalRuleGroupActivatedRule s)

instance P.HasType' (WafregionalRuleGroupActivatedRule s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: WafregionalRuleGroupActivatedRule s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: WafregionalRuleGroupActivatedRule s)

-- | @opsworks_application_app_source@ nested settings.
data OpsworksApplicationAppSource s = OpsworksApplicationAppSource'
    { _password :: TF.Attr s P.Text
    -- ^ @password@ - (Optional)
    --
    , _revision :: TF.Attr s P.Text
    -- ^ @revision@ - (Optional)
    --
    , _sshKey   :: TF.Attr s P.Text
    -- ^ @ssh_key@ - (Optional)
    --
    , _type'    :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    , _url      :: TF.Attr s P.Text
    -- ^ @url@ - (Optional)
    --
    , _username :: TF.Attr s P.Text
    -- ^ @username@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newOpsworksApplicationAppSource
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> OpsworksApplicationAppSource s
newOpsworksApplicationAppSource _type' =
    OpsworksApplicationAppSource'
        { _password = TF.Nil
        , _revision = TF.Nil
        , _sshKey = TF.Nil
        , _type' = _type'
        , _url = TF.Nil
        , _username = TF.Nil
        }

instance P.Hashable  (OpsworksApplicationAppSource s)
instance TF.IsValue  (OpsworksApplicationAppSource s)
instance TF.IsObject (OpsworksApplicationAppSource s) where
    toObject OpsworksApplicationAppSource'{..} = P.catMaybes
        [ TF.assign "password" <$> TF.attribute _password
        , TF.assign "revision" <$> TF.attribute _revision
        , TF.assign "ssh_key" <$> TF.attribute _sshKey
        , TF.assign "type" <$> TF.attribute _type'
        , TF.assign "url" <$> TF.attribute _url
        , TF.assign "username" <$> TF.attribute _username
        ]

instance TF.IsValid (OpsworksApplicationAppSource s) where
    validator = P.mempty

instance P.HasPassword (OpsworksApplicationAppSource s) (TF.Attr s P.Text) where
    password =
        P.lens (_password :: OpsworksApplicationAppSource s -> TF.Attr s P.Text)
               (\s a -> s { _password = a } :: OpsworksApplicationAppSource s)

instance P.HasRevision (OpsworksApplicationAppSource s) (TF.Attr s P.Text) where
    revision =
        P.lens (_revision :: OpsworksApplicationAppSource s -> TF.Attr s P.Text)
               (\s a -> s { _revision = a } :: OpsworksApplicationAppSource s)

instance P.HasSshKey (OpsworksApplicationAppSource s) (TF.Attr s P.Text) where
    sshKey =
        P.lens (_sshKey :: OpsworksApplicationAppSource s -> TF.Attr s P.Text)
               (\s a -> s { _sshKey = a } :: OpsworksApplicationAppSource s)

instance P.HasType' (OpsworksApplicationAppSource s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: OpsworksApplicationAppSource s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: OpsworksApplicationAppSource s)

instance P.HasUrl (OpsworksApplicationAppSource s) (TF.Attr s P.Text) where
    url =
        P.lens (_url :: OpsworksApplicationAppSource s -> TF.Attr s P.Text)
               (\s a -> s { _url = a } :: OpsworksApplicationAppSource s)

instance P.HasUsername (OpsworksApplicationAppSource s) (TF.Attr s P.Text) where
    username =
        P.lens (_username :: OpsworksApplicationAppSource s -> TF.Attr s P.Text)
               (\s a -> s { _username = a } :: OpsworksApplicationAppSource s)

-- | @storage_descriptor_columns@ nested settings.
data StorageDescriptorColumns s = StorageDescriptorColumns'
    { _comment :: TF.Attr s P.Text
    -- ^ @comment@ - (Optional)
    --
    , _name    :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _type'   :: TF.Attr s P.Text
    -- ^ @type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newStorageDescriptorColumns
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> StorageDescriptorColumns s
newStorageDescriptorColumns _name =
    StorageDescriptorColumns'
        { _comment = TF.Nil
        , _name = _name
        , _type' = TF.Nil
        }

instance P.Hashable  (StorageDescriptorColumns s)
instance TF.IsValue  (StorageDescriptorColumns s)
instance TF.IsObject (StorageDescriptorColumns s) where
    toObject StorageDescriptorColumns'{..} = P.catMaybes
        [ TF.assign "comment" <$> TF.attribute _comment
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (StorageDescriptorColumns s) where
    validator = P.mempty

instance P.HasComment (StorageDescriptorColumns s) (TF.Attr s P.Text) where
    comment =
        P.lens (_comment :: StorageDescriptorColumns s -> TF.Attr s P.Text)
               (\s a -> s { _comment = a } :: StorageDescriptorColumns s)

instance P.HasName (StorageDescriptorColumns s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: StorageDescriptorColumns s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: StorageDescriptorColumns s)

instance P.HasType' (StorageDescriptorColumns s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: StorageDescriptorColumns s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: StorageDescriptorColumns s)

-- | @dynamodb_table_global_secondary_index@ nested settings.
data DynamodbTableGlobalSecondaryIndex s = DynamodbTableGlobalSecondaryIndex'
    { _hashKey          :: TF.Attr s P.Text
    -- ^ @hash_key@ - (Required)
    --
    , _name             :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _nonKeyAttributes :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @non_key_attributes@ - (Optional)
    --
    , _projectionType   :: TF.Attr s P.Text
    -- ^ @projection_type@ - (Required)
    --
    , _rangeKey         :: TF.Attr s P.Text
    -- ^ @range_key@ - (Optional)
    --
    , _readCapacity     :: TF.Attr s P.Integer
    -- ^ @read_capacity@ - (Required)
    --
    , _writeCapacity    :: TF.Attr s P.Integer
    -- ^ @write_capacity@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDynamodbTableGlobalSecondaryIndex
    :: TF.Attr s P.Text -- ^ @hash_key@ - 'P.hashKey'
    -> TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @projection_type@ - 'P.projectionType'
    -> TF.Attr s P.Integer -- ^ @read_capacity@ - 'P.readCapacity'
    -> TF.Attr s P.Integer -- ^ @write_capacity@ - 'P.writeCapacity'
    -> DynamodbTableGlobalSecondaryIndex s
newDynamodbTableGlobalSecondaryIndex _hashKey _name _projectionType _readCapacity _writeCapacity =
    DynamodbTableGlobalSecondaryIndex'
        { _hashKey = _hashKey
        , _name = _name
        , _nonKeyAttributes = TF.Nil
        , _projectionType = _projectionType
        , _rangeKey = TF.Nil
        , _readCapacity = _readCapacity
        , _writeCapacity = _writeCapacity
        }

instance P.Hashable  (DynamodbTableGlobalSecondaryIndex s)
instance TF.IsValue  (DynamodbTableGlobalSecondaryIndex s)
instance TF.IsObject (DynamodbTableGlobalSecondaryIndex s) where
    toObject DynamodbTableGlobalSecondaryIndex'{..} = P.catMaybes
        [ TF.assign "hash_key" <$> TF.attribute _hashKey
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "non_key_attributes" <$> TF.attribute _nonKeyAttributes
        , TF.assign "projection_type" <$> TF.attribute _projectionType
        , TF.assign "range_key" <$> TF.attribute _rangeKey
        , TF.assign "read_capacity" <$> TF.attribute _readCapacity
        , TF.assign "write_capacity" <$> TF.attribute _writeCapacity
        ]

instance TF.IsValid (DynamodbTableGlobalSecondaryIndex s) where
    validator = P.mempty

instance P.HasHashKey (DynamodbTableGlobalSecondaryIndex s) (TF.Attr s P.Text) where
    hashKey =
        P.lens (_hashKey :: DynamodbTableGlobalSecondaryIndex s -> TF.Attr s P.Text)
               (\s a -> s { _hashKey = a } :: DynamodbTableGlobalSecondaryIndex s)

instance P.HasName (DynamodbTableGlobalSecondaryIndex s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: DynamodbTableGlobalSecondaryIndex s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: DynamodbTableGlobalSecondaryIndex s)

instance P.HasNonKeyAttributes (DynamodbTableGlobalSecondaryIndex s) (TF.Attr s [TF.Attr s P.Text]) where
    nonKeyAttributes =
        P.lens (_nonKeyAttributes :: DynamodbTableGlobalSecondaryIndex s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _nonKeyAttributes = a } :: DynamodbTableGlobalSecondaryIndex s)

instance P.HasProjectionType (DynamodbTableGlobalSecondaryIndex s) (TF.Attr s P.Text) where
    projectionType =
        P.lens (_projectionType :: DynamodbTableGlobalSecondaryIndex s -> TF.Attr s P.Text)
               (\s a -> s { _projectionType = a } :: DynamodbTableGlobalSecondaryIndex s)

instance P.HasRangeKey (DynamodbTableGlobalSecondaryIndex s) (TF.Attr s P.Text) where
    rangeKey =
        P.lens (_rangeKey :: DynamodbTableGlobalSecondaryIndex s -> TF.Attr s P.Text)
               (\s a -> s { _rangeKey = a } :: DynamodbTableGlobalSecondaryIndex s)

instance P.HasReadCapacity (DynamodbTableGlobalSecondaryIndex s) (TF.Attr s P.Integer) where
    readCapacity =
        P.lens (_readCapacity :: DynamodbTableGlobalSecondaryIndex s -> TF.Attr s P.Integer)
               (\s a -> s { _readCapacity = a } :: DynamodbTableGlobalSecondaryIndex s)

instance P.HasWriteCapacity (DynamodbTableGlobalSecondaryIndex s) (TF.Attr s P.Integer) where
    writeCapacity =
        P.lens (_writeCapacity :: DynamodbTableGlobalSecondaryIndex s -> TF.Attr s P.Integer)
               (\s a -> s { _writeCapacity = a } :: DynamodbTableGlobalSecondaryIndex s)

instance s ~ s' => P.HasComputedHashKey (TF.Ref s' (DynamodbTableGlobalSecondaryIndex s)) (TF.Attr s P.Text) where
    computedHashKey x = TF.compute (TF.refKey x) "hash_key"

instance s ~ s' => P.HasComputedName (TF.Ref s' (DynamodbTableGlobalSecondaryIndex s)) (TF.Attr s P.Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance s ~ s' => P.HasComputedNonKeyAttributes (TF.Ref s' (DynamodbTableGlobalSecondaryIndex s)) (TF.Attr s [TF.Attr s P.Text]) where
    computedNonKeyAttributes x = TF.compute (TF.refKey x) "non_key_attributes"

instance s ~ s' => P.HasComputedProjectionType (TF.Ref s' (DynamodbTableGlobalSecondaryIndex s)) (TF.Attr s P.Text) where
    computedProjectionType x = TF.compute (TF.refKey x) "projection_type"

instance s ~ s' => P.HasComputedRangeKey (TF.Ref s' (DynamodbTableGlobalSecondaryIndex s)) (TF.Attr s P.Text) where
    computedRangeKey x = TF.compute (TF.refKey x) "range_key"

instance s ~ s' => P.HasComputedReadCapacity (TF.Ref s' (DynamodbTableGlobalSecondaryIndex s)) (TF.Attr s P.Integer) where
    computedReadCapacity x = TF.compute (TF.refKey x) "read_capacity"

instance s ~ s' => P.HasComputedWriteCapacity (TF.Ref s' (DynamodbTableGlobalSecondaryIndex s)) (TF.Attr s P.Integer) where
    computedWriteCapacity x = TF.compute (TF.refKey x) "write_capacity"

-- | @cognito_user_pool_sms_configuration@ nested settings.
data CognitoUserPoolSmsConfiguration s = CognitoUserPoolSmsConfiguration'
    { _externalId   :: TF.Attr s P.Text
    -- ^ @external_id@ - (Required)
    --
    , _snsCallerArn :: TF.Attr s P.Text
    -- ^ @sns_caller_arn@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCognitoUserPoolSmsConfiguration
    :: TF.Attr s P.Text -- ^ @external_id@ - 'P.externalId'
    -> TF.Attr s P.Text -- ^ @sns_caller_arn@ - 'P.snsCallerArn'
    -> CognitoUserPoolSmsConfiguration s
newCognitoUserPoolSmsConfiguration _externalId _snsCallerArn =
    CognitoUserPoolSmsConfiguration'
        { _externalId = _externalId
        , _snsCallerArn = _snsCallerArn
        }

instance P.Hashable  (CognitoUserPoolSmsConfiguration s)
instance TF.IsValue  (CognitoUserPoolSmsConfiguration s)
instance TF.IsObject (CognitoUserPoolSmsConfiguration s) where
    toObject CognitoUserPoolSmsConfiguration'{..} = P.catMaybes
        [ TF.assign "external_id" <$> TF.attribute _externalId
        , TF.assign "sns_caller_arn" <$> TF.attribute _snsCallerArn
        ]

instance TF.IsValid (CognitoUserPoolSmsConfiguration s) where
    validator = P.mempty

instance P.HasExternalId (CognitoUserPoolSmsConfiguration s) (TF.Attr s P.Text) where
    externalId =
        P.lens (_externalId :: CognitoUserPoolSmsConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _externalId = a } :: CognitoUserPoolSmsConfiguration s)

instance P.HasSnsCallerArn (CognitoUserPoolSmsConfiguration s) (TF.Attr s P.Text) where
    snsCallerArn =
        P.lens (_snsCallerArn :: CognitoUserPoolSmsConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _snsCallerArn = a } :: CognitoUserPoolSmsConfiguration s)

-- | @server_side_encryption_configuration_rule@ nested settings.
data ServerSideEncryptionConfigurationRule s = ServerSideEncryptionConfigurationRule'
    { _applyServerSideEncryptionByDefault :: TF.Attr s (RuleApplyServerSideEncryptionByDefault s)
    -- ^ @apply_server_side_encryption_by_default@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newServerSideEncryptionConfigurationRule
    :: TF.Attr s (RuleApplyServerSideEncryptionByDefault s) -- ^ @apply_server_side_encryption_by_default@ - 'P.applyServerSideEncryptionByDefault'
    -> ServerSideEncryptionConfigurationRule s
newServerSideEncryptionConfigurationRule _applyServerSideEncryptionByDefault =
    ServerSideEncryptionConfigurationRule'
        { _applyServerSideEncryptionByDefault = _applyServerSideEncryptionByDefault
        }

instance P.Hashable  (ServerSideEncryptionConfigurationRule s)
instance TF.IsValue  (ServerSideEncryptionConfigurationRule s)
instance TF.IsObject (ServerSideEncryptionConfigurationRule s) where
    toObject ServerSideEncryptionConfigurationRule'{..} = P.catMaybes
        [ TF.assign "apply_server_side_encryption_by_default" <$> TF.attribute _applyServerSideEncryptionByDefault
        ]

instance TF.IsValid (ServerSideEncryptionConfigurationRule s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_applyServerSideEncryptionByDefault"
                  (_applyServerSideEncryptionByDefault
                      :: ServerSideEncryptionConfigurationRule s -> TF.Attr s (RuleApplyServerSideEncryptionByDefault s))
                  TF.validator

instance P.HasApplyServerSideEncryptionByDefault (ServerSideEncryptionConfigurationRule s) (TF.Attr s (RuleApplyServerSideEncryptionByDefault s)) where
    applyServerSideEncryptionByDefault =
        P.lens (_applyServerSideEncryptionByDefault :: ServerSideEncryptionConfigurationRule s -> TF.Attr s (RuleApplyServerSideEncryptionByDefault s))
               (\s a -> s { _applyServerSideEncryptionByDefault = a } :: ServerSideEncryptionConfigurationRule s)

-- | @waf_geo_match_set_geo_match_constraint@ nested settings.
data WafGeoMatchSetGeoMatchConstraint s = WafGeoMatchSetGeoMatchConstraint'
    { _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    , _value :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafGeoMatchSetGeoMatchConstraint
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> WafGeoMatchSetGeoMatchConstraint s
newWafGeoMatchSetGeoMatchConstraint _type' _value =
    WafGeoMatchSetGeoMatchConstraint'
        { _type' = _type'
        , _value = _value
        }

instance P.Hashable  (WafGeoMatchSetGeoMatchConstraint s)
instance TF.IsValue  (WafGeoMatchSetGeoMatchConstraint s)
instance TF.IsObject (WafGeoMatchSetGeoMatchConstraint s) where
    toObject WafGeoMatchSetGeoMatchConstraint'{..} = P.catMaybes
        [ TF.assign "type" <$> TF.attribute _type'
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (WafGeoMatchSetGeoMatchConstraint s) where
    validator = P.mempty

instance P.HasType' (WafGeoMatchSetGeoMatchConstraint s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: WafGeoMatchSetGeoMatchConstraint s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: WafGeoMatchSetGeoMatchConstraint s)

instance P.HasValue (WafGeoMatchSetGeoMatchConstraint s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: WafGeoMatchSetGeoMatchConstraint s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: WafGeoMatchSetGeoMatchConstraint s)

-- | @byte_match_tuples_field_to_match@ nested settings.
data ByteMatchTuplesFieldToMatch s = ByteMatchTuplesFieldToMatch'
    { _data' :: TF.Attr s P.Text
    -- ^ @data@ - (Optional)
    --
    , _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newByteMatchTuplesFieldToMatch
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> ByteMatchTuplesFieldToMatch s
newByteMatchTuplesFieldToMatch _type' =
    ByteMatchTuplesFieldToMatch'
        { _data' = TF.Nil
        , _type' = _type'
        }

instance P.Hashable  (ByteMatchTuplesFieldToMatch s)
instance TF.IsValue  (ByteMatchTuplesFieldToMatch s)
instance TF.IsObject (ByteMatchTuplesFieldToMatch s) where
    toObject ByteMatchTuplesFieldToMatch'{..} = P.catMaybes
        [ TF.assign "data" <$> TF.attribute _data'
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (ByteMatchTuplesFieldToMatch s) where
    validator = P.mempty

instance P.HasData' (ByteMatchTuplesFieldToMatch s) (TF.Attr s P.Text) where
    data' =
        P.lens (_data' :: ByteMatchTuplesFieldToMatch s -> TF.Attr s P.Text)
               (\s a -> s { _data' = a } :: ByteMatchTuplesFieldToMatch s)

instance P.HasType' (ByteMatchTuplesFieldToMatch s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: ByteMatchTuplesFieldToMatch s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: ByteMatchTuplesFieldToMatch s)

-- | @route53_record_weighted_routing_policy@ nested settings.
data Route53RecordWeightedRoutingPolicy s = Route53RecordWeightedRoutingPolicy'
    { _weight :: TF.Attr s P.Integer
    -- ^ @weight@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRoute53RecordWeightedRoutingPolicy
    :: TF.Attr s P.Integer -- ^ @weight@ - 'P.weight'
    -> Route53RecordWeightedRoutingPolicy s
newRoute53RecordWeightedRoutingPolicy _weight =
    Route53RecordWeightedRoutingPolicy'
        { _weight = _weight
        }

instance P.Hashable  (Route53RecordWeightedRoutingPolicy s)
instance TF.IsValue  (Route53RecordWeightedRoutingPolicy s)
instance TF.IsObject (Route53RecordWeightedRoutingPolicy s) where
    toObject Route53RecordWeightedRoutingPolicy'{..} = P.catMaybes
        [ TF.assign "weight" <$> TF.attribute _weight
        ]

instance TF.IsValid (Route53RecordWeightedRoutingPolicy s) where
    validator = P.mempty

instance P.HasWeight (Route53RecordWeightedRoutingPolicy s) (TF.Attr s P.Integer) where
    weight =
        P.lens (_weight :: Route53RecordWeightedRoutingPolicy s -> TF.Attr s P.Integer)
               (\s a -> s { _weight = a } :: Route53RecordWeightedRoutingPolicy s)

-- | @api_gateway_method_settings_settings@ nested settings.
data ApiGatewayMethodSettingsSettings s = ApiGatewayMethodSettingsSettings'
    { _cacheDataEncrypted                     :: TF.Attr s P.Bool
    -- ^ @cache_data_encrypted@ - (Optional)
    --
    , _cacheTtlInSeconds                      :: TF.Attr s P.Integer
    -- ^ @cache_ttl_in_seconds@ - (Optional)
    --
    , _cachingEnabled                         :: TF.Attr s P.Bool
    -- ^ @caching_enabled@ - (Optional)
    --
    , _dataTraceEnabled                       :: TF.Attr s P.Bool
    -- ^ @data_trace_enabled@ - (Optional)
    --
    , _loggingLevel                           :: TF.Attr s P.Text
    -- ^ @logging_level@ - (Optional)
    --
    , _metricsEnabled                         :: TF.Attr s P.Bool
    -- ^ @metrics_enabled@ - (Optional)
    --
    , _requireAuthorizationForCacheControl    :: TF.Attr s P.Bool
    -- ^ @require_authorization_for_cache_control@ - (Optional)
    --
    , _throttlingBurstLimit                   :: TF.Attr s P.Integer
    -- ^ @throttling_burst_limit@ - (Optional)
    --
    , _throttlingRateLimit                    :: TF.Attr s P.Double
    -- ^ @throttling_rate_limit@ - (Optional)
    --
    , _unauthorizedCacheControlHeaderStrategy :: TF.Attr s P.Text
    -- ^ @unauthorized_cache_control_header_strategy@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newApiGatewayMethodSettingsSettings
    :: ApiGatewayMethodSettingsSettings s
newApiGatewayMethodSettingsSettings =
    ApiGatewayMethodSettingsSettings'
        { _cacheDataEncrypted = TF.Nil
        , _cacheTtlInSeconds = TF.Nil
        , _cachingEnabled = TF.Nil
        , _dataTraceEnabled = TF.Nil
        , _loggingLevel = TF.Nil
        , _metricsEnabled = TF.Nil
        , _requireAuthorizationForCacheControl = TF.Nil
        , _throttlingBurstLimit = TF.Nil
        , _throttlingRateLimit = TF.Nil
        , _unauthorizedCacheControlHeaderStrategy = TF.Nil
        }

instance P.Hashable  (ApiGatewayMethodSettingsSettings s)
instance TF.IsValue  (ApiGatewayMethodSettingsSettings s)
instance TF.IsObject (ApiGatewayMethodSettingsSettings s) where
    toObject ApiGatewayMethodSettingsSettings'{..} = P.catMaybes
        [ TF.assign "cache_data_encrypted" <$> TF.attribute _cacheDataEncrypted
        , TF.assign "cache_ttl_in_seconds" <$> TF.attribute _cacheTtlInSeconds
        , TF.assign "caching_enabled" <$> TF.attribute _cachingEnabled
        , TF.assign "data_trace_enabled" <$> TF.attribute _dataTraceEnabled
        , TF.assign "logging_level" <$> TF.attribute _loggingLevel
        , TF.assign "metrics_enabled" <$> TF.attribute _metricsEnabled
        , TF.assign "require_authorization_for_cache_control" <$> TF.attribute _requireAuthorizationForCacheControl
        , TF.assign "throttling_burst_limit" <$> TF.attribute _throttlingBurstLimit
        , TF.assign "throttling_rate_limit" <$> TF.attribute _throttlingRateLimit
        , TF.assign "unauthorized_cache_control_header_strategy" <$> TF.attribute _unauthorizedCacheControlHeaderStrategy
        ]

instance TF.IsValid (ApiGatewayMethodSettingsSettings s) where
    validator = P.mempty

instance P.HasCacheDataEncrypted (ApiGatewayMethodSettingsSettings s) (TF.Attr s P.Bool) where
    cacheDataEncrypted =
        P.lens (_cacheDataEncrypted :: ApiGatewayMethodSettingsSettings s -> TF.Attr s P.Bool)
               (\s a -> s { _cacheDataEncrypted = a } :: ApiGatewayMethodSettingsSettings s)

instance P.HasCacheTtlInSeconds (ApiGatewayMethodSettingsSettings s) (TF.Attr s P.Integer) where
    cacheTtlInSeconds =
        P.lens (_cacheTtlInSeconds :: ApiGatewayMethodSettingsSettings s -> TF.Attr s P.Integer)
               (\s a -> s { _cacheTtlInSeconds = a } :: ApiGatewayMethodSettingsSettings s)

instance P.HasCachingEnabled (ApiGatewayMethodSettingsSettings s) (TF.Attr s P.Bool) where
    cachingEnabled =
        P.lens (_cachingEnabled :: ApiGatewayMethodSettingsSettings s -> TF.Attr s P.Bool)
               (\s a -> s { _cachingEnabled = a } :: ApiGatewayMethodSettingsSettings s)

instance P.HasDataTraceEnabled (ApiGatewayMethodSettingsSettings s) (TF.Attr s P.Bool) where
    dataTraceEnabled =
        P.lens (_dataTraceEnabled :: ApiGatewayMethodSettingsSettings s -> TF.Attr s P.Bool)
               (\s a -> s { _dataTraceEnabled = a } :: ApiGatewayMethodSettingsSettings s)

instance P.HasLoggingLevel (ApiGatewayMethodSettingsSettings s) (TF.Attr s P.Text) where
    loggingLevel =
        P.lens (_loggingLevel :: ApiGatewayMethodSettingsSettings s -> TF.Attr s P.Text)
               (\s a -> s { _loggingLevel = a } :: ApiGatewayMethodSettingsSettings s)

instance P.HasMetricsEnabled (ApiGatewayMethodSettingsSettings s) (TF.Attr s P.Bool) where
    metricsEnabled =
        P.lens (_metricsEnabled :: ApiGatewayMethodSettingsSettings s -> TF.Attr s P.Bool)
               (\s a -> s { _metricsEnabled = a } :: ApiGatewayMethodSettingsSettings s)

instance P.HasRequireAuthorizationForCacheControl (ApiGatewayMethodSettingsSettings s) (TF.Attr s P.Bool) where
    requireAuthorizationForCacheControl =
        P.lens (_requireAuthorizationForCacheControl :: ApiGatewayMethodSettingsSettings s -> TF.Attr s P.Bool)
               (\s a -> s { _requireAuthorizationForCacheControl = a } :: ApiGatewayMethodSettingsSettings s)

instance P.HasThrottlingBurstLimit (ApiGatewayMethodSettingsSettings s) (TF.Attr s P.Integer) where
    throttlingBurstLimit =
        P.lens (_throttlingBurstLimit :: ApiGatewayMethodSettingsSettings s -> TF.Attr s P.Integer)
               (\s a -> s { _throttlingBurstLimit = a } :: ApiGatewayMethodSettingsSettings s)

instance P.HasThrottlingRateLimit (ApiGatewayMethodSettingsSettings s) (TF.Attr s P.Double) where
    throttlingRateLimit =
        P.lens (_throttlingRateLimit :: ApiGatewayMethodSettingsSettings s -> TF.Attr s P.Double)
               (\s a -> s { _throttlingRateLimit = a } :: ApiGatewayMethodSettingsSettings s)

instance P.HasUnauthorizedCacheControlHeaderStrategy (ApiGatewayMethodSettingsSettings s) (TF.Attr s P.Text) where
    unauthorizedCacheControlHeaderStrategy =
        P.lens (_unauthorizedCacheControlHeaderStrategy :: ApiGatewayMethodSettingsSettings s -> TF.Attr s P.Text)
               (\s a -> s { _unauthorizedCacheControlHeaderStrategy = a } :: ApiGatewayMethodSettingsSettings s)

-- | @redshift_cluster_snapshot_copy@ nested settings.
data RedshiftClusterSnapshotCopy s = RedshiftClusterSnapshotCopy'
    { _destinationRegion :: TF.Attr s P.Text
    -- ^ @destination_region@ - (Required)
    --
    , _grantName         :: TF.Attr s P.Text
    -- ^ @grant_name@ - (Optional)
    --
    , _retentionPeriod   :: TF.Attr s P.Integer
    -- ^ @retention_period@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRedshiftClusterSnapshotCopy
    :: TF.Attr s P.Text -- ^ @destination_region@ - 'P.destinationRegion'
    -> RedshiftClusterSnapshotCopy s
newRedshiftClusterSnapshotCopy _destinationRegion =
    RedshiftClusterSnapshotCopy'
        { _destinationRegion = _destinationRegion
        , _grantName = TF.Nil
        , _retentionPeriod = TF.value 7
        }

instance P.Hashable  (RedshiftClusterSnapshotCopy s)
instance TF.IsValue  (RedshiftClusterSnapshotCopy s)
instance TF.IsObject (RedshiftClusterSnapshotCopy s) where
    toObject RedshiftClusterSnapshotCopy'{..} = P.catMaybes
        [ TF.assign "destination_region" <$> TF.attribute _destinationRegion
        , TF.assign "grant_name" <$> TF.attribute _grantName
        , TF.assign "retention_period" <$> TF.attribute _retentionPeriod
        ]

instance TF.IsValid (RedshiftClusterSnapshotCopy s) where
    validator = P.mempty

instance P.HasDestinationRegion (RedshiftClusterSnapshotCopy s) (TF.Attr s P.Text) where
    destinationRegion =
        P.lens (_destinationRegion :: RedshiftClusterSnapshotCopy s -> TF.Attr s P.Text)
               (\s a -> s { _destinationRegion = a } :: RedshiftClusterSnapshotCopy s)

instance P.HasGrantName (RedshiftClusterSnapshotCopy s) (TF.Attr s P.Text) where
    grantName =
        P.lens (_grantName :: RedshiftClusterSnapshotCopy s -> TF.Attr s P.Text)
               (\s a -> s { _grantName = a } :: RedshiftClusterSnapshotCopy s)

instance P.HasRetentionPeriod (RedshiftClusterSnapshotCopy s) (TF.Attr s P.Integer) where
    retentionPeriod =
        P.lens (_retentionPeriod :: RedshiftClusterSnapshotCopy s -> TF.Attr s P.Integer)
               (\s a -> s { _retentionPeriod = a } :: RedshiftClusterSnapshotCopy s)

-- | @output_format_configuration_serializer@ nested settings.
data OutputFormatConfigurationSerializer s = OutputFormatConfigurationSerializer'
    { _orcSerDe     :: TF.Attr s (SerializerOrcSerDe s)
    -- ^ @orc_ser_de@ - (Optional)
    --
    -- Conflicts with:
    --
    -- * 'parquetSerDe'
    , _parquetSerDe :: TF.Attr s (SerializerParquetSerDe s)
    -- ^ @parquet_ser_de@ - (Optional)
    --
    -- Conflicts with:
    --
    -- * 'orcSerDe'
    } deriving (P.Show, P.Eq, P.Generic)

newOutputFormatConfigurationSerializer
    :: OutputFormatConfigurationSerializer s
newOutputFormatConfigurationSerializer =
    OutputFormatConfigurationSerializer'
        { _orcSerDe = TF.Nil
        , _parquetSerDe = TF.Nil
        }

instance P.Hashable  (OutputFormatConfigurationSerializer s)
instance TF.IsValue  (OutputFormatConfigurationSerializer s)
instance TF.IsObject (OutputFormatConfigurationSerializer s) where
    toObject OutputFormatConfigurationSerializer'{..} = P.catMaybes
        [ TF.assign "orc_ser_de" <$> TF.attribute _orcSerDe
        , TF.assign "parquet_ser_de" <$> TF.attribute _parquetSerDe
        ]

instance TF.IsValid (OutputFormatConfigurationSerializer s) where
    validator = TF.fieldsValidator (\OutputFormatConfigurationSerializer'{..} -> Map.fromList $ P.catMaybes
        [ if (_orcSerDe P.== TF.Nil)
              then P.Nothing
              else P.Just ("_orcSerDe",
                            [ "_parquetSerDe"
                            ])
        , if (_parquetSerDe P.== TF.Nil)
              then P.Nothing
              else P.Just ("_parquetSerDe",
                            [ "_orcSerDe"
                            ])
        ])
           P.<> TF.settingsValidator "_orcSerDe"
                  (_orcSerDe
                      :: OutputFormatConfigurationSerializer s -> TF.Attr s (SerializerOrcSerDe s))
                  TF.validator
           P.<> TF.settingsValidator "_parquetSerDe"
                  (_parquetSerDe
                      :: OutputFormatConfigurationSerializer s -> TF.Attr s (SerializerParquetSerDe s))
                  TF.validator

instance P.HasOrcSerDe (OutputFormatConfigurationSerializer s) (TF.Attr s (SerializerOrcSerDe s)) where
    orcSerDe =
        P.lens (_orcSerDe :: OutputFormatConfigurationSerializer s -> TF.Attr s (SerializerOrcSerDe s))
               (\s a -> s { _orcSerDe = a } :: OutputFormatConfigurationSerializer s)

instance P.HasParquetSerDe (OutputFormatConfigurationSerializer s) (TF.Attr s (SerializerParquetSerDe s)) where
    parquetSerDe =
        P.lens (_parquetSerDe :: OutputFormatConfigurationSerializer s -> TF.Attr s (SerializerParquetSerDe s))
               (\s a -> s { _parquetSerDe = a } :: OutputFormatConfigurationSerializer s)

-- | @vpc_peering_connection_options_requester@ nested settings.
data VpcPeeringConnectionOptionsRequester s = VpcPeeringConnectionOptionsRequester'
    { _allowClassicLinkToRemoteVpc :: TF.Attr s P.Bool
    -- ^ @allow_classic_link_to_remote_vpc@ - (Optional)
    --
    , _allowRemoteVpcDnsResolution :: TF.Attr s P.Bool
    -- ^ @allow_remote_vpc_dns_resolution@ - (Optional)
    --
    , _allowVpcToRemoteClassicLink :: TF.Attr s P.Bool
    -- ^ @allow_vpc_to_remote_classic_link@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newVpcPeeringConnectionOptionsRequester
    :: VpcPeeringConnectionOptionsRequester s
newVpcPeeringConnectionOptionsRequester =
    VpcPeeringConnectionOptionsRequester'
        { _allowClassicLinkToRemoteVpc = TF.value P.False
        , _allowRemoteVpcDnsResolution = TF.value P.False
        , _allowVpcToRemoteClassicLink = TF.value P.False
        }

instance P.Hashable  (VpcPeeringConnectionOptionsRequester s)
instance TF.IsValue  (VpcPeeringConnectionOptionsRequester s)
instance TF.IsObject (VpcPeeringConnectionOptionsRequester s) where
    toObject VpcPeeringConnectionOptionsRequester'{..} = P.catMaybes
        [ TF.assign "allow_classic_link_to_remote_vpc" <$> TF.attribute _allowClassicLinkToRemoteVpc
        , TF.assign "allow_remote_vpc_dns_resolution" <$> TF.attribute _allowRemoteVpcDnsResolution
        , TF.assign "allow_vpc_to_remote_classic_link" <$> TF.attribute _allowVpcToRemoteClassicLink
        ]

instance TF.IsValid (VpcPeeringConnectionOptionsRequester s) where
    validator = P.mempty

instance P.HasAllowClassicLinkToRemoteVpc (VpcPeeringConnectionOptionsRequester s) (TF.Attr s P.Bool) where
    allowClassicLinkToRemoteVpc =
        P.lens (_allowClassicLinkToRemoteVpc :: VpcPeeringConnectionOptionsRequester s -> TF.Attr s P.Bool)
               (\s a -> s { _allowClassicLinkToRemoteVpc = a } :: VpcPeeringConnectionOptionsRequester s)

instance P.HasAllowRemoteVpcDnsResolution (VpcPeeringConnectionOptionsRequester s) (TF.Attr s P.Bool) where
    allowRemoteVpcDnsResolution =
        P.lens (_allowRemoteVpcDnsResolution :: VpcPeeringConnectionOptionsRequester s -> TF.Attr s P.Bool)
               (\s a -> s { _allowRemoteVpcDnsResolution = a } :: VpcPeeringConnectionOptionsRequester s)

instance P.HasAllowVpcToRemoteClassicLink (VpcPeeringConnectionOptionsRequester s) (TF.Attr s P.Bool) where
    allowVpcToRemoteClassicLink =
        P.lens (_allowVpcToRemoteClassicLink :: VpcPeeringConnectionOptionsRequester s -> TF.Attr s P.Bool)
               (\s a -> s { _allowVpcToRemoteClassicLink = a } :: VpcPeeringConnectionOptionsRequester s)

-- | @revocation_configuration_crl_configuration@ nested settings.
data RevocationConfigurationCrlConfiguration s = RevocationConfigurationCrlConfiguration'
    { _customCname      :: TF.Attr s P.Text
    -- ^ @custom_cname@ - (Optional)
    --
    , _enabled          :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Optional)
    --
    , _expirationInDays :: TF.Attr s P.Integer
    -- ^ @expiration_in_days@ - (Required)
    --
    , _s3BucketName     :: TF.Attr s P.Text
    -- ^ @s3_bucket_name@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRevocationConfigurationCrlConfiguration
    :: TF.Attr s P.Integer -- ^ @expiration_in_days@ - 'P.expirationInDays'
    -> RevocationConfigurationCrlConfiguration s
newRevocationConfigurationCrlConfiguration _expirationInDays =
    RevocationConfigurationCrlConfiguration'
        { _customCname = TF.Nil
        , _enabled = TF.Nil
        , _expirationInDays = _expirationInDays
        , _s3BucketName = TF.Nil
        }

instance P.Hashable  (RevocationConfigurationCrlConfiguration s)
instance TF.IsValue  (RevocationConfigurationCrlConfiguration s)
instance TF.IsObject (RevocationConfigurationCrlConfiguration s) where
    toObject RevocationConfigurationCrlConfiguration'{..} = P.catMaybes
        [ TF.assign "custom_cname" <$> TF.attribute _customCname
        , TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "expiration_in_days" <$> TF.attribute _expirationInDays
        , TF.assign "s3_bucket_name" <$> TF.attribute _s3BucketName
        ]

instance TF.IsValid (RevocationConfigurationCrlConfiguration s) where
    validator = P.mempty

instance P.HasCustomCname (RevocationConfigurationCrlConfiguration s) (TF.Attr s P.Text) where
    customCname =
        P.lens (_customCname :: RevocationConfigurationCrlConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _customCname = a } :: RevocationConfigurationCrlConfiguration s)

instance P.HasEnabled (RevocationConfigurationCrlConfiguration s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: RevocationConfigurationCrlConfiguration s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: RevocationConfigurationCrlConfiguration s)

instance P.HasExpirationInDays (RevocationConfigurationCrlConfiguration s) (TF.Attr s P.Integer) where
    expirationInDays =
        P.lens (_expirationInDays :: RevocationConfigurationCrlConfiguration s -> TF.Attr s P.Integer)
               (\s a -> s { _expirationInDays = a } :: RevocationConfigurationCrlConfiguration s)

instance P.HasS3BucketName (RevocationConfigurationCrlConfiguration s) (TF.Attr s P.Text) where
    s3BucketName =
        P.lens (_s3BucketName :: RevocationConfigurationCrlConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _s3BucketName = a } :: RevocationConfigurationCrlConfiguration s)

instance s ~ s' => P.HasComputedCustomCname (TF.Ref s' (RevocationConfigurationCrlConfiguration s)) (TF.Attr s P.Text) where
    computedCustomCname x = TF.compute (TF.refKey x) "custom_cname"

instance s ~ s' => P.HasComputedEnabled (TF.Ref s' (RevocationConfigurationCrlConfiguration s)) (TF.Attr s P.Bool) where
    computedEnabled x = TF.compute (TF.refKey x) "enabled"

instance s ~ s' => P.HasComputedExpirationInDays (TF.Ref s' (RevocationConfigurationCrlConfiguration s)) (TF.Attr s P.Integer) where
    computedExpirationInDays x = TF.compute (TF.refKey x) "expiration_in_days"

instance s ~ s' => P.HasComputedS3BucketName (TF.Ref s' (RevocationConfigurationCrlConfiguration s)) (TF.Attr s P.Text) where
    computedS3BucketName x = TF.compute (TF.refKey x) "s3_bucket_name"

-- | @cloudfront_distribution_viewer_certificate@ nested settings.
data CloudfrontDistributionViewerCertificate s = CloudfrontDistributionViewerCertificate'
    { _acmCertificateArn            :: TF.Attr s P.Text
    -- ^ @acm_certificate_arn@ - (Optional)
    --
    -- Conflicts with:
    --
    -- * 'iamCertificateId'
    -- * 'cloudfrontDefaultCertificate'
    , _cloudfrontDefaultCertificate :: TF.Attr s P.Bool
    -- ^ @cloudfront_default_certificate@ - (Optional)
    --
    -- Conflicts with:
    --
    -- * 'iamCertificateId'
    -- * 'acmCertificateArn'
    , _iamCertificateId             :: TF.Attr s P.Text
    -- ^ @iam_certificate_id@ - (Optional)
    --
    -- Conflicts with:
    --
    -- * 'cloudfrontDefaultCertificate'
    -- * 'acmCertificateArn'
    , _minimumProtocolVersion       :: TF.Attr s P.Text
    -- ^ @minimum_protocol_version@ - (Optional)
    --
    , _sslSupportMethod             :: TF.Attr s P.Text
    -- ^ @ssl_support_method@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCloudfrontDistributionViewerCertificate
    :: CloudfrontDistributionViewerCertificate s
newCloudfrontDistributionViewerCertificate =
    CloudfrontDistributionViewerCertificate'
        { _acmCertificateArn = TF.Nil
        , _cloudfrontDefaultCertificate = TF.Nil
        , _iamCertificateId = TF.Nil
        , _minimumProtocolVersion = TF.value "TLSv1"
        , _sslSupportMethod = TF.Nil
        }

instance P.Hashable  (CloudfrontDistributionViewerCertificate s)
instance TF.IsValue  (CloudfrontDistributionViewerCertificate s)
instance TF.IsObject (CloudfrontDistributionViewerCertificate s) where
    toObject CloudfrontDistributionViewerCertificate'{..} = P.catMaybes
        [ TF.assign "acm_certificate_arn" <$> TF.attribute _acmCertificateArn
        , TF.assign "cloudfront_default_certificate" <$> TF.attribute _cloudfrontDefaultCertificate
        , TF.assign "iam_certificate_id" <$> TF.attribute _iamCertificateId
        , TF.assign "minimum_protocol_version" <$> TF.attribute _minimumProtocolVersion
        , TF.assign "ssl_support_method" <$> TF.attribute _sslSupportMethod
        ]

instance TF.IsValid (CloudfrontDistributionViewerCertificate s) where
    validator = TF.fieldsValidator (\CloudfrontDistributionViewerCertificate'{..} -> Map.fromList $ P.catMaybes
        [ if (_acmCertificateArn P.== TF.Nil)
              then P.Nothing
              else P.Just ("_acmCertificateArn",
                            [ "_iamCertificateId"                            , "_cloudfrontDefaultCertificate"
                            ])
        , if (_cloudfrontDefaultCertificate P.== TF.Nil)
              then P.Nothing
              else P.Just ("_cloudfrontDefaultCertificate",
                            [ "_iamCertificateId"                            , "_acmCertificateArn"
                            ])
        , if (_iamCertificateId P.== TF.Nil)
              then P.Nothing
              else P.Just ("_iamCertificateId",
                            [ "_cloudfrontDefaultCertificate"                            , "_acmCertificateArn"
                            ])
        ])

instance P.HasAcmCertificateArn (CloudfrontDistributionViewerCertificate s) (TF.Attr s P.Text) where
    acmCertificateArn =
        P.lens (_acmCertificateArn :: CloudfrontDistributionViewerCertificate s -> TF.Attr s P.Text)
               (\s a -> s { _acmCertificateArn = a } :: CloudfrontDistributionViewerCertificate s)

instance P.HasCloudfrontDefaultCertificate (CloudfrontDistributionViewerCertificate s) (TF.Attr s P.Bool) where
    cloudfrontDefaultCertificate =
        P.lens (_cloudfrontDefaultCertificate :: CloudfrontDistributionViewerCertificate s -> TF.Attr s P.Bool)
               (\s a -> s { _cloudfrontDefaultCertificate = a } :: CloudfrontDistributionViewerCertificate s)

instance P.HasIamCertificateId (CloudfrontDistributionViewerCertificate s) (TF.Attr s P.Text) where
    iamCertificateId =
        P.lens (_iamCertificateId :: CloudfrontDistributionViewerCertificate s -> TF.Attr s P.Text)
               (\s a -> s { _iamCertificateId = a } :: CloudfrontDistributionViewerCertificate s)

instance P.HasMinimumProtocolVersion (CloudfrontDistributionViewerCertificate s) (TF.Attr s P.Text) where
    minimumProtocolVersion =
        P.lens (_minimumProtocolVersion :: CloudfrontDistributionViewerCertificate s -> TF.Attr s P.Text)
               (\s a -> s { _minimumProtocolVersion = a } :: CloudfrontDistributionViewerCertificate s)

instance P.HasSslSupportMethod (CloudfrontDistributionViewerCertificate s) (TF.Attr s P.Text) where
    sslSupportMethod =
        P.lens (_sslSupportMethod :: CloudfrontDistributionViewerCertificate s -> TF.Attr s P.Text)
               (\s a -> s { _sslSupportMethod = a } :: CloudfrontDistributionViewerCertificate s)

-- | @dynamodb_table_point_in_time_recovery@ nested settings.
data DynamodbTablePointInTimeRecovery s = DynamodbTablePointInTimeRecovery'
    { _enabled :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDynamodbTablePointInTimeRecovery
    :: TF.Attr s P.Bool -- ^ @enabled@ - 'P.enabled'
    -> DynamodbTablePointInTimeRecovery s
newDynamodbTablePointInTimeRecovery _enabled =
    DynamodbTablePointInTimeRecovery'
        { _enabled = _enabled
        }

instance P.Hashable  (DynamodbTablePointInTimeRecovery s)
instance TF.IsValue  (DynamodbTablePointInTimeRecovery s)
instance TF.IsObject (DynamodbTablePointInTimeRecovery s) where
    toObject DynamodbTablePointInTimeRecovery'{..} = P.catMaybes
        [ TF.assign "enabled" <$> TF.attribute _enabled
        ]

instance TF.IsValid (DynamodbTablePointInTimeRecovery s) where
    validator = P.mempty

instance P.HasEnabled (DynamodbTablePointInTimeRecovery s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: DynamodbTablePointInTimeRecovery s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: DynamodbTablePointInTimeRecovery s)

-- | @cloudfront_distribution_custom_error_response@ nested settings.
data CloudfrontDistributionCustomErrorResponse s = CloudfrontDistributionCustomErrorResponse'
    { _errorCachingMinTtl :: TF.Attr s P.Integer
    -- ^ @error_caching_min_ttl@ - (Optional)
    --
    , _errorCode          :: TF.Attr s P.Integer
    -- ^ @error_code@ - (Required)
    --
    , _responseCode       :: TF.Attr s P.Integer
    -- ^ @response_code@ - (Optional)
    --
    , _responsePagePath   :: TF.Attr s P.Text
    -- ^ @response_page_path@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCloudfrontDistributionCustomErrorResponse
    :: TF.Attr s P.Integer -- ^ @error_code@ - 'P.errorCode'
    -> CloudfrontDistributionCustomErrorResponse s
newCloudfrontDistributionCustomErrorResponse _errorCode =
    CloudfrontDistributionCustomErrorResponse'
        { _errorCachingMinTtl = TF.Nil
        , _errorCode = _errorCode
        , _responseCode = TF.Nil
        , _responsePagePath = TF.Nil
        }

instance P.Hashable  (CloudfrontDistributionCustomErrorResponse s)
instance TF.IsValue  (CloudfrontDistributionCustomErrorResponse s)
instance TF.IsObject (CloudfrontDistributionCustomErrorResponse s) where
    toObject CloudfrontDistributionCustomErrorResponse'{..} = P.catMaybes
        [ TF.assign "error_caching_min_ttl" <$> TF.attribute _errorCachingMinTtl
        , TF.assign "error_code" <$> TF.attribute _errorCode
        , TF.assign "response_code" <$> TF.attribute _responseCode
        , TF.assign "response_page_path" <$> TF.attribute _responsePagePath
        ]

instance TF.IsValid (CloudfrontDistributionCustomErrorResponse s) where
    validator = P.mempty

instance P.HasErrorCachingMinTtl (CloudfrontDistributionCustomErrorResponse s) (TF.Attr s P.Integer) where
    errorCachingMinTtl =
        P.lens (_errorCachingMinTtl :: CloudfrontDistributionCustomErrorResponse s -> TF.Attr s P.Integer)
               (\s a -> s { _errorCachingMinTtl = a } :: CloudfrontDistributionCustomErrorResponse s)

instance P.HasErrorCode (CloudfrontDistributionCustomErrorResponse s) (TF.Attr s P.Integer) where
    errorCode =
        P.lens (_errorCode :: CloudfrontDistributionCustomErrorResponse s -> TF.Attr s P.Integer)
               (\s a -> s { _errorCode = a } :: CloudfrontDistributionCustomErrorResponse s)

instance P.HasResponseCode (CloudfrontDistributionCustomErrorResponse s) (TF.Attr s P.Integer) where
    responseCode =
        P.lens (_responseCode :: CloudfrontDistributionCustomErrorResponse s -> TF.Attr s P.Integer)
               (\s a -> s { _responseCode = a } :: CloudfrontDistributionCustomErrorResponse s)

instance P.HasResponsePagePath (CloudfrontDistributionCustomErrorResponse s) (TF.Attr s P.Text) where
    responsePagePath =
        P.lens (_responsePagePath :: CloudfrontDistributionCustomErrorResponse s -> TF.Attr s P.Text)
               (\s a -> s { _responsePagePath = a } :: CloudfrontDistributionCustomErrorResponse s)

-- | @glue_script_dag_edge@ nested settings.
data GlueScriptDagEdge s = GlueScriptDagEdge'
    { _source          :: TF.Attr s P.Text
    -- ^ @source@ - (Required)
    --
    , _target          :: TF.Attr s P.Text
    -- ^ @target@ - (Required)
    --
    , _targetParameter :: TF.Attr s P.Text
    -- ^ @target_parameter@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newGlueScriptDagEdge
    :: TF.Attr s P.Text -- ^ @source@ - 'P.source'
    -> TF.Attr s P.Text -- ^ @target@ - 'P.target'
    -> GlueScriptDagEdge s
newGlueScriptDagEdge _source _target =
    GlueScriptDagEdge'
        { _source = _source
        , _target = _target
        , _targetParameter = TF.Nil
        }

instance P.Hashable  (GlueScriptDagEdge s)
instance TF.IsValue  (GlueScriptDagEdge s)
instance TF.IsObject (GlueScriptDagEdge s) where
    toObject GlueScriptDagEdge'{..} = P.catMaybes
        [ TF.assign "source" <$> TF.attribute _source
        , TF.assign "target" <$> TF.attribute _target
        , TF.assign "target_parameter" <$> TF.attribute _targetParameter
        ]

instance TF.IsValid (GlueScriptDagEdge s) where
    validator = P.mempty

instance P.HasSource (GlueScriptDagEdge s) (TF.Attr s P.Text) where
    source =
        P.lens (_source :: GlueScriptDagEdge s -> TF.Attr s P.Text)
               (\s a -> s { _source = a } :: GlueScriptDagEdge s)

instance P.HasTarget (GlueScriptDagEdge s) (TF.Attr s P.Text) where
    target =
        P.lens (_target :: GlueScriptDagEdge s -> TF.Attr s P.Text)
               (\s a -> s { _target = a } :: GlueScriptDagEdge s)

instance P.HasTargetParameter (GlueScriptDagEdge s) (TF.Attr s P.Text) where
    targetParameter =
        P.lens (_targetParameter :: GlueScriptDagEdge s -> TF.Attr s P.Text)
               (\s a -> s { _targetParameter = a } :: GlueScriptDagEdge s)

-- | @emr_cluster_step@ nested settings.
data EmrClusterStep s = EmrClusterStep'
    { _actionOnFailure :: TF.Attr s P.Text
    -- ^ @action_on_failure@ - (Required, Forces New)
    --
    , _hadoopJarStep   :: TF.Attr s (StepHadoopJarStep s)
    -- ^ @hadoop_jar_step@ - (Required, Forces New)
    --
    , _name            :: TF.Attr s P.Text
    -- ^ @name@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newEmrClusterStep
    :: TF.Attr s P.Text -- ^ @action_on_failure@ - 'P.actionOnFailure'
    -> TF.Attr s (StepHadoopJarStep s) -- ^ @hadoop_jar_step@ - 'P.hadoopJarStep'
    -> TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> EmrClusterStep s
newEmrClusterStep _actionOnFailure _hadoopJarStep _name =
    EmrClusterStep'
        { _actionOnFailure = _actionOnFailure
        , _hadoopJarStep = _hadoopJarStep
        , _name = _name
        }

instance P.Hashable  (EmrClusterStep s)
instance TF.IsValue  (EmrClusterStep s)
instance TF.IsObject (EmrClusterStep s) where
    toObject EmrClusterStep'{..} = P.catMaybes
        [ TF.assign "action_on_failure" <$> TF.attribute _actionOnFailure
        , TF.assign "hadoop_jar_step" <$> TF.attribute _hadoopJarStep
        , TF.assign "name" <$> TF.attribute _name
        ]

instance TF.IsValid (EmrClusterStep s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_hadoopJarStep"
                  (_hadoopJarStep
                      :: EmrClusterStep s -> TF.Attr s (StepHadoopJarStep s))
                  TF.validator

instance P.HasActionOnFailure (EmrClusterStep s) (TF.Attr s P.Text) where
    actionOnFailure =
        P.lens (_actionOnFailure :: EmrClusterStep s -> TF.Attr s P.Text)
               (\s a -> s { _actionOnFailure = a } :: EmrClusterStep s)

instance P.HasHadoopJarStep (EmrClusterStep s) (TF.Attr s (StepHadoopJarStep s)) where
    hadoopJarStep =
        P.lens (_hadoopJarStep :: EmrClusterStep s -> TF.Attr s (StepHadoopJarStep s))
               (\s a -> s { _hadoopJarStep = a } :: EmrClusterStep s)

instance P.HasName (EmrClusterStep s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: EmrClusterStep s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: EmrClusterStep s)

-- | @default_route_table_route@ nested settings.
data DefaultRouteTableRoute s = DefaultRouteTableRoute'
    { _cidrBlock              :: TF.Attr s P.Text
    -- ^ @cidr_block@ - (Optional)
    --
    , _egressOnlyGatewayId    :: TF.Attr s P.Text
    -- ^ @egress_only_gateway_id@ - (Optional)
    --
    , _gatewayId              :: TF.Attr s P.Text
    -- ^ @gateway_id@ - (Optional)
    --
    , _instanceId             :: TF.Attr s P.Text
    -- ^ @instance_id@ - (Optional)
    --
    , _ipv6CidrBlock          :: TF.Attr s P.Text
    -- ^ @ipv6_cidr_block@ - (Optional)
    --
    , _natGatewayId           :: TF.Attr s P.Text
    -- ^ @nat_gateway_id@ - (Optional)
    --
    , _networkInterfaceId     :: TF.Attr s P.Text
    -- ^ @network_interface_id@ - (Optional)
    --
    , _vpcPeeringConnectionId :: TF.Attr s P.Text
    -- ^ @vpc_peering_connection_id@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDefaultRouteTableRoute
    :: DefaultRouteTableRoute s
newDefaultRouteTableRoute =
    DefaultRouteTableRoute'
        { _cidrBlock = TF.Nil
        , _egressOnlyGatewayId = TF.Nil
        , _gatewayId = TF.Nil
        , _instanceId = TF.Nil
        , _ipv6CidrBlock = TF.Nil
        , _natGatewayId = TF.Nil
        , _networkInterfaceId = TF.Nil
        , _vpcPeeringConnectionId = TF.Nil
        }

instance P.Hashable  (DefaultRouteTableRoute s)
instance TF.IsValue  (DefaultRouteTableRoute s)
instance TF.IsObject (DefaultRouteTableRoute s) where
    toObject DefaultRouteTableRoute'{..} = P.catMaybes
        [ TF.assign "cidr_block" <$> TF.attribute _cidrBlock
        , TF.assign "egress_only_gateway_id" <$> TF.attribute _egressOnlyGatewayId
        , TF.assign "gateway_id" <$> TF.attribute _gatewayId
        , TF.assign "instance_id" <$> TF.attribute _instanceId
        , TF.assign "ipv6_cidr_block" <$> TF.attribute _ipv6CidrBlock
        , TF.assign "nat_gateway_id" <$> TF.attribute _natGatewayId
        , TF.assign "network_interface_id" <$> TF.attribute _networkInterfaceId
        , TF.assign "vpc_peering_connection_id" <$> TF.attribute _vpcPeeringConnectionId
        ]

instance TF.IsValid (DefaultRouteTableRoute s) where
    validator = P.mempty

instance P.HasCidrBlock (DefaultRouteTableRoute s) (TF.Attr s P.Text) where
    cidrBlock =
        P.lens (_cidrBlock :: DefaultRouteTableRoute s -> TF.Attr s P.Text)
               (\s a -> s { _cidrBlock = a } :: DefaultRouteTableRoute s)

instance P.HasEgressOnlyGatewayId (DefaultRouteTableRoute s) (TF.Attr s P.Text) where
    egressOnlyGatewayId =
        P.lens (_egressOnlyGatewayId :: DefaultRouteTableRoute s -> TF.Attr s P.Text)
               (\s a -> s { _egressOnlyGatewayId = a } :: DefaultRouteTableRoute s)

instance P.HasGatewayId (DefaultRouteTableRoute s) (TF.Attr s P.Text) where
    gatewayId =
        P.lens (_gatewayId :: DefaultRouteTableRoute s -> TF.Attr s P.Text)
               (\s a -> s { _gatewayId = a } :: DefaultRouteTableRoute s)

instance P.HasInstanceId (DefaultRouteTableRoute s) (TF.Attr s P.Text) where
    instanceId =
        P.lens (_instanceId :: DefaultRouteTableRoute s -> TF.Attr s P.Text)
               (\s a -> s { _instanceId = a } :: DefaultRouteTableRoute s)

instance P.HasIpv6CidrBlock (DefaultRouteTableRoute s) (TF.Attr s P.Text) where
    ipv6CidrBlock =
        P.lens (_ipv6CidrBlock :: DefaultRouteTableRoute s -> TF.Attr s P.Text)
               (\s a -> s { _ipv6CidrBlock = a } :: DefaultRouteTableRoute s)

instance P.HasNatGatewayId (DefaultRouteTableRoute s) (TF.Attr s P.Text) where
    natGatewayId =
        P.lens (_natGatewayId :: DefaultRouteTableRoute s -> TF.Attr s P.Text)
               (\s a -> s { _natGatewayId = a } :: DefaultRouteTableRoute s)

instance P.HasNetworkInterfaceId (DefaultRouteTableRoute s) (TF.Attr s P.Text) where
    networkInterfaceId =
        P.lens (_networkInterfaceId :: DefaultRouteTableRoute s -> TF.Attr s P.Text)
               (\s a -> s { _networkInterfaceId = a } :: DefaultRouteTableRoute s)

instance P.HasVpcPeeringConnectionId (DefaultRouteTableRoute s) (TF.Attr s P.Text) where
    vpcPeeringConnectionId =
        P.lens (_vpcPeeringConnectionId :: DefaultRouteTableRoute s -> TF.Attr s P.Text)
               (\s a -> s { _vpcPeeringConnectionId = a } :: DefaultRouteTableRoute s)

-- | @lb_target_group_health_check@ nested settings.
data LbTargetGroupHealthCheck s = LbTargetGroupHealthCheck'
    { _healthyThreshold   :: TF.Attr s P.Integer
    -- ^ @healthy_threshold@ - (Optional)
    --
    , _interval           :: TF.Attr s P.Integer
    -- ^ @interval@ - (Optional)
    --
    , _port               :: TF.Attr s P.Text
    -- ^ @port@ - (Optional)
    --
    , _protocol           :: TF.Attr s P.Text
    -- ^ @protocol@ - (Optional)
    --
    , _unhealthyThreshold :: TF.Attr s P.Integer
    -- ^ @unhealthy_threshold@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLbTargetGroupHealthCheck
    :: LbTargetGroupHealthCheck s
newLbTargetGroupHealthCheck =
    LbTargetGroupHealthCheck'
        { _healthyThreshold = TF.value 3
        , _interval = TF.value 30
        , _port = TF.value "traffic-port"
        , _protocol = TF.value "HTTP"
        , _unhealthyThreshold = TF.value 3
        }

instance P.Hashable  (LbTargetGroupHealthCheck s)
instance TF.IsValue  (LbTargetGroupHealthCheck s)
instance TF.IsObject (LbTargetGroupHealthCheck s) where
    toObject LbTargetGroupHealthCheck'{..} = P.catMaybes
        [ TF.assign "healthy_threshold" <$> TF.attribute _healthyThreshold
        , TF.assign "interval" <$> TF.attribute _interval
        , TF.assign "port" <$> TF.attribute _port
        , TF.assign "protocol" <$> TF.attribute _protocol
        , TF.assign "unhealthy_threshold" <$> TF.attribute _unhealthyThreshold
        ]

instance TF.IsValid (LbTargetGroupHealthCheck s) where
    validator = P.mempty

instance P.HasHealthyThreshold (LbTargetGroupHealthCheck s) (TF.Attr s P.Integer) where
    healthyThreshold =
        P.lens (_healthyThreshold :: LbTargetGroupHealthCheck s -> TF.Attr s P.Integer)
               (\s a -> s { _healthyThreshold = a } :: LbTargetGroupHealthCheck s)

instance P.HasInterval (LbTargetGroupHealthCheck s) (TF.Attr s P.Integer) where
    interval =
        P.lens (_interval :: LbTargetGroupHealthCheck s -> TF.Attr s P.Integer)
               (\s a -> s { _interval = a } :: LbTargetGroupHealthCheck s)

instance P.HasPort (LbTargetGroupHealthCheck s) (TF.Attr s P.Text) where
    port =
        P.lens (_port :: LbTargetGroupHealthCheck s -> TF.Attr s P.Text)
               (\s a -> s { _port = a } :: LbTargetGroupHealthCheck s)

instance P.HasProtocol (LbTargetGroupHealthCheck s) (TF.Attr s P.Text) where
    protocol =
        P.lens (_protocol :: LbTargetGroupHealthCheck s -> TF.Attr s P.Text)
               (\s a -> s { _protocol = a } :: LbTargetGroupHealthCheck s)

instance P.HasUnhealthyThreshold (LbTargetGroupHealthCheck s) (TF.Attr s P.Integer) where
    unhealthyThreshold =
        P.lens (_unhealthyThreshold :: LbTargetGroupHealthCheck s -> TF.Attr s P.Integer)
               (\s a -> s { _unhealthyThreshold = a } :: LbTargetGroupHealthCheck s)

instance s ~ s' => P.HasComputedMatcher (TF.Ref s' (LbTargetGroupHealthCheck s)) (TF.Attr s P.Text) where
    computedMatcher x = TF.compute (TF.refKey x) "matcher"

instance s ~ s' => P.HasComputedPath (TF.Ref s' (LbTargetGroupHealthCheck s)) (TF.Attr s P.Text) where
    computedPath x = TF.compute (TF.refKey x) "path"

instance s ~ s' => P.HasComputedTimeout (TF.Ref s' (LbTargetGroupHealthCheck s)) (TF.Attr s P.Integer) where
    computedTimeout x = TF.compute (TF.refKey x) "timeout"

instance s ~ s' => P.HasComputedHealthyThreshold (TF.Ref s' (LbTargetGroupHealthCheck s)) (TF.Attr s P.Integer) where
    computedHealthyThreshold x = TF.compute (TF.refKey x) "healthy_threshold"

instance s ~ s' => P.HasComputedInterval (TF.Ref s' (LbTargetGroupHealthCheck s)) (TF.Attr s P.Integer) where
    computedInterval x = TF.compute (TF.refKey x) "interval"

instance s ~ s' => P.HasComputedPort (TF.Ref s' (LbTargetGroupHealthCheck s)) (TF.Attr s P.Text) where
    computedPort x = TF.compute (TF.refKey x) "port"

instance s ~ s' => P.HasComputedProtocol (TF.Ref s' (LbTargetGroupHealthCheck s)) (TF.Attr s P.Text) where
    computedProtocol x = TF.compute (TF.refKey x) "protocol"

instance s ~ s' => P.HasComputedUnhealthyThreshold (TF.Ref s' (LbTargetGroupHealthCheck s)) (TF.Attr s P.Integer) where
    computedUnhealthyThreshold x = TF.compute (TF.refKey x) "unhealthy_threshold"

-- | @launch_template_credit_specification@ nested settings.
data LaunchTemplateCreditSpecification s = LaunchTemplateCreditSpecification'
    { _cpuCredits :: TF.Attr s P.Text
    -- ^ @cpu_credits@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLaunchTemplateCreditSpecification
    :: LaunchTemplateCreditSpecification s
newLaunchTemplateCreditSpecification =
    LaunchTemplateCreditSpecification'
        { _cpuCredits = TF.Nil
        }

instance P.Hashable  (LaunchTemplateCreditSpecification s)
instance TF.IsValue  (LaunchTemplateCreditSpecification s)
instance TF.IsObject (LaunchTemplateCreditSpecification s) where
    toObject LaunchTemplateCreditSpecification'{..} = P.catMaybes
        [ TF.assign "cpu_credits" <$> TF.attribute _cpuCredits
        ]

instance TF.IsValid (LaunchTemplateCreditSpecification s) where
    validator = P.mempty

instance P.HasCpuCredits (LaunchTemplateCreditSpecification s) (TF.Attr s P.Text) where
    cpuCredits =
        P.lens (_cpuCredits :: LaunchTemplateCreditSpecification s -> TF.Attr s P.Text)
               (\s a -> s { _cpuCredits = a } :: LaunchTemplateCreditSpecification s)

-- | @emr_instance_group_ebs_config@ nested settings.
data EmrInstanceGroupEbsConfig s = EmrInstanceGroupEbsConfig'
    { _iops               :: TF.Attr s P.Integer
    -- ^ @iops@ - (Optional)
    --
    , _size               :: TF.Attr s P.Integer
    -- ^ @size@ - (Required)
    --
    , _type'              :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    , _volumesPerInstance :: TF.Attr s P.Integer
    -- ^ @volumes_per_instance@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newEmrInstanceGroupEbsConfig
    :: TF.Attr s P.Integer -- ^ @size@ - 'P.size'
    -> TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> EmrInstanceGroupEbsConfig s
newEmrInstanceGroupEbsConfig _size _type' =
    EmrInstanceGroupEbsConfig'
        { _iops = TF.Nil
        , _size = _size
        , _type' = _type'
        , _volumesPerInstance = TF.Nil
        }

instance P.Hashable  (EmrInstanceGroupEbsConfig s)
instance TF.IsValue  (EmrInstanceGroupEbsConfig s)
instance TF.IsObject (EmrInstanceGroupEbsConfig s) where
    toObject EmrInstanceGroupEbsConfig'{..} = P.catMaybes
        [ TF.assign "iops" <$> TF.attribute _iops
        , TF.assign "size" <$> TF.attribute _size
        , TF.assign "type" <$> TF.attribute _type'
        , TF.assign "volumes_per_instance" <$> TF.attribute _volumesPerInstance
        ]

instance TF.IsValid (EmrInstanceGroupEbsConfig s) where
    validator = P.mempty

instance P.HasIops (EmrInstanceGroupEbsConfig s) (TF.Attr s P.Integer) where
    iops =
        P.lens (_iops :: EmrInstanceGroupEbsConfig s -> TF.Attr s P.Integer)
               (\s a -> s { _iops = a } :: EmrInstanceGroupEbsConfig s)

instance P.HasSize (EmrInstanceGroupEbsConfig s) (TF.Attr s P.Integer) where
    size =
        P.lens (_size :: EmrInstanceGroupEbsConfig s -> TF.Attr s P.Integer)
               (\s a -> s { _size = a } :: EmrInstanceGroupEbsConfig s)

instance P.HasType' (EmrInstanceGroupEbsConfig s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: EmrInstanceGroupEbsConfig s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: EmrInstanceGroupEbsConfig s)

instance P.HasVolumesPerInstance (EmrInstanceGroupEbsConfig s) (TF.Attr s P.Integer) where
    volumesPerInstance =
        P.lens (_volumesPerInstance :: EmrInstanceGroupEbsConfig s -> TF.Attr s P.Integer)
               (\s a -> s { _volumesPerInstance = a } :: EmrInstanceGroupEbsConfig s)

-- | @acmpca_certificate_authority_certificate_authority_configuration@ nested settings.
data AcmpcaCertificateAuthorityCertificateAuthorityConfiguration s = AcmpcaCertificateAuthorityCertificateAuthorityConfiguration'
    { _keyAlgorithm :: TF.Attr s P.Text
    -- ^ @key_algorithm@ - (Required, Forces New)
    --
    , _signingAlgorithm :: TF.Attr s P.Text
    -- ^ @signing_algorithm@ - (Required, Forces New)
    --
    , _subject :: TF.Attr s (CertificateAuthorityConfigurationSubject s)
    -- ^ @subject@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAcmpcaCertificateAuthorityCertificateAuthorityConfiguration
    :: TF.Attr s P.Text -- ^ @key_algorithm@ - 'P.keyAlgorithm'
    -> TF.Attr s P.Text -- ^ @signing_algorithm@ - 'P.signingAlgorithm'
    -> TF.Attr s (CertificateAuthorityConfigurationSubject s) -- ^ @subject@ - 'P.subject'
    -> AcmpcaCertificateAuthorityCertificateAuthorityConfiguration s
newAcmpcaCertificateAuthorityCertificateAuthorityConfiguration _keyAlgorithm _signingAlgorithm _subject =
    AcmpcaCertificateAuthorityCertificateAuthorityConfiguration'
        { _keyAlgorithm = _keyAlgorithm
        , _signingAlgorithm = _signingAlgorithm
        , _subject = _subject
        }

instance P.Hashable  (AcmpcaCertificateAuthorityCertificateAuthorityConfiguration s)
instance TF.IsValue  (AcmpcaCertificateAuthorityCertificateAuthorityConfiguration s)
instance TF.IsObject (AcmpcaCertificateAuthorityCertificateAuthorityConfiguration s) where
    toObject AcmpcaCertificateAuthorityCertificateAuthorityConfiguration'{..} = P.catMaybes
        [ TF.assign "key_algorithm" <$> TF.attribute _keyAlgorithm
        , TF.assign "signing_algorithm" <$> TF.attribute _signingAlgorithm
        , TF.assign "subject" <$> TF.attribute _subject
        ]

instance TF.IsValid (AcmpcaCertificateAuthorityCertificateAuthorityConfiguration s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_subject"
                  (_subject
                      :: AcmpcaCertificateAuthorityCertificateAuthorityConfiguration s -> TF.Attr s (CertificateAuthorityConfigurationSubject s))
                  TF.validator

instance P.HasKeyAlgorithm (AcmpcaCertificateAuthorityCertificateAuthorityConfiguration s) (TF.Attr s P.Text) where
    keyAlgorithm =
        P.lens (_keyAlgorithm :: AcmpcaCertificateAuthorityCertificateAuthorityConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _keyAlgorithm = a } :: AcmpcaCertificateAuthorityCertificateAuthorityConfiguration s)

instance P.HasSigningAlgorithm (AcmpcaCertificateAuthorityCertificateAuthorityConfiguration s) (TF.Attr s P.Text) where
    signingAlgorithm =
        P.lens (_signingAlgorithm :: AcmpcaCertificateAuthorityCertificateAuthorityConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _signingAlgorithm = a } :: AcmpcaCertificateAuthorityCertificateAuthorityConfiguration s)

instance P.HasSubject (AcmpcaCertificateAuthorityCertificateAuthorityConfiguration s) (TF.Attr s (CertificateAuthorityConfigurationSubject s)) where
    subject =
        P.lens (_subject :: AcmpcaCertificateAuthorityCertificateAuthorityConfiguration s -> TF.Attr s (CertificateAuthorityConfigurationSubject s))
               (\s a -> s { _subject = a } :: AcmpcaCertificateAuthorityCertificateAuthorityConfiguration s)

-- | @encryption_sse_s3@ nested settings.
data EncryptionSseS3 s = EncryptionSseS3'
    deriving (P.Show, P.Eq, P.Generic)

newEncryptionSseS3
    :: EncryptionSseS3 s
newEncryptionSseS3 =
    EncryptionSseS3'

instance P.Hashable  (EncryptionSseS3 s)
instance TF.IsValue  (EncryptionSseS3 s)
instance TF.IsObject (EncryptionSseS3 s) where
    toObject EncryptionSseS3' = []

instance TF.IsValid (EncryptionSseS3 s) where
    validator = P.mempty

-- | @security_groups_filter@ nested settings.
data SecurityGroupsFilter s = SecurityGroupsFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSecurityGroupsFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> SecurityGroupsFilter s
newSecurityGroupsFilter _name _values =
    SecurityGroupsFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (SecurityGroupsFilter s)
instance TF.IsValue  (SecurityGroupsFilter s)
instance TF.IsObject (SecurityGroupsFilter s) where
    toObject SecurityGroupsFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (SecurityGroupsFilter s) where
    validator = P.mempty

instance P.HasName (SecurityGroupsFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: SecurityGroupsFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: SecurityGroupsFilter s)

instance P.HasValues (SecurityGroupsFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: SecurityGroupsFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: SecurityGroupsFilter s)

-- | @redshift_cluster_logging@ nested settings.
data RedshiftClusterLogging s = RedshiftClusterLogging'
    { _enable :: TF.Attr s P.Bool
    -- ^ @enable@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRedshiftClusterLogging
    :: TF.Attr s P.Bool -- ^ @enable@ - 'P.enable'
    -> RedshiftClusterLogging s
newRedshiftClusterLogging _enable =
    RedshiftClusterLogging'
        { _enable = _enable
        }

instance P.Hashable  (RedshiftClusterLogging s)
instance TF.IsValue  (RedshiftClusterLogging s)
instance TF.IsObject (RedshiftClusterLogging s) where
    toObject RedshiftClusterLogging'{..} = P.catMaybes
        [ TF.assign "enable" <$> TF.attribute _enable
        ]

instance TF.IsValid (RedshiftClusterLogging s) where
    validator = P.mempty

instance P.HasEnable (RedshiftClusterLogging s) (TF.Attr s P.Bool) where
    enable =
        P.lens (_enable :: RedshiftClusterLogging s -> TF.Attr s P.Bool)
               (\s a -> s { _enable = a } :: RedshiftClusterLogging s)

instance s ~ s' => P.HasComputedBucketName (TF.Ref s' (RedshiftClusterLogging s)) (TF.Attr s P.Text) where
    computedBucketName x = TF.compute (TF.refKey x) "bucket_name"

instance s ~ s' => P.HasComputedS3KeyPrefix (TF.Ref s' (RedshiftClusterLogging s)) (TF.Attr s P.Text) where
    computedS3KeyPrefix x = TF.compute (TF.refKey x) "s3_key_prefix"

-- | @wafregional_rule_predicate@ nested settings.
data WafregionalRulePredicate s = WafregionalRulePredicate'
    { _dataId  :: TF.Attr s P.Text
    -- ^ @data_id@ - (Required)
    --
    , _negated :: TF.Attr s P.Bool
    -- ^ @negated@ - (Required)
    --
    , _type'   :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafregionalRulePredicate
    :: TF.Attr s P.Text -- ^ @data_id@ - 'P.dataId'
    -> TF.Attr s P.Bool -- ^ @negated@ - 'P.negated'
    -> TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> WafregionalRulePredicate s
newWafregionalRulePredicate _dataId _negated _type' =
    WafregionalRulePredicate'
        { _dataId = _dataId
        , _negated = _negated
        , _type' = _type'
        }

instance P.Hashable  (WafregionalRulePredicate s)
instance TF.IsValue  (WafregionalRulePredicate s)
instance TF.IsObject (WafregionalRulePredicate s) where
    toObject WafregionalRulePredicate'{..} = P.catMaybes
        [ TF.assign "data_id" <$> TF.attribute _dataId
        , TF.assign "negated" <$> TF.attribute _negated
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (WafregionalRulePredicate s) where
    validator = P.mempty

instance P.HasDataId (WafregionalRulePredicate s) (TF.Attr s P.Text) where
    dataId =
        P.lens (_dataId :: WafregionalRulePredicate s -> TF.Attr s P.Text)
               (\s a -> s { _dataId = a } :: WafregionalRulePredicate s)

instance P.HasNegated (WafregionalRulePredicate s) (TF.Attr s P.Bool) where
    negated =
        P.lens (_negated :: WafregionalRulePredicate s -> TF.Attr s P.Bool)
               (\s a -> s { _negated = a } :: WafregionalRulePredicate s)

instance P.HasType' (WafregionalRulePredicate s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: WafregionalRulePredicate s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: WafregionalRulePredicate s)

-- | @vpc_filter@ nested settings.
data VpcFilter s = VpcFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newVpcFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> VpcFilter s
newVpcFilter _name _values =
    VpcFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (VpcFilter s)
instance TF.IsValue  (VpcFilter s)
instance TF.IsObject (VpcFilter s) where
    toObject VpcFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (VpcFilter s) where
    validator = P.mempty

instance P.HasName (VpcFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: VpcFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: VpcFilter s)

instance P.HasValues (VpcFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: VpcFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: VpcFilter s)

-- | @redshift_security_group_ingress@ nested settings.
data RedshiftSecurityGroupIngress s = RedshiftSecurityGroupIngress'
    { _cidr :: TF.Attr s P.Text
    -- ^ @cidr@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRedshiftSecurityGroupIngress
    :: RedshiftSecurityGroupIngress s
newRedshiftSecurityGroupIngress =
    RedshiftSecurityGroupIngress'
        { _cidr = TF.Nil
        }

instance P.Hashable  (RedshiftSecurityGroupIngress s)
instance TF.IsValue  (RedshiftSecurityGroupIngress s)
instance TF.IsObject (RedshiftSecurityGroupIngress s) where
    toObject RedshiftSecurityGroupIngress'{..} = P.catMaybes
        [ TF.assign "cidr" <$> TF.attribute _cidr
        ]

instance TF.IsValid (RedshiftSecurityGroupIngress s) where
    validator = P.mempty

instance P.HasCidr (RedshiftSecurityGroupIngress s) (TF.Attr s P.Text) where
    cidr =
        P.lens (_cidr :: RedshiftSecurityGroupIngress s -> TF.Attr s P.Text)
               (\s a -> s { _cidr = a } :: RedshiftSecurityGroupIngress s)

instance s ~ s' => P.HasComputedSecurityGroupName (TF.Ref s' (RedshiftSecurityGroupIngress s)) (TF.Attr s P.Text) where
    computedSecurityGroupName x = TF.compute (TF.refKey x) "security_group_name"

instance s ~ s' => P.HasComputedSecurityGroupOwnerId (TF.Ref s' (RedshiftSecurityGroupIngress s)) (TF.Attr s P.Text) where
    computedSecurityGroupOwnerId x = TF.compute (TF.refKey x) "security_group_owner_id"

-- | @opsworks_instance_ebs_block_device@ nested settings.
data OpsworksInstanceEbsBlockDevice s = OpsworksInstanceEbsBlockDevice'
    { _deleteOnTermination :: TF.Attr s P.Bool
    -- ^ @delete_on_termination@ - (Optional, Forces New)
    --
    , _deviceName          :: TF.Attr s P.Text
    -- ^ @device_name@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newOpsworksInstanceEbsBlockDevice
    :: TF.Attr s P.Text -- ^ @device_name@ - 'P.deviceName'
    -> OpsworksInstanceEbsBlockDevice s
newOpsworksInstanceEbsBlockDevice _deviceName =
    OpsworksInstanceEbsBlockDevice'
        { _deleteOnTermination = TF.value P.True
        , _deviceName = _deviceName
        }

instance P.Hashable  (OpsworksInstanceEbsBlockDevice s)
instance TF.IsValue  (OpsworksInstanceEbsBlockDevice s)
instance TF.IsObject (OpsworksInstanceEbsBlockDevice s) where
    toObject OpsworksInstanceEbsBlockDevice'{..} = P.catMaybes
        [ TF.assign "delete_on_termination" <$> TF.attribute _deleteOnTermination
        , TF.assign "device_name" <$> TF.attribute _deviceName
        ]

instance TF.IsValid (OpsworksInstanceEbsBlockDevice s) where
    validator = P.mempty

instance P.HasDeleteOnTermination (OpsworksInstanceEbsBlockDevice s) (TF.Attr s P.Bool) where
    deleteOnTermination =
        P.lens (_deleteOnTermination :: OpsworksInstanceEbsBlockDevice s -> TF.Attr s P.Bool)
               (\s a -> s { _deleteOnTermination = a } :: OpsworksInstanceEbsBlockDevice s)

instance P.HasDeviceName (OpsworksInstanceEbsBlockDevice s) (TF.Attr s P.Text) where
    deviceName =
        P.lens (_deviceName :: OpsworksInstanceEbsBlockDevice s -> TF.Attr s P.Text)
               (\s a -> s { _deviceName = a } :: OpsworksInstanceEbsBlockDevice s)

instance s ~ s' => P.HasComputedIops (TF.Ref s' (OpsworksInstanceEbsBlockDevice s)) (TF.Attr s P.Integer) where
    computedIops x = TF.compute (TF.refKey x) "iops"

instance s ~ s' => P.HasComputedSnapshotId (TF.Ref s' (OpsworksInstanceEbsBlockDevice s)) (TF.Attr s P.Text) where
    computedSnapshotId x = TF.compute (TF.refKey x) "snapshot_id"

instance s ~ s' => P.HasComputedVolumeSize (TF.Ref s' (OpsworksInstanceEbsBlockDevice s)) (TF.Attr s P.Integer) where
    computedVolumeSize x = TF.compute (TF.refKey x) "volume_size"

instance s ~ s' => P.HasComputedVolumeType (TF.Ref s' (OpsworksInstanceEbsBlockDevice s)) (TF.Attr s P.Text) where
    computedVolumeType x = TF.compute (TF.refKey x) "volume_type"

-- | @elb_listener@ nested settings.
data ElbListener s = ElbListener'
    { _instancePort     :: TF.Attr s P.Integer
    -- ^ @instance_port@ - (Required)
    --
    , _instanceProtocol :: TF.Attr s P.Text
    -- ^ @instance_protocol@ - (Required)
    --
    , _lbPort           :: TF.Attr s P.Integer
    -- ^ @lb_port@ - (Required)
    --
    , _lbProtocol       :: TF.Attr s P.Text
    -- ^ @lb_protocol@ - (Required)
    --
    , _sslCertificateId :: TF.Attr s P.Text
    -- ^ @ssl_certificate_id@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElbListener
    :: TF.Attr s P.Integer -- ^ @instance_port@ - 'P.instancePort'
    -> TF.Attr s P.Text -- ^ @instance_protocol@ - 'P.instanceProtocol'
    -> TF.Attr s P.Integer -- ^ @lb_port@ - 'P.lbPort'
    -> TF.Attr s P.Text -- ^ @lb_protocol@ - 'P.lbProtocol'
    -> ElbListener s
newElbListener _instancePort _instanceProtocol _lbPort _lbProtocol =
    ElbListener'
        { _instancePort = _instancePort
        , _instanceProtocol = _instanceProtocol
        , _lbPort = _lbPort
        , _lbProtocol = _lbProtocol
        , _sslCertificateId = TF.Nil
        }

instance P.Hashable  (ElbListener s)
instance TF.IsValue  (ElbListener s)
instance TF.IsObject (ElbListener s) where
    toObject ElbListener'{..} = P.catMaybes
        [ TF.assign "instance_port" <$> TF.attribute _instancePort
        , TF.assign "instance_protocol" <$> TF.attribute _instanceProtocol
        , TF.assign "lb_port" <$> TF.attribute _lbPort
        , TF.assign "lb_protocol" <$> TF.attribute _lbProtocol
        , TF.assign "ssl_certificate_id" <$> TF.attribute _sslCertificateId
        ]

instance TF.IsValid (ElbListener s) where
    validator = P.mempty

instance P.HasInstancePort (ElbListener s) (TF.Attr s P.Integer) where
    instancePort =
        P.lens (_instancePort :: ElbListener s -> TF.Attr s P.Integer)
               (\s a -> s { _instancePort = a } :: ElbListener s)

instance P.HasInstanceProtocol (ElbListener s) (TF.Attr s P.Text) where
    instanceProtocol =
        P.lens (_instanceProtocol :: ElbListener s -> TF.Attr s P.Text)
               (\s a -> s { _instanceProtocol = a } :: ElbListener s)

instance P.HasLbPort (ElbListener s) (TF.Attr s P.Integer) where
    lbPort =
        P.lens (_lbPort :: ElbListener s -> TF.Attr s P.Integer)
               (\s a -> s { _lbPort = a } :: ElbListener s)

instance P.HasLbProtocol (ElbListener s) (TF.Attr s P.Text) where
    lbProtocol =
        P.lens (_lbProtocol :: ElbListener s -> TF.Attr s P.Text)
               (\s a -> s { _lbProtocol = a } :: ElbListener s)

instance P.HasSslCertificateId (ElbListener s) (TF.Attr s P.Text) where
    sslCertificateId =
        P.lens (_sslCertificateId :: ElbListener s -> TF.Attr s P.Text)
               (\s a -> s { _sslCertificateId = a } :: ElbListener s)

instance s ~ s' => P.HasComputedInstancePort (TF.Ref s' (ElbListener s)) (TF.Attr s P.Integer) where
    computedInstancePort x = TF.compute (TF.refKey x) "instance_port"

instance s ~ s' => P.HasComputedInstanceProtocol (TF.Ref s' (ElbListener s)) (TF.Attr s P.Text) where
    computedInstanceProtocol x = TF.compute (TF.refKey x) "instance_protocol"

instance s ~ s' => P.HasComputedLbPort (TF.Ref s' (ElbListener s)) (TF.Attr s P.Integer) where
    computedLbPort x = TF.compute (TF.refKey x) "lb_port"

instance s ~ s' => P.HasComputedLbProtocol (TF.Ref s' (ElbListener s)) (TF.Attr s P.Text) where
    computedLbProtocol x = TF.compute (TF.refKey x) "lb_protocol"

instance s ~ s' => P.HasComputedSslCertificateId (TF.Ref s' (ElbListener s)) (TF.Attr s P.Text) where
    computedSslCertificateId x = TF.compute (TF.refKey x) "ssl_certificate_id"

-- | @codedeploy_deployment_config_minimum_healthy_hosts@ nested settings.
data CodedeployDeploymentConfigMinimumHealthyHosts s = CodedeployDeploymentConfigMinimumHealthyHosts'
    { _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required, Forces New)
    --
    , _value :: TF.Attr s P.Integer
    -- ^ @value@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCodedeployDeploymentConfigMinimumHealthyHosts
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> CodedeployDeploymentConfigMinimumHealthyHosts s
newCodedeployDeploymentConfigMinimumHealthyHosts _type' =
    CodedeployDeploymentConfigMinimumHealthyHosts'
        { _type' = _type'
        , _value = TF.Nil
        }

instance P.Hashable  (CodedeployDeploymentConfigMinimumHealthyHosts s)
instance TF.IsValue  (CodedeployDeploymentConfigMinimumHealthyHosts s)
instance TF.IsObject (CodedeployDeploymentConfigMinimumHealthyHosts s) where
    toObject CodedeployDeploymentConfigMinimumHealthyHosts'{..} = P.catMaybes
        [ TF.assign "type" <$> TF.attribute _type'
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (CodedeployDeploymentConfigMinimumHealthyHosts s) where
    validator = P.mempty

instance P.HasType' (CodedeployDeploymentConfigMinimumHealthyHosts s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: CodedeployDeploymentConfigMinimumHealthyHosts s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: CodedeployDeploymentConfigMinimumHealthyHosts s)

instance P.HasValue (CodedeployDeploymentConfigMinimumHealthyHosts s) (TF.Attr s P.Integer) where
    value =
        P.lens (_value :: CodedeployDeploymentConfigMinimumHealthyHosts s -> TF.Attr s P.Integer)
               (\s a -> s { _value = a } :: CodedeployDeploymentConfigMinimumHealthyHosts s)

-- | @glue_connection_physical_connection_requirements@ nested settings.
data GlueConnectionPhysicalConnectionRequirements s = GlueConnectionPhysicalConnectionRequirements'
    { _availabilityZone    :: TF.Attr s P.Zone
    -- ^ @availability_zone@ - (Optional)
    --
    , _securityGroupIdList :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @security_group_id_list@ - (Optional)
    --
    , _subnetId            :: TF.Attr s P.Text
    -- ^ @subnet_id@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newGlueConnectionPhysicalConnectionRequirements
    :: GlueConnectionPhysicalConnectionRequirements s
newGlueConnectionPhysicalConnectionRequirements =
    GlueConnectionPhysicalConnectionRequirements'
        { _availabilityZone = TF.Nil
        , _securityGroupIdList = TF.Nil
        , _subnetId = TF.Nil
        }

instance P.Hashable  (GlueConnectionPhysicalConnectionRequirements s)
instance TF.IsValue  (GlueConnectionPhysicalConnectionRequirements s)
instance TF.IsObject (GlueConnectionPhysicalConnectionRequirements s) where
    toObject GlueConnectionPhysicalConnectionRequirements'{..} = P.catMaybes
        [ TF.assign "availability_zone" <$> TF.attribute _availabilityZone
        , TF.assign "security_group_id_list" <$> TF.attribute _securityGroupIdList
        , TF.assign "subnet_id" <$> TF.attribute _subnetId
        ]

instance TF.IsValid (GlueConnectionPhysicalConnectionRequirements s) where
    validator = P.mempty

instance P.HasAvailabilityZone (GlueConnectionPhysicalConnectionRequirements s) (TF.Attr s P.Zone) where
    availabilityZone =
        P.lens (_availabilityZone :: GlueConnectionPhysicalConnectionRequirements s -> TF.Attr s P.Zone)
               (\s a -> s { _availabilityZone = a } :: GlueConnectionPhysicalConnectionRequirements s)

instance P.HasSecurityGroupIdList (GlueConnectionPhysicalConnectionRequirements s) (TF.Attr s [TF.Attr s P.Text]) where
    securityGroupIdList =
        P.lens (_securityGroupIdList :: GlueConnectionPhysicalConnectionRequirements s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _securityGroupIdList = a } :: GlueConnectionPhysicalConnectionRequirements s)

instance P.HasSubnetId (GlueConnectionPhysicalConnectionRequirements s) (TF.Attr s P.Text) where
    subnetId =
        P.lens (_subnetId :: GlueConnectionPhysicalConnectionRequirements s -> TF.Attr s P.Text)
               (\s a -> s { _subnetId = a } :: GlueConnectionPhysicalConnectionRequirements s)

-- | @opsworks_ganglia_layer_ebs_volume@ nested settings.
data OpsworksGangliaLayerEbsVolume s = OpsworksGangliaLayerEbsVolume'
    { _iops          :: TF.Attr s P.Integer
    -- ^ @iops@ - (Optional)
    --
    , _mountPoint    :: TF.Attr s P.Text
    -- ^ @mount_point@ - (Required)
    --
    , _numberOfDisks :: TF.Attr s P.Integer
    -- ^ @number_of_disks@ - (Required)
    --
    , _raidLevel     :: TF.Attr s P.Text
    -- ^ @raid_level@ - (Optional)
    --
    , _size          :: TF.Attr s P.Integer
    -- ^ @size@ - (Required)
    --
    , _type'         :: TF.Attr s P.Text
    -- ^ @type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newOpsworksGangliaLayerEbsVolume
    :: TF.Attr s P.Text -- ^ @mount_point@ - 'P.mountPoint'
    -> TF.Attr s P.Integer -- ^ @number_of_disks@ - 'P.numberOfDisks'
    -> TF.Attr s P.Integer -- ^ @size@ - 'P.size'
    -> OpsworksGangliaLayerEbsVolume s
newOpsworksGangliaLayerEbsVolume _mountPoint _numberOfDisks _size =
    OpsworksGangliaLayerEbsVolume'
        { _iops = TF.value 0
        , _mountPoint = _mountPoint
        , _numberOfDisks = _numberOfDisks
        , _raidLevel = TF.Nil
        , _size = _size
        , _type' = TF.value "standard"
        }

instance P.Hashable  (OpsworksGangliaLayerEbsVolume s)
instance TF.IsValue  (OpsworksGangliaLayerEbsVolume s)
instance TF.IsObject (OpsworksGangliaLayerEbsVolume s) where
    toObject OpsworksGangliaLayerEbsVolume'{..} = P.catMaybes
        [ TF.assign "iops" <$> TF.attribute _iops
        , TF.assign "mount_point" <$> TF.attribute _mountPoint
        , TF.assign "number_of_disks" <$> TF.attribute _numberOfDisks
        , TF.assign "raid_level" <$> TF.attribute _raidLevel
        , TF.assign "size" <$> TF.attribute _size
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (OpsworksGangliaLayerEbsVolume s) where
    validator = P.mempty

instance P.HasIops (OpsworksGangliaLayerEbsVolume s) (TF.Attr s P.Integer) where
    iops =
        P.lens (_iops :: OpsworksGangliaLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _iops = a } :: OpsworksGangliaLayerEbsVolume s)

instance P.HasMountPoint (OpsworksGangliaLayerEbsVolume s) (TF.Attr s P.Text) where
    mountPoint =
        P.lens (_mountPoint :: OpsworksGangliaLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _mountPoint = a } :: OpsworksGangliaLayerEbsVolume s)

instance P.HasNumberOfDisks (OpsworksGangliaLayerEbsVolume s) (TF.Attr s P.Integer) where
    numberOfDisks =
        P.lens (_numberOfDisks :: OpsworksGangliaLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _numberOfDisks = a } :: OpsworksGangliaLayerEbsVolume s)

instance P.HasRaidLevel (OpsworksGangliaLayerEbsVolume s) (TF.Attr s P.Text) where
    raidLevel =
        P.lens (_raidLevel :: OpsworksGangliaLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _raidLevel = a } :: OpsworksGangliaLayerEbsVolume s)

instance P.HasSize (OpsworksGangliaLayerEbsVolume s) (TF.Attr s P.Integer) where
    size =
        P.lens (_size :: OpsworksGangliaLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _size = a } :: OpsworksGangliaLayerEbsVolume s)

instance P.HasType' (OpsworksGangliaLayerEbsVolume s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: OpsworksGangliaLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: OpsworksGangliaLayerEbsVolume s)

-- | @lb_listener_rule_condition@ nested settings.
data LbListenerRuleCondition s = LbListenerRuleCondition'
    { _field  :: TF.Attr s P.Text
    -- ^ @field@ - (Optional)
    --
    , _values :: TF.Attr s P.Text
    -- ^ @values@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLbListenerRuleCondition
    :: LbListenerRuleCondition s
newLbListenerRuleCondition =
    LbListenerRuleCondition'
        { _field = TF.Nil
        , _values = TF.Nil
        }

instance P.Hashable  (LbListenerRuleCondition s)
instance TF.IsValue  (LbListenerRuleCondition s)
instance TF.IsObject (LbListenerRuleCondition s) where
    toObject LbListenerRuleCondition'{..} = P.catMaybes
        [ TF.assign "field" <$> TF.attribute _field
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (LbListenerRuleCondition s) where
    validator = P.mempty

instance P.HasField (LbListenerRuleCondition s) (TF.Attr s P.Text) where
    field =
        P.lens (_field :: LbListenerRuleCondition s -> TF.Attr s P.Text)
               (\s a -> s { _field = a } :: LbListenerRuleCondition s)

instance P.HasValues (LbListenerRuleCondition s) (TF.Attr s P.Text) where
    values =
        P.lens (_values :: LbListenerRuleCondition s -> TF.Attr s P.Text)
               (\s a -> s { _values = a } :: LbListenerRuleCondition s)

-- | @cognito_user_pool_admin_create_user_config@ nested settings.
data CognitoUserPoolAdminCreateUserConfig s = CognitoUserPoolAdminCreateUserConfig'
    { _allowAdminCreateUserOnly :: TF.Attr s P.Bool
    -- ^ @allow_admin_create_user_only@ - (Optional)
    --
    , _inviteMessageTemplate :: TF.Attr s (AdminCreateUserConfigInviteMessageTemplate s)
    -- ^ @invite_message_template@ - (Optional)
    --
    , _unusedAccountValidityDays :: TF.Attr s P.Integer
    -- ^ @unused_account_validity_days@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCognitoUserPoolAdminCreateUserConfig
    :: CognitoUserPoolAdminCreateUserConfig s
newCognitoUserPoolAdminCreateUserConfig =
    CognitoUserPoolAdminCreateUserConfig'
        { _allowAdminCreateUserOnly = TF.Nil
        , _inviteMessageTemplate = TF.Nil
        , _unusedAccountValidityDays = TF.value 7
        }

instance P.Hashable  (CognitoUserPoolAdminCreateUserConfig s)
instance TF.IsValue  (CognitoUserPoolAdminCreateUserConfig s)
instance TF.IsObject (CognitoUserPoolAdminCreateUserConfig s) where
    toObject CognitoUserPoolAdminCreateUserConfig'{..} = P.catMaybes
        [ TF.assign "allow_admin_create_user_only" <$> TF.attribute _allowAdminCreateUserOnly
        , TF.assign "invite_message_template" <$> TF.attribute _inviteMessageTemplate
        , TF.assign "unused_account_validity_days" <$> TF.attribute _unusedAccountValidityDays
        ]

instance TF.IsValid (CognitoUserPoolAdminCreateUserConfig s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_inviteMessageTemplate"
                  (_inviteMessageTemplate
                      :: CognitoUserPoolAdminCreateUserConfig s -> TF.Attr s (AdminCreateUserConfigInviteMessageTemplate s))
                  TF.validator

instance P.HasAllowAdminCreateUserOnly (CognitoUserPoolAdminCreateUserConfig s) (TF.Attr s P.Bool) where
    allowAdminCreateUserOnly =
        P.lens (_allowAdminCreateUserOnly :: CognitoUserPoolAdminCreateUserConfig s -> TF.Attr s P.Bool)
               (\s a -> s { _allowAdminCreateUserOnly = a } :: CognitoUserPoolAdminCreateUserConfig s)

instance P.HasInviteMessageTemplate (CognitoUserPoolAdminCreateUserConfig s) (TF.Attr s (AdminCreateUserConfigInviteMessageTemplate s)) where
    inviteMessageTemplate =
        P.lens (_inviteMessageTemplate :: CognitoUserPoolAdminCreateUserConfig s -> TF.Attr s (AdminCreateUserConfigInviteMessageTemplate s))
               (\s a -> s { _inviteMessageTemplate = a } :: CognitoUserPoolAdminCreateUserConfig s)

instance P.HasUnusedAccountValidityDays (CognitoUserPoolAdminCreateUserConfig s) (TF.Attr s P.Integer) where
    unusedAccountValidityDays =
        P.lens (_unusedAccountValidityDays :: CognitoUserPoolAdminCreateUserConfig s -> TF.Attr s P.Integer)
               (\s a -> s { _unusedAccountValidityDays = a } :: CognitoUserPoolAdminCreateUserConfig s)

-- | @opsworks_custom_layer_ebs_volume@ nested settings.
data OpsworksCustomLayerEbsVolume s = OpsworksCustomLayerEbsVolume'
    { _iops          :: TF.Attr s P.Integer
    -- ^ @iops@ - (Optional)
    --
    , _mountPoint    :: TF.Attr s P.Text
    -- ^ @mount_point@ - (Required)
    --
    , _numberOfDisks :: TF.Attr s P.Integer
    -- ^ @number_of_disks@ - (Required)
    --
    , _raidLevel     :: TF.Attr s P.Text
    -- ^ @raid_level@ - (Optional)
    --
    , _size          :: TF.Attr s P.Integer
    -- ^ @size@ - (Required)
    --
    , _type'         :: TF.Attr s P.Text
    -- ^ @type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newOpsworksCustomLayerEbsVolume
    :: TF.Attr s P.Text -- ^ @mount_point@ - 'P.mountPoint'
    -> TF.Attr s P.Integer -- ^ @number_of_disks@ - 'P.numberOfDisks'
    -> TF.Attr s P.Integer -- ^ @size@ - 'P.size'
    -> OpsworksCustomLayerEbsVolume s
newOpsworksCustomLayerEbsVolume _mountPoint _numberOfDisks _size =
    OpsworksCustomLayerEbsVolume'
        { _iops = TF.value 0
        , _mountPoint = _mountPoint
        , _numberOfDisks = _numberOfDisks
        , _raidLevel = TF.Nil
        , _size = _size
        , _type' = TF.value "standard"
        }

instance P.Hashable  (OpsworksCustomLayerEbsVolume s)
instance TF.IsValue  (OpsworksCustomLayerEbsVolume s)
instance TF.IsObject (OpsworksCustomLayerEbsVolume s) where
    toObject OpsworksCustomLayerEbsVolume'{..} = P.catMaybes
        [ TF.assign "iops" <$> TF.attribute _iops
        , TF.assign "mount_point" <$> TF.attribute _mountPoint
        , TF.assign "number_of_disks" <$> TF.attribute _numberOfDisks
        , TF.assign "raid_level" <$> TF.attribute _raidLevel
        , TF.assign "size" <$> TF.attribute _size
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (OpsworksCustomLayerEbsVolume s) where
    validator = P.mempty

instance P.HasIops (OpsworksCustomLayerEbsVolume s) (TF.Attr s P.Integer) where
    iops =
        P.lens (_iops :: OpsworksCustomLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _iops = a } :: OpsworksCustomLayerEbsVolume s)

instance P.HasMountPoint (OpsworksCustomLayerEbsVolume s) (TF.Attr s P.Text) where
    mountPoint =
        P.lens (_mountPoint :: OpsworksCustomLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _mountPoint = a } :: OpsworksCustomLayerEbsVolume s)

instance P.HasNumberOfDisks (OpsworksCustomLayerEbsVolume s) (TF.Attr s P.Integer) where
    numberOfDisks =
        P.lens (_numberOfDisks :: OpsworksCustomLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _numberOfDisks = a } :: OpsworksCustomLayerEbsVolume s)

instance P.HasRaidLevel (OpsworksCustomLayerEbsVolume s) (TF.Attr s P.Text) where
    raidLevel =
        P.lens (_raidLevel :: OpsworksCustomLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _raidLevel = a } :: OpsworksCustomLayerEbsVolume s)

instance P.HasSize (OpsworksCustomLayerEbsVolume s) (TF.Attr s P.Integer) where
    size =
        P.lens (_size :: OpsworksCustomLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _size = a } :: OpsworksCustomLayerEbsVolume s)

instance P.HasType' (OpsworksCustomLayerEbsVolume s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: OpsworksCustomLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: OpsworksCustomLayerEbsVolume s)

-- | @codebuild_project_cache@ nested settings.
data CodebuildProjectCache s = CodebuildProjectCache'
    { _location :: TF.Attr s P.Text
    -- ^ @location@ - (Optional)
    --
    , _type'    :: TF.Attr s P.Text
    -- ^ @type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCodebuildProjectCache
    :: CodebuildProjectCache s
newCodebuildProjectCache =
    CodebuildProjectCache'
        { _location = TF.Nil
        , _type' = TF.value "NO_CACHE"
        }

instance P.Hashable  (CodebuildProjectCache s)
instance TF.IsValue  (CodebuildProjectCache s)
instance TF.IsObject (CodebuildProjectCache s) where
    toObject CodebuildProjectCache'{..} = P.catMaybes
        [ TF.assign "location" <$> TF.attribute _location
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (CodebuildProjectCache s) where
    validator = P.mempty

instance P.HasLocation (CodebuildProjectCache s) (TF.Attr s P.Text) where
    location =
        P.lens (_location :: CodebuildProjectCache s -> TF.Attr s P.Text)
               (\s a -> s { _location = a } :: CodebuildProjectCache s)

instance P.HasType' (CodebuildProjectCache s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: CodebuildProjectCache s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: CodebuildProjectCache s)

-- | @deserializer_hive_json_ser_de@ nested settings.
data DeserializerHiveJsonSerDe s = DeserializerHiveJsonSerDe'
    { _timestampFormats :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @timestamp_formats@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDeserializerHiveJsonSerDe
    :: DeserializerHiveJsonSerDe s
newDeserializerHiveJsonSerDe =
    DeserializerHiveJsonSerDe'
        { _timestampFormats = TF.Nil
        }

instance P.Hashable  (DeserializerHiveJsonSerDe s)
instance TF.IsValue  (DeserializerHiveJsonSerDe s)
instance TF.IsObject (DeserializerHiveJsonSerDe s) where
    toObject DeserializerHiveJsonSerDe'{..} = P.catMaybes
        [ TF.assign "timestamp_formats" <$> TF.attribute _timestampFormats
        ]

instance TF.IsValid (DeserializerHiveJsonSerDe s) where
    validator = P.mempty

instance P.HasTimestampFormats (DeserializerHiveJsonSerDe s) (TF.Attr s [TF.Attr s P.Text]) where
    timestampFormats =
        P.lens (_timestampFormats :: DeserializerHiveJsonSerDe s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _timestampFormats = a } :: DeserializerHiveJsonSerDe s)

-- | @cognito_user_pool_device_configuration@ nested settings.
data CognitoUserPoolDeviceConfiguration s = CognitoUserPoolDeviceConfiguration'
    { _challengeRequiredOnNewDevice     :: TF.Attr s P.Bool
    -- ^ @challenge_required_on_new_device@ - (Optional)
    --
    , _deviceOnlyRememberedOnUserPrompt :: TF.Attr s P.Bool
    -- ^ @device_only_remembered_on_user_prompt@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCognitoUserPoolDeviceConfiguration
    :: CognitoUserPoolDeviceConfiguration s
newCognitoUserPoolDeviceConfiguration =
    CognitoUserPoolDeviceConfiguration'
        { _challengeRequiredOnNewDevice = TF.Nil
        , _deviceOnlyRememberedOnUserPrompt = TF.Nil
        }

instance P.Hashable  (CognitoUserPoolDeviceConfiguration s)
instance TF.IsValue  (CognitoUserPoolDeviceConfiguration s)
instance TF.IsObject (CognitoUserPoolDeviceConfiguration s) where
    toObject CognitoUserPoolDeviceConfiguration'{..} = P.catMaybes
        [ TF.assign "challenge_required_on_new_device" <$> TF.attribute _challengeRequiredOnNewDevice
        , TF.assign "device_only_remembered_on_user_prompt" <$> TF.attribute _deviceOnlyRememberedOnUserPrompt
        ]

instance TF.IsValid (CognitoUserPoolDeviceConfiguration s) where
    validator = P.mempty

instance P.HasChallengeRequiredOnNewDevice (CognitoUserPoolDeviceConfiguration s) (TF.Attr s P.Bool) where
    challengeRequiredOnNewDevice =
        P.lens (_challengeRequiredOnNewDevice :: CognitoUserPoolDeviceConfiguration s -> TF.Attr s P.Bool)
               (\s a -> s { _challengeRequiredOnNewDevice = a } :: CognitoUserPoolDeviceConfiguration s)

instance P.HasDeviceOnlyRememberedOnUserPrompt (CognitoUserPoolDeviceConfiguration s) (TF.Attr s P.Bool) where
    deviceOnlyRememberedOnUserPrompt =
        P.lens (_deviceOnlyRememberedOnUserPrompt :: CognitoUserPoolDeviceConfiguration s -> TF.Attr s P.Bool)
               (\s a -> s { _deviceOnlyRememberedOnUserPrompt = a } :: CognitoUserPoolDeviceConfiguration s)

-- | @s3_backup_configuration_cloudwatch_logging_options@ nested settings.
data S3BackupConfigurationCloudwatchLoggingOptions s = S3BackupConfigurationCloudwatchLoggingOptions'
    { _enabled       :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Optional)
    --
    , _logGroupName  :: TF.Attr s P.Text
    -- ^ @log_group_name@ - (Optional)
    --
    , _logStreamName :: TF.Attr s P.Text
    -- ^ @log_stream_name@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newS3BackupConfigurationCloudwatchLoggingOptions
    :: S3BackupConfigurationCloudwatchLoggingOptions s
newS3BackupConfigurationCloudwatchLoggingOptions =
    S3BackupConfigurationCloudwatchLoggingOptions'
        { _enabled = TF.value P.False
        , _logGroupName = TF.Nil
        , _logStreamName = TF.Nil
        }

instance P.Hashable  (S3BackupConfigurationCloudwatchLoggingOptions s)
instance TF.IsValue  (S3BackupConfigurationCloudwatchLoggingOptions s)
instance TF.IsObject (S3BackupConfigurationCloudwatchLoggingOptions s) where
    toObject S3BackupConfigurationCloudwatchLoggingOptions'{..} = P.catMaybes
        [ TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "log_group_name" <$> TF.attribute _logGroupName
        , TF.assign "log_stream_name" <$> TF.attribute _logStreamName
        ]

instance TF.IsValid (S3BackupConfigurationCloudwatchLoggingOptions s) where
    validator = P.mempty

instance P.HasEnabled (S3BackupConfigurationCloudwatchLoggingOptions s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: S3BackupConfigurationCloudwatchLoggingOptions s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: S3BackupConfigurationCloudwatchLoggingOptions s)

instance P.HasLogGroupName (S3BackupConfigurationCloudwatchLoggingOptions s) (TF.Attr s P.Text) where
    logGroupName =
        P.lens (_logGroupName :: S3BackupConfigurationCloudwatchLoggingOptions s -> TF.Attr s P.Text)
               (\s a -> s { _logGroupName = a } :: S3BackupConfigurationCloudwatchLoggingOptions s)

instance P.HasLogStreamName (S3BackupConfigurationCloudwatchLoggingOptions s) (TF.Attr s P.Text) where
    logStreamName =
        P.lens (_logStreamName :: S3BackupConfigurationCloudwatchLoggingOptions s -> TF.Attr s P.Text)
               (\s a -> s { _logStreamName = a } :: S3BackupConfigurationCloudwatchLoggingOptions s)

-- | @waf_rule_group_activated_rule@ nested settings.
data WafRuleGroupActivatedRule s = WafRuleGroupActivatedRule'
    { _action   :: TF.Attr s (ActivatedRuleAction s)
    -- ^ @action@ - (Required)
    --
    , _priority :: TF.Attr s P.Integer
    -- ^ @priority@ - (Required)
    --
    , _ruleId   :: TF.Attr s P.Text
    -- ^ @rule_id@ - (Required)
    --
    , _type'    :: TF.Attr s P.Text
    -- ^ @type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafRuleGroupActivatedRule
    :: TF.Attr s (ActivatedRuleAction s) -- ^ @action@ - 'P.action'
    -> TF.Attr s P.Integer -- ^ @priority@ - 'P.priority'
    -> TF.Attr s P.Text -- ^ @rule_id@ - 'P.ruleId'
    -> WafRuleGroupActivatedRule s
newWafRuleGroupActivatedRule _action _priority _ruleId =
    WafRuleGroupActivatedRule'
        { _action = _action
        , _priority = _priority
        , _ruleId = _ruleId
        , _type' = TF.value "REGULAR"
        }

instance P.Hashable  (WafRuleGroupActivatedRule s)
instance TF.IsValue  (WafRuleGroupActivatedRule s)
instance TF.IsObject (WafRuleGroupActivatedRule s) where
    toObject WafRuleGroupActivatedRule'{..} = P.catMaybes
        [ TF.assign "action" <$> TF.attribute _action
        , TF.assign "priority" <$> TF.attribute _priority
        , TF.assign "rule_id" <$> TF.attribute _ruleId
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (WafRuleGroupActivatedRule s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_action"
                  (_action
                      :: WafRuleGroupActivatedRule s -> TF.Attr s (ActivatedRuleAction s))
                  TF.validator

instance P.HasAction (WafRuleGroupActivatedRule s) (TF.Attr s (ActivatedRuleAction s)) where
    action =
        P.lens (_action :: WafRuleGroupActivatedRule s -> TF.Attr s (ActivatedRuleAction s))
               (\s a -> s { _action = a } :: WafRuleGroupActivatedRule s)

instance P.HasPriority (WafRuleGroupActivatedRule s) (TF.Attr s P.Integer) where
    priority =
        P.lens (_priority :: WafRuleGroupActivatedRule s -> TF.Attr s P.Integer)
               (\s a -> s { _priority = a } :: WafRuleGroupActivatedRule s)

instance P.HasRuleId (WafRuleGroupActivatedRule s) (TF.Attr s P.Text) where
    ruleId =
        P.lens (_ruleId :: WafRuleGroupActivatedRule s -> TF.Attr s P.Text)
               (\s a -> s { _ruleId = a } :: WafRuleGroupActivatedRule s)

instance P.HasType' (WafRuleGroupActivatedRule s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: WafRuleGroupActivatedRule s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: WafRuleGroupActivatedRule s)

-- | @elastictranscoder_preset_thumbnails@ nested settings.
data ElastictranscoderPresetThumbnails s = ElastictranscoderPresetThumbnails'
    { _aspectRatio   :: TF.Attr s P.Text
    -- ^ @aspect_ratio@ - (Optional, Forces New)
    --
    , _format        :: TF.Attr s P.Text
    -- ^ @format@ - (Optional, Forces New)
    --
    , _interval      :: TF.Attr s P.Text
    -- ^ @interval@ - (Optional, Forces New)
    --
    , _maxHeight     :: TF.Attr s P.Text
    -- ^ @max_height@ - (Optional, Forces New)
    --
    , _maxWidth      :: TF.Attr s P.Text
    -- ^ @max_width@ - (Optional, Forces New)
    --
    , _paddingPolicy :: TF.Attr s P.Text
    -- ^ @padding_policy@ - (Optional, Forces New)
    --
    , _resolution    :: TF.Attr s P.Text
    -- ^ @resolution@ - (Optional, Forces New)
    --
    , _sizingPolicy  :: TF.Attr s P.Text
    -- ^ @sizing_policy@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElastictranscoderPresetThumbnails
    :: ElastictranscoderPresetThumbnails s
newElastictranscoderPresetThumbnails =
    ElastictranscoderPresetThumbnails'
        { _aspectRatio = TF.Nil
        , _format = TF.Nil
        , _interval = TF.Nil
        , _maxHeight = TF.Nil
        , _maxWidth = TF.Nil
        , _paddingPolicy = TF.Nil
        , _resolution = TF.Nil
        , _sizingPolicy = TF.Nil
        }

instance P.Hashable  (ElastictranscoderPresetThumbnails s)
instance TF.IsValue  (ElastictranscoderPresetThumbnails s)
instance TF.IsObject (ElastictranscoderPresetThumbnails s) where
    toObject ElastictranscoderPresetThumbnails'{..} = P.catMaybes
        [ TF.assign "aspect_ratio" <$> TF.attribute _aspectRatio
        , TF.assign "format" <$> TF.attribute _format
        , TF.assign "interval" <$> TF.attribute _interval
        , TF.assign "max_height" <$> TF.attribute _maxHeight
        , TF.assign "max_width" <$> TF.attribute _maxWidth
        , TF.assign "padding_policy" <$> TF.attribute _paddingPolicy
        , TF.assign "resolution" <$> TF.attribute _resolution
        , TF.assign "sizing_policy" <$> TF.attribute _sizingPolicy
        ]

instance TF.IsValid (ElastictranscoderPresetThumbnails s) where
    validator = P.mempty

instance P.HasAspectRatio (ElastictranscoderPresetThumbnails s) (TF.Attr s P.Text) where
    aspectRatio =
        P.lens (_aspectRatio :: ElastictranscoderPresetThumbnails s -> TF.Attr s P.Text)
               (\s a -> s { _aspectRatio = a } :: ElastictranscoderPresetThumbnails s)

instance P.HasFormat (ElastictranscoderPresetThumbnails s) (TF.Attr s P.Text) where
    format =
        P.lens (_format :: ElastictranscoderPresetThumbnails s -> TF.Attr s P.Text)
               (\s a -> s { _format = a } :: ElastictranscoderPresetThumbnails s)

instance P.HasInterval (ElastictranscoderPresetThumbnails s) (TF.Attr s P.Text) where
    interval =
        P.lens (_interval :: ElastictranscoderPresetThumbnails s -> TF.Attr s P.Text)
               (\s a -> s { _interval = a } :: ElastictranscoderPresetThumbnails s)

instance P.HasMaxHeight (ElastictranscoderPresetThumbnails s) (TF.Attr s P.Text) where
    maxHeight =
        P.lens (_maxHeight :: ElastictranscoderPresetThumbnails s -> TF.Attr s P.Text)
               (\s a -> s { _maxHeight = a } :: ElastictranscoderPresetThumbnails s)

instance P.HasMaxWidth (ElastictranscoderPresetThumbnails s) (TF.Attr s P.Text) where
    maxWidth =
        P.lens (_maxWidth :: ElastictranscoderPresetThumbnails s -> TF.Attr s P.Text)
               (\s a -> s { _maxWidth = a } :: ElastictranscoderPresetThumbnails s)

instance P.HasPaddingPolicy (ElastictranscoderPresetThumbnails s) (TF.Attr s P.Text) where
    paddingPolicy =
        P.lens (_paddingPolicy :: ElastictranscoderPresetThumbnails s -> TF.Attr s P.Text)
               (\s a -> s { _paddingPolicy = a } :: ElastictranscoderPresetThumbnails s)

instance P.HasResolution (ElastictranscoderPresetThumbnails s) (TF.Attr s P.Text) where
    resolution =
        P.lens (_resolution :: ElastictranscoderPresetThumbnails s -> TF.Attr s P.Text)
               (\s a -> s { _resolution = a } :: ElastictranscoderPresetThumbnails s)

instance P.HasSizingPolicy (ElastictranscoderPresetThumbnails s) (TF.Attr s P.Text) where
    sizingPolicy =
        P.lens (_sizingPolicy :: ElastictranscoderPresetThumbnails s -> TF.Attr s P.Text)
               (\s a -> s { _sizingPolicy = a } :: ElastictranscoderPresetThumbnails s)

-- | @option_option_settings@ nested settings.
data OptionOptionSettings s = OptionOptionSettings'
    { _name  :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _value :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newOptionOptionSettings
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> OptionOptionSettings s
newOptionOptionSettings _name _value =
    OptionOptionSettings'
        { _name = _name
        , _value = _value
        }

instance P.Hashable  (OptionOptionSettings s)
instance TF.IsValue  (OptionOptionSettings s)
instance TF.IsObject (OptionOptionSettings s) where
    toObject OptionOptionSettings'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (OptionOptionSettings s) where
    validator = P.mempty

instance P.HasName (OptionOptionSettings s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: OptionOptionSettings s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: OptionOptionSettings s)

instance P.HasValue (OptionOptionSettings s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: OptionOptionSettings s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: OptionOptionSettings s)

-- | @destination_bucket@ nested settings.
data DestinationBucket s = DestinationBucket'
    { _accountId  :: TF.Attr s P.Text
    -- ^ @account_id@ - (Optional)
    --
    , _bucketArn  :: TF.Attr s P.Text
    -- ^ @bucket_arn@ - (Required)
    --
    , _encryption :: TF.Attr s (BucketEncryption s)
    -- ^ @encryption@ - (Optional)
    --
    , _format     :: TF.Attr s P.Text
    -- ^ @format@ - (Required)
    --
    , _prefix     :: TF.Attr s P.Text
    -- ^ @prefix@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDestinationBucket
    :: TF.Attr s P.Text -- ^ @bucket_arn@ - 'P.bucketArn'
    -> TF.Attr s P.Text -- ^ @format@ - 'P.format'
    -> DestinationBucket s
newDestinationBucket _bucketArn _format =
    DestinationBucket'
        { _accountId = TF.Nil
        , _bucketArn = _bucketArn
        , _encryption = TF.Nil
        , _format = _format
        , _prefix = TF.Nil
        }

instance P.Hashable  (DestinationBucket s)
instance TF.IsValue  (DestinationBucket s)
instance TF.IsObject (DestinationBucket s) where
    toObject DestinationBucket'{..} = P.catMaybes
        [ TF.assign "account_id" <$> TF.attribute _accountId
        , TF.assign "bucket_arn" <$> TF.attribute _bucketArn
        , TF.assign "encryption" <$> TF.attribute _encryption
        , TF.assign "format" <$> TF.attribute _format
        , TF.assign "prefix" <$> TF.attribute _prefix
        ]

instance TF.IsValid (DestinationBucket s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_encryption"
                  (_encryption
                      :: DestinationBucket s -> TF.Attr s (BucketEncryption s))
                  TF.validator

instance P.HasAccountId (DestinationBucket s) (TF.Attr s P.Text) where
    accountId =
        P.lens (_accountId :: DestinationBucket s -> TF.Attr s P.Text)
               (\s a -> s { _accountId = a } :: DestinationBucket s)

instance P.HasBucketArn (DestinationBucket s) (TF.Attr s P.Text) where
    bucketArn =
        P.lens (_bucketArn :: DestinationBucket s -> TF.Attr s P.Text)
               (\s a -> s { _bucketArn = a } :: DestinationBucket s)

instance P.HasEncryption (DestinationBucket s) (TF.Attr s (BucketEncryption s)) where
    encryption =
        P.lens (_encryption :: DestinationBucket s -> TF.Attr s (BucketEncryption s))
               (\s a -> s { _encryption = a } :: DestinationBucket s)

instance P.HasFormat (DestinationBucket s) (TF.Attr s P.Text) where
    format =
        P.lens (_format :: DestinationBucket s -> TF.Attr s P.Text)
               (\s a -> s { _format = a } :: DestinationBucket s)

instance P.HasPrefix (DestinationBucket s) (TF.Attr s P.Text) where
    prefix =
        P.lens (_prefix :: DestinationBucket s -> TF.Attr s P.Text)
               (\s a -> s { _prefix = a } :: DestinationBucket s)

-- | @service_discovery_service_health_check_config@ nested settings.
data ServiceDiscoveryServiceHealthCheckConfig s = ServiceDiscoveryServiceHealthCheckConfig'
    { _failureThreshold :: TF.Attr s P.Integer
    -- ^ @failure_threshold@ - (Optional)
    --
    , _resourcePath     :: TF.Attr s P.Text
    -- ^ @resource_path@ - (Optional)
    --
    , _type'            :: TF.Attr s P.Text
    -- ^ @type@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newServiceDiscoveryServiceHealthCheckConfig
    :: ServiceDiscoveryServiceHealthCheckConfig s
newServiceDiscoveryServiceHealthCheckConfig =
    ServiceDiscoveryServiceHealthCheckConfig'
        { _failureThreshold = TF.Nil
        , _resourcePath = TF.Nil
        , _type' = TF.Nil
        }

instance P.Hashable  (ServiceDiscoveryServiceHealthCheckConfig s)
instance TF.IsValue  (ServiceDiscoveryServiceHealthCheckConfig s)
instance TF.IsObject (ServiceDiscoveryServiceHealthCheckConfig s) where
    toObject ServiceDiscoveryServiceHealthCheckConfig'{..} = P.catMaybes
        [ TF.assign "failure_threshold" <$> TF.attribute _failureThreshold
        , TF.assign "resource_path" <$> TF.attribute _resourcePath
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (ServiceDiscoveryServiceHealthCheckConfig s) where
    validator = P.mempty

instance P.HasFailureThreshold (ServiceDiscoveryServiceHealthCheckConfig s) (TF.Attr s P.Integer) where
    failureThreshold =
        P.lens (_failureThreshold :: ServiceDiscoveryServiceHealthCheckConfig s -> TF.Attr s P.Integer)
               (\s a -> s { _failureThreshold = a } :: ServiceDiscoveryServiceHealthCheckConfig s)

instance P.HasResourcePath (ServiceDiscoveryServiceHealthCheckConfig s) (TF.Attr s P.Text) where
    resourcePath =
        P.lens (_resourcePath :: ServiceDiscoveryServiceHealthCheckConfig s -> TF.Attr s P.Text)
               (\s a -> s { _resourcePath = a } :: ServiceDiscoveryServiceHealthCheckConfig s)

instance P.HasType' (ServiceDiscoveryServiceHealthCheckConfig s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: ServiceDiscoveryServiceHealthCheckConfig s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: ServiceDiscoveryServiceHealthCheckConfig s)

-- | @redshift_configuration_s3_backup_configuration@ nested settings.
data RedshiftConfigurationS3BackupConfiguration s = RedshiftConfigurationS3BackupConfiguration'
    { _bucketArn         :: TF.Attr s P.Text
    -- ^ @bucket_arn@ - (Required)
    --
    , _bufferInterval    :: TF.Attr s P.Integer
    -- ^ @buffer_interval@ - (Optional)
    --
    , _bufferSize        :: TF.Attr s P.Integer
    -- ^ @buffer_size@ - (Optional)
    --
    , _compressionFormat :: TF.Attr s P.Text
    -- ^ @compression_format@ - (Optional)
    --
    , _kmsKeyArn         :: TF.Attr s P.Text
    -- ^ @kms_key_arn@ - (Optional)
    --
    , _prefix            :: TF.Attr s P.Text
    -- ^ @prefix@ - (Optional)
    --
    , _roleArn           :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRedshiftConfigurationS3BackupConfiguration
    :: TF.Attr s P.Text -- ^ @bucket_arn@ - 'P.bucketArn'
    -> TF.Attr s P.Text -- ^ @role_arn@ - 'P.roleArn'
    -> RedshiftConfigurationS3BackupConfiguration s
newRedshiftConfigurationS3BackupConfiguration _bucketArn _roleArn =
    RedshiftConfigurationS3BackupConfiguration'
        { _bucketArn = _bucketArn
        , _bufferInterval = TF.value 300
        , _bufferSize = TF.value 5
        , _compressionFormat = TF.value "UNCOMPRESSED"
        , _kmsKeyArn = TF.Nil
        , _prefix = TF.Nil
        , _roleArn = _roleArn
        }

instance P.Hashable  (RedshiftConfigurationS3BackupConfiguration s)
instance TF.IsValue  (RedshiftConfigurationS3BackupConfiguration s)
instance TF.IsObject (RedshiftConfigurationS3BackupConfiguration s) where
    toObject RedshiftConfigurationS3BackupConfiguration'{..} = P.catMaybes
        [ TF.assign "bucket_arn" <$> TF.attribute _bucketArn
        , TF.assign "buffer_interval" <$> TF.attribute _bufferInterval
        , TF.assign "buffer_size" <$> TF.attribute _bufferSize
        , TF.assign "compression_format" <$> TF.attribute _compressionFormat
        , TF.assign "kms_key_arn" <$> TF.attribute _kmsKeyArn
        , TF.assign "prefix" <$> TF.attribute _prefix
        , TF.assign "role_arn" <$> TF.attribute _roleArn
        ]

instance TF.IsValid (RedshiftConfigurationS3BackupConfiguration s) where
    validator = P.mempty

instance P.HasBucketArn (RedshiftConfigurationS3BackupConfiguration s) (TF.Attr s P.Text) where
    bucketArn =
        P.lens (_bucketArn :: RedshiftConfigurationS3BackupConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _bucketArn = a } :: RedshiftConfigurationS3BackupConfiguration s)

instance P.HasBufferInterval (RedshiftConfigurationS3BackupConfiguration s) (TF.Attr s P.Integer) where
    bufferInterval =
        P.lens (_bufferInterval :: RedshiftConfigurationS3BackupConfiguration s -> TF.Attr s P.Integer)
               (\s a -> s { _bufferInterval = a } :: RedshiftConfigurationS3BackupConfiguration s)

instance P.HasBufferSize (RedshiftConfigurationS3BackupConfiguration s) (TF.Attr s P.Integer) where
    bufferSize =
        P.lens (_bufferSize :: RedshiftConfigurationS3BackupConfiguration s -> TF.Attr s P.Integer)
               (\s a -> s { _bufferSize = a } :: RedshiftConfigurationS3BackupConfiguration s)

instance P.HasCompressionFormat (RedshiftConfigurationS3BackupConfiguration s) (TF.Attr s P.Text) where
    compressionFormat =
        P.lens (_compressionFormat :: RedshiftConfigurationS3BackupConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _compressionFormat = a } :: RedshiftConfigurationS3BackupConfiguration s)

instance P.HasKmsKeyArn (RedshiftConfigurationS3BackupConfiguration s) (TF.Attr s P.Text) where
    kmsKeyArn =
        P.lens (_kmsKeyArn :: RedshiftConfigurationS3BackupConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _kmsKeyArn = a } :: RedshiftConfigurationS3BackupConfiguration s)

instance P.HasPrefix (RedshiftConfigurationS3BackupConfiguration s) (TF.Attr s P.Text) where
    prefix =
        P.lens (_prefix :: RedshiftConfigurationS3BackupConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _prefix = a } :: RedshiftConfigurationS3BackupConfiguration s)

instance P.HasRoleArn (RedshiftConfigurationS3BackupConfiguration s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: RedshiftConfigurationS3BackupConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: RedshiftConfigurationS3BackupConfiguration s)

instance s ~ s' => P.HasComputedCloudwatchLoggingOptions (TF.Ref s' (RedshiftConfigurationS3BackupConfiguration s)) (TF.Attr s (S3BackupConfigurationCloudwatchLoggingOptions s)) where
    computedCloudwatchLoggingOptions x = TF.compute (TF.refKey x) "cloudwatch_logging_options"

-- | @ami_copy_ebs_block_device@ nested settings.
data AmiCopyEbsBlockDevice s = AmiCopyEbsBlockDevice'
    deriving (P.Show, P.Eq, P.Generic)

newAmiCopyEbsBlockDevice
    :: AmiCopyEbsBlockDevice s
newAmiCopyEbsBlockDevice =
    AmiCopyEbsBlockDevice'

instance P.Hashable  (AmiCopyEbsBlockDevice s)
instance TF.IsValue  (AmiCopyEbsBlockDevice s)
instance TF.IsObject (AmiCopyEbsBlockDevice s) where
    toObject AmiCopyEbsBlockDevice' = []

instance TF.IsValid (AmiCopyEbsBlockDevice s) where
    validator = P.mempty

instance s ~ s' => P.HasComputedDeleteOnTermination (TF.Ref s' (AmiCopyEbsBlockDevice s)) (TF.Attr s P.Bool) where
    computedDeleteOnTermination x = TF.compute (TF.refKey x) "delete_on_termination"

instance s ~ s' => P.HasComputedDeviceName (TF.Ref s' (AmiCopyEbsBlockDevice s)) (TF.Attr s P.Text) where
    computedDeviceName x = TF.compute (TF.refKey x) "device_name"

instance s ~ s' => P.HasComputedEncrypted (TF.Ref s' (AmiCopyEbsBlockDevice s)) (TF.Attr s P.Bool) where
    computedEncrypted x = TF.compute (TF.refKey x) "encrypted"

instance s ~ s' => P.HasComputedIops (TF.Ref s' (AmiCopyEbsBlockDevice s)) (TF.Attr s P.Integer) where
    computedIops x = TF.compute (TF.refKey x) "iops"

instance s ~ s' => P.HasComputedSnapshotId (TF.Ref s' (AmiCopyEbsBlockDevice s)) (TF.Attr s P.Text) where
    computedSnapshotId x = TF.compute (TF.refKey x) "snapshot_id"

instance s ~ s' => P.HasComputedVolumeSize (TF.Ref s' (AmiCopyEbsBlockDevice s)) (TF.Attr s P.Integer) where
    computedVolumeSize x = TF.compute (TF.refKey x) "volume_size"

instance s ~ s' => P.HasComputedVolumeType (TF.Ref s' (AmiCopyEbsBlockDevice s)) (TF.Attr s P.Text) where
    computedVolumeType x = TF.compute (TF.refKey x) "volume_type"

-- | @batch_job_definition_retry_strategy@ nested settings.
data BatchJobDefinitionRetryStrategy s = BatchJobDefinitionRetryStrategy'
    { _attempts :: TF.Attr s P.Integer
    -- ^ @attempts@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newBatchJobDefinitionRetryStrategy
    :: BatchJobDefinitionRetryStrategy s
newBatchJobDefinitionRetryStrategy =
    BatchJobDefinitionRetryStrategy'
        { _attempts = TF.Nil
        }

instance P.Hashable  (BatchJobDefinitionRetryStrategy s)
instance TF.IsValue  (BatchJobDefinitionRetryStrategy s)
instance TF.IsObject (BatchJobDefinitionRetryStrategy s) where
    toObject BatchJobDefinitionRetryStrategy'{..} = P.catMaybes
        [ TF.assign "attempts" <$> TF.attribute _attempts
        ]

instance TF.IsValid (BatchJobDefinitionRetryStrategy s) where
    validator = P.mempty

instance P.HasAttempts (BatchJobDefinitionRetryStrategy s) (TF.Attr s P.Integer) where
    attempts =
        P.lens (_attempts :: BatchJobDefinitionRetryStrategy s -> TF.Attr s P.Integer)
               (\s a -> s { _attempts = a } :: BatchJobDefinitionRetryStrategy s)

-- | @block_device_mappings_ebs@ nested settings.
data BlockDeviceMappingsEbs s = BlockDeviceMappingsEbs'
    { _deleteOnTermination :: TF.Attr s P.Bool
    -- ^ @delete_on_termination@ - (Optional)
    --
    , _encrypted           :: TF.Attr s P.Bool
    -- ^ @encrypted@ - (Optional)
    --
    , _kmsKeyId            :: TF.Attr s P.Text
    -- ^ @kms_key_id@ - (Optional)
    --
    , _snapshotId          :: TF.Attr s P.Text
    -- ^ @snapshot_id@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newBlockDeviceMappingsEbs
    :: BlockDeviceMappingsEbs s
newBlockDeviceMappingsEbs =
    BlockDeviceMappingsEbs'
        { _deleteOnTermination = TF.Nil
        , _encrypted = TF.Nil
        , _kmsKeyId = TF.Nil
        , _snapshotId = TF.Nil
        }

instance P.Hashable  (BlockDeviceMappingsEbs s)
instance TF.IsValue  (BlockDeviceMappingsEbs s)
instance TF.IsObject (BlockDeviceMappingsEbs s) where
    toObject BlockDeviceMappingsEbs'{..} = P.catMaybes
        [ TF.assign "delete_on_termination" <$> TF.attribute _deleteOnTermination
        , TF.assign "encrypted" <$> TF.attribute _encrypted
        , TF.assign "kms_key_id" <$> TF.attribute _kmsKeyId
        , TF.assign "snapshot_id" <$> TF.attribute _snapshotId
        ]

instance TF.IsValid (BlockDeviceMappingsEbs s) where
    validator = P.mempty

instance P.HasDeleteOnTermination (BlockDeviceMappingsEbs s) (TF.Attr s P.Bool) where
    deleteOnTermination =
        P.lens (_deleteOnTermination :: BlockDeviceMappingsEbs s -> TF.Attr s P.Bool)
               (\s a -> s { _deleteOnTermination = a } :: BlockDeviceMappingsEbs s)

instance P.HasEncrypted (BlockDeviceMappingsEbs s) (TF.Attr s P.Bool) where
    encrypted =
        P.lens (_encrypted :: BlockDeviceMappingsEbs s -> TF.Attr s P.Bool)
               (\s a -> s { _encrypted = a } :: BlockDeviceMappingsEbs s)

instance P.HasKmsKeyId (BlockDeviceMappingsEbs s) (TF.Attr s P.Text) where
    kmsKeyId =
        P.lens (_kmsKeyId :: BlockDeviceMappingsEbs s -> TF.Attr s P.Text)
               (\s a -> s { _kmsKeyId = a } :: BlockDeviceMappingsEbs s)

instance P.HasSnapshotId (BlockDeviceMappingsEbs s) (TF.Attr s P.Text) where
    snapshotId =
        P.lens (_snapshotId :: BlockDeviceMappingsEbs s -> TF.Attr s P.Text)
               (\s a -> s { _snapshotId = a } :: BlockDeviceMappingsEbs s)

instance s ~ s' => P.HasComputedIops (TF.Ref s' (BlockDeviceMappingsEbs s)) (TF.Attr s P.Integer) where
    computedIops x = TF.compute (TF.refKey x) "iops"

instance s ~ s' => P.HasComputedVolumeSize (TF.Ref s' (BlockDeviceMappingsEbs s)) (TF.Attr s P.Integer) where
    computedVolumeSize x = TF.compute (TF.refKey x) "volume_size"

instance s ~ s' => P.HasComputedVolumeType (TF.Ref s' (BlockDeviceMappingsEbs s)) (TF.Attr s P.Text) where
    computedVolumeType x = TF.compute (TF.refKey x) "volume_type"

-- | @ecs_service_ordered_placement_strategy@ nested settings.
data EcsServiceOrderedPlacementStrategy s = EcsServiceOrderedPlacementStrategy'
    { _field :: TF.Attr s P.Text
    -- ^ @field@ - (Optional, Forces New)
    --
    , _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newEcsServiceOrderedPlacementStrategy
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> EcsServiceOrderedPlacementStrategy s
newEcsServiceOrderedPlacementStrategy _type' =
    EcsServiceOrderedPlacementStrategy'
        { _field = TF.Nil
        , _type' = _type'
        }

instance P.Hashable  (EcsServiceOrderedPlacementStrategy s)
instance TF.IsValue  (EcsServiceOrderedPlacementStrategy s)
instance TF.IsObject (EcsServiceOrderedPlacementStrategy s) where
    toObject EcsServiceOrderedPlacementStrategy'{..} = P.catMaybes
        [ TF.assign "field" <$> TF.attribute _field
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (EcsServiceOrderedPlacementStrategy s) where
    validator = P.mempty

instance P.HasField (EcsServiceOrderedPlacementStrategy s) (TF.Attr s P.Text) where
    field =
        P.lens (_field :: EcsServiceOrderedPlacementStrategy s -> TF.Attr s P.Text)
               (\s a -> s { _field = a } :: EcsServiceOrderedPlacementStrategy s)

instance P.HasType' (EcsServiceOrderedPlacementStrategy s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: EcsServiceOrderedPlacementStrategy s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: EcsServiceOrderedPlacementStrategy s)

-- | @gamelift_fleet_ec2_inbound_permission@ nested settings.
data GameliftFleetEc2InboundPermission s = GameliftFleetEc2InboundPermission'
    { _fromPort :: TF.Attr s P.Integer
    -- ^ @from_port@ - (Required)
    --
    , _ipRange  :: TF.Attr s P.Text
    -- ^ @ip_range@ - (Required)
    --
    , _protocol :: TF.Attr s P.Text
    -- ^ @protocol@ - (Required)
    --
    , _toPort   :: TF.Attr s P.Integer
    -- ^ @to_port@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newGameliftFleetEc2InboundPermission
    :: TF.Attr s P.Integer -- ^ @from_port@ - 'P.fromPort'
    -> TF.Attr s P.Text -- ^ @ip_range@ - 'P.ipRange'
    -> TF.Attr s P.Text -- ^ @protocol@ - 'P.protocol'
    -> TF.Attr s P.Integer -- ^ @to_port@ - 'P.toPort'
    -> GameliftFleetEc2InboundPermission s
newGameliftFleetEc2InboundPermission _fromPort _ipRange _protocol _toPort =
    GameliftFleetEc2InboundPermission'
        { _fromPort = _fromPort
        , _ipRange = _ipRange
        , _protocol = _protocol
        , _toPort = _toPort
        }

instance P.Hashable  (GameliftFleetEc2InboundPermission s)
instance TF.IsValue  (GameliftFleetEc2InboundPermission s)
instance TF.IsObject (GameliftFleetEc2InboundPermission s) where
    toObject GameliftFleetEc2InboundPermission'{..} = P.catMaybes
        [ TF.assign "from_port" <$> TF.attribute _fromPort
        , TF.assign "ip_range" <$> TF.attribute _ipRange
        , TF.assign "protocol" <$> TF.attribute _protocol
        , TF.assign "to_port" <$> TF.attribute _toPort
        ]

instance TF.IsValid (GameliftFleetEc2InboundPermission s) where
    validator = P.mempty

instance P.HasFromPort (GameliftFleetEc2InboundPermission s) (TF.Attr s P.Integer) where
    fromPort =
        P.lens (_fromPort :: GameliftFleetEc2InboundPermission s -> TF.Attr s P.Integer)
               (\s a -> s { _fromPort = a } :: GameliftFleetEc2InboundPermission s)

instance P.HasIpRange (GameliftFleetEc2InboundPermission s) (TF.Attr s P.Text) where
    ipRange =
        P.lens (_ipRange :: GameliftFleetEc2InboundPermission s -> TF.Attr s P.Text)
               (\s a -> s { _ipRange = a } :: GameliftFleetEc2InboundPermission s)

instance P.HasProtocol (GameliftFleetEc2InboundPermission s) (TF.Attr s P.Text) where
    protocol =
        P.lens (_protocol :: GameliftFleetEc2InboundPermission s -> TF.Attr s P.Text)
               (\s a -> s { _protocol = a } :: GameliftFleetEc2InboundPermission s)

instance P.HasToPort (GameliftFleetEc2InboundPermission s) (TF.Attr s P.Integer) where
    toPort =
        P.lens (_toPort :: GameliftFleetEc2InboundPermission s -> TF.Attr s P.Integer)
               (\s a -> s { _toPort = a } :: GameliftFleetEc2InboundPermission s)

-- | @ordered_cache_behavior_forwarded_values@ nested settings.
data OrderedCacheBehaviorForwardedValues s = OrderedCacheBehaviorForwardedValues'
    { _cookies              :: TF.Attr s (ForwardedValuesCookies s)
    -- ^ @cookies@ - (Required)
    --
    , _headers              :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @headers@ - (Optional)
    --
    , _queryString          :: TF.Attr s P.Bool
    -- ^ @query_string@ - (Required)
    --
    , _queryStringCacheKeys :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @query_string_cache_keys@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newOrderedCacheBehaviorForwardedValues
    :: TF.Attr s (ForwardedValuesCookies s) -- ^ @cookies@ - 'P.cookies'
    -> TF.Attr s P.Bool -- ^ @query_string@ - 'P.queryString'
    -> OrderedCacheBehaviorForwardedValues s
newOrderedCacheBehaviorForwardedValues _cookies _queryString =
    OrderedCacheBehaviorForwardedValues'
        { _cookies = _cookies
        , _headers = TF.Nil
        , _queryString = _queryString
        , _queryStringCacheKeys = TF.Nil
        }

instance P.Hashable  (OrderedCacheBehaviorForwardedValues s)
instance TF.IsValue  (OrderedCacheBehaviorForwardedValues s)
instance TF.IsObject (OrderedCacheBehaviorForwardedValues s) where
    toObject OrderedCacheBehaviorForwardedValues'{..} = P.catMaybes
        [ TF.assign "cookies" <$> TF.attribute _cookies
        , TF.assign "headers" <$> TF.attribute _headers
        , TF.assign "query_string" <$> TF.attribute _queryString
        , TF.assign "query_string_cache_keys" <$> TF.attribute _queryStringCacheKeys
        ]

instance TF.IsValid (OrderedCacheBehaviorForwardedValues s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_cookies"
                  (_cookies
                      :: OrderedCacheBehaviorForwardedValues s -> TF.Attr s (ForwardedValuesCookies s))
                  TF.validator

instance P.HasCookies (OrderedCacheBehaviorForwardedValues s) (TF.Attr s (ForwardedValuesCookies s)) where
    cookies =
        P.lens (_cookies :: OrderedCacheBehaviorForwardedValues s -> TF.Attr s (ForwardedValuesCookies s))
               (\s a -> s { _cookies = a } :: OrderedCacheBehaviorForwardedValues s)

instance P.HasHeaders (OrderedCacheBehaviorForwardedValues s) (TF.Attr s [TF.Attr s P.Text]) where
    headers =
        P.lens (_headers :: OrderedCacheBehaviorForwardedValues s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _headers = a } :: OrderedCacheBehaviorForwardedValues s)

instance P.HasQueryString (OrderedCacheBehaviorForwardedValues s) (TF.Attr s P.Bool) where
    queryString =
        P.lens (_queryString :: OrderedCacheBehaviorForwardedValues s -> TF.Attr s P.Bool)
               (\s a -> s { _queryString = a } :: OrderedCacheBehaviorForwardedValues s)

instance P.HasQueryStringCacheKeys (OrderedCacheBehaviorForwardedValues s) (TF.Attr s [TF.Attr s P.Text]) where
    queryStringCacheKeys =
        P.lens (_queryStringCacheKeys :: OrderedCacheBehaviorForwardedValues s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _queryStringCacheKeys = a } :: OrderedCacheBehaviorForwardedValues s)

-- | @stage_action@ nested settings.
data StageAction s = StageAction'
    { _category        :: TF.Attr s P.Text
    -- ^ @category@ - (Required)
    --
    , _configuration   :: TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))
    -- ^ @configuration@ - (Optional)
    --
    , _inputArtifacts  :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @input_artifacts@ - (Optional)
    --
    , _name            :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _outputArtifacts :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @output_artifacts@ - (Optional)
    --
    , _owner           :: TF.Attr s P.Text
    -- ^ @owner@ - (Required)
    --
    , _provider        :: TF.Attr s P.Text
    -- ^ @provider@ - (Required)
    --
    , _roleArn         :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Optional)
    --
    , _version         :: TF.Attr s P.Text
    -- ^ @version@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newStageAction
    :: TF.Attr s P.Text -- ^ @category@ - 'P.category'
    -> TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @owner@ - 'P.owner'
    -> TF.Attr s P.Text -- ^ @provider@ - 'P.provider'
    -> TF.Attr s P.Text -- ^ @version@ - 'P.version'
    -> StageAction s
newStageAction _category _name _owner _provider _version =
    StageAction'
        { _category = _category
        , _configuration = TF.Nil
        , _inputArtifacts = TF.Nil
        , _name = _name
        , _outputArtifacts = TF.Nil
        , _owner = _owner
        , _provider = _provider
        , _roleArn = TF.Nil
        , _version = _version
        }

instance P.Hashable  (StageAction s)
instance TF.IsValue  (StageAction s)
instance TF.IsObject (StageAction s) where
    toObject StageAction'{..} = P.catMaybes
        [ TF.assign "category" <$> TF.attribute _category
        , TF.assign "configuration" <$> TF.attribute _configuration
        , TF.assign "input_artifacts" <$> TF.attribute _inputArtifacts
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "output_artifacts" <$> TF.attribute _outputArtifacts
        , TF.assign "owner" <$> TF.attribute _owner
        , TF.assign "provider" <$> TF.attribute _provider
        , TF.assign "role_arn" <$> TF.attribute _roleArn
        , TF.assign "version" <$> TF.attribute _version
        ]

instance TF.IsValid (StageAction s) where
    validator = P.mempty

instance P.HasCategory (StageAction s) (TF.Attr s P.Text) where
    category =
        P.lens (_category :: StageAction s -> TF.Attr s P.Text)
               (\s a -> s { _category = a } :: StageAction s)

instance P.HasConfiguration (StageAction s) (TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))) where
    configuration =
        P.lens (_configuration :: StageAction s -> TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text)))
               (\s a -> s { _configuration = a } :: StageAction s)

instance P.HasInputArtifacts (StageAction s) (TF.Attr s [TF.Attr s P.Text]) where
    inputArtifacts =
        P.lens (_inputArtifacts :: StageAction s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _inputArtifacts = a } :: StageAction s)

instance P.HasName (StageAction s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: StageAction s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: StageAction s)

instance P.HasOutputArtifacts (StageAction s) (TF.Attr s [TF.Attr s P.Text]) where
    outputArtifacts =
        P.lens (_outputArtifacts :: StageAction s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _outputArtifacts = a } :: StageAction s)

instance P.HasOwner (StageAction s) (TF.Attr s P.Text) where
    owner =
        P.lens (_owner :: StageAction s -> TF.Attr s P.Text)
               (\s a -> s { _owner = a } :: StageAction s)

instance P.HasProvider (StageAction s) (TF.Attr s P.Text) where
    provider =
        P.lens (_provider :: StageAction s -> TF.Attr s P.Text)
               (\s a -> s { _provider = a } :: StageAction s)

instance P.HasRoleArn (StageAction s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: StageAction s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: StageAction s)

instance P.HasVersion (StageAction s) (TF.Attr s P.Text) where
    version =
        P.lens (_version :: StageAction s -> TF.Attr s P.Text)
               (\s a -> s { _version = a } :: StageAction s)

instance s ~ s' => P.HasComputedRunOrder (TF.Ref s' (StageAction s)) (TF.Attr s P.Integer) where
    computedRunOrder x = TF.compute (TF.refKey x) "run_order"

-- | @xss_match_tuples_field_to_match@ nested settings.
data XssMatchTuplesFieldToMatch s = XssMatchTuplesFieldToMatch'
    { _data' :: TF.Attr s P.Text
    -- ^ @data@ - (Optional)
    --
    , _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newXssMatchTuplesFieldToMatch
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> XssMatchTuplesFieldToMatch s
newXssMatchTuplesFieldToMatch _type' =
    XssMatchTuplesFieldToMatch'
        { _data' = TF.Nil
        , _type' = _type'
        }

instance P.Hashable  (XssMatchTuplesFieldToMatch s)
instance TF.IsValue  (XssMatchTuplesFieldToMatch s)
instance TF.IsObject (XssMatchTuplesFieldToMatch s) where
    toObject XssMatchTuplesFieldToMatch'{..} = P.catMaybes
        [ TF.assign "data" <$> TF.attribute _data'
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (XssMatchTuplesFieldToMatch s) where
    validator = P.mempty

instance P.HasData' (XssMatchTuplesFieldToMatch s) (TF.Attr s P.Text) where
    data' =
        P.lens (_data' :: XssMatchTuplesFieldToMatch s -> TF.Attr s P.Text)
               (\s a -> s { _data' = a } :: XssMatchTuplesFieldToMatch s)

instance P.HasType' (XssMatchTuplesFieldToMatch s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: XssMatchTuplesFieldToMatch s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: XssMatchTuplesFieldToMatch s)

-- | @elastictranscoder_preset_audio_codec_options@ nested settings.
data ElastictranscoderPresetAudioCodecOptions s = ElastictranscoderPresetAudioCodecOptions'
    { _bitDepth :: TF.Attr s P.Text
    -- ^ @bit_depth@ - (Optional, Forces New)
    --
    , _bitOrder :: TF.Attr s P.Text
    -- ^ @bit_order@ - (Optional, Forces New)
    --
    , _profile  :: TF.Attr s P.Text
    -- ^ @profile@ - (Optional, Forces New)
    --
    , _signed   :: TF.Attr s P.Text
    -- ^ @signed@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElastictranscoderPresetAudioCodecOptions
    :: ElastictranscoderPresetAudioCodecOptions s
newElastictranscoderPresetAudioCodecOptions =
    ElastictranscoderPresetAudioCodecOptions'
        { _bitDepth = TF.Nil
        , _bitOrder = TF.Nil
        , _profile = TF.Nil
        , _signed = TF.Nil
        }

instance P.Hashable  (ElastictranscoderPresetAudioCodecOptions s)
instance TF.IsValue  (ElastictranscoderPresetAudioCodecOptions s)
instance TF.IsObject (ElastictranscoderPresetAudioCodecOptions s) where
    toObject ElastictranscoderPresetAudioCodecOptions'{..} = P.catMaybes
        [ TF.assign "bit_depth" <$> TF.attribute _bitDepth
        , TF.assign "bit_order" <$> TF.attribute _bitOrder
        , TF.assign "profile" <$> TF.attribute _profile
        , TF.assign "signed" <$> TF.attribute _signed
        ]

instance TF.IsValid (ElastictranscoderPresetAudioCodecOptions s) where
    validator = P.mempty

instance P.HasBitDepth (ElastictranscoderPresetAudioCodecOptions s) (TF.Attr s P.Text) where
    bitDepth =
        P.lens (_bitDepth :: ElastictranscoderPresetAudioCodecOptions s -> TF.Attr s P.Text)
               (\s a -> s { _bitDepth = a } :: ElastictranscoderPresetAudioCodecOptions s)

instance P.HasBitOrder (ElastictranscoderPresetAudioCodecOptions s) (TF.Attr s P.Text) where
    bitOrder =
        P.lens (_bitOrder :: ElastictranscoderPresetAudioCodecOptions s -> TF.Attr s P.Text)
               (\s a -> s { _bitOrder = a } :: ElastictranscoderPresetAudioCodecOptions s)

instance P.HasProfile (ElastictranscoderPresetAudioCodecOptions s) (TF.Attr s P.Text) where
    profile =
        P.lens (_profile :: ElastictranscoderPresetAudioCodecOptions s -> TF.Attr s P.Text)
               (\s a -> s { _profile = a } :: ElastictranscoderPresetAudioCodecOptions s)

instance P.HasSigned (ElastictranscoderPresetAudioCodecOptions s) (TF.Attr s P.Text) where
    signed =
        P.lens (_signed :: ElastictranscoderPresetAudioCodecOptions s -> TF.Attr s P.Text)
               (\s a -> s { _signed = a } :: ElastictranscoderPresetAudioCodecOptions s)

-- | @lb_ssl_negotiation_policy_attribute@ nested settings.
data LbSslNegotiationPolicyAttribute s = LbSslNegotiationPolicyAttribute'
    { _name  :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _value :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLbSslNegotiationPolicyAttribute
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> LbSslNegotiationPolicyAttribute s
newLbSslNegotiationPolicyAttribute _name _value =
    LbSslNegotiationPolicyAttribute'
        { _name = _name
        , _value = _value
        }

instance P.Hashable  (LbSslNegotiationPolicyAttribute s)
instance TF.IsValue  (LbSslNegotiationPolicyAttribute s)
instance TF.IsObject (LbSslNegotiationPolicyAttribute s) where
    toObject LbSslNegotiationPolicyAttribute'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (LbSslNegotiationPolicyAttribute s) where
    validator = P.mempty

instance P.HasName (LbSslNegotiationPolicyAttribute s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: LbSslNegotiationPolicyAttribute s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: LbSslNegotiationPolicyAttribute s)

instance P.HasValue (LbSslNegotiationPolicyAttribute s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: LbSslNegotiationPolicyAttribute s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: LbSslNegotiationPolicyAttribute s)

-- | @kms_grant_constraints@ nested settings.
data KmsGrantConstraints s = KmsGrantConstraints'
    { _encryptionContextEquals :: TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))
    -- ^ @encryption_context_equals@ - (Optional, Forces New)
    --
    , _encryptionContextSubset :: TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))
    -- ^ @encryption_context_subset@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newKmsGrantConstraints
    :: KmsGrantConstraints s
newKmsGrantConstraints =
    KmsGrantConstraints'
        { _encryptionContextEquals = TF.Nil
        , _encryptionContextSubset = TF.Nil
        }

instance P.Hashable  (KmsGrantConstraints s)
instance TF.IsValue  (KmsGrantConstraints s)
instance TF.IsObject (KmsGrantConstraints s) where
    toObject KmsGrantConstraints'{..} = P.catMaybes
        [ TF.assign "encryption_context_equals" <$> TF.attribute _encryptionContextEquals
        , TF.assign "encryption_context_subset" <$> TF.attribute _encryptionContextSubset
        ]

instance TF.IsValid (KmsGrantConstraints s) where
    validator = P.mempty

instance P.HasEncryptionContextEquals (KmsGrantConstraints s) (TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))) where
    encryptionContextEquals =
        P.lens (_encryptionContextEquals :: KmsGrantConstraints s -> TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text)))
               (\s a -> s { _encryptionContextEquals = a } :: KmsGrantConstraints s)

instance P.HasEncryptionContextSubset (KmsGrantConstraints s) (TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))) where
    encryptionContextSubset =
        P.lens (_encryptionContextSubset :: KmsGrantConstraints s -> TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text)))
               (\s a -> s { _encryptionContextSubset = a } :: KmsGrantConstraints s)

-- | @ecs_service_load_balancer@ nested settings.
data EcsServiceLoadBalancer s = EcsServiceLoadBalancer'
    { _containerName  :: TF.Attr s P.Text
    -- ^ @container_name@ - (Required, Forces New)
    --
    , _containerPort  :: TF.Attr s P.Integer
    -- ^ @container_port@ - (Required, Forces New)
    --
    , _elbName        :: TF.Attr s P.Text
    -- ^ @elb_name@ - (Optional, Forces New)
    --
    , _targetGroupArn :: TF.Attr s P.Text
    -- ^ @target_group_arn@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newEcsServiceLoadBalancer
    :: TF.Attr s P.Text -- ^ @container_name@ - 'P.containerName'
    -> TF.Attr s P.Integer -- ^ @container_port@ - 'P.containerPort'
    -> EcsServiceLoadBalancer s
newEcsServiceLoadBalancer _containerName _containerPort =
    EcsServiceLoadBalancer'
        { _containerName = _containerName
        , _containerPort = _containerPort
        , _elbName = TF.Nil
        , _targetGroupArn = TF.Nil
        }

instance P.Hashable  (EcsServiceLoadBalancer s)
instance TF.IsValue  (EcsServiceLoadBalancer s)
instance TF.IsObject (EcsServiceLoadBalancer s) where
    toObject EcsServiceLoadBalancer'{..} = P.catMaybes
        [ TF.assign "container_name" <$> TF.attribute _containerName
        , TF.assign "container_port" <$> TF.attribute _containerPort
        , TF.assign "elb_name" <$> TF.attribute _elbName
        , TF.assign "target_group_arn" <$> TF.attribute _targetGroupArn
        ]

instance TF.IsValid (EcsServiceLoadBalancer s) where
    validator = P.mempty

instance P.HasContainerName (EcsServiceLoadBalancer s) (TF.Attr s P.Text) where
    containerName =
        P.lens (_containerName :: EcsServiceLoadBalancer s -> TF.Attr s P.Text)
               (\s a -> s { _containerName = a } :: EcsServiceLoadBalancer s)

instance P.HasContainerPort (EcsServiceLoadBalancer s) (TF.Attr s P.Integer) where
    containerPort =
        P.lens (_containerPort :: EcsServiceLoadBalancer s -> TF.Attr s P.Integer)
               (\s a -> s { _containerPort = a } :: EcsServiceLoadBalancer s)

instance P.HasElbName (EcsServiceLoadBalancer s) (TF.Attr s P.Text) where
    elbName =
        P.lens (_elbName :: EcsServiceLoadBalancer s -> TF.Attr s P.Text)
               (\s a -> s { _elbName = a } :: EcsServiceLoadBalancer s)

instance P.HasTargetGroupArn (EcsServiceLoadBalancer s) (TF.Attr s P.Text) where
    targetGroupArn =
        P.lens (_targetGroupArn :: EcsServiceLoadBalancer s -> TF.Attr s P.Text)
               (\s a -> s { _targetGroupArn = a } :: EcsServiceLoadBalancer s)

-- | @runtime_configuration_server_process@ nested settings.
data RuntimeConfigurationServerProcess s = RuntimeConfigurationServerProcess'
    { _concurrentExecutions :: TF.Attr s P.Integer
    -- ^ @concurrent_executions@ - (Required)
    --
    , _launchPath           :: TF.Attr s P.Text
    -- ^ @launch_path@ - (Required)
    --
    , _parameters           :: TF.Attr s P.Text
    -- ^ @parameters@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRuntimeConfigurationServerProcess
    :: TF.Attr s P.Integer -- ^ @concurrent_executions@ - 'P.concurrentExecutions'
    -> TF.Attr s P.Text -- ^ @launch_path@ - 'P.launchPath'
    -> RuntimeConfigurationServerProcess s
newRuntimeConfigurationServerProcess _concurrentExecutions _launchPath =
    RuntimeConfigurationServerProcess'
        { _concurrentExecutions = _concurrentExecutions
        , _launchPath = _launchPath
        , _parameters = TF.Nil
        }

instance P.Hashable  (RuntimeConfigurationServerProcess s)
instance TF.IsValue  (RuntimeConfigurationServerProcess s)
instance TF.IsObject (RuntimeConfigurationServerProcess s) where
    toObject RuntimeConfigurationServerProcess'{..} = P.catMaybes
        [ TF.assign "concurrent_executions" <$> TF.attribute _concurrentExecutions
        , TF.assign "launch_path" <$> TF.attribute _launchPath
        , TF.assign "parameters" <$> TF.attribute _parameters
        ]

instance TF.IsValid (RuntimeConfigurationServerProcess s) where
    validator = P.mempty

instance P.HasConcurrentExecutions (RuntimeConfigurationServerProcess s) (TF.Attr s P.Integer) where
    concurrentExecutions =
        P.lens (_concurrentExecutions :: RuntimeConfigurationServerProcess s -> TF.Attr s P.Integer)
               (\s a -> s { _concurrentExecutions = a } :: RuntimeConfigurationServerProcess s)

instance P.HasLaunchPath (RuntimeConfigurationServerProcess s) (TF.Attr s P.Text) where
    launchPath =
        P.lens (_launchPath :: RuntimeConfigurationServerProcess s -> TF.Attr s P.Text)
               (\s a -> s { _launchPath = a } :: RuntimeConfigurationServerProcess s)

instance P.HasParameters (RuntimeConfigurationServerProcess s) (TF.Attr s P.Text) where
    parameters =
        P.lens (_parameters :: RuntimeConfigurationServerProcess s -> TF.Attr s P.Text)
               (\s a -> s { _parameters = a } :: RuntimeConfigurationServerProcess s)

-- | @glue_classifier_xml_classifier@ nested settings.
data GlueClassifierXmlClassifier s = GlueClassifierXmlClassifier'
    { _classification :: TF.Attr s P.Text
    -- ^ @classification@ - (Required)
    --
    , _rowTag         :: TF.Attr s P.Text
    -- ^ @row_tag@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newGlueClassifierXmlClassifier
    :: TF.Attr s P.Text -- ^ @classification@ - 'P.classification'
    -> TF.Attr s P.Text -- ^ @row_tag@ - 'P.rowTag'
    -> GlueClassifierXmlClassifier s
newGlueClassifierXmlClassifier _classification _rowTag =
    GlueClassifierXmlClassifier'
        { _classification = _classification
        , _rowTag = _rowTag
        }

instance P.Hashable  (GlueClassifierXmlClassifier s)
instance TF.IsValue  (GlueClassifierXmlClassifier s)
instance TF.IsObject (GlueClassifierXmlClassifier s) where
    toObject GlueClassifierXmlClassifier'{..} = P.catMaybes
        [ TF.assign "classification" <$> TF.attribute _classification
        , TF.assign "row_tag" <$> TF.attribute _rowTag
        ]

instance TF.IsValid (GlueClassifierXmlClassifier s) where
    validator = P.mempty

instance P.HasClassification (GlueClassifierXmlClassifier s) (TF.Attr s P.Text) where
    classification =
        P.lens (_classification :: GlueClassifierXmlClassifier s -> TF.Attr s P.Text)
               (\s a -> s { _classification = a } :: GlueClassifierXmlClassifier s)

instance P.HasRowTag (GlueClassifierXmlClassifier s) (TF.Attr s P.Text) where
    rowTag =
        P.lens (_rowTag :: GlueClassifierXmlClassifier s -> TF.Attr s P.Text)
               (\s a -> s { _rowTag = a } :: GlueClassifierXmlClassifier s)

-- | @vpc_cidr_block_associations@ nested settings.
data VpcCidrBlockAssociations s = VpcCidrBlockAssociations'
    deriving (P.Show, P.Eq, P.Generic)

newVpcCidrBlockAssociations
    :: VpcCidrBlockAssociations s
newVpcCidrBlockAssociations =
    VpcCidrBlockAssociations'

instance P.Hashable  (VpcCidrBlockAssociations s)
instance TF.IsValue  (VpcCidrBlockAssociations s)
instance TF.IsObject (VpcCidrBlockAssociations s) where
    toObject VpcCidrBlockAssociations' = []

instance TF.IsValid (VpcCidrBlockAssociations s) where
    validator = P.mempty

instance s ~ s' => P.HasComputedAssociationId (TF.Ref s' (VpcCidrBlockAssociations s)) (TF.Attr s P.Text) where
    computedAssociationId x = TF.compute (TF.refKey x) "association_id"

instance s ~ s' => P.HasComputedCidrBlock (TF.Ref s' (VpcCidrBlockAssociations s)) (TF.Attr s P.Text) where
    computedCidrBlock x = TF.compute (TF.refKey x) "cidr_block"

instance s ~ s' => P.HasComputedState (TF.Ref s' (VpcCidrBlockAssociations s)) (TF.Attr s P.Text) where
    computedState x = TF.compute (TF.refKey x) "state"

-- | @glue_classifier_grok_classifier@ nested settings.
data GlueClassifierGrokClassifier s = GlueClassifierGrokClassifier'
    { _classification :: TF.Attr s P.Text
    -- ^ @classification@ - (Required)
    --
    , _customPatterns :: TF.Attr s P.Text
    -- ^ @custom_patterns@ - (Optional)
    --
    , _grokPattern    :: TF.Attr s P.Text
    -- ^ @grok_pattern@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newGlueClassifierGrokClassifier
    :: TF.Attr s P.Text -- ^ @classification@ - 'P.classification'
    -> TF.Attr s P.Text -- ^ @grok_pattern@ - 'P.grokPattern'
    -> GlueClassifierGrokClassifier s
newGlueClassifierGrokClassifier _classification _grokPattern =
    GlueClassifierGrokClassifier'
        { _classification = _classification
        , _customPatterns = TF.Nil
        , _grokPattern = _grokPattern
        }

instance P.Hashable  (GlueClassifierGrokClassifier s)
instance TF.IsValue  (GlueClassifierGrokClassifier s)
instance TF.IsObject (GlueClassifierGrokClassifier s) where
    toObject GlueClassifierGrokClassifier'{..} = P.catMaybes
        [ TF.assign "classification" <$> TF.attribute _classification
        , TF.assign "custom_patterns" <$> TF.attribute _customPatterns
        , TF.assign "grok_pattern" <$> TF.attribute _grokPattern
        ]

instance TF.IsValid (GlueClassifierGrokClassifier s) where
    validator = P.mempty

instance P.HasClassification (GlueClassifierGrokClassifier s) (TF.Attr s P.Text) where
    classification =
        P.lens (_classification :: GlueClassifierGrokClassifier s -> TF.Attr s P.Text)
               (\s a -> s { _classification = a } :: GlueClassifierGrokClassifier s)

instance P.HasCustomPatterns (GlueClassifierGrokClassifier s) (TF.Attr s P.Text) where
    customPatterns =
        P.lens (_customPatterns :: GlueClassifierGrokClassifier s -> TF.Attr s P.Text)
               (\s a -> s { _customPatterns = a } :: GlueClassifierGrokClassifier s)

instance P.HasGrokPattern (GlueClassifierGrokClassifier s) (TF.Attr s P.Text) where
    grokPattern =
        P.lens (_grokPattern :: GlueClassifierGrokClassifier s -> TF.Attr s P.Text)
               (\s a -> s { _grokPattern = a } :: GlueClassifierGrokClassifier s)

-- | @network_acl_egress@ nested settings.
data NetworkAclEgress s = NetworkAclEgress'
    { _action        :: TF.Attr s P.Text
    -- ^ @action@ - (Required)
    --
    , _cidrBlock     :: TF.Attr s P.Text
    -- ^ @cidr_block@ - (Optional)
    --
    , _fromPort      :: TF.Attr s P.Integer
    -- ^ @from_port@ - (Required)
    --
    , _icmpCode      :: TF.Attr s P.Integer
    -- ^ @icmp_code@ - (Optional)
    --
    , _icmpType      :: TF.Attr s P.Integer
    -- ^ @icmp_type@ - (Optional)
    --
    , _ipv6CidrBlock :: TF.Attr s P.Text
    -- ^ @ipv6_cidr_block@ - (Optional)
    --
    , _protocol      :: TF.Attr s P.Text
    -- ^ @protocol@ - (Required)
    --
    , _ruleNo        :: TF.Attr s P.Integer
    -- ^ @rule_no@ - (Required)
    --
    , _toPort        :: TF.Attr s P.Integer
    -- ^ @to_port@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newNetworkAclEgress
    :: TF.Attr s P.Text -- ^ @action@ - 'P.action'
    -> TF.Attr s P.Integer -- ^ @from_port@ - 'P.fromPort'
    -> TF.Attr s P.Text -- ^ @protocol@ - 'P.protocol'
    -> TF.Attr s P.Integer -- ^ @rule_no@ - 'P.ruleNo'
    -> TF.Attr s P.Integer -- ^ @to_port@ - 'P.toPort'
    -> NetworkAclEgress s
newNetworkAclEgress _action _fromPort _protocol _ruleNo _toPort =
    NetworkAclEgress'
        { _action = _action
        , _cidrBlock = TF.Nil
        , _fromPort = _fromPort
        , _icmpCode = TF.Nil
        , _icmpType = TF.Nil
        , _ipv6CidrBlock = TF.Nil
        , _protocol = _protocol
        , _ruleNo = _ruleNo
        , _toPort = _toPort
        }

instance P.Hashable  (NetworkAclEgress s)
instance TF.IsValue  (NetworkAclEgress s)
instance TF.IsObject (NetworkAclEgress s) where
    toObject NetworkAclEgress'{..} = P.catMaybes
        [ TF.assign "action" <$> TF.attribute _action
        , TF.assign "cidr_block" <$> TF.attribute _cidrBlock
        , TF.assign "from_port" <$> TF.attribute _fromPort
        , TF.assign "icmp_code" <$> TF.attribute _icmpCode
        , TF.assign "icmp_type" <$> TF.attribute _icmpType
        , TF.assign "ipv6_cidr_block" <$> TF.attribute _ipv6CidrBlock
        , TF.assign "protocol" <$> TF.attribute _protocol
        , TF.assign "rule_no" <$> TF.attribute _ruleNo
        , TF.assign "to_port" <$> TF.attribute _toPort
        ]

instance TF.IsValid (NetworkAclEgress s) where
    validator = P.mempty

instance P.HasAction (NetworkAclEgress s) (TF.Attr s P.Text) where
    action =
        P.lens (_action :: NetworkAclEgress s -> TF.Attr s P.Text)
               (\s a -> s { _action = a } :: NetworkAclEgress s)

instance P.HasCidrBlock (NetworkAclEgress s) (TF.Attr s P.Text) where
    cidrBlock =
        P.lens (_cidrBlock :: NetworkAclEgress s -> TF.Attr s P.Text)
               (\s a -> s { _cidrBlock = a } :: NetworkAclEgress s)

instance P.HasFromPort (NetworkAclEgress s) (TF.Attr s P.Integer) where
    fromPort =
        P.lens (_fromPort :: NetworkAclEgress s -> TF.Attr s P.Integer)
               (\s a -> s { _fromPort = a } :: NetworkAclEgress s)

instance P.HasIcmpCode (NetworkAclEgress s) (TF.Attr s P.Integer) where
    icmpCode =
        P.lens (_icmpCode :: NetworkAclEgress s -> TF.Attr s P.Integer)
               (\s a -> s { _icmpCode = a } :: NetworkAclEgress s)

instance P.HasIcmpType (NetworkAclEgress s) (TF.Attr s P.Integer) where
    icmpType =
        P.lens (_icmpType :: NetworkAclEgress s -> TF.Attr s P.Integer)
               (\s a -> s { _icmpType = a } :: NetworkAclEgress s)

instance P.HasIpv6CidrBlock (NetworkAclEgress s) (TF.Attr s P.Text) where
    ipv6CidrBlock =
        P.lens (_ipv6CidrBlock :: NetworkAclEgress s -> TF.Attr s P.Text)
               (\s a -> s { _ipv6CidrBlock = a } :: NetworkAclEgress s)

instance P.HasProtocol (NetworkAclEgress s) (TF.Attr s P.Text) where
    protocol =
        P.lens (_protocol :: NetworkAclEgress s -> TF.Attr s P.Text)
               (\s a -> s { _protocol = a } :: NetworkAclEgress s)

instance P.HasRuleNo (NetworkAclEgress s) (TF.Attr s P.Integer) where
    ruleNo =
        P.lens (_ruleNo :: NetworkAclEgress s -> TF.Attr s P.Integer)
               (\s a -> s { _ruleNo = a } :: NetworkAclEgress s)

instance P.HasToPort (NetworkAclEgress s) (TF.Attr s P.Integer) where
    toPort =
        P.lens (_toPort :: NetworkAclEgress s -> TF.Attr s P.Integer)
               (\s a -> s { _toPort = a } :: NetworkAclEgress s)

-- | @vpc_dhcp_options_filter@ nested settings.
data VpcDhcpOptionsFilter s = VpcDhcpOptionsFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newVpcDhcpOptionsFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> VpcDhcpOptionsFilter s
newVpcDhcpOptionsFilter _name _values =
    VpcDhcpOptionsFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (VpcDhcpOptionsFilter s)
instance TF.IsValue  (VpcDhcpOptionsFilter s)
instance TF.IsObject (VpcDhcpOptionsFilter s) where
    toObject VpcDhcpOptionsFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (VpcDhcpOptionsFilter s) where
    validator = P.mempty

instance P.HasName (VpcDhcpOptionsFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: VpcDhcpOptionsFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: VpcDhcpOptionsFilter s)

instance P.HasValues (VpcDhcpOptionsFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: VpcDhcpOptionsFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: VpcDhcpOptionsFilter s)

-- | @s3_bucket_metric_filter@ nested settings.
data S3BucketMetricFilter s = S3BucketMetricFilter'
    { _prefix :: TF.Attr s P.Text
    -- ^ @prefix@ - (Optional)
    --
    , _tags   :: TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))
    -- ^ @tags@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newS3BucketMetricFilter
    :: S3BucketMetricFilter s
newS3BucketMetricFilter =
    S3BucketMetricFilter'
        { _prefix = TF.Nil
        , _tags = TF.Nil
        }

instance P.Hashable  (S3BucketMetricFilter s)
instance TF.IsValue  (S3BucketMetricFilter s)
instance TF.IsObject (S3BucketMetricFilter s) where
    toObject S3BucketMetricFilter'{..} = P.catMaybes
        [ TF.assign "prefix" <$> TF.attribute _prefix
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance TF.IsValid (S3BucketMetricFilter s) where
    validator = P.mempty

instance P.HasPrefix (S3BucketMetricFilter s) (TF.Attr s P.Text) where
    prefix =
        P.lens (_prefix :: S3BucketMetricFilter s -> TF.Attr s P.Text)
               (\s a -> s { _prefix = a } :: S3BucketMetricFilter s)

instance P.HasTags (S3BucketMetricFilter s) (TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))) where
    tags =
        P.lens (_tags :: S3BucketMetricFilter s -> TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text)))
               (\s a -> s { _tags = a } :: S3BucketMetricFilter s)

-- | @ec2_tag_set_ec2_tag_filter@ nested settings.
data Ec2TagSetEc2TagFilter s = Ec2TagSetEc2TagFilter'
    { _key   :: TF.Attr s P.Text
    -- ^ @key@ - (Optional)
    --
    , _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Optional)
    --
    , _value :: TF.Attr s P.Text
    -- ^ @value@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newEc2TagSetEc2TagFilter
    :: Ec2TagSetEc2TagFilter s
newEc2TagSetEc2TagFilter =
    Ec2TagSetEc2TagFilter'
        { _key = TF.Nil
        , _type' = TF.Nil
        , _value = TF.Nil
        }

instance P.Hashable  (Ec2TagSetEc2TagFilter s)
instance TF.IsValue  (Ec2TagSetEc2TagFilter s)
instance TF.IsObject (Ec2TagSetEc2TagFilter s) where
    toObject Ec2TagSetEc2TagFilter'{..} = P.catMaybes
        [ TF.assign "key" <$> TF.attribute _key
        , TF.assign "type" <$> TF.attribute _type'
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (Ec2TagSetEc2TagFilter s) where
    validator = P.mempty

instance P.HasKey (Ec2TagSetEc2TagFilter s) (TF.Attr s P.Text) where
    key =
        P.lens (_key :: Ec2TagSetEc2TagFilter s -> TF.Attr s P.Text)
               (\s a -> s { _key = a } :: Ec2TagSetEc2TagFilter s)

instance P.HasType' (Ec2TagSetEc2TagFilter s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: Ec2TagSetEc2TagFilter s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: Ec2TagSetEc2TagFilter s)

instance P.HasValue (Ec2TagSetEc2TagFilter s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: Ec2TagSetEc2TagFilter s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: Ec2TagSetEc2TagFilter s)

-- | @macie_s3_bucket_association_classification_type@ nested settings.
data MacieS3BucketAssociationClassificationType s = MacieS3BucketAssociationClassificationType'
    { _continuous :: TF.Attr s P.Text
    -- ^ @continuous@ - (Optional)
    --
    , _oneTime    :: TF.Attr s P.Text
    -- ^ @one_time@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newMacieS3BucketAssociationClassificationType
    :: MacieS3BucketAssociationClassificationType s
newMacieS3BucketAssociationClassificationType =
    MacieS3BucketAssociationClassificationType'
        { _continuous = TF.value "FULL"
        , _oneTime = TF.value "NONE"
        }

instance P.Hashable  (MacieS3BucketAssociationClassificationType s)
instance TF.IsValue  (MacieS3BucketAssociationClassificationType s)
instance TF.IsObject (MacieS3BucketAssociationClassificationType s) where
    toObject MacieS3BucketAssociationClassificationType'{..} = P.catMaybes
        [ TF.assign "continuous" <$> TF.attribute _continuous
        , TF.assign "one_time" <$> TF.attribute _oneTime
        ]

instance TF.IsValid (MacieS3BucketAssociationClassificationType s) where
    validator = P.mempty

instance P.HasContinuous (MacieS3BucketAssociationClassificationType s) (TF.Attr s P.Text) where
    continuous =
        P.lens (_continuous :: MacieS3BucketAssociationClassificationType s -> TF.Attr s P.Text)
               (\s a -> s { _continuous = a } :: MacieS3BucketAssociationClassificationType s)

instance P.HasOneTime (MacieS3BucketAssociationClassificationType s) (TF.Attr s P.Text) where
    oneTime =
        P.lens (_oneTime :: MacieS3BucketAssociationClassificationType s -> TF.Attr s P.Text)
               (\s a -> s { _oneTime = a } :: MacieS3BucketAssociationClassificationType s)

-- | @emr_cluster_kerberos_attributes@ nested settings.
data EmrClusterKerberosAttributes s = EmrClusterKerberosAttributes'
    { _adDomainJoinPassword             :: TF.Attr s P.Text
    -- ^ @ad_domain_join_password@ - (Optional, Forces New)
    --
    , _adDomainJoinUser                 :: TF.Attr s P.Text
    -- ^ @ad_domain_join_user@ - (Optional, Forces New)
    --
    , _crossRealmTrustPrincipalPassword :: TF.Attr s P.Text
    -- ^ @cross_realm_trust_principal_password@ - (Optional, Forces New)
    --
    , _kdcAdminPassword                 :: TF.Attr s P.Text
    -- ^ @kdc_admin_password@ - (Required, Forces New)
    --
    , _realm                            :: TF.Attr s P.Text
    -- ^ @realm@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newEmrClusterKerberosAttributes
    :: TF.Attr s P.Text -- ^ @kdc_admin_password@ - 'P.kdcAdminPassword'
    -> TF.Attr s P.Text -- ^ @realm@ - 'P.realm'
    -> EmrClusterKerberosAttributes s
newEmrClusterKerberosAttributes _kdcAdminPassword _realm =
    EmrClusterKerberosAttributes'
        { _adDomainJoinPassword = TF.Nil
        , _adDomainJoinUser = TF.Nil
        , _crossRealmTrustPrincipalPassword = TF.Nil
        , _kdcAdminPassword = _kdcAdminPassword
        , _realm = _realm
        }

instance P.Hashable  (EmrClusterKerberosAttributes s)
instance TF.IsValue  (EmrClusterKerberosAttributes s)
instance TF.IsObject (EmrClusterKerberosAttributes s) where
    toObject EmrClusterKerberosAttributes'{..} = P.catMaybes
        [ TF.assign "ad_domain_join_password" <$> TF.attribute _adDomainJoinPassword
        , TF.assign "ad_domain_join_user" <$> TF.attribute _adDomainJoinUser
        , TF.assign "cross_realm_trust_principal_password" <$> TF.attribute _crossRealmTrustPrincipalPassword
        , TF.assign "kdc_admin_password" <$> TF.attribute _kdcAdminPassword
        , TF.assign "realm" <$> TF.attribute _realm
        ]

instance TF.IsValid (EmrClusterKerberosAttributes s) where
    validator = P.mempty

instance P.HasAdDomainJoinPassword (EmrClusterKerberosAttributes s) (TF.Attr s P.Text) where
    adDomainJoinPassword =
        P.lens (_adDomainJoinPassword :: EmrClusterKerberosAttributes s -> TF.Attr s P.Text)
               (\s a -> s { _adDomainJoinPassword = a } :: EmrClusterKerberosAttributes s)

instance P.HasAdDomainJoinUser (EmrClusterKerberosAttributes s) (TF.Attr s P.Text) where
    adDomainJoinUser =
        P.lens (_adDomainJoinUser :: EmrClusterKerberosAttributes s -> TF.Attr s P.Text)
               (\s a -> s { _adDomainJoinUser = a } :: EmrClusterKerberosAttributes s)

instance P.HasCrossRealmTrustPrincipalPassword (EmrClusterKerberosAttributes s) (TF.Attr s P.Text) where
    crossRealmTrustPrincipalPassword =
        P.lens (_crossRealmTrustPrincipalPassword :: EmrClusterKerberosAttributes s -> TF.Attr s P.Text)
               (\s a -> s { _crossRealmTrustPrincipalPassword = a } :: EmrClusterKerberosAttributes s)

instance P.HasKdcAdminPassword (EmrClusterKerberosAttributes s) (TF.Attr s P.Text) where
    kdcAdminPassword =
        P.lens (_kdcAdminPassword :: EmrClusterKerberosAttributes s -> TF.Attr s P.Text)
               (\s a -> s { _kdcAdminPassword = a } :: EmrClusterKerberosAttributes s)

instance P.HasRealm (EmrClusterKerberosAttributes s) (TF.Attr s P.Text) where
    realm =
        P.lens (_realm :: EmrClusterKerberosAttributes s -> TF.Attr s P.Text)
               (\s a -> s { _realm = a } :: EmrClusterKerberosAttributes s)

-- | @route_table_associations@ nested settings.
data RouteTableAssociations s = RouteTableAssociations'
    deriving (P.Show, P.Eq, P.Generic)

newRouteTableAssociations
    :: RouteTableAssociations s
newRouteTableAssociations =
    RouteTableAssociations'

instance P.Hashable  (RouteTableAssociations s)
instance TF.IsValue  (RouteTableAssociations s)
instance TF.IsObject (RouteTableAssociations s) where
    toObject RouteTableAssociations' = []

instance TF.IsValid (RouteTableAssociations s) where
    validator = P.mempty

instance s ~ s' => P.HasComputedMain (TF.Ref s' (RouteTableAssociations s)) (TF.Attr s P.Bool) where
    computedMain x = TF.compute (TF.refKey x) "main"

instance s ~ s' => P.HasComputedRouteTableAssociationId (TF.Ref s' (RouteTableAssociations s)) (TF.Attr s P.Text) where
    computedRouteTableAssociationId x = TF.compute (TF.refKey x) "route_table_association_id"

instance s ~ s' => P.HasComputedRouteTableId (TF.Ref s' (RouteTableAssociations s)) (TF.Attr s P.Text) where
    computedRouteTableId x = TF.compute (TF.refKey x) "route_table_id"

instance s ~ s' => P.HasComputedSubnetId (TF.Ref s' (RouteTableAssociations s)) (TF.Attr s P.Text) where
    computedSubnetId x = TF.compute (TF.refKey x) "subnet_id"

-- | @rds_cluster_s3_import@ nested settings.
data RdsClusterS3Import s = RdsClusterS3Import'
    { _bucketName          :: TF.Attr s P.Text
    -- ^ @bucket_name@ - (Required, Forces New)
    --
    , _bucketPrefix        :: TF.Attr s P.Text
    -- ^ @bucket_prefix@ - (Optional, Forces New)
    --
    , _ingestionRole       :: TF.Attr s P.Text
    -- ^ @ingestion_role@ - (Required, Forces New)
    --
    , _sourceEngine        :: TF.Attr s P.Text
    -- ^ @source_engine@ - (Required, Forces New)
    --
    , _sourceEngineVersion :: TF.Attr s P.Text
    -- ^ @source_engine_version@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRdsClusterS3Import
    :: TF.Attr s P.Text -- ^ @bucket_name@ - 'P.bucketName'
    -> TF.Attr s P.Text -- ^ @ingestion_role@ - 'P.ingestionRole'
    -> TF.Attr s P.Text -- ^ @source_engine@ - 'P.sourceEngine'
    -> TF.Attr s P.Text -- ^ @source_engine_version@ - 'P.sourceEngineVersion'
    -> RdsClusterS3Import s
newRdsClusterS3Import _bucketName _ingestionRole _sourceEngine _sourceEngineVersion =
    RdsClusterS3Import'
        { _bucketName = _bucketName
        , _bucketPrefix = TF.Nil
        , _ingestionRole = _ingestionRole
        , _sourceEngine = _sourceEngine
        , _sourceEngineVersion = _sourceEngineVersion
        }

instance P.Hashable  (RdsClusterS3Import s)
instance TF.IsValue  (RdsClusterS3Import s)
instance TF.IsObject (RdsClusterS3Import s) where
    toObject RdsClusterS3Import'{..} = P.catMaybes
        [ TF.assign "bucket_name" <$> TF.attribute _bucketName
        , TF.assign "bucket_prefix" <$> TF.attribute _bucketPrefix
        , TF.assign "ingestion_role" <$> TF.attribute _ingestionRole
        , TF.assign "source_engine" <$> TF.attribute _sourceEngine
        , TF.assign "source_engine_version" <$> TF.attribute _sourceEngineVersion
        ]

instance TF.IsValid (RdsClusterS3Import s) where
    validator = P.mempty

instance P.HasBucketName (RdsClusterS3Import s) (TF.Attr s P.Text) where
    bucketName =
        P.lens (_bucketName :: RdsClusterS3Import s -> TF.Attr s P.Text)
               (\s a -> s { _bucketName = a } :: RdsClusterS3Import s)

instance P.HasBucketPrefix (RdsClusterS3Import s) (TF.Attr s P.Text) where
    bucketPrefix =
        P.lens (_bucketPrefix :: RdsClusterS3Import s -> TF.Attr s P.Text)
               (\s a -> s { _bucketPrefix = a } :: RdsClusterS3Import s)

instance P.HasIngestionRole (RdsClusterS3Import s) (TF.Attr s P.Text) where
    ingestionRole =
        P.lens (_ingestionRole :: RdsClusterS3Import s -> TF.Attr s P.Text)
               (\s a -> s { _ingestionRole = a } :: RdsClusterS3Import s)

instance P.HasSourceEngine (RdsClusterS3Import s) (TF.Attr s P.Text) where
    sourceEngine =
        P.lens (_sourceEngine :: RdsClusterS3Import s -> TF.Attr s P.Text)
               (\s a -> s { _sourceEngine = a } :: RdsClusterS3Import s)

instance P.HasSourceEngineVersion (RdsClusterS3Import s) (TF.Attr s P.Text) where
    sourceEngineVersion =
        P.lens (_sourceEngineVersion :: RdsClusterS3Import s -> TF.Attr s P.Text)
               (\s a -> s { _sourceEngineVersion = a } :: RdsClusterS3Import s)

-- | @cognito_user_pool_password_policy@ nested settings.
data CognitoUserPoolPasswordPolicy s = CognitoUserPoolPasswordPolicy'
    { _minimumLength    :: TF.Attr s P.Integer
    -- ^ @minimum_length@ - (Optional)
    --
    , _requireLowercase :: TF.Attr s P.Bool
    -- ^ @require_lowercase@ - (Optional)
    --
    , _requireNumbers   :: TF.Attr s P.Bool
    -- ^ @require_numbers@ - (Optional)
    --
    , _requireSymbols   :: TF.Attr s P.Bool
    -- ^ @require_symbols@ - (Optional)
    --
    , _requireUppercase :: TF.Attr s P.Bool
    -- ^ @require_uppercase@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCognitoUserPoolPasswordPolicy
    :: CognitoUserPoolPasswordPolicy s
newCognitoUserPoolPasswordPolicy =
    CognitoUserPoolPasswordPolicy'
        { _minimumLength = TF.Nil
        , _requireLowercase = TF.Nil
        , _requireNumbers = TF.Nil
        , _requireSymbols = TF.Nil
        , _requireUppercase = TF.Nil
        }

instance P.Hashable  (CognitoUserPoolPasswordPolicy s)
instance TF.IsValue  (CognitoUserPoolPasswordPolicy s)
instance TF.IsObject (CognitoUserPoolPasswordPolicy s) where
    toObject CognitoUserPoolPasswordPolicy'{..} = P.catMaybes
        [ TF.assign "minimum_length" <$> TF.attribute _minimumLength
        , TF.assign "require_lowercase" <$> TF.attribute _requireLowercase
        , TF.assign "require_numbers" <$> TF.attribute _requireNumbers
        , TF.assign "require_symbols" <$> TF.attribute _requireSymbols
        , TF.assign "require_uppercase" <$> TF.attribute _requireUppercase
        ]

instance TF.IsValid (CognitoUserPoolPasswordPolicy s) where
    validator = P.mempty

instance P.HasMinimumLength (CognitoUserPoolPasswordPolicy s) (TF.Attr s P.Integer) where
    minimumLength =
        P.lens (_minimumLength :: CognitoUserPoolPasswordPolicy s -> TF.Attr s P.Integer)
               (\s a -> s { _minimumLength = a } :: CognitoUserPoolPasswordPolicy s)

instance P.HasRequireLowercase (CognitoUserPoolPasswordPolicy s) (TF.Attr s P.Bool) where
    requireLowercase =
        P.lens (_requireLowercase :: CognitoUserPoolPasswordPolicy s -> TF.Attr s P.Bool)
               (\s a -> s { _requireLowercase = a } :: CognitoUserPoolPasswordPolicy s)

instance P.HasRequireNumbers (CognitoUserPoolPasswordPolicy s) (TF.Attr s P.Bool) where
    requireNumbers =
        P.lens (_requireNumbers :: CognitoUserPoolPasswordPolicy s -> TF.Attr s P.Bool)
               (\s a -> s { _requireNumbers = a } :: CognitoUserPoolPasswordPolicy s)

instance P.HasRequireSymbols (CognitoUserPoolPasswordPolicy s) (TF.Attr s P.Bool) where
    requireSymbols =
        P.lens (_requireSymbols :: CognitoUserPoolPasswordPolicy s -> TF.Attr s P.Bool)
               (\s a -> s { _requireSymbols = a } :: CognitoUserPoolPasswordPolicy s)

instance P.HasRequireUppercase (CognitoUserPoolPasswordPolicy s) (TF.Attr s P.Bool) where
    requireUppercase =
        P.lens (_requireUppercase :: CognitoUserPoolPasswordPolicy s -> TF.Attr s P.Bool)
               (\s a -> s { _requireUppercase = a } :: CognitoUserPoolPasswordPolicy s)

-- | @kinesis_firehose_delivery_stream_redshift_configuration@ nested settings.
data KinesisFirehoseDeliveryStreamRedshiftConfiguration s = KinesisFirehoseDeliveryStreamRedshiftConfiguration'
    { _clusterJdbcurl :: TF.Attr s P.Text
    -- ^ @cluster_jdbcurl@ - (Required)
    --
    , _copyOptions :: TF.Attr s P.Text
    -- ^ @copy_options@ - (Optional)
    --
    , _dataTableColumns :: TF.Attr s P.Text
    -- ^ @data_table_columns@ - (Optional)
    --
    , _dataTableName :: TF.Attr s P.Text
    -- ^ @data_table_name@ - (Required)
    --
    , _password :: TF.Attr s P.Text
    -- ^ @password@ - (Required)
    --
    , _processingConfiguration :: TF.Attr s (RedshiftConfigurationProcessingConfiguration s)
    -- ^ @processing_configuration@ - (Optional)
    --
    , _retryDuration :: TF.Attr s P.Integer
    -- ^ @retry_duration@ - (Optional)
    --
    , _roleArn :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Required)
    --
    , _s3BackupConfiguration :: TF.Attr s (RedshiftConfigurationS3BackupConfiguration s)
    -- ^ @s3_backup_configuration@ - (Optional)
    --
    , _s3BackupMode :: TF.Attr s P.Text
    -- ^ @s3_backup_mode@ - (Optional)
    --
    , _username :: TF.Attr s P.Text
    -- ^ @username@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newKinesisFirehoseDeliveryStreamRedshiftConfiguration
    :: TF.Attr s P.Text -- ^ @cluster_jdbcurl@ - 'P.clusterJdbcurl'
    -> TF.Attr s P.Text -- ^ @data_table_name@ - 'P.dataTableName'
    -> TF.Attr s P.Text -- ^ @password@ - 'P.password'
    -> TF.Attr s P.Text -- ^ @role_arn@ - 'P.roleArn'
    -> TF.Attr s P.Text -- ^ @username@ - 'P.username'
    -> KinesisFirehoseDeliveryStreamRedshiftConfiguration s
newKinesisFirehoseDeliveryStreamRedshiftConfiguration _clusterJdbcurl _dataTableName _password _roleArn _username =
    KinesisFirehoseDeliveryStreamRedshiftConfiguration'
        { _clusterJdbcurl = _clusterJdbcurl
        , _copyOptions = TF.Nil
        , _dataTableColumns = TF.Nil
        , _dataTableName = _dataTableName
        , _password = _password
        , _processingConfiguration = TF.Nil
        , _retryDuration = TF.value 3600
        , _roleArn = _roleArn
        , _s3BackupConfiguration = TF.Nil
        , _s3BackupMode = TF.value "Disabled"
        , _username = _username
        }

instance P.Hashable  (KinesisFirehoseDeliveryStreamRedshiftConfiguration s)
instance TF.IsValue  (KinesisFirehoseDeliveryStreamRedshiftConfiguration s)
instance TF.IsObject (KinesisFirehoseDeliveryStreamRedshiftConfiguration s) where
    toObject KinesisFirehoseDeliveryStreamRedshiftConfiguration'{..} = P.catMaybes
        [ TF.assign "cluster_jdbcurl" <$> TF.attribute _clusterJdbcurl
        , TF.assign "copy_options" <$> TF.attribute _copyOptions
        , TF.assign "data_table_columns" <$> TF.attribute _dataTableColumns
        , TF.assign "data_table_name" <$> TF.attribute _dataTableName
        , TF.assign "password" <$> TF.attribute _password
        , TF.assign "processing_configuration" <$> TF.attribute _processingConfiguration
        , TF.assign "retry_duration" <$> TF.attribute _retryDuration
        , TF.assign "role_arn" <$> TF.attribute _roleArn
        , TF.assign "s3_backup_configuration" <$> TF.attribute _s3BackupConfiguration
        , TF.assign "s3_backup_mode" <$> TF.attribute _s3BackupMode
        , TF.assign "username" <$> TF.attribute _username
        ]

instance TF.IsValid (KinesisFirehoseDeliveryStreamRedshiftConfiguration s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_processingConfiguration"
                  (_processingConfiguration
                      :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s -> TF.Attr s (RedshiftConfigurationProcessingConfiguration s))
                  TF.validator
           P.<> TF.settingsValidator "_s3BackupConfiguration"
                  (_s3BackupConfiguration
                      :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s -> TF.Attr s (RedshiftConfigurationS3BackupConfiguration s))
                  TF.validator

instance P.HasClusterJdbcurl (KinesisFirehoseDeliveryStreamRedshiftConfiguration s) (TF.Attr s P.Text) where
    clusterJdbcurl =
        P.lens (_clusterJdbcurl :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _clusterJdbcurl = a } :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s)

instance P.HasCopyOptions (KinesisFirehoseDeliveryStreamRedshiftConfiguration s) (TF.Attr s P.Text) where
    copyOptions =
        P.lens (_copyOptions :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _copyOptions = a } :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s)

instance P.HasDataTableColumns (KinesisFirehoseDeliveryStreamRedshiftConfiguration s) (TF.Attr s P.Text) where
    dataTableColumns =
        P.lens (_dataTableColumns :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _dataTableColumns = a } :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s)

instance P.HasDataTableName (KinesisFirehoseDeliveryStreamRedshiftConfiguration s) (TF.Attr s P.Text) where
    dataTableName =
        P.lens (_dataTableName :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _dataTableName = a } :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s)

instance P.HasPassword (KinesisFirehoseDeliveryStreamRedshiftConfiguration s) (TF.Attr s P.Text) where
    password =
        P.lens (_password :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _password = a } :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s)

instance P.HasProcessingConfiguration (KinesisFirehoseDeliveryStreamRedshiftConfiguration s) (TF.Attr s (RedshiftConfigurationProcessingConfiguration s)) where
    processingConfiguration =
        P.lens (_processingConfiguration :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s -> TF.Attr s (RedshiftConfigurationProcessingConfiguration s))
               (\s a -> s { _processingConfiguration = a } :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s)

instance P.HasRetryDuration (KinesisFirehoseDeliveryStreamRedshiftConfiguration s) (TF.Attr s P.Integer) where
    retryDuration =
        P.lens (_retryDuration :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s -> TF.Attr s P.Integer)
               (\s a -> s { _retryDuration = a } :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s)

instance P.HasRoleArn (KinesisFirehoseDeliveryStreamRedshiftConfiguration s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s)

instance P.HasS3BackupConfiguration (KinesisFirehoseDeliveryStreamRedshiftConfiguration s) (TF.Attr s (RedshiftConfigurationS3BackupConfiguration s)) where
    s3BackupConfiguration =
        P.lens (_s3BackupConfiguration :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s -> TF.Attr s (RedshiftConfigurationS3BackupConfiguration s))
               (\s a -> s { _s3BackupConfiguration = a } :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s)

instance P.HasS3BackupMode (KinesisFirehoseDeliveryStreamRedshiftConfiguration s) (TF.Attr s P.Text) where
    s3BackupMode =
        P.lens (_s3BackupMode :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _s3BackupMode = a } :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s)

instance P.HasUsername (KinesisFirehoseDeliveryStreamRedshiftConfiguration s) (TF.Attr s P.Text) where
    username =
        P.lens (_username :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _username = a } :: KinesisFirehoseDeliveryStreamRedshiftConfiguration s)

instance s ~ s' => P.HasComputedCloudwatchLoggingOptions (TF.Ref s' (KinesisFirehoseDeliveryStreamRedshiftConfiguration s)) (TF.Attr s (RedshiftConfigurationCloudwatchLoggingOptions s)) where
    computedCloudwatchLoggingOptions x = TF.compute (TF.refKey x) "cloudwatch_logging_options"

-- | @cloudfront_distribution_restrictions@ nested settings.
data CloudfrontDistributionRestrictions s = CloudfrontDistributionRestrictions'
    { _geoRestriction :: TF.Attr s (RestrictionsGeoRestriction s)
    -- ^ @geo_restriction@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCloudfrontDistributionRestrictions
    :: TF.Attr s (RestrictionsGeoRestriction s) -- ^ @geo_restriction@ - 'P.geoRestriction'
    -> CloudfrontDistributionRestrictions s
newCloudfrontDistributionRestrictions _geoRestriction =
    CloudfrontDistributionRestrictions'
        { _geoRestriction = _geoRestriction
        }

instance P.Hashable  (CloudfrontDistributionRestrictions s)
instance TF.IsValue  (CloudfrontDistributionRestrictions s)
instance TF.IsObject (CloudfrontDistributionRestrictions s) where
    toObject CloudfrontDistributionRestrictions'{..} = P.catMaybes
        [ TF.assign "geo_restriction" <$> TF.attribute _geoRestriction
        ]

instance TF.IsValid (CloudfrontDistributionRestrictions s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_geoRestriction"
                  (_geoRestriction
                      :: CloudfrontDistributionRestrictions s -> TF.Attr s (RestrictionsGeoRestriction s))
                  TF.validator

instance P.HasGeoRestriction (CloudfrontDistributionRestrictions s) (TF.Attr s (RestrictionsGeoRestriction s)) where
    geoRestriction =
        P.lens (_geoRestriction :: CloudfrontDistributionRestrictions s -> TF.Attr s (RestrictionsGeoRestriction s))
               (\s a -> s { _geoRestriction = a } :: CloudfrontDistributionRestrictions s)

-- | @s3_bucket_logging@ nested settings.
data S3BucketLogging s = S3BucketLogging'
    { _targetBucket :: TF.Attr s P.Text
    -- ^ @target_bucket@ - (Required)
    --
    , _targetPrefix :: TF.Attr s P.Text
    -- ^ @target_prefix@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newS3BucketLogging
    :: TF.Attr s P.Text -- ^ @target_bucket@ - 'P.targetBucket'
    -> S3BucketLogging s
newS3BucketLogging _targetBucket =
    S3BucketLogging'
        { _targetBucket = _targetBucket
        , _targetPrefix = TF.Nil
        }

instance P.Hashable  (S3BucketLogging s)
instance TF.IsValue  (S3BucketLogging s)
instance TF.IsObject (S3BucketLogging s) where
    toObject S3BucketLogging'{..} = P.catMaybes
        [ TF.assign "target_bucket" <$> TF.attribute _targetBucket
        , TF.assign "target_prefix" <$> TF.attribute _targetPrefix
        ]

instance TF.IsValid (S3BucketLogging s) where
    validator = P.mempty

instance P.HasTargetBucket (S3BucketLogging s) (TF.Attr s P.Text) where
    targetBucket =
        P.lens (_targetBucket :: S3BucketLogging s -> TF.Attr s P.Text)
               (\s a -> s { _targetBucket = a } :: S3BucketLogging s)

instance P.HasTargetPrefix (S3BucketLogging s) (TF.Attr s P.Text) where
    targetPrefix =
        P.lens (_targetPrefix :: S3BucketLogging s -> TF.Attr s P.Text)
               (\s a -> s { _targetPrefix = a } :: S3BucketLogging s)

-- | @data_format_conversion_configuration_schema_configuration@ nested settings.
data DataFormatConversionConfigurationSchemaConfiguration s = DataFormatConversionConfigurationSchemaConfiguration'
    { _databaseName :: TF.Attr s P.Text
    -- ^ @database_name@ - (Required)
    --
    , _roleArn      :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Required)
    --
    , _tableName    :: TF.Attr s P.Text
    -- ^ @table_name@ - (Required)
    --
    , _versionId    :: TF.Attr s P.Text
    -- ^ @version_id@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDataFormatConversionConfigurationSchemaConfiguration
    :: TF.Attr s P.Text -- ^ @database_name@ - 'P.databaseName'
    -> TF.Attr s P.Text -- ^ @role_arn@ - 'P.roleArn'
    -> TF.Attr s P.Text -- ^ @table_name@ - 'P.tableName'
    -> DataFormatConversionConfigurationSchemaConfiguration s
newDataFormatConversionConfigurationSchemaConfiguration _databaseName _roleArn _tableName =
    DataFormatConversionConfigurationSchemaConfiguration'
        { _databaseName = _databaseName
        , _roleArn = _roleArn
        , _tableName = _tableName
        , _versionId = TF.value "LATEST"
        }

instance P.Hashable  (DataFormatConversionConfigurationSchemaConfiguration s)
instance TF.IsValue  (DataFormatConversionConfigurationSchemaConfiguration s)
instance TF.IsObject (DataFormatConversionConfigurationSchemaConfiguration s) where
    toObject DataFormatConversionConfigurationSchemaConfiguration'{..} = P.catMaybes
        [ TF.assign "database_name" <$> TF.attribute _databaseName
        , TF.assign "role_arn" <$> TF.attribute _roleArn
        , TF.assign "table_name" <$> TF.attribute _tableName
        , TF.assign "version_id" <$> TF.attribute _versionId
        ]

instance TF.IsValid (DataFormatConversionConfigurationSchemaConfiguration s) where
    validator = P.mempty

instance P.HasDatabaseName (DataFormatConversionConfigurationSchemaConfiguration s) (TF.Attr s P.Text) where
    databaseName =
        P.lens (_databaseName :: DataFormatConversionConfigurationSchemaConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _databaseName = a } :: DataFormatConversionConfigurationSchemaConfiguration s)

instance P.HasRoleArn (DataFormatConversionConfigurationSchemaConfiguration s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: DataFormatConversionConfigurationSchemaConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: DataFormatConversionConfigurationSchemaConfiguration s)

instance P.HasTableName (DataFormatConversionConfigurationSchemaConfiguration s) (TF.Attr s P.Text) where
    tableName =
        P.lens (_tableName :: DataFormatConversionConfigurationSchemaConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _tableName = a } :: DataFormatConversionConfigurationSchemaConfiguration s)

instance P.HasVersionId (DataFormatConversionConfigurationSchemaConfiguration s) (TF.Attr s P.Text) where
    versionId =
        P.lens (_versionId :: DataFormatConversionConfigurationSchemaConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _versionId = a } :: DataFormatConversionConfigurationSchemaConfiguration s)

instance s ~ s' => P.HasComputedCatalogId (TF.Ref s' (DataFormatConversionConfigurationSchemaConfiguration s)) (TF.Attr s P.Text) where
    computedCatalogId x = TF.compute (TF.refKey x) "catalog_id"

instance s ~ s' => P.HasComputedRegion (TF.Ref s' (DataFormatConversionConfigurationSchemaConfiguration s)) (TF.Attr s P.Text) where
    computedRegion x = TF.compute (TF.refKey x) "region"

-- | @mq_broker_instances@ nested settings.
data MqBrokerInstances s = MqBrokerInstances'
    deriving (P.Show, P.Eq, P.Generic)

newMqBrokerInstances
    :: MqBrokerInstances s
newMqBrokerInstances =
    MqBrokerInstances'

instance P.Hashable  (MqBrokerInstances s)
instance TF.IsValue  (MqBrokerInstances s)
instance TF.IsObject (MqBrokerInstances s) where
    toObject MqBrokerInstances' = []

instance TF.IsValid (MqBrokerInstances s) where
    validator = P.mempty

instance s ~ s' => P.HasComputedConsoleUrl (TF.Ref s' (MqBrokerInstances s)) (TF.Attr s P.Text) where
    computedConsoleUrl x = TF.compute (TF.refKey x) "console_url"

instance s ~ s' => P.HasComputedEndpoints (TF.Ref s' (MqBrokerInstances s)) (TF.Attr s [TF.Attr s P.Text]) where
    computedEndpoints x = TF.compute (TF.refKey x) "endpoints"

-- | @cloudwatch_event_target_sqs_target@ nested settings.
data CloudwatchEventTargetSqsTarget s = CloudwatchEventTargetSqsTarget'
    { _messageGroupId :: TF.Attr s P.Text
    -- ^ @message_group_id@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCloudwatchEventTargetSqsTarget
    :: CloudwatchEventTargetSqsTarget s
newCloudwatchEventTargetSqsTarget =
    CloudwatchEventTargetSqsTarget'
        { _messageGroupId = TF.Nil
        }

instance P.Hashable  (CloudwatchEventTargetSqsTarget s)
instance TF.IsValue  (CloudwatchEventTargetSqsTarget s)
instance TF.IsObject (CloudwatchEventTargetSqsTarget s) where
    toObject CloudwatchEventTargetSqsTarget'{..} = P.catMaybes
        [ TF.assign "message_group_id" <$> TF.attribute _messageGroupId
        ]

instance TF.IsValid (CloudwatchEventTargetSqsTarget s) where
    validator = P.mempty

instance P.HasMessageGroupId (CloudwatchEventTargetSqsTarget s) (TF.Attr s P.Text) where
    messageGroupId =
        P.lens (_messageGroupId :: CloudwatchEventTargetSqsTarget s -> TF.Attr s P.Text)
               (\s a -> s { _messageGroupId = a } :: CloudwatchEventTargetSqsTarget s)

-- | @spot_instance_request_root_block_device@ nested settings.
data SpotInstanceRequestRootBlockDevice s = SpotInstanceRequestRootBlockDevice'
    { _deleteOnTermination :: TF.Attr s P.Bool
    -- ^ @delete_on_termination@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSpotInstanceRequestRootBlockDevice
    :: SpotInstanceRequestRootBlockDevice s
newSpotInstanceRequestRootBlockDevice =
    SpotInstanceRequestRootBlockDevice'
        { _deleteOnTermination = TF.value P.True
        }

instance P.Hashable  (SpotInstanceRequestRootBlockDevice s)
instance TF.IsValue  (SpotInstanceRequestRootBlockDevice s)
instance TF.IsObject (SpotInstanceRequestRootBlockDevice s) where
    toObject SpotInstanceRequestRootBlockDevice'{..} = P.catMaybes
        [ TF.assign "delete_on_termination" <$> TF.attribute _deleteOnTermination
        ]

instance TF.IsValid (SpotInstanceRequestRootBlockDevice s) where
    validator = P.mempty

instance P.HasDeleteOnTermination (SpotInstanceRequestRootBlockDevice s) (TF.Attr s P.Bool) where
    deleteOnTermination =
        P.lens (_deleteOnTermination :: SpotInstanceRequestRootBlockDevice s -> TF.Attr s P.Bool)
               (\s a -> s { _deleteOnTermination = a } :: SpotInstanceRequestRootBlockDevice s)

instance s ~ s' => P.HasComputedIops (TF.Ref s' (SpotInstanceRequestRootBlockDevice s)) (TF.Attr s P.Integer) where
    computedIops x = TF.compute (TF.refKey x) "iops"

instance s ~ s' => P.HasComputedVolumeId (TF.Ref s' (SpotInstanceRequestRootBlockDevice s)) (TF.Attr s P.Text) where
    computedVolumeId x = TF.compute (TF.refKey x) "volume_id"

instance s ~ s' => P.HasComputedVolumeSize (TF.Ref s' (SpotInstanceRequestRootBlockDevice s)) (TF.Attr s P.Integer) where
    computedVolumeSize x = TF.compute (TF.refKey x) "volume_size"

instance s ~ s' => P.HasComputedVolumeType (TF.Ref s' (SpotInstanceRequestRootBlockDevice s)) (TF.Attr s P.Text) where
    computedVolumeType x = TF.compute (TF.refKey x) "volume_type"

-- | @glacier_vault_notification@ nested settings.
data GlacierVaultNotification s = GlacierVaultNotification'
    { _events   :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @events@ - (Required)
    --
    , _snsTopic :: TF.Attr s P.Text
    -- ^ @sns_topic@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newGlacierVaultNotification
    :: TF.Attr s [TF.Attr s P.Text] -- ^ @events@ - 'P.events'
    -> TF.Attr s P.Text -- ^ @sns_topic@ - 'P.snsTopic'
    -> GlacierVaultNotification s
newGlacierVaultNotification _events _snsTopic =
    GlacierVaultNotification'
        { _events = _events
        , _snsTopic = _snsTopic
        }

instance P.Hashable  (GlacierVaultNotification s)
instance TF.IsValue  (GlacierVaultNotification s)
instance TF.IsObject (GlacierVaultNotification s) where
    toObject GlacierVaultNotification'{..} = P.catMaybes
        [ TF.assign "events" <$> TF.attribute _events
        , TF.assign "sns_topic" <$> TF.attribute _snsTopic
        ]

instance TF.IsValid (GlacierVaultNotification s) where
    validator = P.mempty

instance P.HasEvents (GlacierVaultNotification s) (TF.Attr s [TF.Attr s P.Text]) where
    events =
        P.lens (_events :: GlacierVaultNotification s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _events = a } :: GlacierVaultNotification s)

instance P.HasSnsTopic (GlacierVaultNotification s) (TF.Attr s P.Text) where
    snsTopic =
        P.lens (_snsTopic :: GlacierVaultNotification s -> TF.Attr s P.Text)
               (\s a -> s { _snsTopic = a } :: GlacierVaultNotification s)

-- | @vpn_connection_vgw_telemetry@ nested settings.
data VpnConnectionVgwTelemetry s = VpnConnectionVgwTelemetry'
    deriving (P.Show, P.Eq, P.Generic)

newVpnConnectionVgwTelemetry
    :: VpnConnectionVgwTelemetry s
newVpnConnectionVgwTelemetry =
    VpnConnectionVgwTelemetry'

instance P.Hashable  (VpnConnectionVgwTelemetry s)
instance TF.IsValue  (VpnConnectionVgwTelemetry s)
instance TF.IsObject (VpnConnectionVgwTelemetry s) where
    toObject VpnConnectionVgwTelemetry' = []

instance TF.IsValid (VpnConnectionVgwTelemetry s) where
    validator = P.mempty

instance s ~ s' => P.HasComputedAcceptedRouteCount (TF.Ref s' (VpnConnectionVgwTelemetry s)) (TF.Attr s P.Integer) where
    computedAcceptedRouteCount x = TF.compute (TF.refKey x) "accepted_route_count"

instance s ~ s' => P.HasComputedLastStatusChange (TF.Ref s' (VpnConnectionVgwTelemetry s)) (TF.Attr s P.Text) where
    computedLastStatusChange x = TF.compute (TF.refKey x) "last_status_change"

instance s ~ s' => P.HasComputedOutsideIpAddress (TF.Ref s' (VpnConnectionVgwTelemetry s)) (TF.Attr s P.Text) where
    computedOutsideIpAddress x = TF.compute (TF.refKey x) "outside_ip_address"

instance s ~ s' => P.HasComputedStatus (TF.Ref s' (VpnConnectionVgwTelemetry s)) (TF.Attr s P.Text) where
    computedStatus x = TF.compute (TF.refKey x) "status"

instance s ~ s' => P.HasComputedStatusMessage (TF.Ref s' (VpnConnectionVgwTelemetry s)) (TF.Attr s P.Text) where
    computedStatusMessage x = TF.compute (TF.refKey x) "status_message"

-- | @waf_ipset_ip_set_descriptors@ nested settings.
data WafIpsetIpSetDescriptors s = WafIpsetIpSetDescriptors'
    { _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    , _value :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafIpsetIpSetDescriptors
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> WafIpsetIpSetDescriptors s
newWafIpsetIpSetDescriptors _type' _value =
    WafIpsetIpSetDescriptors'
        { _type' = _type'
        , _value = _value
        }

instance P.Hashable  (WafIpsetIpSetDescriptors s)
instance TF.IsValue  (WafIpsetIpSetDescriptors s)
instance TF.IsObject (WafIpsetIpSetDescriptors s) where
    toObject WafIpsetIpSetDescriptors'{..} = P.catMaybes
        [ TF.assign "type" <$> TF.attribute _type'
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (WafIpsetIpSetDescriptors s) where
    validator = P.mempty

instance P.HasType' (WafIpsetIpSetDescriptors s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: WafIpsetIpSetDescriptors s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: WafIpsetIpSetDescriptors s)

instance P.HasValue (WafIpsetIpSetDescriptors s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: WafIpsetIpSetDescriptors s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: WafIpsetIpSetDescriptors s)

-- | @launch_configuration_ebs_block_device@ nested settings.
data LaunchConfigurationEbsBlockDevice s = LaunchConfigurationEbsBlockDevice'
    { _deleteOnTermination :: TF.Attr s P.Bool
    -- ^ @delete_on_termination@ - (Optional, Forces New)
    --
    , _deviceName          :: TF.Attr s P.Text
    -- ^ @device_name@ - (Required, Forces New)
    --
    , _noDevice            :: TF.Attr s P.Bool
    -- ^ @no_device@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLaunchConfigurationEbsBlockDevice
    :: TF.Attr s P.Text -- ^ @device_name@ - 'P.deviceName'
    -> LaunchConfigurationEbsBlockDevice s
newLaunchConfigurationEbsBlockDevice _deviceName =
    LaunchConfigurationEbsBlockDevice'
        { _deleteOnTermination = TF.value P.True
        , _deviceName = _deviceName
        , _noDevice = TF.Nil
        }

instance P.Hashable  (LaunchConfigurationEbsBlockDevice s)
instance TF.IsValue  (LaunchConfigurationEbsBlockDevice s)
instance TF.IsObject (LaunchConfigurationEbsBlockDevice s) where
    toObject LaunchConfigurationEbsBlockDevice'{..} = P.catMaybes
        [ TF.assign "delete_on_termination" <$> TF.attribute _deleteOnTermination
        , TF.assign "device_name" <$> TF.attribute _deviceName
        , TF.assign "no_device" <$> TF.attribute _noDevice
        ]

instance TF.IsValid (LaunchConfigurationEbsBlockDevice s) where
    validator = P.mempty

instance P.HasDeleteOnTermination (LaunchConfigurationEbsBlockDevice s) (TF.Attr s P.Bool) where
    deleteOnTermination =
        P.lens (_deleteOnTermination :: LaunchConfigurationEbsBlockDevice s -> TF.Attr s P.Bool)
               (\s a -> s { _deleteOnTermination = a } :: LaunchConfigurationEbsBlockDevice s)

instance P.HasDeviceName (LaunchConfigurationEbsBlockDevice s) (TF.Attr s P.Text) where
    deviceName =
        P.lens (_deviceName :: LaunchConfigurationEbsBlockDevice s -> TF.Attr s P.Text)
               (\s a -> s { _deviceName = a } :: LaunchConfigurationEbsBlockDevice s)

instance P.HasNoDevice (LaunchConfigurationEbsBlockDevice s) (TF.Attr s P.Bool) where
    noDevice =
        P.lens (_noDevice :: LaunchConfigurationEbsBlockDevice s -> TF.Attr s P.Bool)
               (\s a -> s { _noDevice = a } :: LaunchConfigurationEbsBlockDevice s)

instance s ~ s' => P.HasComputedEncrypted (TF.Ref s' (LaunchConfigurationEbsBlockDevice s)) (TF.Attr s P.Bool) where
    computedEncrypted x = TF.compute (TF.refKey x) "encrypted"

instance s ~ s' => P.HasComputedIops (TF.Ref s' (LaunchConfigurationEbsBlockDevice s)) (TF.Attr s P.Integer) where
    computedIops x = TF.compute (TF.refKey x) "iops"

instance s ~ s' => P.HasComputedSnapshotId (TF.Ref s' (LaunchConfigurationEbsBlockDevice s)) (TF.Attr s P.Text) where
    computedSnapshotId x = TF.compute (TF.refKey x) "snapshot_id"

instance s ~ s' => P.HasComputedVolumeSize (TF.Ref s' (LaunchConfigurationEbsBlockDevice s)) (TF.Attr s P.Integer) where
    computedVolumeSize x = TF.compute (TF.refKey x) "volume_size"

instance s ~ s' => P.HasComputedVolumeType (TF.Ref s' (LaunchConfigurationEbsBlockDevice s)) (TF.Attr s P.Text) where
    computedVolumeType x = TF.compute (TF.refKey x) "volume_type"

instance s ~ s' => P.HasComputedDeleteOnTermination (TF.Ref s' (LaunchConfigurationEbsBlockDevice s)) (TF.Attr s P.Bool) where
    computedDeleteOnTermination x = TF.compute (TF.refKey x) "delete_on_termination"

instance s ~ s' => P.HasComputedDeviceName (TF.Ref s' (LaunchConfigurationEbsBlockDevice s)) (TF.Attr s P.Text) where
    computedDeviceName x = TF.compute (TF.refKey x) "device_name"

-- | @appautoscaling_policy_target_tracking_scaling_policy_configuration@ nested settings.
data AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s = AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration'
    { _customizedMetricSpecification :: TF.Attr s (TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s)
    -- ^ @customized_metric_specification@ - (Optional)
    --
    -- Conflicts with:
    --
    -- * 'predefinedMetricSpecification'
    , _disableScaleIn :: TF.Attr s P.Bool
    -- ^ @disable_scale_in@ - (Optional)
    --
    , _predefinedMetricSpecification :: TF.Attr s (TargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification s)
    -- ^ @predefined_metric_specification@ - (Optional)
    --
    -- Conflicts with:
    --
    -- * 'customizedMetricSpecification'
    , _scaleInCooldown :: TF.Attr s P.Integer
    -- ^ @scale_in_cooldown@ - (Optional)
    --
    , _scaleOutCooldown :: TF.Attr s P.Integer
    -- ^ @scale_out_cooldown@ - (Optional)
    --
    , _targetValue :: TF.Attr s P.Double
    -- ^ @target_value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAppautoscalingPolicyTargetTrackingScalingPolicyConfiguration
    :: TF.Attr s P.Double -- ^ @target_value@ - 'P.targetValue'
    -> AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s
newAppautoscalingPolicyTargetTrackingScalingPolicyConfiguration _targetValue =
    AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration'
        { _customizedMetricSpecification = TF.Nil
        , _disableScaleIn = TF.value P.False
        , _predefinedMetricSpecification = TF.Nil
        , _scaleInCooldown = TF.Nil
        , _scaleOutCooldown = TF.Nil
        , _targetValue = _targetValue
        }

instance P.Hashable  (AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s)
instance TF.IsValue  (AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s)
instance TF.IsObject (AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s) where
    toObject AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration'{..} = P.catMaybes
        [ TF.assign "customized_metric_specification" <$> TF.attribute _customizedMetricSpecification
        , TF.assign "disable_scale_in" <$> TF.attribute _disableScaleIn
        , TF.assign "predefined_metric_specification" <$> TF.attribute _predefinedMetricSpecification
        , TF.assign "scale_in_cooldown" <$> TF.attribute _scaleInCooldown
        , TF.assign "scale_out_cooldown" <$> TF.attribute _scaleOutCooldown
        , TF.assign "target_value" <$> TF.attribute _targetValue
        ]

instance TF.IsValid (AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s) where
    validator = TF.fieldsValidator (\AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration'{..} -> Map.fromList $ P.catMaybes
        [ if (_customizedMetricSpecification P.== TF.Nil)
              then P.Nothing
              else P.Just ("_customizedMetricSpecification",
                            [ "_predefinedMetricSpecification"
                            ])
        , if (_predefinedMetricSpecification P.== TF.Nil)
              then P.Nothing
              else P.Just ("_predefinedMetricSpecification",
                            [ "_customizedMetricSpecification"
                            ])
        ])
           P.<> TF.settingsValidator "_customizedMetricSpecification"
                  (_customizedMetricSpecification
                      :: AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s -> TF.Attr s (TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s))
                  TF.validator
           P.<> TF.settingsValidator "_predefinedMetricSpecification"
                  (_predefinedMetricSpecification
                      :: AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s -> TF.Attr s (TargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification s))
                  TF.validator

instance P.HasCustomizedMetricSpecification (AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s) (TF.Attr s (TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s)) where
    customizedMetricSpecification =
        P.lens (_customizedMetricSpecification :: AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s -> TF.Attr s (TargetTrackingScalingPolicyConfigurationCustomizedMetricSpecification s))
               (\s a -> s { _customizedMetricSpecification = a } :: AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s)

instance P.HasDisableScaleIn (AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s) (TF.Attr s P.Bool) where
    disableScaleIn =
        P.lens (_disableScaleIn :: AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s -> TF.Attr s P.Bool)
               (\s a -> s { _disableScaleIn = a } :: AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s)

instance P.HasPredefinedMetricSpecification (AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s) (TF.Attr s (TargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification s)) where
    predefinedMetricSpecification =
        P.lens (_predefinedMetricSpecification :: AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s -> TF.Attr s (TargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification s))
               (\s a -> s { _predefinedMetricSpecification = a } :: AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s)

instance P.HasScaleInCooldown (AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s) (TF.Attr s P.Integer) where
    scaleInCooldown =
        P.lens (_scaleInCooldown :: AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s -> TF.Attr s P.Integer)
               (\s a -> s { _scaleInCooldown = a } :: AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s)

instance P.HasScaleOutCooldown (AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s) (TF.Attr s P.Integer) where
    scaleOutCooldown =
        P.lens (_scaleOutCooldown :: AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s -> TF.Attr s P.Integer)
               (\s a -> s { _scaleOutCooldown = a } :: AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s)

instance P.HasTargetValue (AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s) (TF.Attr s P.Double) where
    targetValue =
        P.lens (_targetValue :: AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s -> TF.Attr s P.Double)
               (\s a -> s { _targetValue = a } :: AppautoscalingPolicyTargetTrackingScalingPolicyConfiguration s)

-- | @approval_rule_patch_filter@ nested settings.
data ApprovalRulePatchFilter s = ApprovalRulePatchFilter'
    { _key    :: TF.Attr s P.Text
    -- ^ @key@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newApprovalRulePatchFilter
    :: TF.Attr s P.Text -- ^ @key@ - 'P.key'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> ApprovalRulePatchFilter s
newApprovalRulePatchFilter _key _values =
    ApprovalRulePatchFilter'
        { _key = _key
        , _values = _values
        }

instance P.Hashable  (ApprovalRulePatchFilter s)
instance TF.IsValue  (ApprovalRulePatchFilter s)
instance TF.IsObject (ApprovalRulePatchFilter s) where
    toObject ApprovalRulePatchFilter'{..} = P.catMaybes
        [ TF.assign "key" <$> TF.attribute _key
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (ApprovalRulePatchFilter s) where
    validator = P.mempty

instance P.HasKey (ApprovalRulePatchFilter s) (TF.Attr s P.Text) where
    key =
        P.lens (_key :: ApprovalRulePatchFilter s -> TF.Attr s P.Text)
               (\s a -> s { _key = a } :: ApprovalRulePatchFilter s)

instance P.HasValues (ApprovalRulePatchFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: ApprovalRulePatchFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: ApprovalRulePatchFilter s)

-- | @elb_access_logs@ nested settings.
data ElbAccessLogs s = ElbAccessLogs'
    { _bucket       :: TF.Attr s P.Text
    -- ^ @bucket@ - (Required)
    --
    , _bucketPrefix :: TF.Attr s P.Text
    -- ^ @bucket_prefix@ - (Optional)
    --
    , _enabled      :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Optional)
    --
    , _interval     :: TF.Attr s P.Integer
    -- ^ @interval@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElbAccessLogs
    :: TF.Attr s P.Text -- ^ @bucket@ - 'P.bucket'
    -> ElbAccessLogs s
newElbAccessLogs _bucket =
    ElbAccessLogs'
        { _bucket = _bucket
        , _bucketPrefix = TF.Nil
        , _enabled = TF.value P.True
        , _interval = TF.value 60
        }

instance P.Hashable  (ElbAccessLogs s)
instance TF.IsValue  (ElbAccessLogs s)
instance TF.IsObject (ElbAccessLogs s) where
    toObject ElbAccessLogs'{..} = P.catMaybes
        [ TF.assign "bucket" <$> TF.attribute _bucket
        , TF.assign "bucket_prefix" <$> TF.attribute _bucketPrefix
        , TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "interval" <$> TF.attribute _interval
        ]

instance TF.IsValid (ElbAccessLogs s) where
    validator = P.mempty

instance P.HasBucket (ElbAccessLogs s) (TF.Attr s P.Text) where
    bucket =
        P.lens (_bucket :: ElbAccessLogs s -> TF.Attr s P.Text)
               (\s a -> s { _bucket = a } :: ElbAccessLogs s)

instance P.HasBucketPrefix (ElbAccessLogs s) (TF.Attr s P.Text) where
    bucketPrefix =
        P.lens (_bucketPrefix :: ElbAccessLogs s -> TF.Attr s P.Text)
               (\s a -> s { _bucketPrefix = a } :: ElbAccessLogs s)

instance P.HasEnabled (ElbAccessLogs s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: ElbAccessLogs s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: ElbAccessLogs s)

instance P.HasInterval (ElbAccessLogs s) (TF.Attr s P.Integer) where
    interval =
        P.lens (_interval :: ElbAccessLogs s -> TF.Attr s P.Integer)
               (\s a -> s { _interval = a } :: ElbAccessLogs s)

instance s ~ s' => P.HasComputedBucket (TF.Ref s' (ElbAccessLogs s)) (TF.Attr s P.Text) where
    computedBucket x = TF.compute (TF.refKey x) "bucket"

instance s ~ s' => P.HasComputedBucketPrefix (TF.Ref s' (ElbAccessLogs s)) (TF.Attr s P.Text) where
    computedBucketPrefix x = TF.compute (TF.refKey x) "bucket_prefix"

instance s ~ s' => P.HasComputedEnabled (TF.Ref s' (ElbAccessLogs s)) (TF.Attr s P.Bool) where
    computedEnabled x = TF.compute (TF.refKey x) "enabled"

instance s ~ s' => P.HasComputedInterval (TF.Ref s' (ElbAccessLogs s)) (TF.Attr s P.Integer) where
    computedInterval x = TF.compute (TF.refKey x) "interval"

-- | @ecs_service_placement_constraints@ nested settings.
data EcsServicePlacementConstraints s = EcsServicePlacementConstraints'
    { _expression :: TF.Attr s P.Text
    -- ^ @expression@ - (Optional, Forces New)
    --
    , _type'      :: TF.Attr s P.Text
    -- ^ @type@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newEcsServicePlacementConstraints
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> EcsServicePlacementConstraints s
newEcsServicePlacementConstraints _type' =
    EcsServicePlacementConstraints'
        { _expression = TF.Nil
        , _type' = _type'
        }

instance P.Hashable  (EcsServicePlacementConstraints s)
instance TF.IsValue  (EcsServicePlacementConstraints s)
instance TF.IsObject (EcsServicePlacementConstraints s) where
    toObject EcsServicePlacementConstraints'{..} = P.catMaybes
        [ TF.assign "expression" <$> TF.attribute _expression
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (EcsServicePlacementConstraints s) where
    validator = P.mempty

instance P.HasExpression (EcsServicePlacementConstraints s) (TF.Attr s P.Text) where
    expression =
        P.lens (_expression :: EcsServicePlacementConstraints s -> TF.Attr s P.Text)
               (\s a -> s { _expression = a } :: EcsServicePlacementConstraints s)

instance P.HasType' (EcsServicePlacementConstraints s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: EcsServicePlacementConstraints s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: EcsServicePlacementConstraints s)

-- | @redshift_configuration_cloudwatch_logging_options@ nested settings.
data RedshiftConfigurationCloudwatchLoggingOptions s = RedshiftConfigurationCloudwatchLoggingOptions'
    { _enabled       :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Optional)
    --
    , _logGroupName  :: TF.Attr s P.Text
    -- ^ @log_group_name@ - (Optional)
    --
    , _logStreamName :: TF.Attr s P.Text
    -- ^ @log_stream_name@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRedshiftConfigurationCloudwatchLoggingOptions
    :: RedshiftConfigurationCloudwatchLoggingOptions s
newRedshiftConfigurationCloudwatchLoggingOptions =
    RedshiftConfigurationCloudwatchLoggingOptions'
        { _enabled = TF.value P.False
        , _logGroupName = TF.Nil
        , _logStreamName = TF.Nil
        }

instance P.Hashable  (RedshiftConfigurationCloudwatchLoggingOptions s)
instance TF.IsValue  (RedshiftConfigurationCloudwatchLoggingOptions s)
instance TF.IsObject (RedshiftConfigurationCloudwatchLoggingOptions s) where
    toObject RedshiftConfigurationCloudwatchLoggingOptions'{..} = P.catMaybes
        [ TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "log_group_name" <$> TF.attribute _logGroupName
        , TF.assign "log_stream_name" <$> TF.attribute _logStreamName
        ]

instance TF.IsValid (RedshiftConfigurationCloudwatchLoggingOptions s) where
    validator = P.mempty

instance P.HasEnabled (RedshiftConfigurationCloudwatchLoggingOptions s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: RedshiftConfigurationCloudwatchLoggingOptions s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: RedshiftConfigurationCloudwatchLoggingOptions s)

instance P.HasLogGroupName (RedshiftConfigurationCloudwatchLoggingOptions s) (TF.Attr s P.Text) where
    logGroupName =
        P.lens (_logGroupName :: RedshiftConfigurationCloudwatchLoggingOptions s -> TF.Attr s P.Text)
               (\s a -> s { _logGroupName = a } :: RedshiftConfigurationCloudwatchLoggingOptions s)

instance P.HasLogStreamName (RedshiftConfigurationCloudwatchLoggingOptions s) (TF.Attr s P.Text) where
    logStreamName =
        P.lens (_logStreamName :: RedshiftConfigurationCloudwatchLoggingOptions s -> TF.Attr s P.Text)
               (\s a -> s { _logStreamName = a } :: RedshiftConfigurationCloudwatchLoggingOptions s)

-- | @alb_subnet_mapping@ nested settings.
data AlbSubnetMapping s = AlbSubnetMapping'
    { _allocationId :: TF.Attr s P.Text
    -- ^ @allocation_id@ - (Optional, Forces New)
    --
    , _subnetId     :: TF.Attr s P.Text
    -- ^ @subnet_id@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAlbSubnetMapping
    :: TF.Attr s P.Text -- ^ @subnet_id@ - 'P.subnetId'
    -> AlbSubnetMapping s
newAlbSubnetMapping _subnetId =
    AlbSubnetMapping'
        { _allocationId = TF.Nil
        , _subnetId = _subnetId
        }

instance P.Hashable  (AlbSubnetMapping s)
instance TF.IsValue  (AlbSubnetMapping s)
instance TF.IsObject (AlbSubnetMapping s) where
    toObject AlbSubnetMapping'{..} = P.catMaybes
        [ TF.assign "allocation_id" <$> TF.attribute _allocationId
        , TF.assign "subnet_id" <$> TF.attribute _subnetId
        ]

instance TF.IsValid (AlbSubnetMapping s) where
    validator = P.mempty

instance P.HasAllocationId (AlbSubnetMapping s) (TF.Attr s P.Text) where
    allocationId =
        P.lens (_allocationId :: AlbSubnetMapping s -> TF.Attr s P.Text)
               (\s a -> s { _allocationId = a } :: AlbSubnetMapping s)

instance P.HasSubnetId (AlbSubnetMapping s) (TF.Attr s P.Text) where
    subnetId =
        P.lens (_subnetId :: AlbSubnetMapping s -> TF.Attr s P.Text)
               (\s a -> s { _subnetId = a } :: AlbSubnetMapping s)

-- | @autoscaling_policy_step_adjustment@ nested settings.
data AutoscalingPolicyStepAdjustment s = AutoscalingPolicyStepAdjustment'
    { _metricIntervalLowerBound :: TF.Attr s P.Text
    -- ^ @metric_interval_lower_bound@ - (Optional)
    --
    , _metricIntervalUpperBound :: TF.Attr s P.Text
    -- ^ @metric_interval_upper_bound@ - (Optional)
    --
    , _scalingAdjustment        :: TF.Attr s P.Integer
    -- ^ @scaling_adjustment@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAutoscalingPolicyStepAdjustment
    :: TF.Attr s P.Integer -- ^ @scaling_adjustment@ - 'P.scalingAdjustment'
    -> AutoscalingPolicyStepAdjustment s
newAutoscalingPolicyStepAdjustment _scalingAdjustment =
    AutoscalingPolicyStepAdjustment'
        { _metricIntervalLowerBound = TF.Nil
        , _metricIntervalUpperBound = TF.Nil
        , _scalingAdjustment = _scalingAdjustment
        }

instance P.Hashable  (AutoscalingPolicyStepAdjustment s)
instance TF.IsValue  (AutoscalingPolicyStepAdjustment s)
instance TF.IsObject (AutoscalingPolicyStepAdjustment s) where
    toObject AutoscalingPolicyStepAdjustment'{..} = P.catMaybes
        [ TF.assign "metric_interval_lower_bound" <$> TF.attribute _metricIntervalLowerBound
        , TF.assign "metric_interval_upper_bound" <$> TF.attribute _metricIntervalUpperBound
        , TF.assign "scaling_adjustment" <$> TF.attribute _scalingAdjustment
        ]

instance TF.IsValid (AutoscalingPolicyStepAdjustment s) where
    validator = P.mempty

instance P.HasMetricIntervalLowerBound (AutoscalingPolicyStepAdjustment s) (TF.Attr s P.Text) where
    metricIntervalLowerBound =
        P.lens (_metricIntervalLowerBound :: AutoscalingPolicyStepAdjustment s -> TF.Attr s P.Text)
               (\s a -> s { _metricIntervalLowerBound = a } :: AutoscalingPolicyStepAdjustment s)

instance P.HasMetricIntervalUpperBound (AutoscalingPolicyStepAdjustment s) (TF.Attr s P.Text) where
    metricIntervalUpperBound =
        P.lens (_metricIntervalUpperBound :: AutoscalingPolicyStepAdjustment s -> TF.Attr s P.Text)
               (\s a -> s { _metricIntervalUpperBound = a } :: AutoscalingPolicyStepAdjustment s)

instance P.HasScalingAdjustment (AutoscalingPolicyStepAdjustment s) (TF.Attr s P.Integer) where
    scalingAdjustment =
        P.lens (_scalingAdjustment :: AutoscalingPolicyStepAdjustment s -> TF.Attr s P.Integer)
               (\s a -> s { _scalingAdjustment = a } :: AutoscalingPolicyStepAdjustment s)

-- | @ami_from_instance_ebs_block_device@ nested settings.
data AmiFromInstanceEbsBlockDevice s = AmiFromInstanceEbsBlockDevice'
    deriving (P.Show, P.Eq, P.Generic)

newAmiFromInstanceEbsBlockDevice
    :: AmiFromInstanceEbsBlockDevice s
newAmiFromInstanceEbsBlockDevice =
    AmiFromInstanceEbsBlockDevice'

instance P.Hashable  (AmiFromInstanceEbsBlockDevice s)
instance TF.IsValue  (AmiFromInstanceEbsBlockDevice s)
instance TF.IsObject (AmiFromInstanceEbsBlockDevice s) where
    toObject AmiFromInstanceEbsBlockDevice' = []

instance TF.IsValid (AmiFromInstanceEbsBlockDevice s) where
    validator = P.mempty

instance s ~ s' => P.HasComputedDeleteOnTermination (TF.Ref s' (AmiFromInstanceEbsBlockDevice s)) (TF.Attr s P.Bool) where
    computedDeleteOnTermination x = TF.compute (TF.refKey x) "delete_on_termination"

instance s ~ s' => P.HasComputedDeviceName (TF.Ref s' (AmiFromInstanceEbsBlockDevice s)) (TF.Attr s P.Text) where
    computedDeviceName x = TF.compute (TF.refKey x) "device_name"

instance s ~ s' => P.HasComputedEncrypted (TF.Ref s' (AmiFromInstanceEbsBlockDevice s)) (TF.Attr s P.Bool) where
    computedEncrypted x = TF.compute (TF.refKey x) "encrypted"

instance s ~ s' => P.HasComputedIops (TF.Ref s' (AmiFromInstanceEbsBlockDevice s)) (TF.Attr s P.Integer) where
    computedIops x = TF.compute (TF.refKey x) "iops"

instance s ~ s' => P.HasComputedSnapshotId (TF.Ref s' (AmiFromInstanceEbsBlockDevice s)) (TF.Attr s P.Text) where
    computedSnapshotId x = TF.compute (TF.refKey x) "snapshot_id"

instance s ~ s' => P.HasComputedVolumeSize (TF.Ref s' (AmiFromInstanceEbsBlockDevice s)) (TF.Attr s P.Integer) where
    computedVolumeSize x = TF.compute (TF.refKey x) "volume_size"

instance s ~ s' => P.HasComputedVolumeType (TF.Ref s' (AmiFromInstanceEbsBlockDevice s)) (TF.Attr s P.Text) where
    computedVolumeType x = TF.compute (TF.refKey x) "volume_type"

-- | @default_security_group_egress@ nested settings.
data DefaultSecurityGroupEgress s = DefaultSecurityGroupEgress'
    { _cidrBlocks     :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @cidr_blocks@ - (Optional)
    --
    , _description    :: TF.Attr s P.Text
    -- ^ @description@ - (Optional)
    --
    , _fromPort       :: TF.Attr s P.Integer
    -- ^ @from_port@ - (Required)
    --
    , _ipv6CidrBlocks :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @ipv6_cidr_blocks@ - (Optional)
    --
    , _prefixListIds  :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @prefix_list_ids@ - (Optional)
    --
    , _protocol       :: TF.Attr s P.Text
    -- ^ @protocol@ - (Required)
    --
    , _securityGroups :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @security_groups@ - (Optional)
    --
    , _self           :: TF.Attr s P.Bool
    -- ^ @self@ - (Optional)
    --
    , _toPort         :: TF.Attr s P.Integer
    -- ^ @to_port@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDefaultSecurityGroupEgress
    :: TF.Attr s P.Integer -- ^ @from_port@ - 'P.fromPort'
    -> TF.Attr s P.Text -- ^ @protocol@ - 'P.protocol'
    -> TF.Attr s P.Integer -- ^ @to_port@ - 'P.toPort'
    -> DefaultSecurityGroupEgress s
newDefaultSecurityGroupEgress _fromPort _protocol _toPort =
    DefaultSecurityGroupEgress'
        { _cidrBlocks = TF.Nil
        , _description = TF.Nil
        , _fromPort = _fromPort
        , _ipv6CidrBlocks = TF.Nil
        , _prefixListIds = TF.Nil
        , _protocol = _protocol
        , _securityGroups = TF.Nil
        , _self = TF.value P.False
        , _toPort = _toPort
        }

instance P.Hashable  (DefaultSecurityGroupEgress s)
instance TF.IsValue  (DefaultSecurityGroupEgress s)
instance TF.IsObject (DefaultSecurityGroupEgress s) where
    toObject DefaultSecurityGroupEgress'{..} = P.catMaybes
        [ TF.assign "cidr_blocks" <$> TF.attribute _cidrBlocks
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "from_port" <$> TF.attribute _fromPort
        , TF.assign "ipv6_cidr_blocks" <$> TF.attribute _ipv6CidrBlocks
        , TF.assign "prefix_list_ids" <$> TF.attribute _prefixListIds
        , TF.assign "protocol" <$> TF.attribute _protocol
        , TF.assign "security_groups" <$> TF.attribute _securityGroups
        , TF.assign "self" <$> TF.attribute _self
        , TF.assign "to_port" <$> TF.attribute _toPort
        ]

instance TF.IsValid (DefaultSecurityGroupEgress s) where
    validator = P.mempty

instance P.HasCidrBlocks (DefaultSecurityGroupEgress s) (TF.Attr s [TF.Attr s P.Text]) where
    cidrBlocks =
        P.lens (_cidrBlocks :: DefaultSecurityGroupEgress s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _cidrBlocks = a } :: DefaultSecurityGroupEgress s)

instance P.HasDescription (DefaultSecurityGroupEgress s) (TF.Attr s P.Text) where
    description =
        P.lens (_description :: DefaultSecurityGroupEgress s -> TF.Attr s P.Text)
               (\s a -> s { _description = a } :: DefaultSecurityGroupEgress s)

instance P.HasFromPort (DefaultSecurityGroupEgress s) (TF.Attr s P.Integer) where
    fromPort =
        P.lens (_fromPort :: DefaultSecurityGroupEgress s -> TF.Attr s P.Integer)
               (\s a -> s { _fromPort = a } :: DefaultSecurityGroupEgress s)

instance P.HasIpv6CidrBlocks (DefaultSecurityGroupEgress s) (TF.Attr s [TF.Attr s P.Text]) where
    ipv6CidrBlocks =
        P.lens (_ipv6CidrBlocks :: DefaultSecurityGroupEgress s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _ipv6CidrBlocks = a } :: DefaultSecurityGroupEgress s)

instance P.HasPrefixListIds (DefaultSecurityGroupEgress s) (TF.Attr s [TF.Attr s P.Text]) where
    prefixListIds =
        P.lens (_prefixListIds :: DefaultSecurityGroupEgress s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _prefixListIds = a } :: DefaultSecurityGroupEgress s)

instance P.HasProtocol (DefaultSecurityGroupEgress s) (TF.Attr s P.Text) where
    protocol =
        P.lens (_protocol :: DefaultSecurityGroupEgress s -> TF.Attr s P.Text)
               (\s a -> s { _protocol = a } :: DefaultSecurityGroupEgress s)

instance P.HasSecurityGroups (DefaultSecurityGroupEgress s) (TF.Attr s [TF.Attr s P.Text]) where
    securityGroups =
        P.lens (_securityGroups :: DefaultSecurityGroupEgress s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _securityGroups = a } :: DefaultSecurityGroupEgress s)

instance P.HasSelf (DefaultSecurityGroupEgress s) (TF.Attr s P.Bool) where
    self =
        P.lens (_self :: DefaultSecurityGroupEgress s -> TF.Attr s P.Bool)
               (\s a -> s { _self = a } :: DefaultSecurityGroupEgress s)

instance P.HasToPort (DefaultSecurityGroupEgress s) (TF.Attr s P.Integer) where
    toPort =
        P.lens (_toPort :: DefaultSecurityGroupEgress s -> TF.Attr s P.Integer)
               (\s a -> s { _toPort = a } :: DefaultSecurityGroupEgress s)

-- | @api_gateway_documentation_part_location@ nested settings.
data ApiGatewayDocumentationPartLocation s = ApiGatewayDocumentationPartLocation'
    { _method     :: TF.Attr s P.Text
    -- ^ @method@ - (Optional, Forces New)
    --
    , _name       :: TF.Attr s P.Text
    -- ^ @name@ - (Optional, Forces New)
    --
    , _path       :: TF.Attr s P.Text
    -- ^ @path@ - (Optional, Forces New)
    --
    , _statusCode :: TF.Attr s P.Text
    -- ^ @status_code@ - (Optional, Forces New)
    --
    , _type'      :: TF.Attr s P.Text
    -- ^ @type@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newApiGatewayDocumentationPartLocation
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> ApiGatewayDocumentationPartLocation s
newApiGatewayDocumentationPartLocation _type' =
    ApiGatewayDocumentationPartLocation'
        { _method = TF.Nil
        , _name = TF.Nil
        , _path = TF.Nil
        , _statusCode = TF.Nil
        , _type' = _type'
        }

instance P.Hashable  (ApiGatewayDocumentationPartLocation s)
instance TF.IsValue  (ApiGatewayDocumentationPartLocation s)
instance TF.IsObject (ApiGatewayDocumentationPartLocation s) where
    toObject ApiGatewayDocumentationPartLocation'{..} = P.catMaybes
        [ TF.assign "method" <$> TF.attribute _method
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "path" <$> TF.attribute _path
        , TF.assign "status_code" <$> TF.attribute _statusCode
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (ApiGatewayDocumentationPartLocation s) where
    validator = P.mempty

instance P.HasMethod (ApiGatewayDocumentationPartLocation s) (TF.Attr s P.Text) where
    method =
        P.lens (_method :: ApiGatewayDocumentationPartLocation s -> TF.Attr s P.Text)
               (\s a -> s { _method = a } :: ApiGatewayDocumentationPartLocation s)

instance P.HasName (ApiGatewayDocumentationPartLocation s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: ApiGatewayDocumentationPartLocation s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: ApiGatewayDocumentationPartLocation s)

instance P.HasPath (ApiGatewayDocumentationPartLocation s) (TF.Attr s P.Text) where
    path =
        P.lens (_path :: ApiGatewayDocumentationPartLocation s -> TF.Attr s P.Text)
               (\s a -> s { _path = a } :: ApiGatewayDocumentationPartLocation s)

instance P.HasStatusCode (ApiGatewayDocumentationPartLocation s) (TF.Attr s P.Text) where
    statusCode =
        P.lens (_statusCode :: ApiGatewayDocumentationPartLocation s -> TF.Attr s P.Text)
               (\s a -> s { _statusCode = a } :: ApiGatewayDocumentationPartLocation s)

instance P.HasType' (ApiGatewayDocumentationPartLocation s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: ApiGatewayDocumentationPartLocation s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: ApiGatewayDocumentationPartLocation s)

-- | @glue_catalog_table_partition_keys@ nested settings.
data GlueCatalogTablePartitionKeys s = GlueCatalogTablePartitionKeys'
    { _comment :: TF.Attr s P.Text
    -- ^ @comment@ - (Optional)
    --
    , _name    :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _type'   :: TF.Attr s P.Text
    -- ^ @type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newGlueCatalogTablePartitionKeys
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> GlueCatalogTablePartitionKeys s
newGlueCatalogTablePartitionKeys _name =
    GlueCatalogTablePartitionKeys'
        { _comment = TF.Nil
        , _name = _name
        , _type' = TF.Nil
        }

instance P.Hashable  (GlueCatalogTablePartitionKeys s)
instance TF.IsValue  (GlueCatalogTablePartitionKeys s)
instance TF.IsObject (GlueCatalogTablePartitionKeys s) where
    toObject GlueCatalogTablePartitionKeys'{..} = P.catMaybes
        [ TF.assign "comment" <$> TF.attribute _comment
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (GlueCatalogTablePartitionKeys s) where
    validator = P.mempty

instance P.HasComment (GlueCatalogTablePartitionKeys s) (TF.Attr s P.Text) where
    comment =
        P.lens (_comment :: GlueCatalogTablePartitionKeys s -> TF.Attr s P.Text)
               (\s a -> s { _comment = a } :: GlueCatalogTablePartitionKeys s)

instance P.HasName (GlueCatalogTablePartitionKeys s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: GlueCatalogTablePartitionKeys s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: GlueCatalogTablePartitionKeys s)

instance P.HasType' (GlueCatalogTablePartitionKeys s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: GlueCatalogTablePartitionKeys s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: GlueCatalogTablePartitionKeys s)

-- | @codedeploy_deployment_group_trigger_configuration@ nested settings.
data CodedeployDeploymentGroupTriggerConfiguration s = CodedeployDeploymentGroupTriggerConfiguration'
    { _triggerEvents    :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @trigger_events@ - (Required)
    --
    , _triggerName      :: TF.Attr s P.Text
    -- ^ @trigger_name@ - (Required)
    --
    , _triggerTargetArn :: TF.Attr s P.Text
    -- ^ @trigger_target_arn@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCodedeployDeploymentGroupTriggerConfiguration
    :: TF.Attr s [TF.Attr s P.Text] -- ^ @trigger_events@ - 'P.triggerEvents'
    -> TF.Attr s P.Text -- ^ @trigger_name@ - 'P.triggerName'
    -> TF.Attr s P.Text -- ^ @trigger_target_arn@ - 'P.triggerTargetArn'
    -> CodedeployDeploymentGroupTriggerConfiguration s
newCodedeployDeploymentGroupTriggerConfiguration _triggerEvents _triggerName _triggerTargetArn =
    CodedeployDeploymentGroupTriggerConfiguration'
        { _triggerEvents = _triggerEvents
        , _triggerName = _triggerName
        , _triggerTargetArn = _triggerTargetArn
        }

instance P.Hashable  (CodedeployDeploymentGroupTriggerConfiguration s)
instance TF.IsValue  (CodedeployDeploymentGroupTriggerConfiguration s)
instance TF.IsObject (CodedeployDeploymentGroupTriggerConfiguration s) where
    toObject CodedeployDeploymentGroupTriggerConfiguration'{..} = P.catMaybes
        [ TF.assign "trigger_events" <$> TF.attribute _triggerEvents
        , TF.assign "trigger_name" <$> TF.attribute _triggerName
        , TF.assign "trigger_target_arn" <$> TF.attribute _triggerTargetArn
        ]

instance TF.IsValid (CodedeployDeploymentGroupTriggerConfiguration s) where
    validator = P.mempty

instance P.HasTriggerEvents (CodedeployDeploymentGroupTriggerConfiguration s) (TF.Attr s [TF.Attr s P.Text]) where
    triggerEvents =
        P.lens (_triggerEvents :: CodedeployDeploymentGroupTriggerConfiguration s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _triggerEvents = a } :: CodedeployDeploymentGroupTriggerConfiguration s)

instance P.HasTriggerName (CodedeployDeploymentGroupTriggerConfiguration s) (TF.Attr s P.Text) where
    triggerName =
        P.lens (_triggerName :: CodedeployDeploymentGroupTriggerConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _triggerName = a } :: CodedeployDeploymentGroupTriggerConfiguration s)

instance P.HasTriggerTargetArn (CodedeployDeploymentGroupTriggerConfiguration s) (TF.Attr s P.Text) where
    triggerTargetArn =
        P.lens (_triggerTargetArn :: CodedeployDeploymentGroupTriggerConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _triggerTargetArn = a } :: CodedeployDeploymentGroupTriggerConfiguration s)

-- | @elasticsearch_configuration_cloudwatch_logging_options@ nested settings.
data ElasticsearchConfigurationCloudwatchLoggingOptions s = ElasticsearchConfigurationCloudwatchLoggingOptions'
    { _enabled       :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Optional)
    --
    , _logGroupName  :: TF.Attr s P.Text
    -- ^ @log_group_name@ - (Optional)
    --
    , _logStreamName :: TF.Attr s P.Text
    -- ^ @log_stream_name@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElasticsearchConfigurationCloudwatchLoggingOptions
    :: ElasticsearchConfigurationCloudwatchLoggingOptions s
newElasticsearchConfigurationCloudwatchLoggingOptions =
    ElasticsearchConfigurationCloudwatchLoggingOptions'
        { _enabled = TF.value P.False
        , _logGroupName = TF.Nil
        , _logStreamName = TF.Nil
        }

instance P.Hashable  (ElasticsearchConfigurationCloudwatchLoggingOptions s)
instance TF.IsValue  (ElasticsearchConfigurationCloudwatchLoggingOptions s)
instance TF.IsObject (ElasticsearchConfigurationCloudwatchLoggingOptions s) where
    toObject ElasticsearchConfigurationCloudwatchLoggingOptions'{..} = P.catMaybes
        [ TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "log_group_name" <$> TF.attribute _logGroupName
        , TF.assign "log_stream_name" <$> TF.attribute _logStreamName
        ]

instance TF.IsValid (ElasticsearchConfigurationCloudwatchLoggingOptions s) where
    validator = P.mempty

instance P.HasEnabled (ElasticsearchConfigurationCloudwatchLoggingOptions s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: ElasticsearchConfigurationCloudwatchLoggingOptions s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: ElasticsearchConfigurationCloudwatchLoggingOptions s)

instance P.HasLogGroupName (ElasticsearchConfigurationCloudwatchLoggingOptions s) (TF.Attr s P.Text) where
    logGroupName =
        P.lens (_logGroupName :: ElasticsearchConfigurationCloudwatchLoggingOptions s -> TF.Attr s P.Text)
               (\s a -> s { _logGroupName = a } :: ElasticsearchConfigurationCloudwatchLoggingOptions s)

instance P.HasLogStreamName (ElasticsearchConfigurationCloudwatchLoggingOptions s) (TF.Attr s P.Text) where
    logStreamName =
        P.lens (_logStreamName :: ElasticsearchConfigurationCloudwatchLoggingOptions s -> TF.Attr s P.Text)
               (\s a -> s { _logStreamName = a } :: ElasticsearchConfigurationCloudwatchLoggingOptions s)

-- | @batch_compute_environment_compute_resources@ nested settings.
data BatchComputeEnvironmentComputeResources s = BatchComputeEnvironmentComputeResources'
    { _bidPercentage    :: TF.Attr s P.Integer
    -- ^ @bid_percentage@ - (Optional, Forces New)
    --
    , _desiredVcpus     :: TF.Attr s P.Integer
    -- ^ @desired_vcpus@ - (Optional)
    --
    , _ec2KeyPair       :: TF.Attr s P.Text
    -- ^ @ec2_key_pair@ - (Optional, Forces New)
    --
    , _imageId          :: TF.Attr s P.Text
    -- ^ @image_id@ - (Optional, Forces New)
    --
    , _instanceRole     :: TF.Attr s P.Text
    -- ^ @instance_role@ - (Required, Forces New)
    --
    , _instanceType     :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @instance_type@ - (Required, Forces New)
    --
    , _maxVcpus         :: TF.Attr s P.Integer
    -- ^ @max_vcpus@ - (Required)
    --
    , _minVcpus         :: TF.Attr s P.Integer
    -- ^ @min_vcpus@ - (Required)
    --
    , _securityGroupIds :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @security_group_ids@ - (Required, Forces New)
    --
    , _spotIamFleetRole :: TF.Attr s P.Text
    -- ^ @spot_iam_fleet_role@ - (Optional, Forces New)
    --
    , _subnets          :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @subnets@ - (Required, Forces New)
    --
    , _tags             :: TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))
    -- ^ @tags@ - (Optional)
    --
    , _type'            :: TF.Attr s P.Text
    -- ^ @type@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newBatchComputeEnvironmentComputeResources
    :: TF.Attr s P.Text -- ^ @instance_role@ - 'P.instanceRole'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @instance_type@ - 'P.instanceType'
    -> TF.Attr s P.Integer -- ^ @max_vcpus@ - 'P.maxVcpus'
    -> TF.Attr s P.Integer -- ^ @min_vcpus@ - 'P.minVcpus'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @security_group_ids@ - 'P.securityGroupIds'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @subnets@ - 'P.subnets'
    -> TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> BatchComputeEnvironmentComputeResources s
newBatchComputeEnvironmentComputeResources _instanceRole _instanceType _maxVcpus _minVcpus _securityGroupIds _subnets _type' =
    BatchComputeEnvironmentComputeResources'
        { _bidPercentage = TF.Nil
        , _desiredVcpus = TF.Nil
        , _ec2KeyPair = TF.Nil
        , _imageId = TF.Nil
        , _instanceRole = _instanceRole
        , _instanceType = _instanceType
        , _maxVcpus = _maxVcpus
        , _minVcpus = _minVcpus
        , _securityGroupIds = _securityGroupIds
        , _spotIamFleetRole = TF.Nil
        , _subnets = _subnets
        , _tags = TF.Nil
        , _type' = _type'
        }

instance P.Hashable  (BatchComputeEnvironmentComputeResources s)
instance TF.IsValue  (BatchComputeEnvironmentComputeResources s)
instance TF.IsObject (BatchComputeEnvironmentComputeResources s) where
    toObject BatchComputeEnvironmentComputeResources'{..} = P.catMaybes
        [ TF.assign "bid_percentage" <$> TF.attribute _bidPercentage
        , TF.assign "desired_vcpus" <$> TF.attribute _desiredVcpus
        , TF.assign "ec2_key_pair" <$> TF.attribute _ec2KeyPair
        , TF.assign "image_id" <$> TF.attribute _imageId
        , TF.assign "instance_role" <$> TF.attribute _instanceRole
        , TF.assign "instance_type" <$> TF.attribute _instanceType
        , TF.assign "max_vcpus" <$> TF.attribute _maxVcpus
        , TF.assign "min_vcpus" <$> TF.attribute _minVcpus
        , TF.assign "security_group_ids" <$> TF.attribute _securityGroupIds
        , TF.assign "spot_iam_fleet_role" <$> TF.attribute _spotIamFleetRole
        , TF.assign "subnets" <$> TF.attribute _subnets
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (BatchComputeEnvironmentComputeResources s) where
    validator = P.mempty

instance P.HasBidPercentage (BatchComputeEnvironmentComputeResources s) (TF.Attr s P.Integer) where
    bidPercentage =
        P.lens (_bidPercentage :: BatchComputeEnvironmentComputeResources s -> TF.Attr s P.Integer)
               (\s a -> s { _bidPercentage = a } :: BatchComputeEnvironmentComputeResources s)

instance P.HasDesiredVcpus (BatchComputeEnvironmentComputeResources s) (TF.Attr s P.Integer) where
    desiredVcpus =
        P.lens (_desiredVcpus :: BatchComputeEnvironmentComputeResources s -> TF.Attr s P.Integer)
               (\s a -> s { _desiredVcpus = a } :: BatchComputeEnvironmentComputeResources s)

instance P.HasEc2KeyPair (BatchComputeEnvironmentComputeResources s) (TF.Attr s P.Text) where
    ec2KeyPair =
        P.lens (_ec2KeyPair :: BatchComputeEnvironmentComputeResources s -> TF.Attr s P.Text)
               (\s a -> s { _ec2KeyPair = a } :: BatchComputeEnvironmentComputeResources s)

instance P.HasImageId (BatchComputeEnvironmentComputeResources s) (TF.Attr s P.Text) where
    imageId =
        P.lens (_imageId :: BatchComputeEnvironmentComputeResources s -> TF.Attr s P.Text)
               (\s a -> s { _imageId = a } :: BatchComputeEnvironmentComputeResources s)

instance P.HasInstanceRole (BatchComputeEnvironmentComputeResources s) (TF.Attr s P.Text) where
    instanceRole =
        P.lens (_instanceRole :: BatchComputeEnvironmentComputeResources s -> TF.Attr s P.Text)
               (\s a -> s { _instanceRole = a } :: BatchComputeEnvironmentComputeResources s)

instance P.HasInstanceType (BatchComputeEnvironmentComputeResources s) (TF.Attr s [TF.Attr s P.Text]) where
    instanceType =
        P.lens (_instanceType :: BatchComputeEnvironmentComputeResources s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _instanceType = a } :: BatchComputeEnvironmentComputeResources s)

instance P.HasMaxVcpus (BatchComputeEnvironmentComputeResources s) (TF.Attr s P.Integer) where
    maxVcpus =
        P.lens (_maxVcpus :: BatchComputeEnvironmentComputeResources s -> TF.Attr s P.Integer)
               (\s a -> s { _maxVcpus = a } :: BatchComputeEnvironmentComputeResources s)

instance P.HasMinVcpus (BatchComputeEnvironmentComputeResources s) (TF.Attr s P.Integer) where
    minVcpus =
        P.lens (_minVcpus :: BatchComputeEnvironmentComputeResources s -> TF.Attr s P.Integer)
               (\s a -> s { _minVcpus = a } :: BatchComputeEnvironmentComputeResources s)

instance P.HasSecurityGroupIds (BatchComputeEnvironmentComputeResources s) (TF.Attr s [TF.Attr s P.Text]) where
    securityGroupIds =
        P.lens (_securityGroupIds :: BatchComputeEnvironmentComputeResources s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _securityGroupIds = a } :: BatchComputeEnvironmentComputeResources s)

instance P.HasSpotIamFleetRole (BatchComputeEnvironmentComputeResources s) (TF.Attr s P.Text) where
    spotIamFleetRole =
        P.lens (_spotIamFleetRole :: BatchComputeEnvironmentComputeResources s -> TF.Attr s P.Text)
               (\s a -> s { _spotIamFleetRole = a } :: BatchComputeEnvironmentComputeResources s)

instance P.HasSubnets (BatchComputeEnvironmentComputeResources s) (TF.Attr s [TF.Attr s P.Text]) where
    subnets =
        P.lens (_subnets :: BatchComputeEnvironmentComputeResources s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _subnets = a } :: BatchComputeEnvironmentComputeResources s)

instance P.HasTags (BatchComputeEnvironmentComputeResources s) (TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))) where
    tags =
        P.lens (_tags :: BatchComputeEnvironmentComputeResources s -> TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text)))
               (\s a -> s { _tags = a } :: BatchComputeEnvironmentComputeResources s)

instance P.HasType' (BatchComputeEnvironmentComputeResources s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: BatchComputeEnvironmentComputeResources s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: BatchComputeEnvironmentComputeResources s)

-- | @storage_descriptor_skewed_info@ nested settings.
data StorageDescriptorSkewedInfo s = StorageDescriptorSkewedInfo'
    { _skewedColumnNames :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @skewed_column_names@ - (Optional)
    --
    , _skewedColumnValueLocationMaps :: TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))
    -- ^ @skewed_column_value_location_maps@ - (Optional)
    --
    , _skewedColumnValues :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @skewed_column_values@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newStorageDescriptorSkewedInfo
    :: StorageDescriptorSkewedInfo s
newStorageDescriptorSkewedInfo =
    StorageDescriptorSkewedInfo'
        { _skewedColumnNames = TF.Nil
        , _skewedColumnValueLocationMaps = TF.Nil
        , _skewedColumnValues = TF.Nil
        }

instance P.Hashable  (StorageDescriptorSkewedInfo s)
instance TF.IsValue  (StorageDescriptorSkewedInfo s)
instance TF.IsObject (StorageDescriptorSkewedInfo s) where
    toObject StorageDescriptorSkewedInfo'{..} = P.catMaybes
        [ TF.assign "skewed_column_names" <$> TF.attribute _skewedColumnNames
        , TF.assign "skewed_column_value_location_maps" <$> TF.attribute _skewedColumnValueLocationMaps
        , TF.assign "skewed_column_values" <$> TF.attribute _skewedColumnValues
        ]

instance TF.IsValid (StorageDescriptorSkewedInfo s) where
    validator = P.mempty

instance P.HasSkewedColumnNames (StorageDescriptorSkewedInfo s) (TF.Attr s [TF.Attr s P.Text]) where
    skewedColumnNames =
        P.lens (_skewedColumnNames :: StorageDescriptorSkewedInfo s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _skewedColumnNames = a } :: StorageDescriptorSkewedInfo s)

instance P.HasSkewedColumnValueLocationMaps (StorageDescriptorSkewedInfo s) (TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))) where
    skewedColumnValueLocationMaps =
        P.lens (_skewedColumnValueLocationMaps :: StorageDescriptorSkewedInfo s -> TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text)))
               (\s a -> s { _skewedColumnValueLocationMaps = a } :: StorageDescriptorSkewedInfo s)

instance P.HasSkewedColumnValues (StorageDescriptorSkewedInfo s) (TF.Attr s [TF.Attr s P.Text]) where
    skewedColumnValues =
        P.lens (_skewedColumnValues :: StorageDescriptorSkewedInfo s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _skewedColumnValues = a } :: StorageDescriptorSkewedInfo s)

-- | @launch_template_instance_market_options@ nested settings.
data LaunchTemplateInstanceMarketOptions s = LaunchTemplateInstanceMarketOptions'
    { _marketType  :: TF.Attr s P.Text
    -- ^ @market_type@ - (Optional)
    --
    , _spotOptions :: TF.Attr s (InstanceMarketOptionsSpotOptions s)
    -- ^ @spot_options@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLaunchTemplateInstanceMarketOptions
    :: LaunchTemplateInstanceMarketOptions s
newLaunchTemplateInstanceMarketOptions =
    LaunchTemplateInstanceMarketOptions'
        { _marketType = TF.Nil
        , _spotOptions = TF.Nil
        }

instance P.Hashable  (LaunchTemplateInstanceMarketOptions s)
instance TF.IsValue  (LaunchTemplateInstanceMarketOptions s)
instance TF.IsObject (LaunchTemplateInstanceMarketOptions s) where
    toObject LaunchTemplateInstanceMarketOptions'{..} = P.catMaybes
        [ TF.assign "market_type" <$> TF.attribute _marketType
        , TF.assign "spot_options" <$> TF.attribute _spotOptions
        ]

instance TF.IsValid (LaunchTemplateInstanceMarketOptions s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_spotOptions"
                  (_spotOptions
                      :: LaunchTemplateInstanceMarketOptions s -> TF.Attr s (InstanceMarketOptionsSpotOptions s))
                  TF.validator

instance P.HasMarketType (LaunchTemplateInstanceMarketOptions s) (TF.Attr s P.Text) where
    marketType =
        P.lens (_marketType :: LaunchTemplateInstanceMarketOptions s -> TF.Attr s P.Text)
               (\s a -> s { _marketType = a } :: LaunchTemplateInstanceMarketOptions s)

instance P.HasSpotOptions (LaunchTemplateInstanceMarketOptions s) (TF.Attr s (InstanceMarketOptionsSpotOptions s)) where
    spotOptions =
        P.lens (_spotOptions :: LaunchTemplateInstanceMarketOptions s -> TF.Attr s (InstanceMarketOptionsSpotOptions s))
               (\s a -> s { _spotOptions = a } :: LaunchTemplateInstanceMarketOptions s)

-- | @vpc_peering_connection_accepter_requester@ nested settings.
data VpcPeeringConnectionAccepterRequester s = VpcPeeringConnectionAccepterRequester'
    { _allowClassicLinkToRemoteVpc :: TF.Attr s P.Bool
    -- ^ @allow_classic_link_to_remote_vpc@ - (Optional)
    --
    , _allowRemoteVpcDnsResolution :: TF.Attr s P.Bool
    -- ^ @allow_remote_vpc_dns_resolution@ - (Optional)
    --
    , _allowVpcToRemoteClassicLink :: TF.Attr s P.Bool
    -- ^ @allow_vpc_to_remote_classic_link@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newVpcPeeringConnectionAccepterRequester
    :: VpcPeeringConnectionAccepterRequester s
newVpcPeeringConnectionAccepterRequester =
    VpcPeeringConnectionAccepterRequester'
        { _allowClassicLinkToRemoteVpc = TF.value P.False
        , _allowRemoteVpcDnsResolution = TF.value P.False
        , _allowVpcToRemoteClassicLink = TF.value P.False
        }

instance P.Hashable  (VpcPeeringConnectionAccepterRequester s)
instance TF.IsValue  (VpcPeeringConnectionAccepterRequester s)
instance TF.IsObject (VpcPeeringConnectionAccepterRequester s) where
    toObject VpcPeeringConnectionAccepterRequester'{..} = P.catMaybes
        [ TF.assign "allow_classic_link_to_remote_vpc" <$> TF.attribute _allowClassicLinkToRemoteVpc
        , TF.assign "allow_remote_vpc_dns_resolution" <$> TF.attribute _allowRemoteVpcDnsResolution
        , TF.assign "allow_vpc_to_remote_classic_link" <$> TF.attribute _allowVpcToRemoteClassicLink
        ]

instance TF.IsValid (VpcPeeringConnectionAccepterRequester s) where
    validator = P.mempty

instance P.HasAllowClassicLinkToRemoteVpc (VpcPeeringConnectionAccepterRequester s) (TF.Attr s P.Bool) where
    allowClassicLinkToRemoteVpc =
        P.lens (_allowClassicLinkToRemoteVpc :: VpcPeeringConnectionAccepterRequester s -> TF.Attr s P.Bool)
               (\s a -> s { _allowClassicLinkToRemoteVpc = a } :: VpcPeeringConnectionAccepterRequester s)

instance P.HasAllowRemoteVpcDnsResolution (VpcPeeringConnectionAccepterRequester s) (TF.Attr s P.Bool) where
    allowRemoteVpcDnsResolution =
        P.lens (_allowRemoteVpcDnsResolution :: VpcPeeringConnectionAccepterRequester s -> TF.Attr s P.Bool)
               (\s a -> s { _allowRemoteVpcDnsResolution = a } :: VpcPeeringConnectionAccepterRequester s)

instance P.HasAllowVpcToRemoteClassicLink (VpcPeeringConnectionAccepterRequester s) (TF.Attr s P.Bool) where
    allowVpcToRemoteClassicLink =
        P.lens (_allowVpcToRemoteClassicLink :: VpcPeeringConnectionAccepterRequester s -> TF.Attr s P.Bool)
               (\s a -> s { _allowVpcToRemoteClassicLink = a } :: VpcPeeringConnectionAccepterRequester s)

-- | @network_interfaces_filter@ nested settings.
data NetworkInterfacesFilter s = NetworkInterfacesFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newNetworkInterfacesFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> NetworkInterfacesFilter s
newNetworkInterfacesFilter _name _values =
    NetworkInterfacesFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (NetworkInterfacesFilter s)
instance TF.IsValue  (NetworkInterfacesFilter s)
instance TF.IsObject (NetworkInterfacesFilter s) where
    toObject NetworkInterfacesFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (NetworkInterfacesFilter s) where
    validator = P.mempty

instance P.HasName (NetworkInterfacesFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: NetworkInterfacesFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: NetworkInterfacesFilter s)

instance P.HasValues (NetworkInterfacesFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: NetworkInterfacesFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: NetworkInterfacesFilter s)

-- | @cloudwatch_event_target_batch_target@ nested settings.
data CloudwatchEventTargetBatchTarget s = CloudwatchEventTargetBatchTarget'
    { _arraySize     :: TF.Attr s P.Integer
    -- ^ @array_size@ - (Optional)
    --
    , _jobAttempts   :: TF.Attr s P.Integer
    -- ^ @job_attempts@ - (Optional)
    --
    , _jobDefinition :: TF.Attr s P.Text
    -- ^ @job_definition@ - (Required)
    --
    , _jobName       :: TF.Attr s P.Text
    -- ^ @job_name@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCloudwatchEventTargetBatchTarget
    :: TF.Attr s P.Text -- ^ @job_definition@ - 'P.jobDefinition'
    -> TF.Attr s P.Text -- ^ @job_name@ - 'P.jobName'
    -> CloudwatchEventTargetBatchTarget s
newCloudwatchEventTargetBatchTarget _jobDefinition _jobName =
    CloudwatchEventTargetBatchTarget'
        { _arraySize = TF.Nil
        , _jobAttempts = TF.Nil
        , _jobDefinition = _jobDefinition
        , _jobName = _jobName
        }

instance P.Hashable  (CloudwatchEventTargetBatchTarget s)
instance TF.IsValue  (CloudwatchEventTargetBatchTarget s)
instance TF.IsObject (CloudwatchEventTargetBatchTarget s) where
    toObject CloudwatchEventTargetBatchTarget'{..} = P.catMaybes
        [ TF.assign "array_size" <$> TF.attribute _arraySize
        , TF.assign "job_attempts" <$> TF.attribute _jobAttempts
        , TF.assign "job_definition" <$> TF.attribute _jobDefinition
        , TF.assign "job_name" <$> TF.attribute _jobName
        ]

instance TF.IsValid (CloudwatchEventTargetBatchTarget s) where
    validator = P.mempty

instance P.HasArraySize (CloudwatchEventTargetBatchTarget s) (TF.Attr s P.Integer) where
    arraySize =
        P.lens (_arraySize :: CloudwatchEventTargetBatchTarget s -> TF.Attr s P.Integer)
               (\s a -> s { _arraySize = a } :: CloudwatchEventTargetBatchTarget s)

instance P.HasJobAttempts (CloudwatchEventTargetBatchTarget s) (TF.Attr s P.Integer) where
    jobAttempts =
        P.lens (_jobAttempts :: CloudwatchEventTargetBatchTarget s -> TF.Attr s P.Integer)
               (\s a -> s { _jobAttempts = a } :: CloudwatchEventTargetBatchTarget s)

instance P.HasJobDefinition (CloudwatchEventTargetBatchTarget s) (TF.Attr s P.Text) where
    jobDefinition =
        P.lens (_jobDefinition :: CloudwatchEventTargetBatchTarget s -> TF.Attr s P.Text)
               (\s a -> s { _jobDefinition = a } :: CloudwatchEventTargetBatchTarget s)

instance P.HasJobName (CloudwatchEventTargetBatchTarget s) (TF.Attr s P.Text) where
    jobName =
        P.lens (_jobName :: CloudwatchEventTargetBatchTarget s -> TF.Attr s P.Text)
               (\s a -> s { _jobName = a } :: CloudwatchEventTargetBatchTarget s)

-- | @vpn_gateway_filter@ nested settings.
data VpnGatewayFilter s = VpnGatewayFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newVpnGatewayFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> VpnGatewayFilter s
newVpnGatewayFilter _name _values =
    VpnGatewayFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (VpnGatewayFilter s)
instance TF.IsValue  (VpnGatewayFilter s)
instance TF.IsObject (VpnGatewayFilter s) where
    toObject VpnGatewayFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (VpnGatewayFilter s) where
    validator = P.mempty

instance P.HasName (VpnGatewayFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: VpnGatewayFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: VpnGatewayFilter s)

instance P.HasValues (VpnGatewayFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: VpnGatewayFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: VpnGatewayFilter s)

-- | @ses_receipt_rule_add_header_action@ nested settings.
data SesReceiptRuleAddHeaderAction s = SesReceiptRuleAddHeaderAction'
    { _headerName  :: TF.Attr s P.Text
    -- ^ @header_name@ - (Required)
    --
    , _headerValue :: TF.Attr s P.Text
    -- ^ @header_value@ - (Required)
    --
    , _position    :: TF.Attr s P.Integer
    -- ^ @position@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSesReceiptRuleAddHeaderAction
    :: TF.Attr s P.Text -- ^ @header_name@ - 'P.headerName'
    -> TF.Attr s P.Text -- ^ @header_value@ - 'P.headerValue'
    -> TF.Attr s P.Integer -- ^ @position@ - 'P.position'
    -> SesReceiptRuleAddHeaderAction s
newSesReceiptRuleAddHeaderAction _headerName _headerValue _position =
    SesReceiptRuleAddHeaderAction'
        { _headerName = _headerName
        , _headerValue = _headerValue
        , _position = _position
        }

instance P.Hashable  (SesReceiptRuleAddHeaderAction s)
instance TF.IsValue  (SesReceiptRuleAddHeaderAction s)
instance TF.IsObject (SesReceiptRuleAddHeaderAction s) where
    toObject SesReceiptRuleAddHeaderAction'{..} = P.catMaybes
        [ TF.assign "header_name" <$> TF.attribute _headerName
        , TF.assign "header_value" <$> TF.attribute _headerValue
        , TF.assign "position" <$> TF.attribute _position
        ]

instance TF.IsValid (SesReceiptRuleAddHeaderAction s) where
    validator = P.mempty

instance P.HasHeaderName (SesReceiptRuleAddHeaderAction s) (TF.Attr s P.Text) where
    headerName =
        P.lens (_headerName :: SesReceiptRuleAddHeaderAction s -> TF.Attr s P.Text)
               (\s a -> s { _headerName = a } :: SesReceiptRuleAddHeaderAction s)

instance P.HasHeaderValue (SesReceiptRuleAddHeaderAction s) (TF.Attr s P.Text) where
    headerValue =
        P.lens (_headerValue :: SesReceiptRuleAddHeaderAction s -> TF.Attr s P.Text)
               (\s a -> s { _headerValue = a } :: SesReceiptRuleAddHeaderAction s)

instance P.HasPosition (SesReceiptRuleAddHeaderAction s) (TF.Attr s P.Integer) where
    position =
        P.lens (_position :: SesReceiptRuleAddHeaderAction s -> TF.Attr s P.Integer)
               (\s a -> s { _position = a } :: SesReceiptRuleAddHeaderAction s)

-- | @cloudwatch_event_target_input_transformer@ nested settings.
data CloudwatchEventTargetInputTransformer s = CloudwatchEventTargetInputTransformer'
    { _inputPaths    :: TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))
    -- ^ @input_paths@ - (Optional)
    --
    , _inputTemplate :: TF.Attr s P.Text
    -- ^ @input_template@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCloudwatchEventTargetInputTransformer
    :: TF.Attr s P.Text -- ^ @input_template@ - 'P.inputTemplate'
    -> CloudwatchEventTargetInputTransformer s
newCloudwatchEventTargetInputTransformer _inputTemplate =
    CloudwatchEventTargetInputTransformer'
        { _inputPaths = TF.Nil
        , _inputTemplate = _inputTemplate
        }

instance P.Hashable  (CloudwatchEventTargetInputTransformer s)
instance TF.IsValue  (CloudwatchEventTargetInputTransformer s)
instance TF.IsObject (CloudwatchEventTargetInputTransformer s) where
    toObject CloudwatchEventTargetInputTransformer'{..} = P.catMaybes
        [ TF.assign "input_paths" <$> TF.attribute _inputPaths
        , TF.assign "input_template" <$> TF.attribute _inputTemplate
        ]

instance TF.IsValid (CloudwatchEventTargetInputTransformer s) where
    validator = P.mempty

instance P.HasInputPaths (CloudwatchEventTargetInputTransformer s) (TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))) where
    inputPaths =
        P.lens (_inputPaths :: CloudwatchEventTargetInputTransformer s -> TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text)))
               (\s a -> s { _inputPaths = a } :: CloudwatchEventTargetInputTransformer s)

instance P.HasInputTemplate (CloudwatchEventTargetInputTransformer s) (TF.Attr s P.Text) where
    inputTemplate =
        P.lens (_inputTemplate :: CloudwatchEventTargetInputTransformer s -> TF.Attr s P.Text)
               (\s a -> s { _inputTemplate = a } :: CloudwatchEventTargetInputTransformer s)

-- | @glue_crawler_schema_change_policy@ nested settings.
data GlueCrawlerSchemaChangePolicy s = GlueCrawlerSchemaChangePolicy'
    { _deleteBehavior :: TF.Attr s P.Text
    -- ^ @delete_behavior@ - (Optional)
    --
    , _updateBehavior :: TF.Attr s P.Text
    -- ^ @update_behavior@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newGlueCrawlerSchemaChangePolicy
    :: GlueCrawlerSchemaChangePolicy s
newGlueCrawlerSchemaChangePolicy =
    GlueCrawlerSchemaChangePolicy'
        { _deleteBehavior = TF.value "DEPRECATE_IN_DATABASE"
        , _updateBehavior = TF.value "UPDATE_IN_DATABASE"
        }

instance P.Hashable  (GlueCrawlerSchemaChangePolicy s)
instance TF.IsValue  (GlueCrawlerSchemaChangePolicy s)
instance TF.IsObject (GlueCrawlerSchemaChangePolicy s) where
    toObject GlueCrawlerSchemaChangePolicy'{..} = P.catMaybes
        [ TF.assign "delete_behavior" <$> TF.attribute _deleteBehavior
        , TF.assign "update_behavior" <$> TF.attribute _updateBehavior
        ]

instance TF.IsValid (GlueCrawlerSchemaChangePolicy s) where
    validator = P.mempty

instance P.HasDeleteBehavior (GlueCrawlerSchemaChangePolicy s) (TF.Attr s P.Text) where
    deleteBehavior =
        P.lens (_deleteBehavior :: GlueCrawlerSchemaChangePolicy s -> TF.Attr s P.Text)
               (\s a -> s { _deleteBehavior = a } :: GlueCrawlerSchemaChangePolicy s)

instance P.HasUpdateBehavior (GlueCrawlerSchemaChangePolicy s) (TF.Attr s P.Text) where
    updateBehavior =
        P.lens (_updateBehavior :: GlueCrawlerSchemaChangePolicy s -> TF.Attr s P.Text)
               (\s a -> s { _updateBehavior = a } :: GlueCrawlerSchemaChangePolicy s)

-- | @elastic_beanstalk_environment_setting@ nested settings.
data ElasticBeanstalkEnvironmentSetting s = ElasticBeanstalkEnvironmentSetting'
    { _name      :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _namespace :: TF.Attr s P.Text
    -- ^ @namespace@ - (Required)
    --
    , _resource  :: TF.Attr s P.Text
    -- ^ @resource@ - (Optional)
    --
    , _value     :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElasticBeanstalkEnvironmentSetting
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @namespace@ - 'P.namespace'
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> ElasticBeanstalkEnvironmentSetting s
newElasticBeanstalkEnvironmentSetting _name _namespace _value =
    ElasticBeanstalkEnvironmentSetting'
        { _name = _name
        , _namespace = _namespace
        , _resource = TF.Nil
        , _value = _value
        }

instance P.Hashable  (ElasticBeanstalkEnvironmentSetting s)
instance TF.IsValue  (ElasticBeanstalkEnvironmentSetting s)
instance TF.IsObject (ElasticBeanstalkEnvironmentSetting s) where
    toObject ElasticBeanstalkEnvironmentSetting'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "namespace" <$> TF.attribute _namespace
        , TF.assign "resource" <$> TF.attribute _resource
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (ElasticBeanstalkEnvironmentSetting s) where
    validator = P.mempty

instance P.HasName (ElasticBeanstalkEnvironmentSetting s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: ElasticBeanstalkEnvironmentSetting s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: ElasticBeanstalkEnvironmentSetting s)

instance P.HasNamespace (ElasticBeanstalkEnvironmentSetting s) (TF.Attr s P.Text) where
    namespace =
        P.lens (_namespace :: ElasticBeanstalkEnvironmentSetting s -> TF.Attr s P.Text)
               (\s a -> s { _namespace = a } :: ElasticBeanstalkEnvironmentSetting s)

instance P.HasResource (ElasticBeanstalkEnvironmentSetting s) (TF.Attr s P.Text) where
    resource =
        P.lens (_resource :: ElasticBeanstalkEnvironmentSetting s -> TF.Attr s P.Text)
               (\s a -> s { _resource = a } :: ElasticBeanstalkEnvironmentSetting s)

instance P.HasValue (ElasticBeanstalkEnvironmentSetting s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: ElasticBeanstalkEnvironmentSetting s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: ElasticBeanstalkEnvironmentSetting s)

-- | @ami_product_codes@ nested settings.
data AmiProductCodes s = AmiProductCodes'
    deriving (P.Show, P.Eq, P.Generic)

newAmiProductCodes
    :: AmiProductCodes s
newAmiProductCodes =
    AmiProductCodes'

instance P.Hashable  (AmiProductCodes s)
instance TF.IsValue  (AmiProductCodes s)
instance TF.IsObject (AmiProductCodes s) where
    toObject AmiProductCodes' = []

instance TF.IsValid (AmiProductCodes s) where
    validator = P.mempty

instance s ~ s' => P.HasComputedProductCodeId (TF.Ref s' (AmiProductCodes s)) (TF.Attr s P.Text) where
    computedProductCodeId x = TF.compute (TF.refKey x) "product_code_id"

instance s ~ s' => P.HasComputedProductCodeType (TF.Ref s' (AmiProductCodes s)) (TF.Attr s P.Text) where
    computedProductCodeType x = TF.compute (TF.refKey x) "product_code_type"

-- | @iot_topic_rule_firehose@ nested settings.
data IotTopicRuleFirehose s = IotTopicRuleFirehose'
    { _deliveryStreamName :: TF.Attr s P.Text
    -- ^ @delivery_stream_name@ - (Required)
    --
    , _roleArn            :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newIotTopicRuleFirehose
    :: TF.Attr s P.Text -- ^ @delivery_stream_name@ - 'P.deliveryStreamName'
    -> TF.Attr s P.Text -- ^ @role_arn@ - 'P.roleArn'
    -> IotTopicRuleFirehose s
newIotTopicRuleFirehose _deliveryStreamName _roleArn =
    IotTopicRuleFirehose'
        { _deliveryStreamName = _deliveryStreamName
        , _roleArn = _roleArn
        }

instance P.Hashable  (IotTopicRuleFirehose s)
instance TF.IsValue  (IotTopicRuleFirehose s)
instance TF.IsObject (IotTopicRuleFirehose s) where
    toObject IotTopicRuleFirehose'{..} = P.catMaybes
        [ TF.assign "delivery_stream_name" <$> TF.attribute _deliveryStreamName
        , TF.assign "role_arn" <$> TF.attribute _roleArn
        ]

instance TF.IsValid (IotTopicRuleFirehose s) where
    validator = P.mempty

instance P.HasDeliveryStreamName (IotTopicRuleFirehose s) (TF.Attr s P.Text) where
    deliveryStreamName =
        P.lens (_deliveryStreamName :: IotTopicRuleFirehose s -> TF.Attr s P.Text)
               (\s a -> s { _deliveryStreamName = a } :: IotTopicRuleFirehose s)

instance P.HasRoleArn (IotTopicRuleFirehose s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: IotTopicRuleFirehose s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: IotTopicRuleFirehose s)

-- | @default_network_acl_ingress@ nested settings.
data DefaultNetworkAclIngress s = DefaultNetworkAclIngress'
    { _action        :: TF.Attr s P.Text
    -- ^ @action@ - (Required)
    --
    , _cidrBlock     :: TF.Attr s P.Text
    -- ^ @cidr_block@ - (Optional)
    --
    , _fromPort      :: TF.Attr s P.Integer
    -- ^ @from_port@ - (Required)
    --
    , _icmpCode      :: TF.Attr s P.Integer
    -- ^ @icmp_code@ - (Optional)
    --
    , _icmpType      :: TF.Attr s P.Integer
    -- ^ @icmp_type@ - (Optional)
    --
    , _ipv6CidrBlock :: TF.Attr s P.Text
    -- ^ @ipv6_cidr_block@ - (Optional)
    --
    , _protocol      :: TF.Attr s P.Text
    -- ^ @protocol@ - (Required)
    --
    , _ruleNo        :: TF.Attr s P.Integer
    -- ^ @rule_no@ - (Required)
    --
    , _toPort        :: TF.Attr s P.Integer
    -- ^ @to_port@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDefaultNetworkAclIngress
    :: TF.Attr s P.Text -- ^ @action@ - 'P.action'
    -> TF.Attr s P.Integer -- ^ @from_port@ - 'P.fromPort'
    -> TF.Attr s P.Text -- ^ @protocol@ - 'P.protocol'
    -> TF.Attr s P.Integer -- ^ @rule_no@ - 'P.ruleNo'
    -> TF.Attr s P.Integer -- ^ @to_port@ - 'P.toPort'
    -> DefaultNetworkAclIngress s
newDefaultNetworkAclIngress _action _fromPort _protocol _ruleNo _toPort =
    DefaultNetworkAclIngress'
        { _action = _action
        , _cidrBlock = TF.Nil
        , _fromPort = _fromPort
        , _icmpCode = TF.Nil
        , _icmpType = TF.Nil
        , _ipv6CidrBlock = TF.Nil
        , _protocol = _protocol
        , _ruleNo = _ruleNo
        , _toPort = _toPort
        }

instance P.Hashable  (DefaultNetworkAclIngress s)
instance TF.IsValue  (DefaultNetworkAclIngress s)
instance TF.IsObject (DefaultNetworkAclIngress s) where
    toObject DefaultNetworkAclIngress'{..} = P.catMaybes
        [ TF.assign "action" <$> TF.attribute _action
        , TF.assign "cidr_block" <$> TF.attribute _cidrBlock
        , TF.assign "from_port" <$> TF.attribute _fromPort
        , TF.assign "icmp_code" <$> TF.attribute _icmpCode
        , TF.assign "icmp_type" <$> TF.attribute _icmpType
        , TF.assign "ipv6_cidr_block" <$> TF.attribute _ipv6CidrBlock
        , TF.assign "protocol" <$> TF.attribute _protocol
        , TF.assign "rule_no" <$> TF.attribute _ruleNo
        , TF.assign "to_port" <$> TF.attribute _toPort
        ]

instance TF.IsValid (DefaultNetworkAclIngress s) where
    validator = P.mempty

instance P.HasAction (DefaultNetworkAclIngress s) (TF.Attr s P.Text) where
    action =
        P.lens (_action :: DefaultNetworkAclIngress s -> TF.Attr s P.Text)
               (\s a -> s { _action = a } :: DefaultNetworkAclIngress s)

instance P.HasCidrBlock (DefaultNetworkAclIngress s) (TF.Attr s P.Text) where
    cidrBlock =
        P.lens (_cidrBlock :: DefaultNetworkAclIngress s -> TF.Attr s P.Text)
               (\s a -> s { _cidrBlock = a } :: DefaultNetworkAclIngress s)

instance P.HasFromPort (DefaultNetworkAclIngress s) (TF.Attr s P.Integer) where
    fromPort =
        P.lens (_fromPort :: DefaultNetworkAclIngress s -> TF.Attr s P.Integer)
               (\s a -> s { _fromPort = a } :: DefaultNetworkAclIngress s)

instance P.HasIcmpCode (DefaultNetworkAclIngress s) (TF.Attr s P.Integer) where
    icmpCode =
        P.lens (_icmpCode :: DefaultNetworkAclIngress s -> TF.Attr s P.Integer)
               (\s a -> s { _icmpCode = a } :: DefaultNetworkAclIngress s)

instance P.HasIcmpType (DefaultNetworkAclIngress s) (TF.Attr s P.Integer) where
    icmpType =
        P.lens (_icmpType :: DefaultNetworkAclIngress s -> TF.Attr s P.Integer)
               (\s a -> s { _icmpType = a } :: DefaultNetworkAclIngress s)

instance P.HasIpv6CidrBlock (DefaultNetworkAclIngress s) (TF.Attr s P.Text) where
    ipv6CidrBlock =
        P.lens (_ipv6CidrBlock :: DefaultNetworkAclIngress s -> TF.Attr s P.Text)
               (\s a -> s { _ipv6CidrBlock = a } :: DefaultNetworkAclIngress s)

instance P.HasProtocol (DefaultNetworkAclIngress s) (TF.Attr s P.Text) where
    protocol =
        P.lens (_protocol :: DefaultNetworkAclIngress s -> TF.Attr s P.Text)
               (\s a -> s { _protocol = a } :: DefaultNetworkAclIngress s)

instance P.HasRuleNo (DefaultNetworkAclIngress s) (TF.Attr s P.Integer) where
    ruleNo =
        P.lens (_ruleNo :: DefaultNetworkAclIngress s -> TF.Attr s P.Integer)
               (\s a -> s { _ruleNo = a } :: DefaultNetworkAclIngress s)

instance P.HasToPort (DefaultNetworkAclIngress s) (TF.Attr s P.Integer) where
    toPort =
        P.lens (_toPort :: DefaultNetworkAclIngress s -> TF.Attr s P.Integer)
               (\s a -> s { _toPort = a } :: DefaultNetworkAclIngress s)

-- | @codedeploy_deployment_group_alarm_configuration@ nested settings.
data CodedeployDeploymentGroupAlarmConfiguration s = CodedeployDeploymentGroupAlarmConfiguration'
    { _alarms                 :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @alarms@ - (Optional)
    --
    , _enabled                :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Optional)
    --
    , _ignorePollAlarmFailure :: TF.Attr s P.Bool
    -- ^ @ignore_poll_alarm_failure@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCodedeployDeploymentGroupAlarmConfiguration
    :: CodedeployDeploymentGroupAlarmConfiguration s
newCodedeployDeploymentGroupAlarmConfiguration =
    CodedeployDeploymentGroupAlarmConfiguration'
        { _alarms = TF.Nil
        , _enabled = TF.Nil
        , _ignorePollAlarmFailure = TF.value P.False
        }

instance P.Hashable  (CodedeployDeploymentGroupAlarmConfiguration s)
instance TF.IsValue  (CodedeployDeploymentGroupAlarmConfiguration s)
instance TF.IsObject (CodedeployDeploymentGroupAlarmConfiguration s) where
    toObject CodedeployDeploymentGroupAlarmConfiguration'{..} = P.catMaybes
        [ TF.assign "alarms" <$> TF.attribute _alarms
        , TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "ignore_poll_alarm_failure" <$> TF.attribute _ignorePollAlarmFailure
        ]

instance TF.IsValid (CodedeployDeploymentGroupAlarmConfiguration s) where
    validator = P.mempty

instance P.HasAlarms (CodedeployDeploymentGroupAlarmConfiguration s) (TF.Attr s [TF.Attr s P.Text]) where
    alarms =
        P.lens (_alarms :: CodedeployDeploymentGroupAlarmConfiguration s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _alarms = a } :: CodedeployDeploymentGroupAlarmConfiguration s)

instance P.HasEnabled (CodedeployDeploymentGroupAlarmConfiguration s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: CodedeployDeploymentGroupAlarmConfiguration s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: CodedeployDeploymentGroupAlarmConfiguration s)

instance P.HasIgnorePollAlarmFailure (CodedeployDeploymentGroupAlarmConfiguration s) (TF.Attr s P.Bool) where
    ignorePollAlarmFailure =
        P.lens (_ignorePollAlarmFailure :: CodedeployDeploymentGroupAlarmConfiguration s -> TF.Attr s P.Bool)
               (\s a -> s { _ignorePollAlarmFailure = a } :: CodedeployDeploymentGroupAlarmConfiguration s)

-- | @codedeploy_deployment_group_ec2_tag_set@ nested settings.
data CodedeployDeploymentGroupEc2TagSet s = CodedeployDeploymentGroupEc2TagSet'
    { _ec2TagFilter :: TF.Attr s [TF.Attr s (Ec2TagSetEc2TagFilter s)]
    -- ^ @ec2_tag_filter@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCodedeployDeploymentGroupEc2TagSet
    :: CodedeployDeploymentGroupEc2TagSet s
newCodedeployDeploymentGroupEc2TagSet =
    CodedeployDeploymentGroupEc2TagSet'
        { _ec2TagFilter = TF.Nil
        }

instance P.Hashable  (CodedeployDeploymentGroupEc2TagSet s)
instance TF.IsValue  (CodedeployDeploymentGroupEc2TagSet s)
instance TF.IsObject (CodedeployDeploymentGroupEc2TagSet s) where
    toObject CodedeployDeploymentGroupEc2TagSet'{..} = P.catMaybes
        [ TF.assign "ec2_tag_filter" <$> TF.attribute _ec2TagFilter
        ]

instance TF.IsValid (CodedeployDeploymentGroupEc2TagSet s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_ec2TagFilter"
                  (_ec2TagFilter
                      :: CodedeployDeploymentGroupEc2TagSet s -> TF.Attr s [TF.Attr s (Ec2TagSetEc2TagFilter s)])
                  TF.validator

instance P.HasEc2TagFilter (CodedeployDeploymentGroupEc2TagSet s) (TF.Attr s [TF.Attr s (Ec2TagSetEc2TagFilter s)]) where
    ec2TagFilter =
        P.lens (_ec2TagFilter :: CodedeployDeploymentGroupEc2TagSet s -> TF.Attr s [TF.Attr s (Ec2TagSetEc2TagFilter s)])
               (\s a -> s { _ec2TagFilter = a } :: CodedeployDeploymentGroupEc2TagSet s)

-- | @appautoscaling_scheduled_action_scalable_target_action@ nested settings.
data AppautoscalingScheduledActionScalableTargetAction s = AppautoscalingScheduledActionScalableTargetAction'
    { _maxCapacity :: TF.Attr s P.Integer
    -- ^ @max_capacity@ - (Optional, Forces New)
    --
    , _minCapacity :: TF.Attr s P.Integer
    -- ^ @min_capacity@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAppautoscalingScheduledActionScalableTargetAction
    :: AppautoscalingScheduledActionScalableTargetAction s
newAppautoscalingScheduledActionScalableTargetAction =
    AppautoscalingScheduledActionScalableTargetAction'
        { _maxCapacity = TF.Nil
        , _minCapacity = TF.Nil
        }

instance P.Hashable  (AppautoscalingScheduledActionScalableTargetAction s)
instance TF.IsValue  (AppautoscalingScheduledActionScalableTargetAction s)
instance TF.IsObject (AppautoscalingScheduledActionScalableTargetAction s) where
    toObject AppautoscalingScheduledActionScalableTargetAction'{..} = P.catMaybes
        [ TF.assign "max_capacity" <$> TF.attribute _maxCapacity
        , TF.assign "min_capacity" <$> TF.attribute _minCapacity
        ]

instance TF.IsValid (AppautoscalingScheduledActionScalableTargetAction s) where
    validator = P.mempty

instance P.HasMaxCapacity (AppautoscalingScheduledActionScalableTargetAction s) (TF.Attr s P.Integer) where
    maxCapacity =
        P.lens (_maxCapacity :: AppautoscalingScheduledActionScalableTargetAction s -> TF.Attr s P.Integer)
               (\s a -> s { _maxCapacity = a } :: AppautoscalingScheduledActionScalableTargetAction s)

instance P.HasMinCapacity (AppautoscalingScheduledActionScalableTargetAction s) (TF.Attr s P.Integer) where
    minCapacity =
        P.lens (_minCapacity :: AppautoscalingScheduledActionScalableTargetAction s -> TF.Attr s P.Integer)
               (\s a -> s { _minCapacity = a } :: AppautoscalingScheduledActionScalableTargetAction s)

-- | @regex_match_tuple_field_to_match@ nested settings.
data RegexMatchTupleFieldToMatch s = RegexMatchTupleFieldToMatch'
    { _data' :: TF.Attr s P.Text
    -- ^ @data@ - (Optional)
    --
    , _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRegexMatchTupleFieldToMatch
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> RegexMatchTupleFieldToMatch s
newRegexMatchTupleFieldToMatch _type' =
    RegexMatchTupleFieldToMatch'
        { _data' = TF.Nil
        , _type' = _type'
        }

instance P.Hashable  (RegexMatchTupleFieldToMatch s)
instance TF.IsValue  (RegexMatchTupleFieldToMatch s)
instance TF.IsObject (RegexMatchTupleFieldToMatch s) where
    toObject RegexMatchTupleFieldToMatch'{..} = P.catMaybes
        [ TF.assign "data" <$> TF.attribute _data'
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (RegexMatchTupleFieldToMatch s) where
    validator = P.mempty

instance P.HasData' (RegexMatchTupleFieldToMatch s) (TF.Attr s P.Text) where
    data' =
        P.lens (_data' :: RegexMatchTupleFieldToMatch s -> TF.Attr s P.Text)
               (\s a -> s { _data' = a } :: RegexMatchTupleFieldToMatch s)

instance P.HasType' (RegexMatchTupleFieldToMatch s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: RegexMatchTupleFieldToMatch s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: RegexMatchTupleFieldToMatch s)

-- | @launch_template_block_device_mappings@ nested settings.
data LaunchTemplateBlockDeviceMappings s = LaunchTemplateBlockDeviceMappings'
    { _deviceName  :: TF.Attr s P.Text
    -- ^ @device_name@ - (Optional)
    --
    , _ebs         :: TF.Attr s (BlockDeviceMappingsEbs s)
    -- ^ @ebs@ - (Optional)
    --
    , _noDevice    :: TF.Attr s P.Text
    -- ^ @no_device@ - (Optional)
    --
    , _virtualName :: TF.Attr s P.Text
    -- ^ @virtual_name@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLaunchTemplateBlockDeviceMappings
    :: LaunchTemplateBlockDeviceMappings s
newLaunchTemplateBlockDeviceMappings =
    LaunchTemplateBlockDeviceMappings'
        { _deviceName = TF.Nil
        , _ebs = TF.Nil
        , _noDevice = TF.Nil
        , _virtualName = TF.Nil
        }

instance P.Hashable  (LaunchTemplateBlockDeviceMappings s)
instance TF.IsValue  (LaunchTemplateBlockDeviceMappings s)
instance TF.IsObject (LaunchTemplateBlockDeviceMappings s) where
    toObject LaunchTemplateBlockDeviceMappings'{..} = P.catMaybes
        [ TF.assign "device_name" <$> TF.attribute _deviceName
        , TF.assign "ebs" <$> TF.attribute _ebs
        , TF.assign "no_device" <$> TF.attribute _noDevice
        , TF.assign "virtual_name" <$> TF.attribute _virtualName
        ]

instance TF.IsValid (LaunchTemplateBlockDeviceMappings s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_ebs"
                  (_ebs
                      :: LaunchTemplateBlockDeviceMappings s -> TF.Attr s (BlockDeviceMappingsEbs s))
                  TF.validator

instance P.HasDeviceName (LaunchTemplateBlockDeviceMappings s) (TF.Attr s P.Text) where
    deviceName =
        P.lens (_deviceName :: LaunchTemplateBlockDeviceMappings s -> TF.Attr s P.Text)
               (\s a -> s { _deviceName = a } :: LaunchTemplateBlockDeviceMappings s)

instance P.HasEbs (LaunchTemplateBlockDeviceMappings s) (TF.Attr s (BlockDeviceMappingsEbs s)) where
    ebs =
        P.lens (_ebs :: LaunchTemplateBlockDeviceMappings s -> TF.Attr s (BlockDeviceMappingsEbs s))
               (\s a -> s { _ebs = a } :: LaunchTemplateBlockDeviceMappings s)

instance P.HasNoDevice (LaunchTemplateBlockDeviceMappings s) (TF.Attr s P.Text) where
    noDevice =
        P.lens (_noDevice :: LaunchTemplateBlockDeviceMappings s -> TF.Attr s P.Text)
               (\s a -> s { _noDevice = a } :: LaunchTemplateBlockDeviceMappings s)

instance P.HasVirtualName (LaunchTemplateBlockDeviceMappings s) (TF.Attr s P.Text) where
    virtualName =
        P.lens (_virtualName :: LaunchTemplateBlockDeviceMappings s -> TF.Attr s P.Text)
               (\s a -> s { _virtualName = a } :: LaunchTemplateBlockDeviceMappings s)

-- | @network_interface_filter@ nested settings.
data NetworkInterfaceFilter s = NetworkInterfaceFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newNetworkInterfaceFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> NetworkInterfaceFilter s
newNetworkInterfaceFilter _name _values =
    NetworkInterfaceFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (NetworkInterfaceFilter s)
instance TF.IsValue  (NetworkInterfaceFilter s)
instance TF.IsObject (NetworkInterfaceFilter s) where
    toObject NetworkInterfaceFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (NetworkInterfaceFilter s) where
    validator = P.mempty

instance P.HasName (NetworkInterfaceFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: NetworkInterfaceFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: NetworkInterfaceFilter s)

instance P.HasValues (NetworkInterfaceFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: NetworkInterfaceFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: NetworkInterfaceFilter s)

-- | @wafregional_size_constraint_set_size_constraints@ nested settings.
data WafregionalSizeConstraintSetSizeConstraints s = WafregionalSizeConstraintSetSizeConstraints'
    { _comparisonOperator :: TF.Attr s P.Text
    -- ^ @comparison_operator@ - (Required)
    --
    , _fieldToMatch       :: TF.Attr s (SizeConstraintsFieldToMatch s)
    -- ^ @field_to_match@ - (Required)
    --
    , _size               :: TF.Attr s P.Integer
    -- ^ @size@ - (Required)
    --
    , _textTransformation :: TF.Attr s P.Text
    -- ^ @text_transformation@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafregionalSizeConstraintSetSizeConstraints
    :: TF.Attr s P.Text -- ^ @comparison_operator@ - 'P.comparisonOperator'
    -> TF.Attr s (SizeConstraintsFieldToMatch s) -- ^ @field_to_match@ - 'P.fieldToMatch'
    -> TF.Attr s P.Integer -- ^ @size@ - 'P.size'
    -> TF.Attr s P.Text -- ^ @text_transformation@ - 'P.textTransformation'
    -> WafregionalSizeConstraintSetSizeConstraints s
newWafregionalSizeConstraintSetSizeConstraints _comparisonOperator _fieldToMatch _size _textTransformation =
    WafregionalSizeConstraintSetSizeConstraints'
        { _comparisonOperator = _comparisonOperator
        , _fieldToMatch = _fieldToMatch
        , _size = _size
        , _textTransformation = _textTransformation
        }

instance P.Hashable  (WafregionalSizeConstraintSetSizeConstraints s)
instance TF.IsValue  (WafregionalSizeConstraintSetSizeConstraints s)
instance TF.IsObject (WafregionalSizeConstraintSetSizeConstraints s) where
    toObject WafregionalSizeConstraintSetSizeConstraints'{..} = P.catMaybes
        [ TF.assign "comparison_operator" <$> TF.attribute _comparisonOperator
        , TF.assign "field_to_match" <$> TF.attribute _fieldToMatch
        , TF.assign "size" <$> TF.attribute _size
        , TF.assign "text_transformation" <$> TF.attribute _textTransformation
        ]

instance TF.IsValid (WafregionalSizeConstraintSetSizeConstraints s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_fieldToMatch"
                  (_fieldToMatch
                      :: WafregionalSizeConstraintSetSizeConstraints s -> TF.Attr s (SizeConstraintsFieldToMatch s))
                  TF.validator

instance P.HasComparisonOperator (WafregionalSizeConstraintSetSizeConstraints s) (TF.Attr s P.Text) where
    comparisonOperator =
        P.lens (_comparisonOperator :: WafregionalSizeConstraintSetSizeConstraints s -> TF.Attr s P.Text)
               (\s a -> s { _comparisonOperator = a } :: WafregionalSizeConstraintSetSizeConstraints s)

instance P.HasFieldToMatch (WafregionalSizeConstraintSetSizeConstraints s) (TF.Attr s (SizeConstraintsFieldToMatch s)) where
    fieldToMatch =
        P.lens (_fieldToMatch :: WafregionalSizeConstraintSetSizeConstraints s -> TF.Attr s (SizeConstraintsFieldToMatch s))
               (\s a -> s { _fieldToMatch = a } :: WafregionalSizeConstraintSetSizeConstraints s)

instance P.HasSize (WafregionalSizeConstraintSetSizeConstraints s) (TF.Attr s P.Integer) where
    size =
        P.lens (_size :: WafregionalSizeConstraintSetSizeConstraints s -> TF.Attr s P.Integer)
               (\s a -> s { _size = a } :: WafregionalSizeConstraintSetSizeConstraints s)

instance P.HasTextTransformation (WafregionalSizeConstraintSetSizeConstraints s) (TF.Attr s P.Text) where
    textTransformation =
        P.lens (_textTransformation :: WafregionalSizeConstraintSetSizeConstraints s -> TF.Attr s P.Text)
               (\s a -> s { _textTransformation = a } :: WafregionalSizeConstraintSetSizeConstraints s)

-- | @api_gateway_domain_name_endpoint_configuration@ nested settings.
data ApiGatewayDomainNameEndpointConfiguration s = ApiGatewayDomainNameEndpointConfiguration'
    { _types :: TF.Attr s P.Text
    -- ^ @types@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newApiGatewayDomainNameEndpointConfiguration
    :: TF.Attr s P.Text -- ^ @types@ - 'P.types'
    -> ApiGatewayDomainNameEndpointConfiguration s
newApiGatewayDomainNameEndpointConfiguration _types =
    ApiGatewayDomainNameEndpointConfiguration'
        { _types = _types
        }

instance P.Hashable  (ApiGatewayDomainNameEndpointConfiguration s)
instance TF.IsValue  (ApiGatewayDomainNameEndpointConfiguration s)
instance TF.IsObject (ApiGatewayDomainNameEndpointConfiguration s) where
    toObject ApiGatewayDomainNameEndpointConfiguration'{..} = P.catMaybes
        [ TF.assign "types" <$> TF.attribute _types
        ]

instance TF.IsValid (ApiGatewayDomainNameEndpointConfiguration s) where
    validator = P.mempty

instance P.HasTypes (ApiGatewayDomainNameEndpointConfiguration s) (TF.Attr s P.Text) where
    types =
        P.lens (_types :: ApiGatewayDomainNameEndpointConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _types = a } :: ApiGatewayDomainNameEndpointConfiguration s)

-- | @ami_from_instance_ephemeral_block_device@ nested settings.
data AmiFromInstanceEphemeralBlockDevice s = AmiFromInstanceEphemeralBlockDevice'
    deriving (P.Show, P.Eq, P.Generic)

newAmiFromInstanceEphemeralBlockDevice
    :: AmiFromInstanceEphemeralBlockDevice s
newAmiFromInstanceEphemeralBlockDevice =
    AmiFromInstanceEphemeralBlockDevice'

instance P.Hashable  (AmiFromInstanceEphemeralBlockDevice s)
instance TF.IsValue  (AmiFromInstanceEphemeralBlockDevice s)
instance TF.IsObject (AmiFromInstanceEphemeralBlockDevice s) where
    toObject AmiFromInstanceEphemeralBlockDevice' = []

instance TF.IsValid (AmiFromInstanceEphemeralBlockDevice s) where
    validator = P.mempty

instance s ~ s' => P.HasComputedDeviceName (TF.Ref s' (AmiFromInstanceEphemeralBlockDevice s)) (TF.Attr s P.Text) where
    computedDeviceName x = TF.compute (TF.refKey x) "device_name"

instance s ~ s' => P.HasComputedVirtualName (TF.Ref s' (AmiFromInstanceEphemeralBlockDevice s)) (TF.Attr s P.Text) where
    computedVirtualName x = TF.compute (TF.refKey x) "virtual_name"

-- | @target_tracking_scaling_policy_configuration_predefined_metric_specification@ nested settings.
data TargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification s = TargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification'
    { _predefinedMetricType :: TF.Attr s P.Text
    -- ^ @predefined_metric_type@ - (Required)
    --
    , _resourceLabel        :: TF.Attr s P.Text
    -- ^ @resource_label@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification
    :: TF.Attr s P.Text -- ^ @predefined_metric_type@ - 'P.predefinedMetricType'
    -> TargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification s
newTargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification _predefinedMetricType =
    TargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification'
        { _predefinedMetricType = _predefinedMetricType
        , _resourceLabel = TF.Nil
        }

instance P.Hashable  (TargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification s)
instance TF.IsValue  (TargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification s)
instance TF.IsObject (TargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification s) where
    toObject TargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification'{..} = P.catMaybes
        [ TF.assign "predefined_metric_type" <$> TF.attribute _predefinedMetricType
        , TF.assign "resource_label" <$> TF.attribute _resourceLabel
        ]

instance TF.IsValid (TargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification s) where
    validator = P.mempty

instance P.HasPredefinedMetricType (TargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification s) (TF.Attr s P.Text) where
    predefinedMetricType =
        P.lens (_predefinedMetricType :: TargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification s -> TF.Attr s P.Text)
               (\s a -> s { _predefinedMetricType = a } :: TargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification s)

instance P.HasResourceLabel (TargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification s) (TF.Attr s P.Text) where
    resourceLabel =
        P.lens (_resourceLabel :: TargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification s -> TF.Attr s P.Text)
               (\s a -> s { _resourceLabel = a } :: TargetTrackingScalingPolicyConfigurationPredefinedMetricSpecification s)

-- | @alb_listener_rule_condition@ nested settings.
data AlbListenerRuleCondition s = AlbListenerRuleCondition'
    { _field  :: TF.Attr s P.Text
    -- ^ @field@ - (Optional)
    --
    , _values :: TF.Attr s P.Text
    -- ^ @values@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAlbListenerRuleCondition
    :: AlbListenerRuleCondition s
newAlbListenerRuleCondition =
    AlbListenerRuleCondition'
        { _field = TF.Nil
        , _values = TF.Nil
        }

instance P.Hashable  (AlbListenerRuleCondition s)
instance TF.IsValue  (AlbListenerRuleCondition s)
instance TF.IsObject (AlbListenerRuleCondition s) where
    toObject AlbListenerRuleCondition'{..} = P.catMaybes
        [ TF.assign "field" <$> TF.attribute _field
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (AlbListenerRuleCondition s) where
    validator = P.mempty

instance P.HasField (AlbListenerRuleCondition s) (TF.Attr s P.Text) where
    field =
        P.lens (_field :: AlbListenerRuleCondition s -> TF.Attr s P.Text)
               (\s a -> s { _field = a } :: AlbListenerRuleCondition s)

instance P.HasValues (AlbListenerRuleCondition s) (TF.Attr s P.Text) where
    values =
        P.lens (_values :: AlbListenerRuleCondition s -> TF.Attr s P.Text)
               (\s a -> s { _values = a } :: AlbListenerRuleCondition s)

-- | @elastictranscoder_preset_audio@ nested settings.
data ElastictranscoderPresetAudio s = ElastictranscoderPresetAudio'
    { _audioPackingMode :: TF.Attr s P.Text
    -- ^ @audio_packing_mode@ - (Optional, Forces New)
    --
    , _bitRate          :: TF.Attr s P.Text
    -- ^ @bit_rate@ - (Optional, Forces New)
    --
    , _channels         :: TF.Attr s P.Text
    -- ^ @channels@ - (Optional, Forces New)
    --
    , _codec            :: TF.Attr s P.Text
    -- ^ @codec@ - (Optional, Forces New)
    --
    , _sampleRate       :: TF.Attr s P.Text
    -- ^ @sample_rate@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElastictranscoderPresetAudio
    :: ElastictranscoderPresetAudio s
newElastictranscoderPresetAudio =
    ElastictranscoderPresetAudio'
        { _audioPackingMode = TF.Nil
        , _bitRate = TF.Nil
        , _channels = TF.Nil
        , _codec = TF.Nil
        , _sampleRate = TF.Nil
        }

instance P.Hashable  (ElastictranscoderPresetAudio s)
instance TF.IsValue  (ElastictranscoderPresetAudio s)
instance TF.IsObject (ElastictranscoderPresetAudio s) where
    toObject ElastictranscoderPresetAudio'{..} = P.catMaybes
        [ TF.assign "audio_packing_mode" <$> TF.attribute _audioPackingMode
        , TF.assign "bit_rate" <$> TF.attribute _bitRate
        , TF.assign "channels" <$> TF.attribute _channels
        , TF.assign "codec" <$> TF.attribute _codec
        , TF.assign "sample_rate" <$> TF.attribute _sampleRate
        ]

instance TF.IsValid (ElastictranscoderPresetAudio s) where
    validator = P.mempty

instance P.HasAudioPackingMode (ElastictranscoderPresetAudio s) (TF.Attr s P.Text) where
    audioPackingMode =
        P.lens (_audioPackingMode :: ElastictranscoderPresetAudio s -> TF.Attr s P.Text)
               (\s a -> s { _audioPackingMode = a } :: ElastictranscoderPresetAudio s)

instance P.HasBitRate (ElastictranscoderPresetAudio s) (TF.Attr s P.Text) where
    bitRate =
        P.lens (_bitRate :: ElastictranscoderPresetAudio s -> TF.Attr s P.Text)
               (\s a -> s { _bitRate = a } :: ElastictranscoderPresetAudio s)

instance P.HasChannels (ElastictranscoderPresetAudio s) (TF.Attr s P.Text) where
    channels =
        P.lens (_channels :: ElastictranscoderPresetAudio s -> TF.Attr s P.Text)
               (\s a -> s { _channels = a } :: ElastictranscoderPresetAudio s)

instance P.HasCodec (ElastictranscoderPresetAudio s) (TF.Attr s P.Text) where
    codec =
        P.lens (_codec :: ElastictranscoderPresetAudio s -> TF.Attr s P.Text)
               (\s a -> s { _codec = a } :: ElastictranscoderPresetAudio s)

instance P.HasSampleRate (ElastictranscoderPresetAudio s) (TF.Attr s P.Text) where
    sampleRate =
        P.lens (_sampleRate :: ElastictranscoderPresetAudio s -> TF.Attr s P.Text)
               (\s a -> s { _sampleRate = a } :: ElastictranscoderPresetAudio s)

-- | @statement_principals@ nested settings.
data StatementPrincipals s = StatementPrincipals'
    { _identifiers :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @identifiers@ - (Required)
    --
    , _type'       :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newStatementPrincipals
    :: TF.Attr s [TF.Attr s P.Text] -- ^ @identifiers@ - 'P.identifiers'
    -> TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> StatementPrincipals s
newStatementPrincipals _identifiers _type' =
    StatementPrincipals'
        { _identifiers = _identifiers
        , _type' = _type'
        }

instance P.Hashable  (StatementPrincipals s)
instance TF.IsValue  (StatementPrincipals s)
instance TF.IsObject (StatementPrincipals s) where
    toObject StatementPrincipals'{..} = P.catMaybes
        [ TF.assign "identifiers" <$> TF.attribute _identifiers
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (StatementPrincipals s) where
    validator = P.mempty

instance P.HasIdentifiers (StatementPrincipals s) (TF.Attr s [TF.Attr s P.Text]) where
    identifiers =
        P.lens (_identifiers :: StatementPrincipals s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _identifiers = a } :: StatementPrincipals s)

instance P.HasType' (StatementPrincipals s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: StatementPrincipals s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: StatementPrincipals s)

-- | @internet_gateway_filter@ nested settings.
data InternetGatewayFilter s = InternetGatewayFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newInternetGatewayFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> InternetGatewayFilter s
newInternetGatewayFilter _name _values =
    InternetGatewayFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (InternetGatewayFilter s)
instance TF.IsValue  (InternetGatewayFilter s)
instance TF.IsObject (InternetGatewayFilter s) where
    toObject InternetGatewayFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (InternetGatewayFilter s) where
    validator = P.mempty

instance P.HasName (InternetGatewayFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: InternetGatewayFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: InternetGatewayFilter s)

instance P.HasValues (InternetGatewayFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: InternetGatewayFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: InternetGatewayFilter s)

-- | @alb_target_group_health_check@ nested settings.
data AlbTargetGroupHealthCheck s = AlbTargetGroupHealthCheck'
    { _healthyThreshold   :: TF.Attr s P.Integer
    -- ^ @healthy_threshold@ - (Optional)
    --
    , _interval           :: TF.Attr s P.Integer
    -- ^ @interval@ - (Optional)
    --
    , _port               :: TF.Attr s P.Text
    -- ^ @port@ - (Optional)
    --
    , _protocol           :: TF.Attr s P.Text
    -- ^ @protocol@ - (Optional)
    --
    , _unhealthyThreshold :: TF.Attr s P.Integer
    -- ^ @unhealthy_threshold@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAlbTargetGroupHealthCheck
    :: AlbTargetGroupHealthCheck s
newAlbTargetGroupHealthCheck =
    AlbTargetGroupHealthCheck'
        { _healthyThreshold = TF.value 3
        , _interval = TF.value 30
        , _port = TF.value "traffic-port"
        , _protocol = TF.value "HTTP"
        , _unhealthyThreshold = TF.value 3
        }

instance P.Hashable  (AlbTargetGroupHealthCheck s)
instance TF.IsValue  (AlbTargetGroupHealthCheck s)
instance TF.IsObject (AlbTargetGroupHealthCheck s) where
    toObject AlbTargetGroupHealthCheck'{..} = P.catMaybes
        [ TF.assign "healthy_threshold" <$> TF.attribute _healthyThreshold
        , TF.assign "interval" <$> TF.attribute _interval
        , TF.assign "port" <$> TF.attribute _port
        , TF.assign "protocol" <$> TF.attribute _protocol
        , TF.assign "unhealthy_threshold" <$> TF.attribute _unhealthyThreshold
        ]

instance TF.IsValid (AlbTargetGroupHealthCheck s) where
    validator = P.mempty

instance P.HasHealthyThreshold (AlbTargetGroupHealthCheck s) (TF.Attr s P.Integer) where
    healthyThreshold =
        P.lens (_healthyThreshold :: AlbTargetGroupHealthCheck s -> TF.Attr s P.Integer)
               (\s a -> s { _healthyThreshold = a } :: AlbTargetGroupHealthCheck s)

instance P.HasInterval (AlbTargetGroupHealthCheck s) (TF.Attr s P.Integer) where
    interval =
        P.lens (_interval :: AlbTargetGroupHealthCheck s -> TF.Attr s P.Integer)
               (\s a -> s { _interval = a } :: AlbTargetGroupHealthCheck s)

instance P.HasPort (AlbTargetGroupHealthCheck s) (TF.Attr s P.Text) where
    port =
        P.lens (_port :: AlbTargetGroupHealthCheck s -> TF.Attr s P.Text)
               (\s a -> s { _port = a } :: AlbTargetGroupHealthCheck s)

instance P.HasProtocol (AlbTargetGroupHealthCheck s) (TF.Attr s P.Text) where
    protocol =
        P.lens (_protocol :: AlbTargetGroupHealthCheck s -> TF.Attr s P.Text)
               (\s a -> s { _protocol = a } :: AlbTargetGroupHealthCheck s)

instance P.HasUnhealthyThreshold (AlbTargetGroupHealthCheck s) (TF.Attr s P.Integer) where
    unhealthyThreshold =
        P.lens (_unhealthyThreshold :: AlbTargetGroupHealthCheck s -> TF.Attr s P.Integer)
               (\s a -> s { _unhealthyThreshold = a } :: AlbTargetGroupHealthCheck s)

instance s ~ s' => P.HasComputedMatcher (TF.Ref s' (AlbTargetGroupHealthCheck s)) (TF.Attr s P.Text) where
    computedMatcher x = TF.compute (TF.refKey x) "matcher"

instance s ~ s' => P.HasComputedPath (TF.Ref s' (AlbTargetGroupHealthCheck s)) (TF.Attr s P.Text) where
    computedPath x = TF.compute (TF.refKey x) "path"

instance s ~ s' => P.HasComputedTimeout (TF.Ref s' (AlbTargetGroupHealthCheck s)) (TF.Attr s P.Integer) where
    computedTimeout x = TF.compute (TF.refKey x) "timeout"

instance s ~ s' => P.HasComputedHealthyThreshold (TF.Ref s' (AlbTargetGroupHealthCheck s)) (TF.Attr s P.Integer) where
    computedHealthyThreshold x = TF.compute (TF.refKey x) "healthy_threshold"

instance s ~ s' => P.HasComputedInterval (TF.Ref s' (AlbTargetGroupHealthCheck s)) (TF.Attr s P.Integer) where
    computedInterval x = TF.compute (TF.refKey x) "interval"

instance s ~ s' => P.HasComputedPort (TF.Ref s' (AlbTargetGroupHealthCheck s)) (TF.Attr s P.Text) where
    computedPort x = TF.compute (TF.refKey x) "port"

instance s ~ s' => P.HasComputedProtocol (TF.Ref s' (AlbTargetGroupHealthCheck s)) (TF.Attr s P.Text) where
    computedProtocol x = TF.compute (TF.refKey x) "protocol"

instance s ~ s' => P.HasComputedUnhealthyThreshold (TF.Ref s' (AlbTargetGroupHealthCheck s)) (TF.Attr s P.Integer) where
    computedUnhealthyThreshold x = TF.compute (TF.refKey x) "unhealthy_threshold"

-- | @emr_cluster_bootstrap_action@ nested settings.
data EmrClusterBootstrapAction s = EmrClusterBootstrapAction'
    { _args :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @args@ - (Optional, Forces New)
    --
    , _name :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _path :: TF.Attr s P.Text
    -- ^ @path@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newEmrClusterBootstrapAction
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @path@ - 'P.path'
    -> EmrClusterBootstrapAction s
newEmrClusterBootstrapAction _name _path =
    EmrClusterBootstrapAction'
        { _args = TF.Nil
        , _name = _name
        , _path = _path
        }

instance P.Hashable  (EmrClusterBootstrapAction s)
instance TF.IsValue  (EmrClusterBootstrapAction s)
instance TF.IsObject (EmrClusterBootstrapAction s) where
    toObject EmrClusterBootstrapAction'{..} = P.catMaybes
        [ TF.assign "args" <$> TF.attribute _args
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "path" <$> TF.attribute _path
        ]

instance TF.IsValid (EmrClusterBootstrapAction s) where
    validator = P.mempty

instance P.HasArgs (EmrClusterBootstrapAction s) (TF.Attr s [TF.Attr s P.Text]) where
    args =
        P.lens (_args :: EmrClusterBootstrapAction s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _args = a } :: EmrClusterBootstrapAction s)

instance P.HasName (EmrClusterBootstrapAction s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: EmrClusterBootstrapAction s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: EmrClusterBootstrapAction s)

instance P.HasPath (EmrClusterBootstrapAction s) (TF.Attr s P.Text) where
    path =
        P.lens (_path :: EmrClusterBootstrapAction s -> TF.Attr s P.Text)
               (\s a -> s { _path = a } :: EmrClusterBootstrapAction s)

-- | @waf_web_acl_default_action@ nested settings.
data WafWebAclDefaultAction s = WafWebAclDefaultAction'
    { _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafWebAclDefaultAction
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> WafWebAclDefaultAction s
newWafWebAclDefaultAction _type' =
    WafWebAclDefaultAction'
        { _type' = _type'
        }

instance P.Hashable  (WafWebAclDefaultAction s)
instance TF.IsValue  (WafWebAclDefaultAction s)
instance TF.IsObject (WafWebAclDefaultAction s) where
    toObject WafWebAclDefaultAction'{..} = P.catMaybes
        [ TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (WafWebAclDefaultAction s) where
    validator = P.mempty

instance P.HasType' (WafWebAclDefaultAction s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: WafWebAclDefaultAction s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: WafWebAclDefaultAction s)

-- | @opsworks_mysql_layer_ebs_volume@ nested settings.
data OpsworksMysqlLayerEbsVolume s = OpsworksMysqlLayerEbsVolume'
    { _iops          :: TF.Attr s P.Integer
    -- ^ @iops@ - (Optional)
    --
    , _mountPoint    :: TF.Attr s P.Text
    -- ^ @mount_point@ - (Required)
    --
    , _numberOfDisks :: TF.Attr s P.Integer
    -- ^ @number_of_disks@ - (Required)
    --
    , _raidLevel     :: TF.Attr s P.Text
    -- ^ @raid_level@ - (Optional)
    --
    , _size          :: TF.Attr s P.Integer
    -- ^ @size@ - (Required)
    --
    , _type'         :: TF.Attr s P.Text
    -- ^ @type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newOpsworksMysqlLayerEbsVolume
    :: TF.Attr s P.Text -- ^ @mount_point@ - 'P.mountPoint'
    -> TF.Attr s P.Integer -- ^ @number_of_disks@ - 'P.numberOfDisks'
    -> TF.Attr s P.Integer -- ^ @size@ - 'P.size'
    -> OpsworksMysqlLayerEbsVolume s
newOpsworksMysqlLayerEbsVolume _mountPoint _numberOfDisks _size =
    OpsworksMysqlLayerEbsVolume'
        { _iops = TF.value 0
        , _mountPoint = _mountPoint
        , _numberOfDisks = _numberOfDisks
        , _raidLevel = TF.Nil
        , _size = _size
        , _type' = TF.value "standard"
        }

instance P.Hashable  (OpsworksMysqlLayerEbsVolume s)
instance TF.IsValue  (OpsworksMysqlLayerEbsVolume s)
instance TF.IsObject (OpsworksMysqlLayerEbsVolume s) where
    toObject OpsworksMysqlLayerEbsVolume'{..} = P.catMaybes
        [ TF.assign "iops" <$> TF.attribute _iops
        , TF.assign "mount_point" <$> TF.attribute _mountPoint
        , TF.assign "number_of_disks" <$> TF.attribute _numberOfDisks
        , TF.assign "raid_level" <$> TF.attribute _raidLevel
        , TF.assign "size" <$> TF.attribute _size
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (OpsworksMysqlLayerEbsVolume s) where
    validator = P.mempty

instance P.HasIops (OpsworksMysqlLayerEbsVolume s) (TF.Attr s P.Integer) where
    iops =
        P.lens (_iops :: OpsworksMysqlLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _iops = a } :: OpsworksMysqlLayerEbsVolume s)

instance P.HasMountPoint (OpsworksMysqlLayerEbsVolume s) (TF.Attr s P.Text) where
    mountPoint =
        P.lens (_mountPoint :: OpsworksMysqlLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _mountPoint = a } :: OpsworksMysqlLayerEbsVolume s)

instance P.HasNumberOfDisks (OpsworksMysqlLayerEbsVolume s) (TF.Attr s P.Integer) where
    numberOfDisks =
        P.lens (_numberOfDisks :: OpsworksMysqlLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _numberOfDisks = a } :: OpsworksMysqlLayerEbsVolume s)

instance P.HasRaidLevel (OpsworksMysqlLayerEbsVolume s) (TF.Attr s P.Text) where
    raidLevel =
        P.lens (_raidLevel :: OpsworksMysqlLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _raidLevel = a } :: OpsworksMysqlLayerEbsVolume s)

instance P.HasSize (OpsworksMysqlLayerEbsVolume s) (TF.Attr s P.Integer) where
    size =
        P.lens (_size :: OpsworksMysqlLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _size = a } :: OpsworksMysqlLayerEbsVolume s)

instance P.HasType' (OpsworksMysqlLayerEbsVolume s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: OpsworksMysqlLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: OpsworksMysqlLayerEbsVolume s)

-- | @ssm_patch_baseline_global_filter@ nested settings.
data SsmPatchBaselineGlobalFilter s = SsmPatchBaselineGlobalFilter'
    { _key    :: TF.Attr s P.Text
    -- ^ @key@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSsmPatchBaselineGlobalFilter
    :: TF.Attr s P.Text -- ^ @key@ - 'P.key'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> SsmPatchBaselineGlobalFilter s
newSsmPatchBaselineGlobalFilter _key _values =
    SsmPatchBaselineGlobalFilter'
        { _key = _key
        , _values = _values
        }

instance P.Hashable  (SsmPatchBaselineGlobalFilter s)
instance TF.IsValue  (SsmPatchBaselineGlobalFilter s)
instance TF.IsObject (SsmPatchBaselineGlobalFilter s) where
    toObject SsmPatchBaselineGlobalFilter'{..} = P.catMaybes
        [ TF.assign "key" <$> TF.attribute _key
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (SsmPatchBaselineGlobalFilter s) where
    validator = P.mempty

instance P.HasKey (SsmPatchBaselineGlobalFilter s) (TF.Attr s P.Text) where
    key =
        P.lens (_key :: SsmPatchBaselineGlobalFilter s -> TF.Attr s P.Text)
               (\s a -> s { _key = a } :: SsmPatchBaselineGlobalFilter s)

instance P.HasValues (SsmPatchBaselineGlobalFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: SsmPatchBaselineGlobalFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: SsmPatchBaselineGlobalFilter s)

-- | @s3_bucket_inventory_filter@ nested settings.
data S3BucketInventoryFilter s = S3BucketInventoryFilter'
    { _prefix :: TF.Attr s P.Text
    -- ^ @prefix@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newS3BucketInventoryFilter
    :: S3BucketInventoryFilter s
newS3BucketInventoryFilter =
    S3BucketInventoryFilter'
        { _prefix = TF.Nil
        }

instance P.Hashable  (S3BucketInventoryFilter s)
instance TF.IsValue  (S3BucketInventoryFilter s)
instance TF.IsObject (S3BucketInventoryFilter s) where
    toObject S3BucketInventoryFilter'{..} = P.catMaybes
        [ TF.assign "prefix" <$> TF.attribute _prefix
        ]

instance TF.IsValid (S3BucketInventoryFilter s) where
    validator = P.mempty

instance P.HasPrefix (S3BucketInventoryFilter s) (TF.Attr s P.Text) where
    prefix =
        P.lens (_prefix :: S3BucketInventoryFilter s -> TF.Attr s P.Text)
               (\s a -> s { _prefix = a } :: S3BucketInventoryFilter s)

-- | @splunk_configuration_processing_configuration@ nested settings.
data SplunkConfigurationProcessingConfiguration s = SplunkConfigurationProcessingConfiguration'
    { _enabled    :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Optional)
    --
    , _processors :: TF.Attr s [TF.Attr s (ProcessingConfigurationProcessors s)]
    -- ^ @processors@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSplunkConfigurationProcessingConfiguration
    :: SplunkConfigurationProcessingConfiguration s
newSplunkConfigurationProcessingConfiguration =
    SplunkConfigurationProcessingConfiguration'
        { _enabled = TF.Nil
        , _processors = TF.Nil
        }

instance P.Hashable  (SplunkConfigurationProcessingConfiguration s)
instance TF.IsValue  (SplunkConfigurationProcessingConfiguration s)
instance TF.IsObject (SplunkConfigurationProcessingConfiguration s) where
    toObject SplunkConfigurationProcessingConfiguration'{..} = P.catMaybes
        [ TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "processors" <$> TF.attribute _processors
        ]

instance TF.IsValid (SplunkConfigurationProcessingConfiguration s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_processors"
                  (_processors
                      :: SplunkConfigurationProcessingConfiguration s -> TF.Attr s [TF.Attr s (ProcessingConfigurationProcessors s)])
                  TF.validator

instance P.HasEnabled (SplunkConfigurationProcessingConfiguration s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: SplunkConfigurationProcessingConfiguration s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: SplunkConfigurationProcessingConfiguration s)

instance P.HasProcessors (SplunkConfigurationProcessingConfiguration s) (TF.Attr s [TF.Attr s (ProcessingConfigurationProcessors s)]) where
    processors =
        P.lens (_processors :: SplunkConfigurationProcessingConfiguration s -> TF.Attr s [TF.Attr s (ProcessingConfigurationProcessors s)])
               (\s a -> s { _processors = a } :: SplunkConfigurationProcessingConfiguration s)

-- | @ssm_maintenance_window_task_targets@ nested settings.
data SsmMaintenanceWindowTaskTargets s = SsmMaintenanceWindowTaskTargets'
    { _key    :: TF.Attr s P.Text
    -- ^ @key@ - (Required, Forces New)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSsmMaintenanceWindowTaskTargets
    :: TF.Attr s P.Text -- ^ @key@ - 'P.key'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> SsmMaintenanceWindowTaskTargets s
newSsmMaintenanceWindowTaskTargets _key _values =
    SsmMaintenanceWindowTaskTargets'
        { _key = _key
        , _values = _values
        }

instance P.Hashable  (SsmMaintenanceWindowTaskTargets s)
instance TF.IsValue  (SsmMaintenanceWindowTaskTargets s)
instance TF.IsObject (SsmMaintenanceWindowTaskTargets s) where
    toObject SsmMaintenanceWindowTaskTargets'{..} = P.catMaybes
        [ TF.assign "key" <$> TF.attribute _key
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (SsmMaintenanceWindowTaskTargets s) where
    validator = P.mempty

instance P.HasKey (SsmMaintenanceWindowTaskTargets s) (TF.Attr s P.Text) where
    key =
        P.lens (_key :: SsmMaintenanceWindowTaskTargets s -> TF.Attr s P.Text)
               (\s a -> s { _key = a } :: SsmMaintenanceWindowTaskTargets s)

instance P.HasValues (SsmMaintenanceWindowTaskTargets s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: SsmMaintenanceWindowTaskTargets s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: SsmMaintenanceWindowTaskTargets s)

-- | @spot_instance_request_network_interface@ nested settings.
data SpotInstanceRequestNetworkInterface s = SpotInstanceRequestNetworkInterface'
    { _deleteOnTermination :: TF.Attr s P.Bool
    -- ^ @delete_on_termination@ - (Optional, Forces New)
    --
    , _deviceIndex         :: TF.Attr s P.Integer
    -- ^ @device_index@ - (Required, Forces New)
    --
    , _networkInterfaceId  :: TF.Attr s P.Text
    -- ^ @network_interface_id@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSpotInstanceRequestNetworkInterface
    :: TF.Attr s P.Integer -- ^ @device_index@ - 'P.deviceIndex'
    -> TF.Attr s P.Text -- ^ @network_interface_id@ - 'P.networkInterfaceId'
    -> SpotInstanceRequestNetworkInterface s
newSpotInstanceRequestNetworkInterface _deviceIndex _networkInterfaceId =
    SpotInstanceRequestNetworkInterface'
        { _deleteOnTermination = TF.value P.False
        , _deviceIndex = _deviceIndex
        , _networkInterfaceId = _networkInterfaceId
        }

instance P.Hashable  (SpotInstanceRequestNetworkInterface s)
instance TF.IsValue  (SpotInstanceRequestNetworkInterface s)
instance TF.IsObject (SpotInstanceRequestNetworkInterface s) where
    toObject SpotInstanceRequestNetworkInterface'{..} = P.catMaybes
        [ TF.assign "delete_on_termination" <$> TF.attribute _deleteOnTermination
        , TF.assign "device_index" <$> TF.attribute _deviceIndex
        , TF.assign "network_interface_id" <$> TF.attribute _networkInterfaceId
        ]

instance TF.IsValid (SpotInstanceRequestNetworkInterface s) where
    validator = P.mempty

instance P.HasDeleteOnTermination (SpotInstanceRequestNetworkInterface s) (TF.Attr s P.Bool) where
    deleteOnTermination =
        P.lens (_deleteOnTermination :: SpotInstanceRequestNetworkInterface s -> TF.Attr s P.Bool)
               (\s a -> s { _deleteOnTermination = a } :: SpotInstanceRequestNetworkInterface s)

instance P.HasDeviceIndex (SpotInstanceRequestNetworkInterface s) (TF.Attr s P.Integer) where
    deviceIndex =
        P.lens (_deviceIndex :: SpotInstanceRequestNetworkInterface s -> TF.Attr s P.Integer)
               (\s a -> s { _deviceIndex = a } :: SpotInstanceRequestNetworkInterface s)

instance P.HasNetworkInterfaceId (SpotInstanceRequestNetworkInterface s) (TF.Attr s P.Text) where
    networkInterfaceId =
        P.lens (_networkInterfaceId :: SpotInstanceRequestNetworkInterface s -> TF.Attr s P.Text)
               (\s a -> s { _networkInterfaceId = a } :: SpotInstanceRequestNetworkInterface s)

-- | @launch_configuration_ephemeral_block_device@ nested settings.
data LaunchConfigurationEphemeralBlockDevice s = LaunchConfigurationEphemeralBlockDevice'
    { _deviceName  :: TF.Attr s P.Text
    -- ^ @device_name@ - (Required)
    --
    , _virtualName :: TF.Attr s P.Text
    -- ^ @virtual_name@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLaunchConfigurationEphemeralBlockDevice
    :: TF.Attr s P.Text -- ^ @device_name@ - 'P.deviceName'
    -> TF.Attr s P.Text -- ^ @virtual_name@ - 'P.virtualName'
    -> LaunchConfigurationEphemeralBlockDevice s
newLaunchConfigurationEphemeralBlockDevice _deviceName _virtualName =
    LaunchConfigurationEphemeralBlockDevice'
        { _deviceName = _deviceName
        , _virtualName = _virtualName
        }

instance P.Hashable  (LaunchConfigurationEphemeralBlockDevice s)
instance TF.IsValue  (LaunchConfigurationEphemeralBlockDevice s)
instance TF.IsObject (LaunchConfigurationEphemeralBlockDevice s) where
    toObject LaunchConfigurationEphemeralBlockDevice'{..} = P.catMaybes
        [ TF.assign "device_name" <$> TF.attribute _deviceName
        , TF.assign "virtual_name" <$> TF.attribute _virtualName
        ]

instance TF.IsValid (LaunchConfigurationEphemeralBlockDevice s) where
    validator = P.mempty

instance P.HasDeviceName (LaunchConfigurationEphemeralBlockDevice s) (TF.Attr s P.Text) where
    deviceName =
        P.lens (_deviceName :: LaunchConfigurationEphemeralBlockDevice s -> TF.Attr s P.Text)
               (\s a -> s { _deviceName = a } :: LaunchConfigurationEphemeralBlockDevice s)

instance P.HasVirtualName (LaunchConfigurationEphemeralBlockDevice s) (TF.Attr s P.Text) where
    virtualName =
        P.lens (_virtualName :: LaunchConfigurationEphemeralBlockDevice s -> TF.Attr s P.Text)
               (\s a -> s { _virtualName = a } :: LaunchConfigurationEphemeralBlockDevice s)

instance s ~ s' => P.HasComputedDeviceName (TF.Ref s' (LaunchConfigurationEphemeralBlockDevice s)) (TF.Attr s P.Text) where
    computedDeviceName x = TF.compute (TF.refKey x) "device_name"

instance s ~ s' => P.HasComputedVirtualName (TF.Ref s' (LaunchConfigurationEphemeralBlockDevice s)) (TF.Attr s P.Text) where
    computedVirtualName x = TF.compute (TF.refKey x) "virtual_name"

-- | @codebuild_project_source@ nested settings.
data CodebuildProjectSource s = CodebuildProjectSource'
    { _auth              :: TF.Attr s [TF.Attr s (SourceAuth s)]
    -- ^ @auth@ - (Optional)
    --
    , _buildspec         :: TF.Attr s P.Text
    -- ^ @buildspec@ - (Optional)
    --
    , _gitCloneDepth     :: TF.Attr s P.Integer
    -- ^ @git_clone_depth@ - (Optional)
    --
    , _insecureSsl       :: TF.Attr s P.Bool
    -- ^ @insecure_ssl@ - (Optional)
    --
    , _location          :: TF.Attr s P.Text
    -- ^ @location@ - (Optional)
    --
    , _reportBuildStatus :: TF.Attr s P.Bool
    -- ^ @report_build_status@ - (Optional)
    --
    , _type'             :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCodebuildProjectSource
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> CodebuildProjectSource s
newCodebuildProjectSource _type' =
    CodebuildProjectSource'
        { _auth = TF.Nil
        , _buildspec = TF.Nil
        , _gitCloneDepth = TF.Nil
        , _insecureSsl = TF.Nil
        , _location = TF.Nil
        , _reportBuildStatus = TF.Nil
        , _type' = _type'
        }

instance P.Hashable  (CodebuildProjectSource s)
instance TF.IsValue  (CodebuildProjectSource s)
instance TF.IsObject (CodebuildProjectSource s) where
    toObject CodebuildProjectSource'{..} = P.catMaybes
        [ TF.assign "auth" <$> TF.attribute _auth
        , TF.assign "buildspec" <$> TF.attribute _buildspec
        , TF.assign "git_clone_depth" <$> TF.attribute _gitCloneDepth
        , TF.assign "insecure_ssl" <$> TF.attribute _insecureSsl
        , TF.assign "location" <$> TF.attribute _location
        , TF.assign "report_build_status" <$> TF.attribute _reportBuildStatus
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (CodebuildProjectSource s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_auth"
                  (_auth
                      :: CodebuildProjectSource s -> TF.Attr s [TF.Attr s (SourceAuth s)])
                  TF.validator

instance P.HasAuth (CodebuildProjectSource s) (TF.Attr s [TF.Attr s (SourceAuth s)]) where
    auth =
        P.lens (_auth :: CodebuildProjectSource s -> TF.Attr s [TF.Attr s (SourceAuth s)])
               (\s a -> s { _auth = a } :: CodebuildProjectSource s)

instance P.HasBuildspec (CodebuildProjectSource s) (TF.Attr s P.Text) where
    buildspec =
        P.lens (_buildspec :: CodebuildProjectSource s -> TF.Attr s P.Text)
               (\s a -> s { _buildspec = a } :: CodebuildProjectSource s)

instance P.HasGitCloneDepth (CodebuildProjectSource s) (TF.Attr s P.Integer) where
    gitCloneDepth =
        P.lens (_gitCloneDepth :: CodebuildProjectSource s -> TF.Attr s P.Integer)
               (\s a -> s { _gitCloneDepth = a } :: CodebuildProjectSource s)

instance P.HasInsecureSsl (CodebuildProjectSource s) (TF.Attr s P.Bool) where
    insecureSsl =
        P.lens (_insecureSsl :: CodebuildProjectSource s -> TF.Attr s P.Bool)
               (\s a -> s { _insecureSsl = a } :: CodebuildProjectSource s)

instance P.HasLocation (CodebuildProjectSource s) (TF.Attr s P.Text) where
    location =
        P.lens (_location :: CodebuildProjectSource s -> TF.Attr s P.Text)
               (\s a -> s { _location = a } :: CodebuildProjectSource s)

instance P.HasReportBuildStatus (CodebuildProjectSource s) (TF.Attr s P.Bool) where
    reportBuildStatus =
        P.lens (_reportBuildStatus :: CodebuildProjectSource s -> TF.Attr s P.Bool)
               (\s a -> s { _reportBuildStatus = a } :: CodebuildProjectSource s)

instance P.HasType' (CodebuildProjectSource s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: CodebuildProjectSource s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: CodebuildProjectSource s)

-- | @sql_injection_match_tuples_field_to_match@ nested settings.
data SqlInjectionMatchTuplesFieldToMatch s = SqlInjectionMatchTuplesFieldToMatch'
    { _data' :: TF.Attr s P.Text
    -- ^ @data@ - (Optional)
    --
    , _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSqlInjectionMatchTuplesFieldToMatch
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> SqlInjectionMatchTuplesFieldToMatch s
newSqlInjectionMatchTuplesFieldToMatch _type' =
    SqlInjectionMatchTuplesFieldToMatch'
        { _data' = TF.Nil
        , _type' = _type'
        }

instance P.Hashable  (SqlInjectionMatchTuplesFieldToMatch s)
instance TF.IsValue  (SqlInjectionMatchTuplesFieldToMatch s)
instance TF.IsObject (SqlInjectionMatchTuplesFieldToMatch s) where
    toObject SqlInjectionMatchTuplesFieldToMatch'{..} = P.catMaybes
        [ TF.assign "data" <$> TF.attribute _data'
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (SqlInjectionMatchTuplesFieldToMatch s) where
    validator = P.mempty

instance P.HasData' (SqlInjectionMatchTuplesFieldToMatch s) (TF.Attr s P.Text) where
    data' =
        P.lens (_data' :: SqlInjectionMatchTuplesFieldToMatch s -> TF.Attr s P.Text)
               (\s a -> s { _data' = a } :: SqlInjectionMatchTuplesFieldToMatch s)

instance P.HasType' (SqlInjectionMatchTuplesFieldToMatch s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: SqlInjectionMatchTuplesFieldToMatch s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: SqlInjectionMatchTuplesFieldToMatch s)

-- | @wafregional_web_acl_default_action@ nested settings.
data WafregionalWebAclDefaultAction s = WafregionalWebAclDefaultAction'
    { _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafregionalWebAclDefaultAction
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> WafregionalWebAclDefaultAction s
newWafregionalWebAclDefaultAction _type' =
    WafregionalWebAclDefaultAction'
        { _type' = _type'
        }

instance P.Hashable  (WafregionalWebAclDefaultAction s)
instance TF.IsValue  (WafregionalWebAclDefaultAction s)
instance TF.IsObject (WafregionalWebAclDefaultAction s) where
    toObject WafregionalWebAclDefaultAction'{..} = P.catMaybes
        [ TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (WafregionalWebAclDefaultAction s) where
    validator = P.mempty

instance P.HasType' (WafregionalWebAclDefaultAction s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: WafregionalWebAclDefaultAction s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: WafregionalWebAclDefaultAction s)

-- | @security_group_ingress@ nested settings.
data SecurityGroupIngress s = SecurityGroupIngress'
    { _cidrBlocks     :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @cidr_blocks@ - (Optional)
    --
    , _description    :: TF.Attr s P.Text
    -- ^ @description@ - (Optional)
    --
    , _fromPort       :: TF.Attr s P.Integer
    -- ^ @from_port@ - (Required)
    --
    , _ipv6CidrBlocks :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @ipv6_cidr_blocks@ - (Optional)
    --
    , _protocol       :: TF.Attr s P.Text
    -- ^ @protocol@ - (Required)
    --
    , _securityGroups :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @security_groups@ - (Optional)
    --
    , _self           :: TF.Attr s P.Bool
    -- ^ @self@ - (Optional)
    --
    , _toPort         :: TF.Attr s P.Integer
    -- ^ @to_port@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSecurityGroupIngress
    :: TF.Attr s P.Integer -- ^ @from_port@ - 'P.fromPort'
    -> TF.Attr s P.Text -- ^ @protocol@ - 'P.protocol'
    -> TF.Attr s P.Integer -- ^ @to_port@ - 'P.toPort'
    -> SecurityGroupIngress s
newSecurityGroupIngress _fromPort _protocol _toPort =
    SecurityGroupIngress'
        { _cidrBlocks = TF.Nil
        , _description = TF.Nil
        , _fromPort = _fromPort
        , _ipv6CidrBlocks = TF.Nil
        , _protocol = _protocol
        , _securityGroups = TF.Nil
        , _self = TF.value P.False
        , _toPort = _toPort
        }

instance P.Hashable  (SecurityGroupIngress s)
instance TF.IsValue  (SecurityGroupIngress s)
instance TF.IsObject (SecurityGroupIngress s) where
    toObject SecurityGroupIngress'{..} = P.catMaybes
        [ TF.assign "cidr_blocks" <$> TF.attribute _cidrBlocks
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "from_port" <$> TF.attribute _fromPort
        , TF.assign "ipv6_cidr_blocks" <$> TF.attribute _ipv6CidrBlocks
        , TF.assign "protocol" <$> TF.attribute _protocol
        , TF.assign "security_groups" <$> TF.attribute _securityGroups
        , TF.assign "self" <$> TF.attribute _self
        , TF.assign "to_port" <$> TF.attribute _toPort
        ]

instance TF.IsValid (SecurityGroupIngress s) where
    validator = P.mempty

instance P.HasCidrBlocks (SecurityGroupIngress s) (TF.Attr s [TF.Attr s P.Text]) where
    cidrBlocks =
        P.lens (_cidrBlocks :: SecurityGroupIngress s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _cidrBlocks = a } :: SecurityGroupIngress s)

instance P.HasDescription (SecurityGroupIngress s) (TF.Attr s P.Text) where
    description =
        P.lens (_description :: SecurityGroupIngress s -> TF.Attr s P.Text)
               (\s a -> s { _description = a } :: SecurityGroupIngress s)

instance P.HasFromPort (SecurityGroupIngress s) (TF.Attr s P.Integer) where
    fromPort =
        P.lens (_fromPort :: SecurityGroupIngress s -> TF.Attr s P.Integer)
               (\s a -> s { _fromPort = a } :: SecurityGroupIngress s)

instance P.HasIpv6CidrBlocks (SecurityGroupIngress s) (TF.Attr s [TF.Attr s P.Text]) where
    ipv6CidrBlocks =
        P.lens (_ipv6CidrBlocks :: SecurityGroupIngress s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _ipv6CidrBlocks = a } :: SecurityGroupIngress s)

instance P.HasProtocol (SecurityGroupIngress s) (TF.Attr s P.Text) where
    protocol =
        P.lens (_protocol :: SecurityGroupIngress s -> TF.Attr s P.Text)
               (\s a -> s { _protocol = a } :: SecurityGroupIngress s)

instance P.HasSecurityGroups (SecurityGroupIngress s) (TF.Attr s [TF.Attr s P.Text]) where
    securityGroups =
        P.lens (_securityGroups :: SecurityGroupIngress s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _securityGroups = a } :: SecurityGroupIngress s)

instance P.HasSelf (SecurityGroupIngress s) (TF.Attr s P.Bool) where
    self =
        P.lens (_self :: SecurityGroupIngress s -> TF.Attr s P.Bool)
               (\s a -> s { _self = a } :: SecurityGroupIngress s)

instance P.HasToPort (SecurityGroupIngress s) (TF.Attr s P.Integer) where
    toPort =
        P.lens (_toPort :: SecurityGroupIngress s -> TF.Attr s P.Integer)
               (\s a -> s { _toPort = a } :: SecurityGroupIngress s)

-- | @codedeploy_deployment_group_blue_green_deployment_config@ nested settings.
data CodedeployDeploymentGroupBlueGreenDeploymentConfig s = CodedeployDeploymentGroupBlueGreenDeploymentConfig'
    { _deploymentReadyOption :: TF.Attr s (BlueGreenDeploymentConfigDeploymentReadyOption s)
    -- ^ @deployment_ready_option@ - (Optional)
    --
    , _terminateBlueInstancesOnDeploymentSuccess :: TF.Attr s (BlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess s)
    -- ^ @terminate_blue_instances_on_deployment_success@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCodedeployDeploymentGroupBlueGreenDeploymentConfig
    :: CodedeployDeploymentGroupBlueGreenDeploymentConfig s
newCodedeployDeploymentGroupBlueGreenDeploymentConfig =
    CodedeployDeploymentGroupBlueGreenDeploymentConfig'
        { _deploymentReadyOption = TF.Nil
        , _terminateBlueInstancesOnDeploymentSuccess = TF.Nil
        }

instance P.Hashable  (CodedeployDeploymentGroupBlueGreenDeploymentConfig s)
instance TF.IsValue  (CodedeployDeploymentGroupBlueGreenDeploymentConfig s)
instance TF.IsObject (CodedeployDeploymentGroupBlueGreenDeploymentConfig s) where
    toObject CodedeployDeploymentGroupBlueGreenDeploymentConfig'{..} = P.catMaybes
        [ TF.assign "deployment_ready_option" <$> TF.attribute _deploymentReadyOption
        , TF.assign "terminate_blue_instances_on_deployment_success" <$> TF.attribute _terminateBlueInstancesOnDeploymentSuccess
        ]

instance TF.IsValid (CodedeployDeploymentGroupBlueGreenDeploymentConfig s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_deploymentReadyOption"
                  (_deploymentReadyOption
                      :: CodedeployDeploymentGroupBlueGreenDeploymentConfig s -> TF.Attr s (BlueGreenDeploymentConfigDeploymentReadyOption s))
                  TF.validator
           P.<> TF.settingsValidator "_terminateBlueInstancesOnDeploymentSuccess"
                  (_terminateBlueInstancesOnDeploymentSuccess
                      :: CodedeployDeploymentGroupBlueGreenDeploymentConfig s -> TF.Attr s (BlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess s))
                  TF.validator

instance P.HasDeploymentReadyOption (CodedeployDeploymentGroupBlueGreenDeploymentConfig s) (TF.Attr s (BlueGreenDeploymentConfigDeploymentReadyOption s)) where
    deploymentReadyOption =
        P.lens (_deploymentReadyOption :: CodedeployDeploymentGroupBlueGreenDeploymentConfig s -> TF.Attr s (BlueGreenDeploymentConfigDeploymentReadyOption s))
               (\s a -> s { _deploymentReadyOption = a } :: CodedeployDeploymentGroupBlueGreenDeploymentConfig s)

instance P.HasTerminateBlueInstancesOnDeploymentSuccess (CodedeployDeploymentGroupBlueGreenDeploymentConfig s) (TF.Attr s (BlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess s)) where
    terminateBlueInstancesOnDeploymentSuccess =
        P.lens (_terminateBlueInstancesOnDeploymentSuccess :: CodedeployDeploymentGroupBlueGreenDeploymentConfig s -> TF.Attr s (BlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess s))
               (\s a -> s { _terminateBlueInstancesOnDeploymentSuccess = a } :: CodedeployDeploymentGroupBlueGreenDeploymentConfig s)

instance s ~ s' => P.HasComputedGreenFleetProvisioningOption (TF.Ref s' (CodedeployDeploymentGroupBlueGreenDeploymentConfig s)) (TF.Attr s (BlueGreenDeploymentConfigGreenFleetProvisioningOption s)) where
    computedGreenFleetProvisioningOption x = TF.compute (TF.refKey x) "green_fleet_provisioning_option"

-- | @dax_parameter_group_parameters@ nested settings.
data DaxParameterGroupParameters s = DaxParameterGroupParameters'
    { _name  :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _value :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDaxParameterGroupParameters
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> DaxParameterGroupParameters s
newDaxParameterGroupParameters _name _value =
    DaxParameterGroupParameters'
        { _name = _name
        , _value = _value
        }

instance P.Hashable  (DaxParameterGroupParameters s)
instance TF.IsValue  (DaxParameterGroupParameters s)
instance TF.IsObject (DaxParameterGroupParameters s) where
    toObject DaxParameterGroupParameters'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (DaxParameterGroupParameters s) where
    validator = P.mempty

instance P.HasName (DaxParameterGroupParameters s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: DaxParameterGroupParameters s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: DaxParameterGroupParameters s)

instance P.HasValue (DaxParameterGroupParameters s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: DaxParameterGroupParameters s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: DaxParameterGroupParameters s)

-- | @opsworks_static_web_layer_ebs_volume@ nested settings.
data OpsworksStaticWebLayerEbsVolume s = OpsworksStaticWebLayerEbsVolume'
    { _iops          :: TF.Attr s P.Integer
    -- ^ @iops@ - (Optional)
    --
    , _mountPoint    :: TF.Attr s P.Text
    -- ^ @mount_point@ - (Required)
    --
    , _numberOfDisks :: TF.Attr s P.Integer
    -- ^ @number_of_disks@ - (Required)
    --
    , _raidLevel     :: TF.Attr s P.Text
    -- ^ @raid_level@ - (Optional)
    --
    , _size          :: TF.Attr s P.Integer
    -- ^ @size@ - (Required)
    --
    , _type'         :: TF.Attr s P.Text
    -- ^ @type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newOpsworksStaticWebLayerEbsVolume
    :: TF.Attr s P.Text -- ^ @mount_point@ - 'P.mountPoint'
    -> TF.Attr s P.Integer -- ^ @number_of_disks@ - 'P.numberOfDisks'
    -> TF.Attr s P.Integer -- ^ @size@ - 'P.size'
    -> OpsworksStaticWebLayerEbsVolume s
newOpsworksStaticWebLayerEbsVolume _mountPoint _numberOfDisks _size =
    OpsworksStaticWebLayerEbsVolume'
        { _iops = TF.value 0
        , _mountPoint = _mountPoint
        , _numberOfDisks = _numberOfDisks
        , _raidLevel = TF.Nil
        , _size = _size
        , _type' = TF.value "standard"
        }

instance P.Hashable  (OpsworksStaticWebLayerEbsVolume s)
instance TF.IsValue  (OpsworksStaticWebLayerEbsVolume s)
instance TF.IsObject (OpsworksStaticWebLayerEbsVolume s) where
    toObject OpsworksStaticWebLayerEbsVolume'{..} = P.catMaybes
        [ TF.assign "iops" <$> TF.attribute _iops
        , TF.assign "mount_point" <$> TF.attribute _mountPoint
        , TF.assign "number_of_disks" <$> TF.attribute _numberOfDisks
        , TF.assign "raid_level" <$> TF.attribute _raidLevel
        , TF.assign "size" <$> TF.attribute _size
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (OpsworksStaticWebLayerEbsVolume s) where
    validator = P.mempty

instance P.HasIops (OpsworksStaticWebLayerEbsVolume s) (TF.Attr s P.Integer) where
    iops =
        P.lens (_iops :: OpsworksStaticWebLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _iops = a } :: OpsworksStaticWebLayerEbsVolume s)

instance P.HasMountPoint (OpsworksStaticWebLayerEbsVolume s) (TF.Attr s P.Text) where
    mountPoint =
        P.lens (_mountPoint :: OpsworksStaticWebLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _mountPoint = a } :: OpsworksStaticWebLayerEbsVolume s)

instance P.HasNumberOfDisks (OpsworksStaticWebLayerEbsVolume s) (TF.Attr s P.Integer) where
    numberOfDisks =
        P.lens (_numberOfDisks :: OpsworksStaticWebLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _numberOfDisks = a } :: OpsworksStaticWebLayerEbsVolume s)

instance P.HasRaidLevel (OpsworksStaticWebLayerEbsVolume s) (TF.Attr s P.Text) where
    raidLevel =
        P.lens (_raidLevel :: OpsworksStaticWebLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _raidLevel = a } :: OpsworksStaticWebLayerEbsVolume s)

instance P.HasSize (OpsworksStaticWebLayerEbsVolume s) (TF.Attr s P.Integer) where
    size =
        P.lens (_size :: OpsworksStaticWebLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _size = a } :: OpsworksStaticWebLayerEbsVolume s)

instance P.HasType' (OpsworksStaticWebLayerEbsVolume s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: OpsworksStaticWebLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: OpsworksStaticWebLayerEbsVolume s)

-- | @processing_configuration_processors@ nested settings.
data ProcessingConfigurationProcessors s = ProcessingConfigurationProcessors'
    { _parameters :: TF.Attr s [TF.Attr s (ProcessorsParameters s)]
    -- ^ @parameters@ - (Optional)
    --
    , _type'      :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newProcessingConfigurationProcessors
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> ProcessingConfigurationProcessors s
newProcessingConfigurationProcessors _type' =
    ProcessingConfigurationProcessors'
        { _parameters = TF.Nil
        , _type' = _type'
        }

instance P.Hashable  (ProcessingConfigurationProcessors s)
instance TF.IsValue  (ProcessingConfigurationProcessors s)
instance TF.IsObject (ProcessingConfigurationProcessors s) where
    toObject ProcessingConfigurationProcessors'{..} = P.catMaybes
        [ TF.assign "parameters" <$> TF.attribute _parameters
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (ProcessingConfigurationProcessors s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_parameters"
                  (_parameters
                      :: ProcessingConfigurationProcessors s -> TF.Attr s [TF.Attr s (ProcessorsParameters s)])
                  TF.validator

instance P.HasParameters (ProcessingConfigurationProcessors s) (TF.Attr s [TF.Attr s (ProcessorsParameters s)]) where
    parameters =
        P.lens (_parameters :: ProcessingConfigurationProcessors s -> TF.Attr s [TF.Attr s (ProcessorsParameters s)])
               (\s a -> s { _parameters = a } :: ProcessingConfigurationProcessors s)

instance P.HasType' (ProcessingConfigurationProcessors s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: ProcessingConfigurationProcessors s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: ProcessingConfigurationProcessors s)

-- | @gamelift_fleet_resource_creation_limit_policy@ nested settings.
data GameliftFleetResourceCreationLimitPolicy s = GameliftFleetResourceCreationLimitPolicy'
    { _newGameSessionsPerCreator :: TF.Attr s P.Integer
    -- ^ @new_game_sessions_per_creator@ - (Optional)
    --
    , _policyPeriodInMinutes     :: TF.Attr s P.Integer
    -- ^ @policy_period_in_minutes@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newGameliftFleetResourceCreationLimitPolicy
    :: GameliftFleetResourceCreationLimitPolicy s
newGameliftFleetResourceCreationLimitPolicy =
    GameliftFleetResourceCreationLimitPolicy'
        { _newGameSessionsPerCreator = TF.Nil
        , _policyPeriodInMinutes = TF.Nil
        }

instance P.Hashable  (GameliftFleetResourceCreationLimitPolicy s)
instance TF.IsValue  (GameliftFleetResourceCreationLimitPolicy s)
instance TF.IsObject (GameliftFleetResourceCreationLimitPolicy s) where
    toObject GameliftFleetResourceCreationLimitPolicy'{..} = P.catMaybes
        [ TF.assign "new_game_sessions_per_creator" <$> TF.attribute _newGameSessionsPerCreator
        , TF.assign "policy_period_in_minutes" <$> TF.attribute _policyPeriodInMinutes
        ]

instance TF.IsValid (GameliftFleetResourceCreationLimitPolicy s) where
    validator = P.mempty

instance P.HasNewGameSessionsPerCreator (GameliftFleetResourceCreationLimitPolicy s) (TF.Attr s P.Integer) where
    newGameSessionsPerCreator =
        P.lens (_newGameSessionsPerCreator :: GameliftFleetResourceCreationLimitPolicy s -> TF.Attr s P.Integer)
               (\s a -> s { _newGameSessionsPerCreator = a } :: GameliftFleetResourceCreationLimitPolicy s)

instance P.HasPolicyPeriodInMinutes (GameliftFleetResourceCreationLimitPolicy s) (TF.Attr s P.Integer) where
    policyPeriodInMinutes =
        P.lens (_policyPeriodInMinutes :: GameliftFleetResourceCreationLimitPolicy s -> TF.Attr s P.Integer)
               (\s a -> s { _policyPeriodInMinutes = a } :: GameliftFleetResourceCreationLimitPolicy s)

-- | @s3_bucket_inventory_schedule@ nested settings.
data S3BucketInventorySchedule s = S3BucketInventorySchedule'
    { _frequency :: TF.Attr s P.Text
    -- ^ @frequency@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newS3BucketInventorySchedule
    :: TF.Attr s P.Text -- ^ @frequency@ - 'P.frequency'
    -> S3BucketInventorySchedule s
newS3BucketInventorySchedule _frequency =
    S3BucketInventorySchedule'
        { _frequency = _frequency
        }

instance P.Hashable  (S3BucketInventorySchedule s)
instance TF.IsValue  (S3BucketInventorySchedule s)
instance TF.IsObject (S3BucketInventorySchedule s) where
    toObject S3BucketInventorySchedule'{..} = P.catMaybes
        [ TF.assign "frequency" <$> TF.attribute _frequency
        ]

instance TF.IsValid (S3BucketInventorySchedule s) where
    validator = P.mempty

instance P.HasFrequency (S3BucketInventorySchedule s) (TF.Attr s P.Text) where
    frequency =
        P.lens (_frequency :: S3BucketInventorySchedule s -> TF.Attr s P.Text)
               (\s a -> s { _frequency = a } :: S3BucketInventorySchedule s)

-- | @ssm_association_targets@ nested settings.
data SsmAssociationTargets s = SsmAssociationTargets'
    { _key    :: TF.Attr s P.Text
    -- ^ @key@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSsmAssociationTargets
    :: TF.Attr s P.Text -- ^ @key@ - 'P.key'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> SsmAssociationTargets s
newSsmAssociationTargets _key _values =
    SsmAssociationTargets'
        { _key = _key
        , _values = _values
        }

instance P.Hashable  (SsmAssociationTargets s)
instance TF.IsValue  (SsmAssociationTargets s)
instance TF.IsObject (SsmAssociationTargets s) where
    toObject SsmAssociationTargets'{..} = P.catMaybes
        [ TF.assign "key" <$> TF.attribute _key
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (SsmAssociationTargets s) where
    validator = P.mempty

instance P.HasKey (SsmAssociationTargets s) (TF.Attr s P.Text) where
    key =
        P.lens (_key :: SsmAssociationTargets s -> TF.Attr s P.Text)
               (\s a -> s { _key = a } :: SsmAssociationTargets s)

instance P.HasValues (SsmAssociationTargets s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: SsmAssociationTargets s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: SsmAssociationTargets s)

-- | @config_configuration_aggregator_organization_aggregation_source@ nested settings.
data ConfigConfigurationAggregatorOrganizationAggregationSource s = ConfigConfigurationAggregatorOrganizationAggregationSource'
    { _allRegions :: TF.Attr s P.Bool
    -- ^ @all_regions@ - (Optional)
    --
    , _regions    :: TF.Attr s (P.NonEmpty (TF.Attr s P.Text))
    -- ^ @regions@ - (Optional)
    --
    , _roleArn    :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newConfigConfigurationAggregatorOrganizationAggregationSource
    :: TF.Attr s P.Text -- ^ @role_arn@ - 'P.roleArn'
    -> ConfigConfigurationAggregatorOrganizationAggregationSource s
newConfigConfigurationAggregatorOrganizationAggregationSource _roleArn =
    ConfigConfigurationAggregatorOrganizationAggregationSource'
        { _allRegions = TF.value P.False
        , _regions = TF.Nil
        , _roleArn = _roleArn
        }

instance P.Hashable  (ConfigConfigurationAggregatorOrganizationAggregationSource s)
instance TF.IsValue  (ConfigConfigurationAggregatorOrganizationAggregationSource s)
instance TF.IsObject (ConfigConfigurationAggregatorOrganizationAggregationSource s) where
    toObject ConfigConfigurationAggregatorOrganizationAggregationSource'{..} = P.catMaybes
        [ TF.assign "all_regions" <$> TF.attribute _allRegions
        , TF.assign "regions" <$> TF.attribute _regions
        , TF.assign "role_arn" <$> TF.attribute _roleArn
        ]

instance TF.IsValid (ConfigConfigurationAggregatorOrganizationAggregationSource s) where
    validator = P.mempty

instance P.HasAllRegions (ConfigConfigurationAggregatorOrganizationAggregationSource s) (TF.Attr s P.Bool) where
    allRegions =
        P.lens (_allRegions :: ConfigConfigurationAggregatorOrganizationAggregationSource s -> TF.Attr s P.Bool)
               (\s a -> s { _allRegions = a } :: ConfigConfigurationAggregatorOrganizationAggregationSource s)

instance P.HasRegions (ConfigConfigurationAggregatorOrganizationAggregationSource s) (TF.Attr s (P.NonEmpty (TF.Attr s P.Text))) where
    regions =
        P.lens (_regions :: ConfigConfigurationAggregatorOrganizationAggregationSource s -> TF.Attr s (P.NonEmpty (TF.Attr s P.Text)))
               (\s a -> s { _regions = a } :: ConfigConfigurationAggregatorOrganizationAggregationSource s)

instance P.HasRoleArn (ConfigConfigurationAggregatorOrganizationAggregationSource s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: ConfigConfigurationAggregatorOrganizationAggregationSource s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: ConfigConfigurationAggregatorOrganizationAggregationSource s)

-- | @bucket_encryption@ nested settings.
data BucketEncryption s = BucketEncryption'
    { _sseKms :: TF.Attr s (EncryptionSseKms s)
    -- ^ @sse_kms@ - (Optional)
    --
    -- Conflicts with:
    --
    -- * 'sseS3'
    , _sseS3  :: TF.Attr s (EncryptionSseS3 s)
    -- ^ @sse_s3@ - (Optional)
    --
    -- Conflicts with:
    --
    -- * 'sseKms'
    } deriving (P.Show, P.Eq, P.Generic)

newBucketEncryption
    :: BucketEncryption s
newBucketEncryption =
    BucketEncryption'
        { _sseKms = TF.Nil
        , _sseS3 = TF.Nil
        }

instance P.Hashable  (BucketEncryption s)
instance TF.IsValue  (BucketEncryption s)
instance TF.IsObject (BucketEncryption s) where
    toObject BucketEncryption'{..} = P.catMaybes
        [ TF.assign "sse_kms" <$> TF.attribute _sseKms
        , TF.assign "sse_s3" <$> TF.attribute _sseS3
        ]

instance TF.IsValid (BucketEncryption s) where
    validator = TF.fieldsValidator (\BucketEncryption'{..} -> Map.fromList $ P.catMaybes
        [ if (_sseKms P.== TF.Nil)
              then P.Nothing
              else P.Just ("_sseKms",
                            [ "_sseS3"
                            ])
        , if (_sseS3 P.== TF.Nil)
              then P.Nothing
              else P.Just ("_sseS3",
                            [ "_sseKms"
                            ])
        ])
           P.<> TF.settingsValidator "_sseKms"
                  (_sseKms
                      :: BucketEncryption s -> TF.Attr s (EncryptionSseKms s))
                  TF.validator
           P.<> TF.settingsValidator "_sseS3"
                  (_sseS3
                      :: BucketEncryption s -> TF.Attr s (EncryptionSseS3 s))
                  TF.validator

instance P.HasSseKms (BucketEncryption s) (TF.Attr s (EncryptionSseKms s)) where
    sseKms =
        P.lens (_sseKms :: BucketEncryption s -> TF.Attr s (EncryptionSseKms s))
               (\s a -> s { _sseKms = a } :: BucketEncryption s)

instance P.HasSseS3 (BucketEncryption s) (TF.Attr s (EncryptionSseS3 s)) where
    sseS3 =
        P.lens (_sseS3 :: BucketEncryption s -> TF.Attr s (EncryptionSseS3 s))
               (\s a -> s { _sseS3 = a } :: BucketEncryption s)

-- | @waf_size_constraint_set_size_constraints@ nested settings.
data WafSizeConstraintSetSizeConstraints s = WafSizeConstraintSetSizeConstraints'
    { _comparisonOperator :: TF.Attr s P.Text
    -- ^ @comparison_operator@ - (Required)
    --
    , _fieldToMatch       :: TF.Attr s (SizeConstraintsFieldToMatch s)
    -- ^ @field_to_match@ - (Required)
    --
    , _size               :: TF.Attr s P.Integer
    -- ^ @size@ - (Required)
    --
    , _textTransformation :: TF.Attr s P.Text
    -- ^ @text_transformation@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafSizeConstraintSetSizeConstraints
    :: TF.Attr s P.Text -- ^ @comparison_operator@ - 'P.comparisonOperator'
    -> TF.Attr s (SizeConstraintsFieldToMatch s) -- ^ @field_to_match@ - 'P.fieldToMatch'
    -> TF.Attr s P.Integer -- ^ @size@ - 'P.size'
    -> TF.Attr s P.Text -- ^ @text_transformation@ - 'P.textTransformation'
    -> WafSizeConstraintSetSizeConstraints s
newWafSizeConstraintSetSizeConstraints _comparisonOperator _fieldToMatch _size _textTransformation =
    WafSizeConstraintSetSizeConstraints'
        { _comparisonOperator = _comparisonOperator
        , _fieldToMatch = _fieldToMatch
        , _size = _size
        , _textTransformation = _textTransformation
        }

instance P.Hashable  (WafSizeConstraintSetSizeConstraints s)
instance TF.IsValue  (WafSizeConstraintSetSizeConstraints s)
instance TF.IsObject (WafSizeConstraintSetSizeConstraints s) where
    toObject WafSizeConstraintSetSizeConstraints'{..} = P.catMaybes
        [ TF.assign "comparison_operator" <$> TF.attribute _comparisonOperator
        , TF.assign "field_to_match" <$> TF.attribute _fieldToMatch
        , TF.assign "size" <$> TF.attribute _size
        , TF.assign "text_transformation" <$> TF.attribute _textTransformation
        ]

instance TF.IsValid (WafSizeConstraintSetSizeConstraints s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_fieldToMatch"
                  (_fieldToMatch
                      :: WafSizeConstraintSetSizeConstraints s -> TF.Attr s (SizeConstraintsFieldToMatch s))
                  TF.validator

instance P.HasComparisonOperator (WafSizeConstraintSetSizeConstraints s) (TF.Attr s P.Text) where
    comparisonOperator =
        P.lens (_comparisonOperator :: WafSizeConstraintSetSizeConstraints s -> TF.Attr s P.Text)
               (\s a -> s { _comparisonOperator = a } :: WafSizeConstraintSetSizeConstraints s)

instance P.HasFieldToMatch (WafSizeConstraintSetSizeConstraints s) (TF.Attr s (SizeConstraintsFieldToMatch s)) where
    fieldToMatch =
        P.lens (_fieldToMatch :: WafSizeConstraintSetSizeConstraints s -> TF.Attr s (SizeConstraintsFieldToMatch s))
               (\s a -> s { _fieldToMatch = a } :: WafSizeConstraintSetSizeConstraints s)

instance P.HasSize (WafSizeConstraintSetSizeConstraints s) (TF.Attr s P.Integer) where
    size =
        P.lens (_size :: WafSizeConstraintSetSizeConstraints s -> TF.Attr s P.Integer)
               (\s a -> s { _size = a } :: WafSizeConstraintSetSizeConstraints s)

instance P.HasTextTransformation (WafSizeConstraintSetSizeConstraints s) (TF.Attr s P.Text) where
    textTransformation =
        P.lens (_textTransformation :: WafSizeConstraintSetSizeConstraints s -> TF.Attr s P.Text)
               (\s a -> s { _textTransformation = a } :: WafSizeConstraintSetSizeConstraints s)

-- | @cloudfront_distribution_origin@ nested settings.
data CloudfrontDistributionOrigin s = CloudfrontDistributionOrigin'
    { _customHeader       :: TF.Attr s [TF.Attr s (OriginCustomHeader s)]
    -- ^ @custom_header@ - (Optional)
    --
    , _customOriginConfig :: TF.Attr s (OriginCustomOriginConfig s)
    -- ^ @custom_origin_config@ - (Optional)
    --
    -- Conflicts with:
    --
    -- * 's3OriginConfig'
    , _domainName         :: TF.Attr s P.Text
    -- ^ @domain_name@ - (Required)
    --
    , _originId           :: TF.Attr s P.Text
    -- ^ @origin_id@ - (Required)
    --
    , _originPath         :: TF.Attr s P.Text
    -- ^ @origin_path@ - (Optional)
    --
    , _s3OriginConfig     :: TF.Attr s (OriginS3OriginConfig s)
    -- ^ @s3_origin_config@ - (Optional)
    --
    -- Conflicts with:
    --
    -- * 'customOriginConfig'
    } deriving (P.Show, P.Eq, P.Generic)

newCloudfrontDistributionOrigin
    :: TF.Attr s P.Text -- ^ @domain_name@ - 'P.domainName'
    -> TF.Attr s P.Text -- ^ @origin_id@ - 'P.originId'
    -> CloudfrontDistributionOrigin s
newCloudfrontDistributionOrigin _domainName _originId =
    CloudfrontDistributionOrigin'
        { _customHeader = TF.Nil
        , _customOriginConfig = TF.Nil
        , _domainName = _domainName
        , _originId = _originId
        , _originPath = TF.Nil
        , _s3OriginConfig = TF.Nil
        }

instance P.Hashable  (CloudfrontDistributionOrigin s)
instance TF.IsValue  (CloudfrontDistributionOrigin s)
instance TF.IsObject (CloudfrontDistributionOrigin s) where
    toObject CloudfrontDistributionOrigin'{..} = P.catMaybes
        [ TF.assign "custom_header" <$> TF.attribute _customHeader
        , TF.assign "custom_origin_config" <$> TF.attribute _customOriginConfig
        , TF.assign "domain_name" <$> TF.attribute _domainName
        , TF.assign "origin_id" <$> TF.attribute _originId
        , TF.assign "origin_path" <$> TF.attribute _originPath
        , TF.assign "s3_origin_config" <$> TF.attribute _s3OriginConfig
        ]

instance TF.IsValid (CloudfrontDistributionOrigin s) where
    validator = TF.fieldsValidator (\CloudfrontDistributionOrigin'{..} -> Map.fromList $ P.catMaybes
        [ if (_customOriginConfig P.== TF.Nil)
              then P.Nothing
              else P.Just ("_customOriginConfig",
                            [ "_s3OriginConfig"
                            ])
        , if (_s3OriginConfig P.== TF.Nil)
              then P.Nothing
              else P.Just ("_s3OriginConfig",
                            [ "_customOriginConfig"
                            ])
        ])
           P.<> TF.settingsValidator "_customHeader"
                  (_customHeader
                      :: CloudfrontDistributionOrigin s -> TF.Attr s [TF.Attr s (OriginCustomHeader s)])
                  TF.validator
           P.<> TF.settingsValidator "_customOriginConfig"
                  (_customOriginConfig
                      :: CloudfrontDistributionOrigin s -> TF.Attr s (OriginCustomOriginConfig s))
                  TF.validator
           P.<> TF.settingsValidator "_s3OriginConfig"
                  (_s3OriginConfig
                      :: CloudfrontDistributionOrigin s -> TF.Attr s (OriginS3OriginConfig s))
                  TF.validator

instance P.HasCustomHeader (CloudfrontDistributionOrigin s) (TF.Attr s [TF.Attr s (OriginCustomHeader s)]) where
    customHeader =
        P.lens (_customHeader :: CloudfrontDistributionOrigin s -> TF.Attr s [TF.Attr s (OriginCustomHeader s)])
               (\s a -> s { _customHeader = a } :: CloudfrontDistributionOrigin s)

instance P.HasCustomOriginConfig (CloudfrontDistributionOrigin s) (TF.Attr s (OriginCustomOriginConfig s)) where
    customOriginConfig =
        P.lens (_customOriginConfig :: CloudfrontDistributionOrigin s -> TF.Attr s (OriginCustomOriginConfig s))
               (\s a -> s { _customOriginConfig = a } :: CloudfrontDistributionOrigin s)

instance P.HasDomainName (CloudfrontDistributionOrigin s) (TF.Attr s P.Text) where
    domainName =
        P.lens (_domainName :: CloudfrontDistributionOrigin s -> TF.Attr s P.Text)
               (\s a -> s { _domainName = a } :: CloudfrontDistributionOrigin s)

instance P.HasOriginId (CloudfrontDistributionOrigin s) (TF.Attr s P.Text) where
    originId =
        P.lens (_originId :: CloudfrontDistributionOrigin s -> TF.Attr s P.Text)
               (\s a -> s { _originId = a } :: CloudfrontDistributionOrigin s)

instance P.HasOriginPath (CloudfrontDistributionOrigin s) (TF.Attr s P.Text) where
    originPath =
        P.lens (_originPath :: CloudfrontDistributionOrigin s -> TF.Attr s P.Text)
               (\s a -> s { _originPath = a } :: CloudfrontDistributionOrigin s)

instance P.HasS3OriginConfig (CloudfrontDistributionOrigin s) (TF.Attr s (OriginS3OriginConfig s)) where
    s3OriginConfig =
        P.lens (_s3OriginConfig :: CloudfrontDistributionOrigin s -> TF.Attr s (OriginS3OriginConfig s))
               (\s a -> s { _s3OriginConfig = a } :: CloudfrontDistributionOrigin s)

-- | @xss_match_tuple_field_to_match@ nested settings.
data XssMatchTupleFieldToMatch s = XssMatchTupleFieldToMatch'
    { _data' :: TF.Attr s P.Text
    -- ^ @data@ - (Optional)
    --
    , _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newXssMatchTupleFieldToMatch
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> XssMatchTupleFieldToMatch s
newXssMatchTupleFieldToMatch _type' =
    XssMatchTupleFieldToMatch'
        { _data' = TF.Nil
        , _type' = _type'
        }

instance P.Hashable  (XssMatchTupleFieldToMatch s)
instance TF.IsValue  (XssMatchTupleFieldToMatch s)
instance TF.IsObject (XssMatchTupleFieldToMatch s) where
    toObject XssMatchTupleFieldToMatch'{..} = P.catMaybes
        [ TF.assign "data" <$> TF.attribute _data'
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (XssMatchTupleFieldToMatch s) where
    validator = P.mempty

instance P.HasData' (XssMatchTupleFieldToMatch s) (TF.Attr s P.Text) where
    data' =
        P.lens (_data' :: XssMatchTupleFieldToMatch s -> TF.Attr s P.Text)
               (\s a -> s { _data' = a } :: XssMatchTupleFieldToMatch s)

instance P.HasType' (XssMatchTupleFieldToMatch s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: XssMatchTupleFieldToMatch s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: XssMatchTupleFieldToMatch s)

-- | @launch_specification_ephemeral_block_device@ nested settings.
data LaunchSpecificationEphemeralBlockDevice s = LaunchSpecificationEphemeralBlockDevice'
    { _deviceName  :: TF.Attr s P.Text
    -- ^ @device_name@ - (Required)
    --
    , _virtualName :: TF.Attr s P.Text
    -- ^ @virtual_name@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLaunchSpecificationEphemeralBlockDevice
    :: TF.Attr s P.Text -- ^ @device_name@ - 'P.deviceName'
    -> TF.Attr s P.Text -- ^ @virtual_name@ - 'P.virtualName'
    -> LaunchSpecificationEphemeralBlockDevice s
newLaunchSpecificationEphemeralBlockDevice _deviceName _virtualName =
    LaunchSpecificationEphemeralBlockDevice'
        { _deviceName = _deviceName
        , _virtualName = _virtualName
        }

instance P.Hashable  (LaunchSpecificationEphemeralBlockDevice s)
instance TF.IsValue  (LaunchSpecificationEphemeralBlockDevice s)
instance TF.IsObject (LaunchSpecificationEphemeralBlockDevice s) where
    toObject LaunchSpecificationEphemeralBlockDevice'{..} = P.catMaybes
        [ TF.assign "device_name" <$> TF.attribute _deviceName
        , TF.assign "virtual_name" <$> TF.attribute _virtualName
        ]

instance TF.IsValid (LaunchSpecificationEphemeralBlockDevice s) where
    validator = P.mempty

instance P.HasDeviceName (LaunchSpecificationEphemeralBlockDevice s) (TF.Attr s P.Text) where
    deviceName =
        P.lens (_deviceName :: LaunchSpecificationEphemeralBlockDevice s -> TF.Attr s P.Text)
               (\s a -> s { _deviceName = a } :: LaunchSpecificationEphemeralBlockDevice s)

instance P.HasVirtualName (LaunchSpecificationEphemeralBlockDevice s) (TF.Attr s P.Text) where
    virtualName =
        P.lens (_virtualName :: LaunchSpecificationEphemeralBlockDevice s -> TF.Attr s P.Text)
               (\s a -> s { _virtualName = a } :: LaunchSpecificationEphemeralBlockDevice s)

-- | @kinesis_firehose_delivery_stream_extended_s3_configuration@ nested settings.
data KinesisFirehoseDeliveryStreamExtendedS3Configuration s = KinesisFirehoseDeliveryStreamExtendedS3Configuration'
    { _bucketArn :: TF.Attr s P.Text
    -- ^ @bucket_arn@ - (Required)
    --
    , _bufferInterval :: TF.Attr s P.Integer
    -- ^ @buffer_interval@ - (Optional)
    --
    , _bufferSize :: TF.Attr s P.Integer
    -- ^ @buffer_size@ - (Optional)
    --
    , _compressionFormat :: TF.Attr s P.Text
    -- ^ @compression_format@ - (Optional)
    --
    , _dataFormatConversionConfiguration :: TF.Attr s (ExtendedS3ConfigurationDataFormatConversionConfiguration s)
    -- ^ @data_format_conversion_configuration@ - (Optional)
    --
    , _kmsKeyArn :: TF.Attr s P.Text
    -- ^ @kms_key_arn@ - (Optional)
    --
    , _prefix :: TF.Attr s P.Text
    -- ^ @prefix@ - (Optional)
    --
    , _processingConfiguration :: TF.Attr s (ExtendedS3ConfigurationProcessingConfiguration s)
    -- ^ @processing_configuration@ - (Optional)
    --
    , _roleArn :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Required)
    --
    , _s3BackupConfiguration :: TF.Attr s (ExtendedS3ConfigurationS3BackupConfiguration s)
    -- ^ @s3_backup_configuration@ - (Optional)
    --
    , _s3BackupMode :: TF.Attr s P.Text
    -- ^ @s3_backup_mode@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newKinesisFirehoseDeliveryStreamExtendedS3Configuration
    :: TF.Attr s P.Text -- ^ @bucket_arn@ - 'P.bucketArn'
    -> TF.Attr s P.Text -- ^ @role_arn@ - 'P.roleArn'
    -> KinesisFirehoseDeliveryStreamExtendedS3Configuration s
newKinesisFirehoseDeliveryStreamExtendedS3Configuration _bucketArn _roleArn =
    KinesisFirehoseDeliveryStreamExtendedS3Configuration'
        { _bucketArn = _bucketArn
        , _bufferInterval = TF.value 300
        , _bufferSize = TF.value 5
        , _compressionFormat = TF.value "UNCOMPRESSED"
        , _dataFormatConversionConfiguration = TF.Nil
        , _kmsKeyArn = TF.Nil
        , _prefix = TF.Nil
        , _processingConfiguration = TF.Nil
        , _roleArn = _roleArn
        , _s3BackupConfiguration = TF.Nil
        , _s3BackupMode = TF.value "Disabled"
        }

instance P.Hashable  (KinesisFirehoseDeliveryStreamExtendedS3Configuration s)
instance TF.IsValue  (KinesisFirehoseDeliveryStreamExtendedS3Configuration s)
instance TF.IsObject (KinesisFirehoseDeliveryStreamExtendedS3Configuration s) where
    toObject KinesisFirehoseDeliveryStreamExtendedS3Configuration'{..} = P.catMaybes
        [ TF.assign "bucket_arn" <$> TF.attribute _bucketArn
        , TF.assign "buffer_interval" <$> TF.attribute _bufferInterval
        , TF.assign "buffer_size" <$> TF.attribute _bufferSize
        , TF.assign "compression_format" <$> TF.attribute _compressionFormat
        , TF.assign "data_format_conversion_configuration" <$> TF.attribute _dataFormatConversionConfiguration
        , TF.assign "kms_key_arn" <$> TF.attribute _kmsKeyArn
        , TF.assign "prefix" <$> TF.attribute _prefix
        , TF.assign "processing_configuration" <$> TF.attribute _processingConfiguration
        , TF.assign "role_arn" <$> TF.attribute _roleArn
        , TF.assign "s3_backup_configuration" <$> TF.attribute _s3BackupConfiguration
        , TF.assign "s3_backup_mode" <$> TF.attribute _s3BackupMode
        ]

instance TF.IsValid (KinesisFirehoseDeliveryStreamExtendedS3Configuration s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_dataFormatConversionConfiguration"
                  (_dataFormatConversionConfiguration
                      :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s -> TF.Attr s (ExtendedS3ConfigurationDataFormatConversionConfiguration s))
                  TF.validator
           P.<> TF.settingsValidator "_processingConfiguration"
                  (_processingConfiguration
                      :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s -> TF.Attr s (ExtendedS3ConfigurationProcessingConfiguration s))
                  TF.validator
           P.<> TF.settingsValidator "_s3BackupConfiguration"
                  (_s3BackupConfiguration
                      :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s -> TF.Attr s (ExtendedS3ConfigurationS3BackupConfiguration s))
                  TF.validator

instance P.HasBucketArn (KinesisFirehoseDeliveryStreamExtendedS3Configuration s) (TF.Attr s P.Text) where
    bucketArn =
        P.lens (_bucketArn :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s -> TF.Attr s P.Text)
               (\s a -> s { _bucketArn = a } :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s)

instance P.HasBufferInterval (KinesisFirehoseDeliveryStreamExtendedS3Configuration s) (TF.Attr s P.Integer) where
    bufferInterval =
        P.lens (_bufferInterval :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s -> TF.Attr s P.Integer)
               (\s a -> s { _bufferInterval = a } :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s)

instance P.HasBufferSize (KinesisFirehoseDeliveryStreamExtendedS3Configuration s) (TF.Attr s P.Integer) where
    bufferSize =
        P.lens (_bufferSize :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s -> TF.Attr s P.Integer)
               (\s a -> s { _bufferSize = a } :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s)

instance P.HasCompressionFormat (KinesisFirehoseDeliveryStreamExtendedS3Configuration s) (TF.Attr s P.Text) where
    compressionFormat =
        P.lens (_compressionFormat :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s -> TF.Attr s P.Text)
               (\s a -> s { _compressionFormat = a } :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s)

instance P.HasDataFormatConversionConfiguration (KinesisFirehoseDeliveryStreamExtendedS3Configuration s) (TF.Attr s (ExtendedS3ConfigurationDataFormatConversionConfiguration s)) where
    dataFormatConversionConfiguration =
        P.lens (_dataFormatConversionConfiguration :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s -> TF.Attr s (ExtendedS3ConfigurationDataFormatConversionConfiguration s))
               (\s a -> s { _dataFormatConversionConfiguration = a } :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s)

instance P.HasKmsKeyArn (KinesisFirehoseDeliveryStreamExtendedS3Configuration s) (TF.Attr s P.Text) where
    kmsKeyArn =
        P.lens (_kmsKeyArn :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s -> TF.Attr s P.Text)
               (\s a -> s { _kmsKeyArn = a } :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s)

instance P.HasPrefix (KinesisFirehoseDeliveryStreamExtendedS3Configuration s) (TF.Attr s P.Text) where
    prefix =
        P.lens (_prefix :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s -> TF.Attr s P.Text)
               (\s a -> s { _prefix = a } :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s)

instance P.HasProcessingConfiguration (KinesisFirehoseDeliveryStreamExtendedS3Configuration s) (TF.Attr s (ExtendedS3ConfigurationProcessingConfiguration s)) where
    processingConfiguration =
        P.lens (_processingConfiguration :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s -> TF.Attr s (ExtendedS3ConfigurationProcessingConfiguration s))
               (\s a -> s { _processingConfiguration = a } :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s)

instance P.HasRoleArn (KinesisFirehoseDeliveryStreamExtendedS3Configuration s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s)

instance P.HasS3BackupConfiguration (KinesisFirehoseDeliveryStreamExtendedS3Configuration s) (TF.Attr s (ExtendedS3ConfigurationS3BackupConfiguration s)) where
    s3BackupConfiguration =
        P.lens (_s3BackupConfiguration :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s -> TF.Attr s (ExtendedS3ConfigurationS3BackupConfiguration s))
               (\s a -> s { _s3BackupConfiguration = a } :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s)

instance P.HasS3BackupMode (KinesisFirehoseDeliveryStreamExtendedS3Configuration s) (TF.Attr s P.Text) where
    s3BackupMode =
        P.lens (_s3BackupMode :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s -> TF.Attr s P.Text)
               (\s a -> s { _s3BackupMode = a } :: KinesisFirehoseDeliveryStreamExtendedS3Configuration s)

instance s ~ s' => P.HasComputedCloudwatchLoggingOptions (TF.Ref s' (KinesisFirehoseDeliveryStreamExtendedS3Configuration s)) (TF.Attr s (ExtendedS3ConfigurationCloudwatchLoggingOptions s)) where
    computedCloudwatchLoggingOptions x = TF.compute (TF.refKey x) "cloudwatch_logging_options"

-- | @secretsmanager_secret_rotation_rules@ nested settings.
data SecretsmanagerSecretRotationRules s = SecretsmanagerSecretRotationRules'
    { _automaticallyAfterDays :: TF.Attr s P.Integer
    -- ^ @automatically_after_days@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSecretsmanagerSecretRotationRules
    :: TF.Attr s P.Integer -- ^ @automatically_after_days@ - 'P.automaticallyAfterDays'
    -> SecretsmanagerSecretRotationRules s
newSecretsmanagerSecretRotationRules _automaticallyAfterDays =
    SecretsmanagerSecretRotationRules'
        { _automaticallyAfterDays = _automaticallyAfterDays
        }

instance P.Hashable  (SecretsmanagerSecretRotationRules s)
instance TF.IsValue  (SecretsmanagerSecretRotationRules s)
instance TF.IsObject (SecretsmanagerSecretRotationRules s) where
    toObject SecretsmanagerSecretRotationRules'{..} = P.catMaybes
        [ TF.assign "automatically_after_days" <$> TF.attribute _automaticallyAfterDays
        ]

instance TF.IsValid (SecretsmanagerSecretRotationRules s) where
    validator = P.mempty

instance P.HasAutomaticallyAfterDays (SecretsmanagerSecretRotationRules s) (TF.Attr s P.Integer) where
    automaticallyAfterDays =
        P.lens (_automaticallyAfterDays :: SecretsmanagerSecretRotationRules s -> TF.Attr s P.Integer)
               (\s a -> s { _automaticallyAfterDays = a } :: SecretsmanagerSecretRotationRules s)

instance s ~ s' => P.HasComputedAutomaticallyAfterDays (TF.Ref s' (SecretsmanagerSecretRotationRules s)) (TF.Attr s P.Integer) where
    computedAutomaticallyAfterDays x = TF.compute (TF.refKey x) "automatically_after_days"

-- | @load_balancer_policy_policy_attribute@ nested settings.
data LoadBalancerPolicyPolicyAttribute s = LoadBalancerPolicyPolicyAttribute'
    { _name  :: TF.Attr s P.Text
    -- ^ @name@ - (Optional)
    --
    , _value :: TF.Attr s P.Text
    -- ^ @value@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLoadBalancerPolicyPolicyAttribute
    :: LoadBalancerPolicyPolicyAttribute s
newLoadBalancerPolicyPolicyAttribute =
    LoadBalancerPolicyPolicyAttribute'
        { _name = TF.Nil
        , _value = TF.Nil
        }

instance P.Hashable  (LoadBalancerPolicyPolicyAttribute s)
instance TF.IsValue  (LoadBalancerPolicyPolicyAttribute s)
instance TF.IsObject (LoadBalancerPolicyPolicyAttribute s) where
    toObject LoadBalancerPolicyPolicyAttribute'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (LoadBalancerPolicyPolicyAttribute s) where
    validator = P.mempty

instance P.HasName (LoadBalancerPolicyPolicyAttribute s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: LoadBalancerPolicyPolicyAttribute s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: LoadBalancerPolicyPolicyAttribute s)

instance P.HasValue (LoadBalancerPolicyPolicyAttribute s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: LoadBalancerPolicyPolicyAttribute s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: LoadBalancerPolicyPolicyAttribute s)

-- | @api_gateway_stage_access_log_settings@ nested settings.
data ApiGatewayStageAccessLogSettings s = ApiGatewayStageAccessLogSettings'
    { _destinationArn :: TF.Attr s P.Text
    -- ^ @destination_arn@ - (Required)
    --
    , _format         :: TF.Attr s P.Text
    -- ^ @format@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newApiGatewayStageAccessLogSettings
    :: TF.Attr s P.Text -- ^ @destination_arn@ - 'P.destinationArn'
    -> TF.Attr s P.Text -- ^ @format@ - 'P.format'
    -> ApiGatewayStageAccessLogSettings s
newApiGatewayStageAccessLogSettings _destinationArn _format =
    ApiGatewayStageAccessLogSettings'
        { _destinationArn = _destinationArn
        , _format = _format
        }

instance P.Hashable  (ApiGatewayStageAccessLogSettings s)
instance TF.IsValue  (ApiGatewayStageAccessLogSettings s)
instance TF.IsObject (ApiGatewayStageAccessLogSettings s) where
    toObject ApiGatewayStageAccessLogSettings'{..} = P.catMaybes
        [ TF.assign "destination_arn" <$> TF.attribute _destinationArn
        , TF.assign "format" <$> TF.attribute _format
        ]

instance TF.IsValid (ApiGatewayStageAccessLogSettings s) where
    validator = P.mempty

instance P.HasDestinationArn (ApiGatewayStageAccessLogSettings s) (TF.Attr s P.Text) where
    destinationArn =
        P.lens (_destinationArn :: ApiGatewayStageAccessLogSettings s -> TF.Attr s P.Text)
               (\s a -> s { _destinationArn = a } :: ApiGatewayStageAccessLogSettings s)

instance P.HasFormat (ApiGatewayStageAccessLogSettings s) (TF.Attr s P.Text) where
    format =
        P.lens (_format :: ApiGatewayStageAccessLogSettings s -> TF.Attr s P.Text)
               (\s a -> s { _format = a } :: ApiGatewayStageAccessLogSettings s)

-- | @api_gateway_usage_plan_api_stages@ nested settings.
data ApiGatewayUsagePlanApiStages s = ApiGatewayUsagePlanApiStages'
    { _apiId :: TF.Attr s P.Text
    -- ^ @api_id@ - (Required)
    --
    , _stage :: TF.Attr s P.Text
    -- ^ @stage@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newApiGatewayUsagePlanApiStages
    :: TF.Attr s P.Text -- ^ @api_id@ - 'P.apiId'
    -> TF.Attr s P.Text -- ^ @stage@ - 'P.stage'
    -> ApiGatewayUsagePlanApiStages s
newApiGatewayUsagePlanApiStages _apiId _stage =
    ApiGatewayUsagePlanApiStages'
        { _apiId = _apiId
        , _stage = _stage
        }

instance P.Hashable  (ApiGatewayUsagePlanApiStages s)
instance TF.IsValue  (ApiGatewayUsagePlanApiStages s)
instance TF.IsObject (ApiGatewayUsagePlanApiStages s) where
    toObject ApiGatewayUsagePlanApiStages'{..} = P.catMaybes
        [ TF.assign "api_id" <$> TF.attribute _apiId
        , TF.assign "stage" <$> TF.attribute _stage
        ]

instance TF.IsValid (ApiGatewayUsagePlanApiStages s) where
    validator = P.mempty

instance P.HasApiId (ApiGatewayUsagePlanApiStages s) (TF.Attr s P.Text) where
    apiId =
        P.lens (_apiId :: ApiGatewayUsagePlanApiStages s -> TF.Attr s P.Text)
               (\s a -> s { _apiId = a } :: ApiGatewayUsagePlanApiStages s)

instance P.HasStage (ApiGatewayUsagePlanApiStages s) (TF.Attr s P.Text) where
    stage =
        P.lens (_stage :: ApiGatewayUsagePlanApiStages s -> TF.Attr s P.Text)
               (\s a -> s { _stage = a } :: ApiGatewayUsagePlanApiStages s)

-- | @kms_secrets_secret@ nested settings.
data KmsSecretsSecret s = KmsSecretsSecret'
    { _context     :: TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))
    -- ^ @context@ - (Optional)
    --
    , _grantTokens :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @grant_tokens@ - (Optional)
    --
    , _name        :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _payload     :: TF.Attr s P.Text
    -- ^ @payload@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newKmsSecretsSecret
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @payload@ - 'P.payload'
    -> KmsSecretsSecret s
newKmsSecretsSecret _name _payload =
    KmsSecretsSecret'
        { _context = TF.Nil
        , _grantTokens = TF.Nil
        , _name = _name
        , _payload = _payload
        }

instance P.Hashable  (KmsSecretsSecret s)
instance TF.IsValue  (KmsSecretsSecret s)
instance TF.IsObject (KmsSecretsSecret s) where
    toObject KmsSecretsSecret'{..} = P.catMaybes
        [ TF.assign "context" <$> TF.attribute _context
        , TF.assign "grant_tokens" <$> TF.attribute _grantTokens
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "payload" <$> TF.attribute _payload
        ]

instance TF.IsValid (KmsSecretsSecret s) where
    validator = P.mempty

instance P.HasContext (KmsSecretsSecret s) (TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))) where
    context =
        P.lens (_context :: KmsSecretsSecret s -> TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text)))
               (\s a -> s { _context = a } :: KmsSecretsSecret s)

instance P.HasGrantTokens (KmsSecretsSecret s) (TF.Attr s [TF.Attr s P.Text]) where
    grantTokens =
        P.lens (_grantTokens :: KmsSecretsSecret s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _grantTokens = a } :: KmsSecretsSecret s)

instance P.HasName (KmsSecretsSecret s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: KmsSecretsSecret s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: KmsSecretsSecret s)

instance P.HasPayload (KmsSecretsSecret s) (TF.Attr s P.Text) where
    payload =
        P.lens (_payload :: KmsSecretsSecret s -> TF.Attr s P.Text)
               (\s a -> s { _payload = a } :: KmsSecretsSecret s)

-- | @glue_trigger_actions@ nested settings.
data GlueTriggerActions s = GlueTriggerActions'
    { _arguments :: TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))
    -- ^ @arguments@ - (Optional)
    --
    , _jobName   :: TF.Attr s P.Text
    -- ^ @job_name@ - (Required)
    --
    , _timeout   :: TF.Attr s P.Integer
    -- ^ @timeout@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newGlueTriggerActions
    :: TF.Attr s P.Text -- ^ @job_name@ - 'P.jobName'
    -> GlueTriggerActions s
newGlueTriggerActions _jobName =
    GlueTriggerActions'
        { _arguments = TF.Nil
        , _jobName = _jobName
        , _timeout = TF.Nil
        }

instance P.Hashable  (GlueTriggerActions s)
instance TF.IsValue  (GlueTriggerActions s)
instance TF.IsObject (GlueTriggerActions s) where
    toObject GlueTriggerActions'{..} = P.catMaybes
        [ TF.assign "arguments" <$> TF.attribute _arguments
        , TF.assign "job_name" <$> TF.attribute _jobName
        , TF.assign "timeout" <$> TF.attribute _timeout
        ]

instance TF.IsValid (GlueTriggerActions s) where
    validator = P.mempty

instance P.HasArguments (GlueTriggerActions s) (TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))) where
    arguments =
        P.lens (_arguments :: GlueTriggerActions s -> TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text)))
               (\s a -> s { _arguments = a } :: GlueTriggerActions s)

instance P.HasJobName (GlueTriggerActions s) (TF.Attr s P.Text) where
    jobName =
        P.lens (_jobName :: GlueTriggerActions s -> TF.Attr s P.Text)
               (\s a -> s { _jobName = a } :: GlueTriggerActions s)

instance P.HasTimeout (GlueTriggerActions s) (TF.Attr s P.Integer) where
    timeout =
        P.lens (_timeout :: GlueTriggerActions s -> TF.Attr s P.Integer)
               (\s a -> s { _timeout = a } :: GlueTriggerActions s)

-- | @glue_job_execution_property@ nested settings.
data GlueJobExecutionProperty s = GlueJobExecutionProperty'
    { _maxConcurrentRuns :: TF.Attr s P.Integer
    -- ^ @max_concurrent_runs@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newGlueJobExecutionProperty
    :: GlueJobExecutionProperty s
newGlueJobExecutionProperty =
    GlueJobExecutionProperty'
        { _maxConcurrentRuns = TF.value 1
        }

instance P.Hashable  (GlueJobExecutionProperty s)
instance TF.IsValue  (GlueJobExecutionProperty s)
instance TF.IsObject (GlueJobExecutionProperty s) where
    toObject GlueJobExecutionProperty'{..} = P.catMaybes
        [ TF.assign "max_concurrent_runs" <$> TF.attribute _maxConcurrentRuns
        ]

instance TF.IsValid (GlueJobExecutionProperty s) where
    validator = P.mempty

instance P.HasMaxConcurrentRuns (GlueJobExecutionProperty s) (TF.Attr s P.Integer) where
    maxConcurrentRuns =
        P.lens (_maxConcurrentRuns :: GlueJobExecutionProperty s -> TF.Attr s P.Integer)
               (\s a -> s { _maxConcurrentRuns = a } :: GlueJobExecutionProperty s)

-- | @artifact_store_encryption_key@ nested settings.
data ArtifactStoreEncryptionKey s = ArtifactStoreEncryptionKey'
    { _id    :: TF.Attr s P.Text
    -- ^ @id@ - (Required)
    --
    , _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newArtifactStoreEncryptionKey
    :: TF.Attr s P.Text -- ^ @id@ - 'P.id'
    -> TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> ArtifactStoreEncryptionKey s
newArtifactStoreEncryptionKey _id _type' =
    ArtifactStoreEncryptionKey'
        { _id = _id
        , _type' = _type'
        }

instance P.Hashable  (ArtifactStoreEncryptionKey s)
instance TF.IsValue  (ArtifactStoreEncryptionKey s)
instance TF.IsObject (ArtifactStoreEncryptionKey s) where
    toObject ArtifactStoreEncryptionKey'{..} = P.catMaybes
        [ TF.assign "id" <$> TF.attribute _id
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (ArtifactStoreEncryptionKey s) where
    validator = P.mempty

instance P.HasId (ArtifactStoreEncryptionKey s) (TF.Attr s P.Text) where
    id =
        P.lens (_id :: ArtifactStoreEncryptionKey s -> TF.Attr s P.Text)
               (\s a -> s { _id = a } :: ArtifactStoreEncryptionKey s)

instance P.HasType' (ArtifactStoreEncryptionKey s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: ArtifactStoreEncryptionKey s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: ArtifactStoreEncryptionKey s)

-- | @route53_record_geolocation_routing_policy@ nested settings.
data Route53RecordGeolocationRoutingPolicy s = Route53RecordGeolocationRoutingPolicy'
    { _continent   :: TF.Attr s P.Text
    -- ^ @continent@ - (Optional)
    --
    , _country     :: TF.Attr s P.Text
    -- ^ @country@ - (Optional)
    --
    , _subdivision :: TF.Attr s P.Text
    -- ^ @subdivision@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRoute53RecordGeolocationRoutingPolicy
    :: Route53RecordGeolocationRoutingPolicy s
newRoute53RecordGeolocationRoutingPolicy =
    Route53RecordGeolocationRoutingPolicy'
        { _continent = TF.Nil
        , _country = TF.Nil
        , _subdivision = TF.Nil
        }

instance P.Hashable  (Route53RecordGeolocationRoutingPolicy s)
instance TF.IsValue  (Route53RecordGeolocationRoutingPolicy s)
instance TF.IsObject (Route53RecordGeolocationRoutingPolicy s) where
    toObject Route53RecordGeolocationRoutingPolicy'{..} = P.catMaybes
        [ TF.assign "continent" <$> TF.attribute _continent
        , TF.assign "country" <$> TF.attribute _country
        , TF.assign "subdivision" <$> TF.attribute _subdivision
        ]

instance TF.IsValid (Route53RecordGeolocationRoutingPolicy s) where
    validator = P.mempty

instance P.HasContinent (Route53RecordGeolocationRoutingPolicy s) (TF.Attr s P.Text) where
    continent =
        P.lens (_continent :: Route53RecordGeolocationRoutingPolicy s -> TF.Attr s P.Text)
               (\s a -> s { _continent = a } :: Route53RecordGeolocationRoutingPolicy s)

instance P.HasCountry (Route53RecordGeolocationRoutingPolicy s) (TF.Attr s P.Text) where
    country =
        P.lens (_country :: Route53RecordGeolocationRoutingPolicy s -> TF.Attr s P.Text)
               (\s a -> s { _country = a } :: Route53RecordGeolocationRoutingPolicy s)

instance P.HasSubdivision (Route53RecordGeolocationRoutingPolicy s) (TF.Attr s P.Text) where
    subdivision =
        P.lens (_subdivision :: Route53RecordGeolocationRoutingPolicy s -> TF.Attr s P.Text)
               (\s a -> s { _subdivision = a } :: Route53RecordGeolocationRoutingPolicy s)

-- | @cognito_user_pool_email_configuration@ nested settings.
data CognitoUserPoolEmailConfiguration s = CognitoUserPoolEmailConfiguration'
    { _replyToEmailAddress :: TF.Attr s P.Text
    -- ^ @reply_to_email_address@ - (Optional)
    --
    , _sourceArn           :: TF.Attr s P.Text
    -- ^ @source_arn@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCognitoUserPoolEmailConfiguration
    :: CognitoUserPoolEmailConfiguration s
newCognitoUserPoolEmailConfiguration =
    CognitoUserPoolEmailConfiguration'
        { _replyToEmailAddress = TF.Nil
        , _sourceArn = TF.Nil
        }

instance P.Hashable  (CognitoUserPoolEmailConfiguration s)
instance TF.IsValue  (CognitoUserPoolEmailConfiguration s)
instance TF.IsObject (CognitoUserPoolEmailConfiguration s) where
    toObject CognitoUserPoolEmailConfiguration'{..} = P.catMaybes
        [ TF.assign "reply_to_email_address" <$> TF.attribute _replyToEmailAddress
        , TF.assign "source_arn" <$> TF.attribute _sourceArn
        ]

instance TF.IsValid (CognitoUserPoolEmailConfiguration s) where
    validator = P.mempty

instance P.HasReplyToEmailAddress (CognitoUserPoolEmailConfiguration s) (TF.Attr s P.Text) where
    replyToEmailAddress =
        P.lens (_replyToEmailAddress :: CognitoUserPoolEmailConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _replyToEmailAddress = a } :: CognitoUserPoolEmailConfiguration s)

instance P.HasSourceArn (CognitoUserPoolEmailConfiguration s) (TF.Attr s P.Text) where
    sourceArn =
        P.lens (_sourceArn :: CognitoUserPoolEmailConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _sourceArn = a } :: CognitoUserPoolEmailConfiguration s)

-- | @cloudwatch_event_target_run_command_targets@ nested settings.
data CloudwatchEventTargetRunCommandTargets s = CloudwatchEventTargetRunCommandTargets'
    { _key    :: TF.Attr s P.Text
    -- ^ @key@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCloudwatchEventTargetRunCommandTargets
    :: TF.Attr s P.Text -- ^ @key@ - 'P.key'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> CloudwatchEventTargetRunCommandTargets s
newCloudwatchEventTargetRunCommandTargets _key _values =
    CloudwatchEventTargetRunCommandTargets'
        { _key = _key
        , _values = _values
        }

instance P.Hashable  (CloudwatchEventTargetRunCommandTargets s)
instance TF.IsValue  (CloudwatchEventTargetRunCommandTargets s)
instance TF.IsObject (CloudwatchEventTargetRunCommandTargets s) where
    toObject CloudwatchEventTargetRunCommandTargets'{..} = P.catMaybes
        [ TF.assign "key" <$> TF.attribute _key
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (CloudwatchEventTargetRunCommandTargets s) where
    validator = P.mempty

instance P.HasKey (CloudwatchEventTargetRunCommandTargets s) (TF.Attr s P.Text) where
    key =
        P.lens (_key :: CloudwatchEventTargetRunCommandTargets s -> TF.Attr s P.Text)
               (\s a -> s { _key = a } :: CloudwatchEventTargetRunCommandTargets s)

instance P.HasValues (CloudwatchEventTargetRunCommandTargets s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: CloudwatchEventTargetRunCommandTargets s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: CloudwatchEventTargetRunCommandTargets s)

-- | @predicate_conditions@ nested settings.
data PredicateConditions s = PredicateConditions'
    { _jobName         :: TF.Attr s P.Text
    -- ^ @job_name@ - (Required)
    --
    , _logicalOperator :: TF.Attr s P.Text
    -- ^ @logical_operator@ - (Optional)
    --
    , _state           :: TF.Attr s P.Text
    -- ^ @state@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newPredicateConditions
    :: TF.Attr s P.Text -- ^ @job_name@ - 'P.jobName'
    -> TF.Attr s P.Text -- ^ @state@ - 'P.state'
    -> PredicateConditions s
newPredicateConditions _jobName _state =
    PredicateConditions'
        { _jobName = _jobName
        , _logicalOperator = TF.value "EQUALS"
        , _state = _state
        }

instance P.Hashable  (PredicateConditions s)
instance TF.IsValue  (PredicateConditions s)
instance TF.IsObject (PredicateConditions s) where
    toObject PredicateConditions'{..} = P.catMaybes
        [ TF.assign "job_name" <$> TF.attribute _jobName
        , TF.assign "logical_operator" <$> TF.attribute _logicalOperator
        , TF.assign "state" <$> TF.attribute _state
        ]

instance TF.IsValid (PredicateConditions s) where
    validator = P.mempty

instance P.HasJobName (PredicateConditions s) (TF.Attr s P.Text) where
    jobName =
        P.lens (_jobName :: PredicateConditions s -> TF.Attr s P.Text)
               (\s a -> s { _jobName = a } :: PredicateConditions s)

instance P.HasLogicalOperator (PredicateConditions s) (TF.Attr s P.Text) where
    logicalOperator =
        P.lens (_logicalOperator :: PredicateConditions s -> TF.Attr s P.Text)
               (\s a -> s { _logicalOperator = a } :: PredicateConditions s)

instance P.HasState (PredicateConditions s) (TF.Attr s P.Text) where
    state =
        P.lens (_state :: PredicateConditions s -> TF.Attr s P.Text)
               (\s a -> s { _state = a } :: PredicateConditions s)

-- | @environment_environment_variable@ nested settings.
data EnvironmentEnvironmentVariable s = EnvironmentEnvironmentVariable'
    { _name  :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Optional)
    --
    , _value :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newEnvironmentEnvironmentVariable
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> EnvironmentEnvironmentVariable s
newEnvironmentEnvironmentVariable _name _value =
    EnvironmentEnvironmentVariable'
        { _name = _name
        , _type' = TF.value "PLAINTEXT"
        , _value = _value
        }

instance P.Hashable  (EnvironmentEnvironmentVariable s)
instance TF.IsValue  (EnvironmentEnvironmentVariable s)
instance TF.IsObject (EnvironmentEnvironmentVariable s) where
    toObject EnvironmentEnvironmentVariable'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "type" <$> TF.attribute _type'
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (EnvironmentEnvironmentVariable s) where
    validator = P.mempty

instance P.HasName (EnvironmentEnvironmentVariable s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: EnvironmentEnvironmentVariable s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: EnvironmentEnvironmentVariable s)

instance P.HasType' (EnvironmentEnvironmentVariable s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: EnvironmentEnvironmentVariable s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: EnvironmentEnvironmentVariable s)

instance P.HasValue (EnvironmentEnvironmentVariable s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: EnvironmentEnvironmentVariable s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: EnvironmentEnvironmentVariable s)

-- | @opsworks_nodejs_app_layer_ebs_volume@ nested settings.
data OpsworksNodejsAppLayerEbsVolume s = OpsworksNodejsAppLayerEbsVolume'
    { _iops          :: TF.Attr s P.Integer
    -- ^ @iops@ - (Optional)
    --
    , _mountPoint    :: TF.Attr s P.Text
    -- ^ @mount_point@ - (Required)
    --
    , _numberOfDisks :: TF.Attr s P.Integer
    -- ^ @number_of_disks@ - (Required)
    --
    , _raidLevel     :: TF.Attr s P.Text
    -- ^ @raid_level@ - (Optional)
    --
    , _size          :: TF.Attr s P.Integer
    -- ^ @size@ - (Required)
    --
    , _type'         :: TF.Attr s P.Text
    -- ^ @type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newOpsworksNodejsAppLayerEbsVolume
    :: TF.Attr s P.Text -- ^ @mount_point@ - 'P.mountPoint'
    -> TF.Attr s P.Integer -- ^ @number_of_disks@ - 'P.numberOfDisks'
    -> TF.Attr s P.Integer -- ^ @size@ - 'P.size'
    -> OpsworksNodejsAppLayerEbsVolume s
newOpsworksNodejsAppLayerEbsVolume _mountPoint _numberOfDisks _size =
    OpsworksNodejsAppLayerEbsVolume'
        { _iops = TF.value 0
        , _mountPoint = _mountPoint
        , _numberOfDisks = _numberOfDisks
        , _raidLevel = TF.Nil
        , _size = _size
        , _type' = TF.value "standard"
        }

instance P.Hashable  (OpsworksNodejsAppLayerEbsVolume s)
instance TF.IsValue  (OpsworksNodejsAppLayerEbsVolume s)
instance TF.IsObject (OpsworksNodejsAppLayerEbsVolume s) where
    toObject OpsworksNodejsAppLayerEbsVolume'{..} = P.catMaybes
        [ TF.assign "iops" <$> TF.attribute _iops
        , TF.assign "mount_point" <$> TF.attribute _mountPoint
        , TF.assign "number_of_disks" <$> TF.attribute _numberOfDisks
        , TF.assign "raid_level" <$> TF.attribute _raidLevel
        , TF.assign "size" <$> TF.attribute _size
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (OpsworksNodejsAppLayerEbsVolume s) where
    validator = P.mempty

instance P.HasIops (OpsworksNodejsAppLayerEbsVolume s) (TF.Attr s P.Integer) where
    iops =
        P.lens (_iops :: OpsworksNodejsAppLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _iops = a } :: OpsworksNodejsAppLayerEbsVolume s)

instance P.HasMountPoint (OpsworksNodejsAppLayerEbsVolume s) (TF.Attr s P.Text) where
    mountPoint =
        P.lens (_mountPoint :: OpsworksNodejsAppLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _mountPoint = a } :: OpsworksNodejsAppLayerEbsVolume s)

instance P.HasNumberOfDisks (OpsworksNodejsAppLayerEbsVolume s) (TF.Attr s P.Integer) where
    numberOfDisks =
        P.lens (_numberOfDisks :: OpsworksNodejsAppLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _numberOfDisks = a } :: OpsworksNodejsAppLayerEbsVolume s)

instance P.HasRaidLevel (OpsworksNodejsAppLayerEbsVolume s) (TF.Attr s P.Text) where
    raidLevel =
        P.lens (_raidLevel :: OpsworksNodejsAppLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _raidLevel = a } :: OpsworksNodejsAppLayerEbsVolume s)

instance P.HasSize (OpsworksNodejsAppLayerEbsVolume s) (TF.Attr s P.Integer) where
    size =
        P.lens (_size :: OpsworksNodejsAppLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _size = a } :: OpsworksNodejsAppLayerEbsVolume s)

instance P.HasType' (OpsworksNodejsAppLayerEbsVolume s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: OpsworksNodejsAppLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: OpsworksNodejsAppLayerEbsVolume s)

-- | @default_network_acl_egress@ nested settings.
data DefaultNetworkAclEgress s = DefaultNetworkAclEgress'
    { _action        :: TF.Attr s P.Text
    -- ^ @action@ - (Required)
    --
    , _cidrBlock     :: TF.Attr s P.Text
    -- ^ @cidr_block@ - (Optional)
    --
    , _fromPort      :: TF.Attr s P.Integer
    -- ^ @from_port@ - (Required)
    --
    , _icmpCode      :: TF.Attr s P.Integer
    -- ^ @icmp_code@ - (Optional)
    --
    , _icmpType      :: TF.Attr s P.Integer
    -- ^ @icmp_type@ - (Optional)
    --
    , _ipv6CidrBlock :: TF.Attr s P.Text
    -- ^ @ipv6_cidr_block@ - (Optional)
    --
    , _protocol      :: TF.Attr s P.Text
    -- ^ @protocol@ - (Required)
    --
    , _ruleNo        :: TF.Attr s P.Integer
    -- ^ @rule_no@ - (Required)
    --
    , _toPort        :: TF.Attr s P.Integer
    -- ^ @to_port@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDefaultNetworkAclEgress
    :: TF.Attr s P.Text -- ^ @action@ - 'P.action'
    -> TF.Attr s P.Integer -- ^ @from_port@ - 'P.fromPort'
    -> TF.Attr s P.Text -- ^ @protocol@ - 'P.protocol'
    -> TF.Attr s P.Integer -- ^ @rule_no@ - 'P.ruleNo'
    -> TF.Attr s P.Integer -- ^ @to_port@ - 'P.toPort'
    -> DefaultNetworkAclEgress s
newDefaultNetworkAclEgress _action _fromPort _protocol _ruleNo _toPort =
    DefaultNetworkAclEgress'
        { _action = _action
        , _cidrBlock = TF.Nil
        , _fromPort = _fromPort
        , _icmpCode = TF.Nil
        , _icmpType = TF.Nil
        , _ipv6CidrBlock = TF.Nil
        , _protocol = _protocol
        , _ruleNo = _ruleNo
        , _toPort = _toPort
        }

instance P.Hashable  (DefaultNetworkAclEgress s)
instance TF.IsValue  (DefaultNetworkAclEgress s)
instance TF.IsObject (DefaultNetworkAclEgress s) where
    toObject DefaultNetworkAclEgress'{..} = P.catMaybes
        [ TF.assign "action" <$> TF.attribute _action
        , TF.assign "cidr_block" <$> TF.attribute _cidrBlock
        , TF.assign "from_port" <$> TF.attribute _fromPort
        , TF.assign "icmp_code" <$> TF.attribute _icmpCode
        , TF.assign "icmp_type" <$> TF.attribute _icmpType
        , TF.assign "ipv6_cidr_block" <$> TF.attribute _ipv6CidrBlock
        , TF.assign "protocol" <$> TF.attribute _protocol
        , TF.assign "rule_no" <$> TF.attribute _ruleNo
        , TF.assign "to_port" <$> TF.attribute _toPort
        ]

instance TF.IsValid (DefaultNetworkAclEgress s) where
    validator = P.mempty

instance P.HasAction (DefaultNetworkAclEgress s) (TF.Attr s P.Text) where
    action =
        P.lens (_action :: DefaultNetworkAclEgress s -> TF.Attr s P.Text)
               (\s a -> s { _action = a } :: DefaultNetworkAclEgress s)

instance P.HasCidrBlock (DefaultNetworkAclEgress s) (TF.Attr s P.Text) where
    cidrBlock =
        P.lens (_cidrBlock :: DefaultNetworkAclEgress s -> TF.Attr s P.Text)
               (\s a -> s { _cidrBlock = a } :: DefaultNetworkAclEgress s)

instance P.HasFromPort (DefaultNetworkAclEgress s) (TF.Attr s P.Integer) where
    fromPort =
        P.lens (_fromPort :: DefaultNetworkAclEgress s -> TF.Attr s P.Integer)
               (\s a -> s { _fromPort = a } :: DefaultNetworkAclEgress s)

instance P.HasIcmpCode (DefaultNetworkAclEgress s) (TF.Attr s P.Integer) where
    icmpCode =
        P.lens (_icmpCode :: DefaultNetworkAclEgress s -> TF.Attr s P.Integer)
               (\s a -> s { _icmpCode = a } :: DefaultNetworkAclEgress s)

instance P.HasIcmpType (DefaultNetworkAclEgress s) (TF.Attr s P.Integer) where
    icmpType =
        P.lens (_icmpType :: DefaultNetworkAclEgress s -> TF.Attr s P.Integer)
               (\s a -> s { _icmpType = a } :: DefaultNetworkAclEgress s)

instance P.HasIpv6CidrBlock (DefaultNetworkAclEgress s) (TF.Attr s P.Text) where
    ipv6CidrBlock =
        P.lens (_ipv6CidrBlock :: DefaultNetworkAclEgress s -> TF.Attr s P.Text)
               (\s a -> s { _ipv6CidrBlock = a } :: DefaultNetworkAclEgress s)

instance P.HasProtocol (DefaultNetworkAclEgress s) (TF.Attr s P.Text) where
    protocol =
        P.lens (_protocol :: DefaultNetworkAclEgress s -> TF.Attr s P.Text)
               (\s a -> s { _protocol = a } :: DefaultNetworkAclEgress s)

instance P.HasRuleNo (DefaultNetworkAclEgress s) (TF.Attr s P.Integer) where
    ruleNo =
        P.lens (_ruleNo :: DefaultNetworkAclEgress s -> TF.Attr s P.Integer)
               (\s a -> s { _ruleNo = a } :: DefaultNetworkAclEgress s)

instance P.HasToPort (DefaultNetworkAclEgress s) (TF.Attr s P.Integer) where
    toPort =
        P.lens (_toPort :: DefaultNetworkAclEgress s -> TF.Attr s P.Integer)
               (\s a -> s { _toPort = a } :: DefaultNetworkAclEgress s)

-- | @acmpca_certificate_authority_revocation_configuration@ nested settings.
data AcmpcaCertificateAuthorityRevocationConfiguration s = AcmpcaCertificateAuthorityRevocationConfiguration'
    { _crlConfiguration :: TF.Attr s (RevocationConfigurationCrlConfiguration s)
    -- ^ @crl_configuration@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAcmpcaCertificateAuthorityRevocationConfiguration
    :: AcmpcaCertificateAuthorityRevocationConfiguration s
newAcmpcaCertificateAuthorityRevocationConfiguration =
    AcmpcaCertificateAuthorityRevocationConfiguration'
        { _crlConfiguration = TF.Nil
        }

instance P.Hashable  (AcmpcaCertificateAuthorityRevocationConfiguration s)
instance TF.IsValue  (AcmpcaCertificateAuthorityRevocationConfiguration s)
instance TF.IsObject (AcmpcaCertificateAuthorityRevocationConfiguration s) where
    toObject AcmpcaCertificateAuthorityRevocationConfiguration'{..} = P.catMaybes
        [ TF.assign "crl_configuration" <$> TF.attribute _crlConfiguration
        ]

instance TF.IsValid (AcmpcaCertificateAuthorityRevocationConfiguration s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_crlConfiguration"
                  (_crlConfiguration
                      :: AcmpcaCertificateAuthorityRevocationConfiguration s -> TF.Attr s (RevocationConfigurationCrlConfiguration s))
                  TF.validator

instance P.HasCrlConfiguration (AcmpcaCertificateAuthorityRevocationConfiguration s) (TF.Attr s (RevocationConfigurationCrlConfiguration s)) where
    crlConfiguration =
        P.lens (_crlConfiguration :: AcmpcaCertificateAuthorityRevocationConfiguration s -> TF.Attr s (RevocationConfigurationCrlConfiguration s))
               (\s a -> s { _crlConfiguration = a } :: AcmpcaCertificateAuthorityRevocationConfiguration s)

instance s ~ s' => P.HasComputedCrlConfiguration (TF.Ref s' (AcmpcaCertificateAuthorityRevocationConfiguration s)) (TF.Attr s [TF.Attr s (RevocationConfigurationCrlConfiguration s)]) where
    computedCrlConfiguration x = TF.compute (TF.refKey x) "crl_configuration"

-- | @waf_xss_match_set_xss_match_tuples@ nested settings.
data WafXssMatchSetXssMatchTuples s = WafXssMatchSetXssMatchTuples'
    { _fieldToMatch       :: TF.Attr s (XssMatchTuplesFieldToMatch s)
    -- ^ @field_to_match@ - (Required)
    --
    , _textTransformation :: TF.Attr s P.Text
    -- ^ @text_transformation@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafXssMatchSetXssMatchTuples
    :: TF.Attr s (XssMatchTuplesFieldToMatch s) -- ^ @field_to_match@ - 'P.fieldToMatch'
    -> TF.Attr s P.Text -- ^ @text_transformation@ - 'P.textTransformation'
    -> WafXssMatchSetXssMatchTuples s
newWafXssMatchSetXssMatchTuples _fieldToMatch _textTransformation =
    WafXssMatchSetXssMatchTuples'
        { _fieldToMatch = _fieldToMatch
        , _textTransformation = _textTransformation
        }

instance P.Hashable  (WafXssMatchSetXssMatchTuples s)
instance TF.IsValue  (WafXssMatchSetXssMatchTuples s)
instance TF.IsObject (WafXssMatchSetXssMatchTuples s) where
    toObject WafXssMatchSetXssMatchTuples'{..} = P.catMaybes
        [ TF.assign "field_to_match" <$> TF.attribute _fieldToMatch
        , TF.assign "text_transformation" <$> TF.attribute _textTransformation
        ]

instance TF.IsValid (WafXssMatchSetXssMatchTuples s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_fieldToMatch"
                  (_fieldToMatch
                      :: WafXssMatchSetXssMatchTuples s -> TF.Attr s (XssMatchTuplesFieldToMatch s))
                  TF.validator

instance P.HasFieldToMatch (WafXssMatchSetXssMatchTuples s) (TF.Attr s (XssMatchTuplesFieldToMatch s)) where
    fieldToMatch =
        P.lens (_fieldToMatch :: WafXssMatchSetXssMatchTuples s -> TF.Attr s (XssMatchTuplesFieldToMatch s))
               (\s a -> s { _fieldToMatch = a } :: WafXssMatchSetXssMatchTuples s)

instance P.HasTextTransformation (WafXssMatchSetXssMatchTuples s) (TF.Attr s P.Text) where
    textTransformation =
        P.lens (_textTransformation :: WafXssMatchSetXssMatchTuples s -> TF.Attr s P.Text)
               (\s a -> s { _textTransformation = a } :: WafXssMatchSetXssMatchTuples s)

-- | @replication_configuration_rules@ nested settings.
data ReplicationConfigurationRules s = ReplicationConfigurationRules'
    { _destination             :: TF.Attr s (RulesDestination s)
    -- ^ @destination@ - (Required)
    --
    , _id                      :: TF.Attr s P.Text
    -- ^ @id@ - (Optional)
    --
    , _prefix                  :: TF.Attr s P.Text
    -- ^ @prefix@ - (Required)
    --
    , _sourceSelectionCriteria :: TF.Attr s (RulesSourceSelectionCriteria s)
    -- ^ @source_selection_criteria@ - (Optional)
    --
    , _status                  :: TF.Attr s P.Text
    -- ^ @status@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newReplicationConfigurationRules
    :: TF.Attr s (RulesDestination s) -- ^ @destination@ - 'P.destination'
    -> TF.Attr s P.Text -- ^ @prefix@ - 'P.prefix'
    -> TF.Attr s P.Text -- ^ @status@ - 'P.status'
    -> ReplicationConfigurationRules s
newReplicationConfigurationRules _destination _prefix _status =
    ReplicationConfigurationRules'
        { _destination = _destination
        , _id = TF.Nil
        , _prefix = _prefix
        , _sourceSelectionCriteria = TF.Nil
        , _status = _status
        }

instance P.Hashable  (ReplicationConfigurationRules s)
instance TF.IsValue  (ReplicationConfigurationRules s)
instance TF.IsObject (ReplicationConfigurationRules s) where
    toObject ReplicationConfigurationRules'{..} = P.catMaybes
        [ TF.assign "destination" <$> TF.attribute _destination
        , TF.assign "id" <$> TF.attribute _id
        , TF.assign "prefix" <$> TF.attribute _prefix
        , TF.assign "source_selection_criteria" <$> TF.attribute _sourceSelectionCriteria
        , TF.assign "status" <$> TF.attribute _status
        ]

instance TF.IsValid (ReplicationConfigurationRules s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_destination"
                  (_destination
                      :: ReplicationConfigurationRules s -> TF.Attr s (RulesDestination s))
                  TF.validator
           P.<> TF.settingsValidator "_sourceSelectionCriteria"
                  (_sourceSelectionCriteria
                      :: ReplicationConfigurationRules s -> TF.Attr s (RulesSourceSelectionCriteria s))
                  TF.validator

instance P.HasDestination (ReplicationConfigurationRules s) (TF.Attr s (RulesDestination s)) where
    destination =
        P.lens (_destination :: ReplicationConfigurationRules s -> TF.Attr s (RulesDestination s))
               (\s a -> s { _destination = a } :: ReplicationConfigurationRules s)

instance P.HasId (ReplicationConfigurationRules s) (TF.Attr s P.Text) where
    id =
        P.lens (_id :: ReplicationConfigurationRules s -> TF.Attr s P.Text)
               (\s a -> s { _id = a } :: ReplicationConfigurationRules s)

instance P.HasPrefix (ReplicationConfigurationRules s) (TF.Attr s P.Text) where
    prefix =
        P.lens (_prefix :: ReplicationConfigurationRules s -> TF.Attr s P.Text)
               (\s a -> s { _prefix = a } :: ReplicationConfigurationRules s)

instance P.HasSourceSelectionCriteria (ReplicationConfigurationRules s) (TF.Attr s (RulesSourceSelectionCriteria s)) where
    sourceSelectionCriteria =
        P.lens (_sourceSelectionCriteria :: ReplicationConfigurationRules s -> TF.Attr s (RulesSourceSelectionCriteria s))
               (\s a -> s { _sourceSelectionCriteria = a } :: ReplicationConfigurationRules s)

instance P.HasStatus (ReplicationConfigurationRules s) (TF.Attr s P.Text) where
    status =
        P.lens (_status :: ReplicationConfigurationRules s -> TF.Attr s P.Text)
               (\s a -> s { _status = a } :: ReplicationConfigurationRules s)

-- | @appsync_datasource_lambda_config@ nested settings.
data AppsyncDatasourceLambdaConfig s = AppsyncDatasourceLambdaConfig'
    { _functionArn :: TF.Attr s P.Text
    -- ^ @function_arn@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAppsyncDatasourceLambdaConfig
    :: TF.Attr s P.Text -- ^ @function_arn@ - 'P.functionArn'
    -> AppsyncDatasourceLambdaConfig s
newAppsyncDatasourceLambdaConfig _functionArn =
    AppsyncDatasourceLambdaConfig'
        { _functionArn = _functionArn
        }

instance P.Hashable  (AppsyncDatasourceLambdaConfig s)
instance TF.IsValue  (AppsyncDatasourceLambdaConfig s)
instance TF.IsObject (AppsyncDatasourceLambdaConfig s) where
    toObject AppsyncDatasourceLambdaConfig'{..} = P.catMaybes
        [ TF.assign "function_arn" <$> TF.attribute _functionArn
        ]

instance TF.IsValid (AppsyncDatasourceLambdaConfig s) where
    validator = P.mempty

instance P.HasFunctionArn (AppsyncDatasourceLambdaConfig s) (TF.Attr s P.Text) where
    functionArn =
        P.lens (_functionArn :: AppsyncDatasourceLambdaConfig s -> TF.Attr s P.Text)
               (\s a -> s { _functionArn = a } :: AppsyncDatasourceLambdaConfig s)

-- | @dynamodb_table_server_side_encryption@ nested settings.
data DynamodbTableServerSideEncryption s = DynamodbTableServerSideEncryption'
    { _enabled :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDynamodbTableServerSideEncryption
    :: TF.Attr s P.Bool -- ^ @enabled@ - 'P.enabled'
    -> DynamodbTableServerSideEncryption s
newDynamodbTableServerSideEncryption _enabled =
    DynamodbTableServerSideEncryption'
        { _enabled = _enabled
        }

instance P.Hashable  (DynamodbTableServerSideEncryption s)
instance TF.IsValue  (DynamodbTableServerSideEncryption s)
instance TF.IsObject (DynamodbTableServerSideEncryption s) where
    toObject DynamodbTableServerSideEncryption'{..} = P.catMaybes
        [ TF.assign "enabled" <$> TF.attribute _enabled
        ]

instance TF.IsValid (DynamodbTableServerSideEncryption s) where
    validator = P.mempty

instance P.HasEnabled (DynamodbTableServerSideEncryption s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: DynamodbTableServerSideEncryption s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: DynamodbTableServerSideEncryption s)

instance s ~ s' => P.HasComputedEnabled (TF.Ref s' (DynamodbTableServerSideEncryption s)) (TF.Attr s P.Bool) where
    computedEnabled x = TF.compute (TF.refKey x) "enabled"

-- | @ses_receipt_rule_bounce_action@ nested settings.
data SesReceiptRuleBounceAction s = SesReceiptRuleBounceAction'
    { _message       :: TF.Attr s P.Text
    -- ^ @message@ - (Required)
    --
    , _position      :: TF.Attr s P.Integer
    -- ^ @position@ - (Required)
    --
    , _sender        :: TF.Attr s P.Text
    -- ^ @sender@ - (Required)
    --
    , _smtpReplyCode :: TF.Attr s P.Text
    -- ^ @smtp_reply_code@ - (Required)
    --
    , _statusCode    :: TF.Attr s P.Text
    -- ^ @status_code@ - (Optional)
    --
    , _topicArn      :: TF.Attr s P.Text
    -- ^ @topic_arn@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSesReceiptRuleBounceAction
    :: TF.Attr s P.Text -- ^ @message@ - 'P.message'
    -> TF.Attr s P.Integer -- ^ @position@ - 'P.position'
    -> TF.Attr s P.Text -- ^ @sender@ - 'P.sender'
    -> TF.Attr s P.Text -- ^ @smtp_reply_code@ - 'P.smtpReplyCode'
    -> SesReceiptRuleBounceAction s
newSesReceiptRuleBounceAction _message _position _sender _smtpReplyCode =
    SesReceiptRuleBounceAction'
        { _message = _message
        , _position = _position
        , _sender = _sender
        , _smtpReplyCode = _smtpReplyCode
        , _statusCode = TF.Nil
        , _topicArn = TF.Nil
        }

instance P.Hashable  (SesReceiptRuleBounceAction s)
instance TF.IsValue  (SesReceiptRuleBounceAction s)
instance TF.IsObject (SesReceiptRuleBounceAction s) where
    toObject SesReceiptRuleBounceAction'{..} = P.catMaybes
        [ TF.assign "message" <$> TF.attribute _message
        , TF.assign "position" <$> TF.attribute _position
        , TF.assign "sender" <$> TF.attribute _sender
        , TF.assign "smtp_reply_code" <$> TF.attribute _smtpReplyCode
        , TF.assign "status_code" <$> TF.attribute _statusCode
        , TF.assign "topic_arn" <$> TF.attribute _topicArn
        ]

instance TF.IsValid (SesReceiptRuleBounceAction s) where
    validator = P.mempty

instance P.HasMessage (SesReceiptRuleBounceAction s) (TF.Attr s P.Text) where
    message =
        P.lens (_message :: SesReceiptRuleBounceAction s -> TF.Attr s P.Text)
               (\s a -> s { _message = a } :: SesReceiptRuleBounceAction s)

instance P.HasPosition (SesReceiptRuleBounceAction s) (TF.Attr s P.Integer) where
    position =
        P.lens (_position :: SesReceiptRuleBounceAction s -> TF.Attr s P.Integer)
               (\s a -> s { _position = a } :: SesReceiptRuleBounceAction s)

instance P.HasSender (SesReceiptRuleBounceAction s) (TF.Attr s P.Text) where
    sender =
        P.lens (_sender :: SesReceiptRuleBounceAction s -> TF.Attr s P.Text)
               (\s a -> s { _sender = a } :: SesReceiptRuleBounceAction s)

instance P.HasSmtpReplyCode (SesReceiptRuleBounceAction s) (TF.Attr s P.Text) where
    smtpReplyCode =
        P.lens (_smtpReplyCode :: SesReceiptRuleBounceAction s -> TF.Attr s P.Text)
               (\s a -> s { _smtpReplyCode = a } :: SesReceiptRuleBounceAction s)

instance P.HasStatusCode (SesReceiptRuleBounceAction s) (TF.Attr s P.Text) where
    statusCode =
        P.lens (_statusCode :: SesReceiptRuleBounceAction s -> TF.Attr s P.Text)
               (\s a -> s { _statusCode = a } :: SesReceiptRuleBounceAction s)

instance P.HasTopicArn (SesReceiptRuleBounceAction s) (TF.Attr s P.Text) where
    topicArn =
        P.lens (_topicArn :: SesReceiptRuleBounceAction s -> TF.Attr s P.Text)
               (\s a -> s { _topicArn = a } :: SesReceiptRuleBounceAction s)

-- | @target_tracking_configuration_customized_metric_specification@ nested settings.
data TargetTrackingConfigurationCustomizedMetricSpecification s = TargetTrackingConfigurationCustomizedMetricSpecification'
    { _metricDimension :: TF.Attr s [TF.Attr s (CustomizedMetricSpecificationMetricDimension s)]
    -- ^ @metric_dimension@ - (Optional)
    --
    , _metricName :: TF.Attr s P.Text
    -- ^ @metric_name@ - (Required)
    --
    , _namespace :: TF.Attr s P.Text
    -- ^ @namespace@ - (Required)
    --
    , _statistic :: TF.Attr s P.Text
    -- ^ @statistic@ - (Required)
    --
    , _unit :: TF.Attr s P.Text
    -- ^ @unit@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newTargetTrackingConfigurationCustomizedMetricSpecification
    :: TF.Attr s P.Text -- ^ @metric_name@ - 'P.metricName'
    -> TF.Attr s P.Text -- ^ @namespace@ - 'P.namespace'
    -> TF.Attr s P.Text -- ^ @statistic@ - 'P.statistic'
    -> TargetTrackingConfigurationCustomizedMetricSpecification s
newTargetTrackingConfigurationCustomizedMetricSpecification _metricName _namespace _statistic =
    TargetTrackingConfigurationCustomizedMetricSpecification'
        { _metricDimension = TF.Nil
        , _metricName = _metricName
        , _namespace = _namespace
        , _statistic = _statistic
        , _unit = TF.Nil
        }

instance P.Hashable  (TargetTrackingConfigurationCustomizedMetricSpecification s)
instance TF.IsValue  (TargetTrackingConfigurationCustomizedMetricSpecification s)
instance TF.IsObject (TargetTrackingConfigurationCustomizedMetricSpecification s) where
    toObject TargetTrackingConfigurationCustomizedMetricSpecification'{..} = P.catMaybes
        [ TF.assign "metric_dimension" <$> TF.attribute _metricDimension
        , TF.assign "metric_name" <$> TF.attribute _metricName
        , TF.assign "namespace" <$> TF.attribute _namespace
        , TF.assign "statistic" <$> TF.attribute _statistic
        , TF.assign "unit" <$> TF.attribute _unit
        ]

instance TF.IsValid (TargetTrackingConfigurationCustomizedMetricSpecification s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_metricDimension"
                  (_metricDimension
                      :: TargetTrackingConfigurationCustomizedMetricSpecification s -> TF.Attr s [TF.Attr s (CustomizedMetricSpecificationMetricDimension s)])
                  TF.validator

instance P.HasMetricDimension (TargetTrackingConfigurationCustomizedMetricSpecification s) (TF.Attr s [TF.Attr s (CustomizedMetricSpecificationMetricDimension s)]) where
    metricDimension =
        P.lens (_metricDimension :: TargetTrackingConfigurationCustomizedMetricSpecification s -> TF.Attr s [TF.Attr s (CustomizedMetricSpecificationMetricDimension s)])
               (\s a -> s { _metricDimension = a } :: TargetTrackingConfigurationCustomizedMetricSpecification s)

instance P.HasMetricName (TargetTrackingConfigurationCustomizedMetricSpecification s) (TF.Attr s P.Text) where
    metricName =
        P.lens (_metricName :: TargetTrackingConfigurationCustomizedMetricSpecification s -> TF.Attr s P.Text)
               (\s a -> s { _metricName = a } :: TargetTrackingConfigurationCustomizedMetricSpecification s)

instance P.HasNamespace (TargetTrackingConfigurationCustomizedMetricSpecification s) (TF.Attr s P.Text) where
    namespace =
        P.lens (_namespace :: TargetTrackingConfigurationCustomizedMetricSpecification s -> TF.Attr s P.Text)
               (\s a -> s { _namespace = a } :: TargetTrackingConfigurationCustomizedMetricSpecification s)

instance P.HasStatistic (TargetTrackingConfigurationCustomizedMetricSpecification s) (TF.Attr s P.Text) where
    statistic =
        P.lens (_statistic :: TargetTrackingConfigurationCustomizedMetricSpecification s -> TF.Attr s P.Text)
               (\s a -> s { _statistic = a } :: TargetTrackingConfigurationCustomizedMetricSpecification s)

instance P.HasUnit (TargetTrackingConfigurationCustomizedMetricSpecification s) (TF.Attr s P.Text) where
    unit =
        P.lens (_unit :: TargetTrackingConfigurationCustomizedMetricSpecification s -> TF.Attr s P.Text)
               (\s a -> s { _unit = a } :: TargetTrackingConfigurationCustomizedMetricSpecification s)

-- | @acm_certificate_domain_validation_options@ nested settings.
data AcmCertificateDomainValidationOptions s = AcmCertificateDomainValidationOptions'
    deriving (P.Show, P.Eq, P.Generic)

newAcmCertificateDomainValidationOptions
    :: AcmCertificateDomainValidationOptions s
newAcmCertificateDomainValidationOptions =
    AcmCertificateDomainValidationOptions'

instance P.Hashable  (AcmCertificateDomainValidationOptions s)
instance TF.IsValue  (AcmCertificateDomainValidationOptions s)
instance TF.IsObject (AcmCertificateDomainValidationOptions s) where
    toObject AcmCertificateDomainValidationOptions' = []

instance TF.IsValid (AcmCertificateDomainValidationOptions s) where
    validator = P.mempty

instance s ~ s' => P.HasComputedDomainName (TF.Ref s' (AcmCertificateDomainValidationOptions s)) (TF.Attr s P.Text) where
    computedDomainName x = TF.compute (TF.refKey x) "domain_name"

instance s ~ s' => P.HasComputedResourceRecordName (TF.Ref s' (AcmCertificateDomainValidationOptions s)) (TF.Attr s P.Text) where
    computedResourceRecordName x = TF.compute (TF.refKey x) "resource_record_name"

instance s ~ s' => P.HasComputedResourceRecordType (TF.Ref s' (AcmCertificateDomainValidationOptions s)) (TF.Attr s P.Text) where
    computedResourceRecordType x = TF.compute (TF.refKey x) "resource_record_type"

instance s ~ s' => P.HasComputedResourceRecordValue (TF.Ref s' (AcmCertificateDomainValidationOptions s)) (TF.Attr s P.Text) where
    computedResourceRecordValue x = TF.compute (TF.refKey x) "resource_record_value"

-- | @internet_gateway_attachments@ nested settings.
data InternetGatewayAttachments s = InternetGatewayAttachments'
    deriving (P.Show, P.Eq, P.Generic)

newInternetGatewayAttachments
    :: InternetGatewayAttachments s
newInternetGatewayAttachments =
    InternetGatewayAttachments'

instance P.Hashable  (InternetGatewayAttachments s)
instance TF.IsValue  (InternetGatewayAttachments s)
instance TF.IsObject (InternetGatewayAttachments s) where
    toObject InternetGatewayAttachments' = []

instance TF.IsValid (InternetGatewayAttachments s) where
    validator = P.mempty

instance s ~ s' => P.HasComputedState (TF.Ref s' (InternetGatewayAttachments s)) (TF.Attr s P.Text) where
    computedState x = TF.compute (TF.refKey x) "state"

instance s ~ s' => P.HasComputedVpcId (TF.Ref s' (InternetGatewayAttachments s)) (TF.Attr s P.Text) where
    computedVpcId x = TF.compute (TF.refKey x) "vpc_id"

-- | @dms_endpoint_mongodb_settings@ nested settings.
data DmsEndpointMongodbSettings s = DmsEndpointMongodbSettings'
    { _authMechanism     :: TF.Attr s P.Text
    -- ^ @auth_mechanism@ - (Optional)
    --
    , _authSource        :: TF.Attr s P.Text
    -- ^ @auth_source@ - (Optional)
    --
    , _authType          :: TF.Attr s P.Text
    -- ^ @auth_type@ - (Optional)
    --
    , _docsToInvestigate :: TF.Attr s P.Text
    -- ^ @docs_to_investigate@ - (Optional)
    --
    , _extractDocId      :: TF.Attr s P.Text
    -- ^ @extract_doc_id@ - (Optional)
    --
    , _nestingLevel      :: TF.Attr s P.Text
    -- ^ @nesting_level@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDmsEndpointMongodbSettings
    :: DmsEndpointMongodbSettings s
newDmsEndpointMongodbSettings =
    DmsEndpointMongodbSettings'
        { _authMechanism = TF.value "DEFAULT"
        , _authSource = TF.value "admin"
        , _authType = TF.value "PASSWORD"
        , _docsToInvestigate = TF.value "1000"
        , _extractDocId = TF.value "false"
        , _nestingLevel = TF.value "NONE"
        }

instance P.Hashable  (DmsEndpointMongodbSettings s)
instance TF.IsValue  (DmsEndpointMongodbSettings s)
instance TF.IsObject (DmsEndpointMongodbSettings s) where
    toObject DmsEndpointMongodbSettings'{..} = P.catMaybes
        [ TF.assign "auth_mechanism" <$> TF.attribute _authMechanism
        , TF.assign "auth_source" <$> TF.attribute _authSource
        , TF.assign "auth_type" <$> TF.attribute _authType
        , TF.assign "docs_to_investigate" <$> TF.attribute _docsToInvestigate
        , TF.assign "extract_doc_id" <$> TF.attribute _extractDocId
        , TF.assign "nesting_level" <$> TF.attribute _nestingLevel
        ]

instance TF.IsValid (DmsEndpointMongodbSettings s) where
    validator = P.mempty

instance P.HasAuthMechanism (DmsEndpointMongodbSettings s) (TF.Attr s P.Text) where
    authMechanism =
        P.lens (_authMechanism :: DmsEndpointMongodbSettings s -> TF.Attr s P.Text)
               (\s a -> s { _authMechanism = a } :: DmsEndpointMongodbSettings s)

instance P.HasAuthSource (DmsEndpointMongodbSettings s) (TF.Attr s P.Text) where
    authSource =
        P.lens (_authSource :: DmsEndpointMongodbSettings s -> TF.Attr s P.Text)
               (\s a -> s { _authSource = a } :: DmsEndpointMongodbSettings s)

instance P.HasAuthType (DmsEndpointMongodbSettings s) (TF.Attr s P.Text) where
    authType =
        P.lens (_authType :: DmsEndpointMongodbSettings s -> TF.Attr s P.Text)
               (\s a -> s { _authType = a } :: DmsEndpointMongodbSettings s)

instance P.HasDocsToInvestigate (DmsEndpointMongodbSettings s) (TF.Attr s P.Text) where
    docsToInvestigate =
        P.lens (_docsToInvestigate :: DmsEndpointMongodbSettings s -> TF.Attr s P.Text)
               (\s a -> s { _docsToInvestigate = a } :: DmsEndpointMongodbSettings s)

instance P.HasExtractDocId (DmsEndpointMongodbSettings s) (TF.Attr s P.Text) where
    extractDocId =
        P.lens (_extractDocId :: DmsEndpointMongodbSettings s -> TF.Attr s P.Text)
               (\s a -> s { _extractDocId = a } :: DmsEndpointMongodbSettings s)

instance P.HasNestingLevel (DmsEndpointMongodbSettings s) (TF.Attr s P.Text) where
    nestingLevel =
        P.lens (_nestingLevel :: DmsEndpointMongodbSettings s -> TF.Attr s P.Text)
               (\s a -> s { _nestingLevel = a } :: DmsEndpointMongodbSettings s)

-- | @codedeploy_deployment_group_ec2_tag_filter@ nested settings.
data CodedeployDeploymentGroupEc2TagFilter s = CodedeployDeploymentGroupEc2TagFilter'
    { _key   :: TF.Attr s P.Text
    -- ^ @key@ - (Optional)
    --
    , _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Optional)
    --
    , _value :: TF.Attr s P.Text
    -- ^ @value@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCodedeployDeploymentGroupEc2TagFilter
    :: CodedeployDeploymentGroupEc2TagFilter s
newCodedeployDeploymentGroupEc2TagFilter =
    CodedeployDeploymentGroupEc2TagFilter'
        { _key = TF.Nil
        , _type' = TF.Nil
        , _value = TF.Nil
        }

instance P.Hashable  (CodedeployDeploymentGroupEc2TagFilter s)
instance TF.IsValue  (CodedeployDeploymentGroupEc2TagFilter s)
instance TF.IsObject (CodedeployDeploymentGroupEc2TagFilter s) where
    toObject CodedeployDeploymentGroupEc2TagFilter'{..} = P.catMaybes
        [ TF.assign "key" <$> TF.attribute _key
        , TF.assign "type" <$> TF.attribute _type'
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (CodedeployDeploymentGroupEc2TagFilter s) where
    validator = P.mempty

instance P.HasKey (CodedeployDeploymentGroupEc2TagFilter s) (TF.Attr s P.Text) where
    key =
        P.lens (_key :: CodedeployDeploymentGroupEc2TagFilter s -> TF.Attr s P.Text)
               (\s a -> s { _key = a } :: CodedeployDeploymentGroupEc2TagFilter s)

instance P.HasType' (CodedeployDeploymentGroupEc2TagFilter s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: CodedeployDeploymentGroupEc2TagFilter s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: CodedeployDeploymentGroupEc2TagFilter s)

instance P.HasValue (CodedeployDeploymentGroupEc2TagFilter s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: CodedeployDeploymentGroupEc2TagFilter s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: CodedeployDeploymentGroupEc2TagFilter s)

-- | @ses_receipt_rule_workmail_action@ nested settings.
data SesReceiptRuleWorkmailAction s = SesReceiptRuleWorkmailAction'
    { _organizationArn :: TF.Attr s P.Text
    -- ^ @organization_arn@ - (Required)
    --
    , _position        :: TF.Attr s P.Integer
    -- ^ @position@ - (Required)
    --
    , _topicArn        :: TF.Attr s P.Text
    -- ^ @topic_arn@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSesReceiptRuleWorkmailAction
    :: TF.Attr s P.Text -- ^ @organization_arn@ - 'P.organizationArn'
    -> TF.Attr s P.Integer -- ^ @position@ - 'P.position'
    -> SesReceiptRuleWorkmailAction s
newSesReceiptRuleWorkmailAction _organizationArn _position =
    SesReceiptRuleWorkmailAction'
        { _organizationArn = _organizationArn
        , _position = _position
        , _topicArn = TF.Nil
        }

instance P.Hashable  (SesReceiptRuleWorkmailAction s)
instance TF.IsValue  (SesReceiptRuleWorkmailAction s)
instance TF.IsObject (SesReceiptRuleWorkmailAction s) where
    toObject SesReceiptRuleWorkmailAction'{..} = P.catMaybes
        [ TF.assign "organization_arn" <$> TF.attribute _organizationArn
        , TF.assign "position" <$> TF.attribute _position
        , TF.assign "topic_arn" <$> TF.attribute _topicArn
        ]

instance TF.IsValid (SesReceiptRuleWorkmailAction s) where
    validator = P.mempty

instance P.HasOrganizationArn (SesReceiptRuleWorkmailAction s) (TF.Attr s P.Text) where
    organizationArn =
        P.lens (_organizationArn :: SesReceiptRuleWorkmailAction s -> TF.Attr s P.Text)
               (\s a -> s { _organizationArn = a } :: SesReceiptRuleWorkmailAction s)

instance P.HasPosition (SesReceiptRuleWorkmailAction s) (TF.Attr s P.Integer) where
    position =
        P.lens (_position :: SesReceiptRuleWorkmailAction s -> TF.Attr s P.Integer)
               (\s a -> s { _position = a } :: SesReceiptRuleWorkmailAction s)

instance P.HasTopicArn (SesReceiptRuleWorkmailAction s) (TF.Attr s P.Text) where
    topicArn =
        P.lens (_topicArn :: SesReceiptRuleWorkmailAction s -> TF.Attr s P.Text)
               (\s a -> s { _topicArn = a } :: SesReceiptRuleWorkmailAction s)

-- | @waf_byte_match_set_byte_match_tuples@ nested settings.
data WafByteMatchSetByteMatchTuples s = WafByteMatchSetByteMatchTuples'
    { _fieldToMatch         :: TF.Attr s (ByteMatchTuplesFieldToMatch s)
    -- ^ @field_to_match@ - (Required)
    --
    , _positionalConstraint :: TF.Attr s P.Text
    -- ^ @positional_constraint@ - (Required)
    --
    , _targetString         :: TF.Attr s P.Text
    -- ^ @target_string@ - (Optional)
    --
    , _textTransformation   :: TF.Attr s P.Text
    -- ^ @text_transformation@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafByteMatchSetByteMatchTuples
    :: TF.Attr s (ByteMatchTuplesFieldToMatch s) -- ^ @field_to_match@ - 'P.fieldToMatch'
    -> TF.Attr s P.Text -- ^ @positional_constraint@ - 'P.positionalConstraint'
    -> TF.Attr s P.Text -- ^ @text_transformation@ - 'P.textTransformation'
    -> WafByteMatchSetByteMatchTuples s
newWafByteMatchSetByteMatchTuples _fieldToMatch _positionalConstraint _textTransformation =
    WafByteMatchSetByteMatchTuples'
        { _fieldToMatch = _fieldToMatch
        , _positionalConstraint = _positionalConstraint
        , _targetString = TF.Nil
        , _textTransformation = _textTransformation
        }

instance P.Hashable  (WafByteMatchSetByteMatchTuples s)
instance TF.IsValue  (WafByteMatchSetByteMatchTuples s)
instance TF.IsObject (WafByteMatchSetByteMatchTuples s) where
    toObject WafByteMatchSetByteMatchTuples'{..} = P.catMaybes
        [ TF.assign "field_to_match" <$> TF.attribute _fieldToMatch
        , TF.assign "positional_constraint" <$> TF.attribute _positionalConstraint
        , TF.assign "target_string" <$> TF.attribute _targetString
        , TF.assign "text_transformation" <$> TF.attribute _textTransformation
        ]

instance TF.IsValid (WafByteMatchSetByteMatchTuples s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_fieldToMatch"
                  (_fieldToMatch
                      :: WafByteMatchSetByteMatchTuples s -> TF.Attr s (ByteMatchTuplesFieldToMatch s))
                  TF.validator

instance P.HasFieldToMatch (WafByteMatchSetByteMatchTuples s) (TF.Attr s (ByteMatchTuplesFieldToMatch s)) where
    fieldToMatch =
        P.lens (_fieldToMatch :: WafByteMatchSetByteMatchTuples s -> TF.Attr s (ByteMatchTuplesFieldToMatch s))
               (\s a -> s { _fieldToMatch = a } :: WafByteMatchSetByteMatchTuples s)

instance P.HasPositionalConstraint (WafByteMatchSetByteMatchTuples s) (TF.Attr s P.Text) where
    positionalConstraint =
        P.lens (_positionalConstraint :: WafByteMatchSetByteMatchTuples s -> TF.Attr s P.Text)
               (\s a -> s { _positionalConstraint = a } :: WafByteMatchSetByteMatchTuples s)

instance P.HasTargetString (WafByteMatchSetByteMatchTuples s) (TF.Attr s P.Text) where
    targetString =
        P.lens (_targetString :: WafByteMatchSetByteMatchTuples s -> TF.Attr s P.Text)
               (\s a -> s { _targetString = a } :: WafByteMatchSetByteMatchTuples s)

instance P.HasTextTransformation (WafByteMatchSetByteMatchTuples s) (TF.Attr s P.Text) where
    textTransformation =
        P.lens (_textTransformation :: WafByteMatchSetByteMatchTuples s -> TF.Attr s P.Text)
               (\s a -> s { _textTransformation = a } :: WafByteMatchSetByteMatchTuples s)

-- | @statement_not_principals@ nested settings.
data StatementNotPrincipals s = StatementNotPrincipals'
    { _identifiers :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @identifiers@ - (Required)
    --
    , _type'       :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newStatementNotPrincipals
    :: TF.Attr s [TF.Attr s P.Text] -- ^ @identifiers@ - 'P.identifiers'
    -> TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> StatementNotPrincipals s
newStatementNotPrincipals _identifiers _type' =
    StatementNotPrincipals'
        { _identifiers = _identifiers
        , _type' = _type'
        }

instance P.Hashable  (StatementNotPrincipals s)
instance TF.IsValue  (StatementNotPrincipals s)
instance TF.IsObject (StatementNotPrincipals s) where
    toObject StatementNotPrincipals'{..} = P.catMaybes
        [ TF.assign "identifiers" <$> TF.attribute _identifiers
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (StatementNotPrincipals s) where
    validator = P.mempty

instance P.HasIdentifiers (StatementNotPrincipals s) (TF.Attr s [TF.Attr s P.Text]) where
    identifiers =
        P.lens (_identifiers :: StatementNotPrincipals s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _identifiers = a } :: StatementNotPrincipals s)

instance P.HasType' (StatementNotPrincipals s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: StatementNotPrincipals s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: StatementNotPrincipals s)

-- | @size_constraints_field_to_match@ nested settings.
data SizeConstraintsFieldToMatch s = SizeConstraintsFieldToMatch'
    { _data' :: TF.Attr s P.Text
    -- ^ @data@ - (Optional)
    --
    , _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSizeConstraintsFieldToMatch
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> SizeConstraintsFieldToMatch s
newSizeConstraintsFieldToMatch _type' =
    SizeConstraintsFieldToMatch'
        { _data' = TF.Nil
        , _type' = _type'
        }

instance P.Hashable  (SizeConstraintsFieldToMatch s)
instance TF.IsValue  (SizeConstraintsFieldToMatch s)
instance TF.IsObject (SizeConstraintsFieldToMatch s) where
    toObject SizeConstraintsFieldToMatch'{..} = P.catMaybes
        [ TF.assign "data" <$> TF.attribute _data'
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (SizeConstraintsFieldToMatch s) where
    validator = P.mempty

instance P.HasData' (SizeConstraintsFieldToMatch s) (TF.Attr s P.Text) where
    data' =
        P.lens (_data' :: SizeConstraintsFieldToMatch s -> TF.Attr s P.Text)
               (\s a -> s { _data' = a } :: SizeConstraintsFieldToMatch s)

instance P.HasType' (SizeConstraintsFieldToMatch s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: SizeConstraintsFieldToMatch s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: SizeConstraintsFieldToMatch s)

-- | @elasticsearch_domain_encrypt_at_rest@ nested settings.
data ElasticsearchDomainEncryptAtRest s = ElasticsearchDomainEncryptAtRest'
    { _enabled :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElasticsearchDomainEncryptAtRest
    :: TF.Attr s P.Bool -- ^ @enabled@ - 'P.enabled'
    -> ElasticsearchDomainEncryptAtRest s
newElasticsearchDomainEncryptAtRest _enabled =
    ElasticsearchDomainEncryptAtRest'
        { _enabled = _enabled
        }

instance P.Hashable  (ElasticsearchDomainEncryptAtRest s)
instance TF.IsValue  (ElasticsearchDomainEncryptAtRest s)
instance TF.IsObject (ElasticsearchDomainEncryptAtRest s) where
    toObject ElasticsearchDomainEncryptAtRest'{..} = P.catMaybes
        [ TF.assign "enabled" <$> TF.attribute _enabled
        ]

instance TF.IsValid (ElasticsearchDomainEncryptAtRest s) where
    validator = P.mempty

instance P.HasEnabled (ElasticsearchDomainEncryptAtRest s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: ElasticsearchDomainEncryptAtRest s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: ElasticsearchDomainEncryptAtRest s)

instance s ~ s' => P.HasComputedKmsKeyId (TF.Ref s' (ElasticsearchDomainEncryptAtRest s)) (TF.Attr s P.Text) where
    computedKmsKeyId x = TF.compute (TF.refKey x) "kms_key_id"

-- | @security_group_filter@ nested settings.
data SecurityGroupFilter s = SecurityGroupFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSecurityGroupFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> SecurityGroupFilter s
newSecurityGroupFilter _name _values =
    SecurityGroupFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (SecurityGroupFilter s)
instance TF.IsValue  (SecurityGroupFilter s)
instance TF.IsObject (SecurityGroupFilter s) where
    toObject SecurityGroupFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (SecurityGroupFilter s) where
    validator = P.mempty

instance P.HasName (SecurityGroupFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: SecurityGroupFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: SecurityGroupFilter s)

instance P.HasValues (SecurityGroupFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: SecurityGroupFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: SecurityGroupFilter s)

-- | @ssm_patch_baseline_approval_rule@ nested settings.
data SsmPatchBaselineApprovalRule s = SsmPatchBaselineApprovalRule'
    { _approveAfterDays  :: TF.Attr s P.Integer
    -- ^ @approve_after_days@ - (Required)
    --
    , _complianceLevel   :: TF.Attr s P.Text
    -- ^ @compliance_level@ - (Optional)
    --
    , _enableNonSecurity :: TF.Attr s P.Bool
    -- ^ @enable_non_security@ - (Optional)
    --
    , _patchFilter       :: TF.Attr s [TF.Attr s (ApprovalRulePatchFilter s)]
    -- ^ @patch_filter@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSsmPatchBaselineApprovalRule
    :: TF.Attr s P.Integer -- ^ @approve_after_days@ - 'P.approveAfterDays'
    -> TF.Attr s [TF.Attr s (ApprovalRulePatchFilter s)] -- ^ @patch_filter@ - 'P.patchFilter'
    -> SsmPatchBaselineApprovalRule s
newSsmPatchBaselineApprovalRule _approveAfterDays _patchFilter =
    SsmPatchBaselineApprovalRule'
        { _approveAfterDays = _approveAfterDays
        , _complianceLevel = TF.value "UNSPECIFIED"
        , _enableNonSecurity = TF.value P.False
        , _patchFilter = _patchFilter
        }

instance P.Hashable  (SsmPatchBaselineApprovalRule s)
instance TF.IsValue  (SsmPatchBaselineApprovalRule s)
instance TF.IsObject (SsmPatchBaselineApprovalRule s) where
    toObject SsmPatchBaselineApprovalRule'{..} = P.catMaybes
        [ TF.assign "approve_after_days" <$> TF.attribute _approveAfterDays
        , TF.assign "compliance_level" <$> TF.attribute _complianceLevel
        , TF.assign "enable_non_security" <$> TF.attribute _enableNonSecurity
        , TF.assign "patch_filter" <$> TF.attribute _patchFilter
        ]

instance TF.IsValid (SsmPatchBaselineApprovalRule s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_patchFilter"
                  (_patchFilter
                      :: SsmPatchBaselineApprovalRule s -> TF.Attr s [TF.Attr s (ApprovalRulePatchFilter s)])
                  TF.validator

instance P.HasApproveAfterDays (SsmPatchBaselineApprovalRule s) (TF.Attr s P.Integer) where
    approveAfterDays =
        P.lens (_approveAfterDays :: SsmPatchBaselineApprovalRule s -> TF.Attr s P.Integer)
               (\s a -> s { _approveAfterDays = a } :: SsmPatchBaselineApprovalRule s)

instance P.HasComplianceLevel (SsmPatchBaselineApprovalRule s) (TF.Attr s P.Text) where
    complianceLevel =
        P.lens (_complianceLevel :: SsmPatchBaselineApprovalRule s -> TF.Attr s P.Text)
               (\s a -> s { _complianceLevel = a } :: SsmPatchBaselineApprovalRule s)

instance P.HasEnableNonSecurity (SsmPatchBaselineApprovalRule s) (TF.Attr s P.Bool) where
    enableNonSecurity =
        P.lens (_enableNonSecurity :: SsmPatchBaselineApprovalRule s -> TF.Attr s P.Bool)
               (\s a -> s { _enableNonSecurity = a } :: SsmPatchBaselineApprovalRule s)

instance P.HasPatchFilter (SsmPatchBaselineApprovalRule s) (TF.Attr s [TF.Attr s (ApprovalRulePatchFilter s)]) where
    patchFilter =
        P.lens (_patchFilter :: SsmPatchBaselineApprovalRule s -> TF.Attr s [TF.Attr s (ApprovalRulePatchFilter s)])
               (\s a -> s { _patchFilter = a } :: SsmPatchBaselineApprovalRule s)

-- | @ecs_service_service_registries@ nested settings.
data EcsServiceServiceRegistries s = EcsServiceServiceRegistries'
    { _containerName :: TF.Attr s P.Text
    -- ^ @container_name@ - (Optional)
    --
    , _containerPort :: TF.Attr s P.Integer
    -- ^ @container_port@ - (Optional)
    --
    , _port          :: TF.Attr s P.Integer
    -- ^ @port@ - (Optional)
    --
    , _registryArn   :: TF.Attr s P.Text
    -- ^ @registry_arn@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newEcsServiceServiceRegistries
    :: TF.Attr s P.Text -- ^ @registry_arn@ - 'P.registryArn'
    -> EcsServiceServiceRegistries s
newEcsServiceServiceRegistries _registryArn =
    EcsServiceServiceRegistries'
        { _containerName = TF.Nil
        , _containerPort = TF.Nil
        , _port = TF.Nil
        , _registryArn = _registryArn
        }

instance P.Hashable  (EcsServiceServiceRegistries s)
instance TF.IsValue  (EcsServiceServiceRegistries s)
instance TF.IsObject (EcsServiceServiceRegistries s) where
    toObject EcsServiceServiceRegistries'{..} = P.catMaybes
        [ TF.assign "container_name" <$> TF.attribute _containerName
        , TF.assign "container_port" <$> TF.attribute _containerPort
        , TF.assign "port" <$> TF.attribute _port
        , TF.assign "registry_arn" <$> TF.attribute _registryArn
        ]

instance TF.IsValid (EcsServiceServiceRegistries s) where
    validator = P.mempty

instance P.HasContainerName (EcsServiceServiceRegistries s) (TF.Attr s P.Text) where
    containerName =
        P.lens (_containerName :: EcsServiceServiceRegistries s -> TF.Attr s P.Text)
               (\s a -> s { _containerName = a } :: EcsServiceServiceRegistries s)

instance P.HasContainerPort (EcsServiceServiceRegistries s) (TF.Attr s P.Integer) where
    containerPort =
        P.lens (_containerPort :: EcsServiceServiceRegistries s -> TF.Attr s P.Integer)
               (\s a -> s { _containerPort = a } :: EcsServiceServiceRegistries s)

instance P.HasPort (EcsServiceServiceRegistries s) (TF.Attr s P.Integer) where
    port =
        P.lens (_port :: EcsServiceServiceRegistries s -> TF.Attr s P.Integer)
               (\s a -> s { _port = a } :: EcsServiceServiceRegistries s)

instance P.HasRegistryArn (EcsServiceServiceRegistries s) (TF.Attr s P.Text) where
    registryArn =
        P.lens (_registryArn :: EcsServiceServiceRegistries s -> TF.Attr s P.Text)
               (\s a -> s { _registryArn = a } :: EcsServiceServiceRegistries s)

-- | @waf_sql_injection_match_set_sql_injection_match_tuples@ nested settings.
data WafSqlInjectionMatchSetSqlInjectionMatchTuples s = WafSqlInjectionMatchSetSqlInjectionMatchTuples'
    { _fieldToMatch       :: TF.Attr s (SqlInjectionMatchTuplesFieldToMatch s)
    -- ^ @field_to_match@ - (Required)
    --
    , _textTransformation :: TF.Attr s P.Text
    -- ^ @text_transformation@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafSqlInjectionMatchSetSqlInjectionMatchTuples
    :: TF.Attr s (SqlInjectionMatchTuplesFieldToMatch s) -- ^ @field_to_match@ - 'P.fieldToMatch'
    -> TF.Attr s P.Text -- ^ @text_transformation@ - 'P.textTransformation'
    -> WafSqlInjectionMatchSetSqlInjectionMatchTuples s
newWafSqlInjectionMatchSetSqlInjectionMatchTuples _fieldToMatch _textTransformation =
    WafSqlInjectionMatchSetSqlInjectionMatchTuples'
        { _fieldToMatch = _fieldToMatch
        , _textTransformation = _textTransformation
        }

instance P.Hashable  (WafSqlInjectionMatchSetSqlInjectionMatchTuples s)
instance TF.IsValue  (WafSqlInjectionMatchSetSqlInjectionMatchTuples s)
instance TF.IsObject (WafSqlInjectionMatchSetSqlInjectionMatchTuples s) where
    toObject WafSqlInjectionMatchSetSqlInjectionMatchTuples'{..} = P.catMaybes
        [ TF.assign "field_to_match" <$> TF.attribute _fieldToMatch
        , TF.assign "text_transformation" <$> TF.attribute _textTransformation
        ]

instance TF.IsValid (WafSqlInjectionMatchSetSqlInjectionMatchTuples s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_fieldToMatch"
                  (_fieldToMatch
                      :: WafSqlInjectionMatchSetSqlInjectionMatchTuples s -> TF.Attr s (SqlInjectionMatchTuplesFieldToMatch s))
                  TF.validator

instance P.HasFieldToMatch (WafSqlInjectionMatchSetSqlInjectionMatchTuples s) (TF.Attr s (SqlInjectionMatchTuplesFieldToMatch s)) where
    fieldToMatch =
        P.lens (_fieldToMatch :: WafSqlInjectionMatchSetSqlInjectionMatchTuples s -> TF.Attr s (SqlInjectionMatchTuplesFieldToMatch s))
               (\s a -> s { _fieldToMatch = a } :: WafSqlInjectionMatchSetSqlInjectionMatchTuples s)

instance P.HasTextTransformation (WafSqlInjectionMatchSetSqlInjectionMatchTuples s) (TF.Attr s P.Text) where
    textTransformation =
        P.lens (_textTransformation :: WafSqlInjectionMatchSetSqlInjectionMatchTuples s -> TF.Attr s P.Text)
               (\s a -> s { _textTransformation = a } :: WafSqlInjectionMatchSetSqlInjectionMatchTuples s)

-- | @elb_health_check@ nested settings.
data ElbHealthCheck s = ElbHealthCheck'
    { _healthyThreshold   :: TF.Attr s P.Integer
    -- ^ @healthy_threshold@ - (Required)
    --
    , _interval           :: TF.Attr s P.Integer
    -- ^ @interval@ - (Required)
    --
    , _target             :: TF.Attr s P.Text
    -- ^ @target@ - (Required)
    --
    , _timeout            :: TF.Attr s P.Integer
    -- ^ @timeout@ - (Required)
    --
    , _unhealthyThreshold :: TF.Attr s P.Integer
    -- ^ @unhealthy_threshold@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElbHealthCheck
    :: TF.Attr s P.Integer -- ^ @healthy_threshold@ - 'P.healthyThreshold'
    -> TF.Attr s P.Integer -- ^ @interval@ - 'P.interval'
    -> TF.Attr s P.Text -- ^ @target@ - 'P.target'
    -> TF.Attr s P.Integer -- ^ @timeout@ - 'P.timeout'
    -> TF.Attr s P.Integer -- ^ @unhealthy_threshold@ - 'P.unhealthyThreshold'
    -> ElbHealthCheck s
newElbHealthCheck _healthyThreshold _interval _target _timeout _unhealthyThreshold =
    ElbHealthCheck'
        { _healthyThreshold = _healthyThreshold
        , _interval = _interval
        , _target = _target
        , _timeout = _timeout
        , _unhealthyThreshold = _unhealthyThreshold
        }

instance P.Hashable  (ElbHealthCheck s)
instance TF.IsValue  (ElbHealthCheck s)
instance TF.IsObject (ElbHealthCheck s) where
    toObject ElbHealthCheck'{..} = P.catMaybes
        [ TF.assign "healthy_threshold" <$> TF.attribute _healthyThreshold
        , TF.assign "interval" <$> TF.attribute _interval
        , TF.assign "target" <$> TF.attribute _target
        , TF.assign "timeout" <$> TF.attribute _timeout
        , TF.assign "unhealthy_threshold" <$> TF.attribute _unhealthyThreshold
        ]

instance TF.IsValid (ElbHealthCheck s) where
    validator = P.mempty

instance P.HasHealthyThreshold (ElbHealthCheck s) (TF.Attr s P.Integer) where
    healthyThreshold =
        P.lens (_healthyThreshold :: ElbHealthCheck s -> TF.Attr s P.Integer)
               (\s a -> s { _healthyThreshold = a } :: ElbHealthCheck s)

instance P.HasInterval (ElbHealthCheck s) (TF.Attr s P.Integer) where
    interval =
        P.lens (_interval :: ElbHealthCheck s -> TF.Attr s P.Integer)
               (\s a -> s { _interval = a } :: ElbHealthCheck s)

instance P.HasTarget (ElbHealthCheck s) (TF.Attr s P.Text) where
    target =
        P.lens (_target :: ElbHealthCheck s -> TF.Attr s P.Text)
               (\s a -> s { _target = a } :: ElbHealthCheck s)

instance P.HasTimeout (ElbHealthCheck s) (TF.Attr s P.Integer) where
    timeout =
        P.lens (_timeout :: ElbHealthCheck s -> TF.Attr s P.Integer)
               (\s a -> s { _timeout = a } :: ElbHealthCheck s)

instance P.HasUnhealthyThreshold (ElbHealthCheck s) (TF.Attr s P.Integer) where
    unhealthyThreshold =
        P.lens (_unhealthyThreshold :: ElbHealthCheck s -> TF.Attr s P.Integer)
               (\s a -> s { _unhealthyThreshold = a } :: ElbHealthCheck s)

instance s ~ s' => P.HasComputedHealthyThreshold (TF.Ref s' (ElbHealthCheck s)) (TF.Attr s P.Integer) where
    computedHealthyThreshold x = TF.compute (TF.refKey x) "healthy_threshold"

instance s ~ s' => P.HasComputedInterval (TF.Ref s' (ElbHealthCheck s)) (TF.Attr s P.Integer) where
    computedInterval x = TF.compute (TF.refKey x) "interval"

instance s ~ s' => P.HasComputedTarget (TF.Ref s' (ElbHealthCheck s)) (TF.Attr s P.Text) where
    computedTarget x = TF.compute (TF.refKey x) "target"

instance s ~ s' => P.HasComputedTimeout (TF.Ref s' (ElbHealthCheck s)) (TF.Attr s P.Integer) where
    computedTimeout x = TF.compute (TF.refKey x) "timeout"

instance s ~ s' => P.HasComputedUnhealthyThreshold (TF.Ref s' (ElbHealthCheck s)) (TF.Attr s P.Integer) where
    computedUnhealthyThreshold x = TF.compute (TF.refKey x) "unhealthy_threshold"

-- | @vpc_peering_connection_accepter@ nested settings.
data VpcPeeringConnectionAccepter s = VpcPeeringConnectionAccepter'
    { _allowClassicLinkToRemoteVpc :: TF.Attr s P.Bool
    -- ^ @allow_classic_link_to_remote_vpc@ - (Optional)
    --
    , _allowRemoteVpcDnsResolution :: TF.Attr s P.Bool
    -- ^ @allow_remote_vpc_dns_resolution@ - (Optional)
    --
    , _allowVpcToRemoteClassicLink :: TF.Attr s P.Bool
    -- ^ @allow_vpc_to_remote_classic_link@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newVpcPeeringConnectionAccepter
    :: VpcPeeringConnectionAccepter s
newVpcPeeringConnectionAccepter =
    VpcPeeringConnectionAccepter'
        { _allowClassicLinkToRemoteVpc = TF.value P.False
        , _allowRemoteVpcDnsResolution = TF.value P.False
        , _allowVpcToRemoteClassicLink = TF.value P.False
        }

instance P.Hashable  (VpcPeeringConnectionAccepter s)
instance TF.IsValue  (VpcPeeringConnectionAccepter s)
instance TF.IsObject (VpcPeeringConnectionAccepter s) where
    toObject VpcPeeringConnectionAccepter'{..} = P.catMaybes
        [ TF.assign "allow_classic_link_to_remote_vpc" <$> TF.attribute _allowClassicLinkToRemoteVpc
        , TF.assign "allow_remote_vpc_dns_resolution" <$> TF.attribute _allowRemoteVpcDnsResolution
        , TF.assign "allow_vpc_to_remote_classic_link" <$> TF.attribute _allowVpcToRemoteClassicLink
        ]

instance TF.IsValid (VpcPeeringConnectionAccepter s) where
    validator = P.mempty

instance P.HasAllowClassicLinkToRemoteVpc (VpcPeeringConnectionAccepter s) (TF.Attr s P.Bool) where
    allowClassicLinkToRemoteVpc =
        P.lens (_allowClassicLinkToRemoteVpc :: VpcPeeringConnectionAccepter s -> TF.Attr s P.Bool)
               (\s a -> s { _allowClassicLinkToRemoteVpc = a } :: VpcPeeringConnectionAccepter s)

instance P.HasAllowRemoteVpcDnsResolution (VpcPeeringConnectionAccepter s) (TF.Attr s P.Bool) where
    allowRemoteVpcDnsResolution =
        P.lens (_allowRemoteVpcDnsResolution :: VpcPeeringConnectionAccepter s -> TF.Attr s P.Bool)
               (\s a -> s { _allowRemoteVpcDnsResolution = a } :: VpcPeeringConnectionAccepter s)

instance P.HasAllowVpcToRemoteClassicLink (VpcPeeringConnectionAccepter s) (TF.Attr s P.Bool) where
    allowVpcToRemoteClassicLink =
        P.lens (_allowVpcToRemoteClassicLink :: VpcPeeringConnectionAccepter s -> TF.Attr s P.Bool)
               (\s a -> s { _allowVpcToRemoteClassicLink = a } :: VpcPeeringConnectionAccepter s)

-- | @ecs_service_network_configuration@ nested settings.
data EcsServiceNetworkConfiguration s = EcsServiceNetworkConfiguration'
    { _assignPublicIp :: TF.Attr s P.Bool
    -- ^ @assign_public_ip@ - (Optional)
    --
    , _securityGroups :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @security_groups@ - (Optional)
    --
    , _subnets        :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @subnets@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newEcsServiceNetworkConfiguration
    :: TF.Attr s [TF.Attr s P.Text] -- ^ @subnets@ - 'P.subnets'
    -> EcsServiceNetworkConfiguration s
newEcsServiceNetworkConfiguration _subnets =
    EcsServiceNetworkConfiguration'
        { _assignPublicIp = TF.value P.False
        , _securityGroups = TF.Nil
        , _subnets = _subnets
        }

instance P.Hashable  (EcsServiceNetworkConfiguration s)
instance TF.IsValue  (EcsServiceNetworkConfiguration s)
instance TF.IsObject (EcsServiceNetworkConfiguration s) where
    toObject EcsServiceNetworkConfiguration'{..} = P.catMaybes
        [ TF.assign "assign_public_ip" <$> TF.attribute _assignPublicIp
        , TF.assign "security_groups" <$> TF.attribute _securityGroups
        , TF.assign "subnets" <$> TF.attribute _subnets
        ]

instance TF.IsValid (EcsServiceNetworkConfiguration s) where
    validator = P.mempty

instance P.HasAssignPublicIp (EcsServiceNetworkConfiguration s) (TF.Attr s P.Bool) where
    assignPublicIp =
        P.lens (_assignPublicIp :: EcsServiceNetworkConfiguration s -> TF.Attr s P.Bool)
               (\s a -> s { _assignPublicIp = a } :: EcsServiceNetworkConfiguration s)

instance P.HasSecurityGroups (EcsServiceNetworkConfiguration s) (TF.Attr s [TF.Attr s P.Text]) where
    securityGroups =
        P.lens (_securityGroups :: EcsServiceNetworkConfiguration s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _securityGroups = a } :: EcsServiceNetworkConfiguration s)

instance P.HasSubnets (EcsServiceNetworkConfiguration s) (TF.Attr s [TF.Attr s P.Text]) where
    subnets =
        P.lens (_subnets :: EcsServiceNetworkConfiguration s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _subnets = a } :: EcsServiceNetworkConfiguration s)

-- | @service_discovery_service_dns_config@ nested settings.
data ServiceDiscoveryServiceDnsConfig s = ServiceDiscoveryServiceDnsConfig'
    { _dnsRecords    :: TF.Attr s [TF.Attr s (DnsConfigDnsRecords s)]
    -- ^ @dns_records@ - (Required)
    --
    , _namespaceId   :: TF.Attr s P.Text
    -- ^ @namespace_id@ - (Required, Forces New)
    --
    , _routingPolicy :: TF.Attr s P.Text
    -- ^ @routing_policy@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newServiceDiscoveryServiceDnsConfig
    :: TF.Attr s [TF.Attr s (DnsConfigDnsRecords s)] -- ^ @dns_records@ - 'P.dnsRecords'
    -> TF.Attr s P.Text -- ^ @namespace_id@ - 'P.namespaceId'
    -> ServiceDiscoveryServiceDnsConfig s
newServiceDiscoveryServiceDnsConfig _dnsRecords _namespaceId =
    ServiceDiscoveryServiceDnsConfig'
        { _dnsRecords = _dnsRecords
        , _namespaceId = _namespaceId
        , _routingPolicy = TF.value "MULTIVALUE"
        }

instance P.Hashable  (ServiceDiscoveryServiceDnsConfig s)
instance TF.IsValue  (ServiceDiscoveryServiceDnsConfig s)
instance TF.IsObject (ServiceDiscoveryServiceDnsConfig s) where
    toObject ServiceDiscoveryServiceDnsConfig'{..} = P.catMaybes
        [ TF.assign "dns_records" <$> TF.attribute _dnsRecords
        , TF.assign "namespace_id" <$> TF.attribute _namespaceId
        , TF.assign "routing_policy" <$> TF.attribute _routingPolicy
        ]

instance TF.IsValid (ServiceDiscoveryServiceDnsConfig s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_dnsRecords"
                  (_dnsRecords
                      :: ServiceDiscoveryServiceDnsConfig s -> TF.Attr s [TF.Attr s (DnsConfigDnsRecords s)])
                  TF.validator

instance P.HasDnsRecords (ServiceDiscoveryServiceDnsConfig s) (TF.Attr s [TF.Attr s (DnsConfigDnsRecords s)]) where
    dnsRecords =
        P.lens (_dnsRecords :: ServiceDiscoveryServiceDnsConfig s -> TF.Attr s [TF.Attr s (DnsConfigDnsRecords s)])
               (\s a -> s { _dnsRecords = a } :: ServiceDiscoveryServiceDnsConfig s)

instance P.HasNamespaceId (ServiceDiscoveryServiceDnsConfig s) (TF.Attr s P.Text) where
    namespaceId =
        P.lens (_namespaceId :: ServiceDiscoveryServiceDnsConfig s -> TF.Attr s P.Text)
               (\s a -> s { _namespaceId = a } :: ServiceDiscoveryServiceDnsConfig s)

instance P.HasRoutingPolicy (ServiceDiscoveryServiceDnsConfig s) (TF.Attr s P.Text) where
    routingPolicy =
        P.lens (_routingPolicy :: ServiceDiscoveryServiceDnsConfig s -> TF.Attr s P.Text)
               (\s a -> s { _routingPolicy = a } :: ServiceDiscoveryServiceDnsConfig s)

-- | @cloudfront_distribution_default_cache_behavior@ nested settings.
data CloudfrontDistributionDefaultCacheBehavior s = CloudfrontDistributionDefaultCacheBehavior'
    { _allowedMethods :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @allowed_methods@ - (Required)
    --
    , _cachedMethods :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @cached_methods@ - (Required)
    --
    , _compress :: TF.Attr s P.Bool
    -- ^ @compress@ - (Optional)
    --
    , _defaultTtl :: TF.Attr s P.Integer
    -- ^ @default_ttl@ - (Optional)
    --
    , _fieldLevelEncryptionId :: TF.Attr s P.Text
    -- ^ @field_level_encryption_id@ - (Optional)
    --
    , _forwardedValues :: TF.Attr s (DefaultCacheBehaviorForwardedValues s)
    -- ^ @forwarded_values@ - (Required)
    --
    , _lambdaFunctionAssociation :: TF.Attr s [TF.Attr s (DefaultCacheBehaviorLambdaFunctionAssociation s)]
    -- ^ @lambda_function_association@ - (Optional)
    --
    , _maxTtl :: TF.Attr s P.Integer
    -- ^ @max_ttl@ - (Optional)
    --
    , _minTtl :: TF.Attr s P.Integer
    -- ^ @min_ttl@ - (Optional)
    --
    , _smoothStreaming :: TF.Attr s P.Bool
    -- ^ @smooth_streaming@ - (Optional)
    --
    , _targetOriginId :: TF.Attr s P.Text
    -- ^ @target_origin_id@ - (Required)
    --
    , _trustedSigners :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @trusted_signers@ - (Optional)
    --
    , _viewerProtocolPolicy :: TF.Attr s P.Text
    -- ^ @viewer_protocol_policy@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCloudfrontDistributionDefaultCacheBehavior
    :: TF.Attr s [TF.Attr s P.Text] -- ^ @allowed_methods@ - 'P.allowedMethods'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @cached_methods@ - 'P.cachedMethods'
    -> TF.Attr s (DefaultCacheBehaviorForwardedValues s) -- ^ @forwarded_values@ - 'P.forwardedValues'
    -> TF.Attr s P.Text -- ^ @target_origin_id@ - 'P.targetOriginId'
    -> TF.Attr s P.Text -- ^ @viewer_protocol_policy@ - 'P.viewerProtocolPolicy'
    -> CloudfrontDistributionDefaultCacheBehavior s
newCloudfrontDistributionDefaultCacheBehavior _allowedMethods _cachedMethods _forwardedValues _targetOriginId _viewerProtocolPolicy =
    CloudfrontDistributionDefaultCacheBehavior'
        { _allowedMethods = _allowedMethods
        , _cachedMethods = _cachedMethods
        , _compress = TF.value P.False
        , _defaultTtl = TF.value 86400
        , _fieldLevelEncryptionId = TF.Nil
        , _forwardedValues = _forwardedValues
        , _lambdaFunctionAssociation = TF.Nil
        , _maxTtl = TF.value 31536000
        , _minTtl = TF.value 0
        , _smoothStreaming = TF.Nil
        , _targetOriginId = _targetOriginId
        , _trustedSigners = TF.Nil
        , _viewerProtocolPolicy = _viewerProtocolPolicy
        }

instance P.Hashable  (CloudfrontDistributionDefaultCacheBehavior s)
instance TF.IsValue  (CloudfrontDistributionDefaultCacheBehavior s)
instance TF.IsObject (CloudfrontDistributionDefaultCacheBehavior s) where
    toObject CloudfrontDistributionDefaultCacheBehavior'{..} = P.catMaybes
        [ TF.assign "allowed_methods" <$> TF.attribute _allowedMethods
        , TF.assign "cached_methods" <$> TF.attribute _cachedMethods
        , TF.assign "compress" <$> TF.attribute _compress
        , TF.assign "default_ttl" <$> TF.attribute _defaultTtl
        , TF.assign "field_level_encryption_id" <$> TF.attribute _fieldLevelEncryptionId
        , TF.assign "forwarded_values" <$> TF.attribute _forwardedValues
        , TF.assign "lambda_function_association" <$> TF.attribute _lambdaFunctionAssociation
        , TF.assign "max_ttl" <$> TF.attribute _maxTtl
        , TF.assign "min_ttl" <$> TF.attribute _minTtl
        , TF.assign "smooth_streaming" <$> TF.attribute _smoothStreaming
        , TF.assign "target_origin_id" <$> TF.attribute _targetOriginId
        , TF.assign "trusted_signers" <$> TF.attribute _trustedSigners
        , TF.assign "viewer_protocol_policy" <$> TF.attribute _viewerProtocolPolicy
        ]

instance TF.IsValid (CloudfrontDistributionDefaultCacheBehavior s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_forwardedValues"
                  (_forwardedValues
                      :: CloudfrontDistributionDefaultCacheBehavior s -> TF.Attr s (DefaultCacheBehaviorForwardedValues s))
                  TF.validator
           P.<> TF.settingsValidator "_lambdaFunctionAssociation"
                  (_lambdaFunctionAssociation
                      :: CloudfrontDistributionDefaultCacheBehavior s -> TF.Attr s [TF.Attr s (DefaultCacheBehaviorLambdaFunctionAssociation s)])
                  TF.validator

instance P.HasAllowedMethods (CloudfrontDistributionDefaultCacheBehavior s) (TF.Attr s [TF.Attr s P.Text]) where
    allowedMethods =
        P.lens (_allowedMethods :: CloudfrontDistributionDefaultCacheBehavior s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _allowedMethods = a } :: CloudfrontDistributionDefaultCacheBehavior s)

instance P.HasCachedMethods (CloudfrontDistributionDefaultCacheBehavior s) (TF.Attr s [TF.Attr s P.Text]) where
    cachedMethods =
        P.lens (_cachedMethods :: CloudfrontDistributionDefaultCacheBehavior s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _cachedMethods = a } :: CloudfrontDistributionDefaultCacheBehavior s)

instance P.HasCompress (CloudfrontDistributionDefaultCacheBehavior s) (TF.Attr s P.Bool) where
    compress =
        P.lens (_compress :: CloudfrontDistributionDefaultCacheBehavior s -> TF.Attr s P.Bool)
               (\s a -> s { _compress = a } :: CloudfrontDistributionDefaultCacheBehavior s)

instance P.HasDefaultTtl (CloudfrontDistributionDefaultCacheBehavior s) (TF.Attr s P.Integer) where
    defaultTtl =
        P.lens (_defaultTtl :: CloudfrontDistributionDefaultCacheBehavior s -> TF.Attr s P.Integer)
               (\s a -> s { _defaultTtl = a } :: CloudfrontDistributionDefaultCacheBehavior s)

instance P.HasFieldLevelEncryptionId (CloudfrontDistributionDefaultCacheBehavior s) (TF.Attr s P.Text) where
    fieldLevelEncryptionId =
        P.lens (_fieldLevelEncryptionId :: CloudfrontDistributionDefaultCacheBehavior s -> TF.Attr s P.Text)
               (\s a -> s { _fieldLevelEncryptionId = a } :: CloudfrontDistributionDefaultCacheBehavior s)

instance P.HasForwardedValues (CloudfrontDistributionDefaultCacheBehavior s) (TF.Attr s (DefaultCacheBehaviorForwardedValues s)) where
    forwardedValues =
        P.lens (_forwardedValues :: CloudfrontDistributionDefaultCacheBehavior s -> TF.Attr s (DefaultCacheBehaviorForwardedValues s))
               (\s a -> s { _forwardedValues = a } :: CloudfrontDistributionDefaultCacheBehavior s)

instance P.HasLambdaFunctionAssociation (CloudfrontDistributionDefaultCacheBehavior s) (TF.Attr s [TF.Attr s (DefaultCacheBehaviorLambdaFunctionAssociation s)]) where
    lambdaFunctionAssociation =
        P.lens (_lambdaFunctionAssociation :: CloudfrontDistributionDefaultCacheBehavior s -> TF.Attr s [TF.Attr s (DefaultCacheBehaviorLambdaFunctionAssociation s)])
               (\s a -> s { _lambdaFunctionAssociation = a } :: CloudfrontDistributionDefaultCacheBehavior s)

instance P.HasMaxTtl (CloudfrontDistributionDefaultCacheBehavior s) (TF.Attr s P.Integer) where
    maxTtl =
        P.lens (_maxTtl :: CloudfrontDistributionDefaultCacheBehavior s -> TF.Attr s P.Integer)
               (\s a -> s { _maxTtl = a } :: CloudfrontDistributionDefaultCacheBehavior s)

instance P.HasMinTtl (CloudfrontDistributionDefaultCacheBehavior s) (TF.Attr s P.Integer) where
    minTtl =
        P.lens (_minTtl :: CloudfrontDistributionDefaultCacheBehavior s -> TF.Attr s P.Integer)
               (\s a -> s { _minTtl = a } :: CloudfrontDistributionDefaultCacheBehavior s)

instance P.HasSmoothStreaming (CloudfrontDistributionDefaultCacheBehavior s) (TF.Attr s P.Bool) where
    smoothStreaming =
        P.lens (_smoothStreaming :: CloudfrontDistributionDefaultCacheBehavior s -> TF.Attr s P.Bool)
               (\s a -> s { _smoothStreaming = a } :: CloudfrontDistributionDefaultCacheBehavior s)

instance P.HasTargetOriginId (CloudfrontDistributionDefaultCacheBehavior s) (TF.Attr s P.Text) where
    targetOriginId =
        P.lens (_targetOriginId :: CloudfrontDistributionDefaultCacheBehavior s -> TF.Attr s P.Text)
               (\s a -> s { _targetOriginId = a } :: CloudfrontDistributionDefaultCacheBehavior s)

instance P.HasTrustedSigners (CloudfrontDistributionDefaultCacheBehavior s) (TF.Attr s [TF.Attr s P.Text]) where
    trustedSigners =
        P.lens (_trustedSigners :: CloudfrontDistributionDefaultCacheBehavior s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _trustedSigners = a } :: CloudfrontDistributionDefaultCacheBehavior s)

instance P.HasViewerProtocolPolicy (CloudfrontDistributionDefaultCacheBehavior s) (TF.Attr s P.Text) where
    viewerProtocolPolicy =
        P.lens (_viewerProtocolPolicy :: CloudfrontDistributionDefaultCacheBehavior s -> TF.Attr s P.Text)
               (\s a -> s { _viewerProtocolPolicy = a } :: CloudfrontDistributionDefaultCacheBehavior s)

-- | @emr_cluster_instance_group@ nested settings.
data EmrClusterInstanceGroup s = EmrClusterInstanceGroup'
    { _autoscalingPolicy :: TF.Attr s P.Text
    -- ^ @autoscaling_policy@ - (Optional)
    --
    , _bidPrice          :: TF.Attr s P.Text
    -- ^ @bid_price@ - (Optional)
    --
    , _ebsConfig         :: TF.Attr s [TF.Attr s (InstanceGroupEbsConfig s)]
    -- ^ @ebs_config@ - (Optional, Forces New)
    --
    , _instanceCount     :: TF.Attr s P.Integer
    -- ^ @instance_count@ - (Optional)
    --
    , _instanceRole      :: TF.Attr s P.Text
    -- ^ @instance_role@ - (Required)
    --
    , _instanceType      :: TF.Attr s P.Text
    -- ^ @instance_type@ - (Required, Forces New)
    --
    , _name              :: TF.Attr s P.Text
    -- ^ @name@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newEmrClusterInstanceGroup
    :: TF.Attr s P.Text -- ^ @instance_role@ - 'P.instanceRole'
    -> TF.Attr s P.Text -- ^ @instance_type@ - 'P.instanceType'
    -> EmrClusterInstanceGroup s
newEmrClusterInstanceGroup _instanceRole _instanceType =
    EmrClusterInstanceGroup'
        { _autoscalingPolicy = TF.Nil
        , _bidPrice = TF.Nil
        , _ebsConfig = TF.Nil
        , _instanceCount = TF.value 0
        , _instanceRole = _instanceRole
        , _instanceType = _instanceType
        , _name = TF.Nil
        }

instance P.Hashable  (EmrClusterInstanceGroup s)
instance TF.IsValue  (EmrClusterInstanceGroup s)
instance TF.IsObject (EmrClusterInstanceGroup s) where
    toObject EmrClusterInstanceGroup'{..} = P.catMaybes
        [ TF.assign "autoscaling_policy" <$> TF.attribute _autoscalingPolicy
        , TF.assign "bid_price" <$> TF.attribute _bidPrice
        , TF.assign "ebs_config" <$> TF.attribute _ebsConfig
        , TF.assign "instance_count" <$> TF.attribute _instanceCount
        , TF.assign "instance_role" <$> TF.attribute _instanceRole
        , TF.assign "instance_type" <$> TF.attribute _instanceType
        , TF.assign "name" <$> TF.attribute _name
        ]

instance TF.IsValid (EmrClusterInstanceGroup s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_ebsConfig"
                  (_ebsConfig
                      :: EmrClusterInstanceGroup s -> TF.Attr s [TF.Attr s (InstanceGroupEbsConfig s)])
                  TF.validator

instance P.HasAutoscalingPolicy (EmrClusterInstanceGroup s) (TF.Attr s P.Text) where
    autoscalingPolicy =
        P.lens (_autoscalingPolicy :: EmrClusterInstanceGroup s -> TF.Attr s P.Text)
               (\s a -> s { _autoscalingPolicy = a } :: EmrClusterInstanceGroup s)

instance P.HasBidPrice (EmrClusterInstanceGroup s) (TF.Attr s P.Text) where
    bidPrice =
        P.lens (_bidPrice :: EmrClusterInstanceGroup s -> TF.Attr s P.Text)
               (\s a -> s { _bidPrice = a } :: EmrClusterInstanceGroup s)

instance P.HasEbsConfig (EmrClusterInstanceGroup s) (TF.Attr s [TF.Attr s (InstanceGroupEbsConfig s)]) where
    ebsConfig =
        P.lens (_ebsConfig :: EmrClusterInstanceGroup s -> TF.Attr s [TF.Attr s (InstanceGroupEbsConfig s)])
               (\s a -> s { _ebsConfig = a } :: EmrClusterInstanceGroup s)

instance P.HasInstanceCount (EmrClusterInstanceGroup s) (TF.Attr s P.Integer) where
    instanceCount =
        P.lens (_instanceCount :: EmrClusterInstanceGroup s -> TF.Attr s P.Integer)
               (\s a -> s { _instanceCount = a } :: EmrClusterInstanceGroup s)

instance P.HasInstanceRole (EmrClusterInstanceGroup s) (TF.Attr s P.Text) where
    instanceRole =
        P.lens (_instanceRole :: EmrClusterInstanceGroup s -> TF.Attr s P.Text)
               (\s a -> s { _instanceRole = a } :: EmrClusterInstanceGroup s)

instance P.HasInstanceType (EmrClusterInstanceGroup s) (TF.Attr s P.Text) where
    instanceType =
        P.lens (_instanceType :: EmrClusterInstanceGroup s -> TF.Attr s P.Text)
               (\s a -> s { _instanceType = a } :: EmrClusterInstanceGroup s)

instance P.HasName (EmrClusterInstanceGroup s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: EmrClusterInstanceGroup s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: EmrClusterInstanceGroup s)

-- | @s3_bucket_lifecycle_rule@ nested settings.
data S3BucketLifecycleRule s = S3BucketLifecycleRule'
    { _abortIncompleteMultipartUploadDays :: TF.Attr s P.Integer
    -- ^ @abort_incomplete_multipart_upload_days@ - (Optional)
    --
    , _enabled :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Required)
    --
    , _expiration :: TF.Attr s [TF.Attr s (LifecycleRuleExpiration s)]
    -- ^ @expiration@ - (Optional)
    --
    , _noncurrentVersionExpiration :: TF.Attr s [TF.Attr s (LifecycleRuleNoncurrentVersionExpiration s)]
    -- ^ @noncurrent_version_expiration@ - (Optional)
    --
    , _noncurrentVersionTransition :: TF.Attr s [TF.Attr s (LifecycleRuleNoncurrentVersionTransition s)]
    -- ^ @noncurrent_version_transition@ - (Optional)
    --
    , _prefix :: TF.Attr s P.Text
    -- ^ @prefix@ - (Optional)
    --
    , _tags :: TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))
    -- ^ @tags@ - (Optional)
    --
    , _transition :: TF.Attr s [TF.Attr s (LifecycleRuleTransition s)]
    -- ^ @transition@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newS3BucketLifecycleRule
    :: TF.Attr s P.Bool -- ^ @enabled@ - 'P.enabled'
    -> S3BucketLifecycleRule s
newS3BucketLifecycleRule _enabled =
    S3BucketLifecycleRule'
        { _abortIncompleteMultipartUploadDays = TF.Nil
        , _enabled = _enabled
        , _expiration = TF.Nil
        , _noncurrentVersionExpiration = TF.Nil
        , _noncurrentVersionTransition = TF.Nil
        , _prefix = TF.Nil
        , _tags = TF.Nil
        , _transition = TF.Nil
        }

instance P.Hashable  (S3BucketLifecycleRule s)
instance TF.IsValue  (S3BucketLifecycleRule s)
instance TF.IsObject (S3BucketLifecycleRule s) where
    toObject S3BucketLifecycleRule'{..} = P.catMaybes
        [ TF.assign "abort_incomplete_multipart_upload_days" <$> TF.attribute _abortIncompleteMultipartUploadDays
        , TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "expiration" <$> TF.attribute _expiration
        , TF.assign "noncurrent_version_expiration" <$> TF.attribute _noncurrentVersionExpiration
        , TF.assign "noncurrent_version_transition" <$> TF.attribute _noncurrentVersionTransition
        , TF.assign "prefix" <$> TF.attribute _prefix
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "transition" <$> TF.attribute _transition
        ]

instance TF.IsValid (S3BucketLifecycleRule s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_expiration"
                  (_expiration
                      :: S3BucketLifecycleRule s -> TF.Attr s [TF.Attr s (LifecycleRuleExpiration s)])
                  TF.validator
           P.<> TF.settingsValidator "_noncurrentVersionExpiration"
                  (_noncurrentVersionExpiration
                      :: S3BucketLifecycleRule s -> TF.Attr s [TF.Attr s (LifecycleRuleNoncurrentVersionExpiration s)])
                  TF.validator
           P.<> TF.settingsValidator "_noncurrentVersionTransition"
                  (_noncurrentVersionTransition
                      :: S3BucketLifecycleRule s -> TF.Attr s [TF.Attr s (LifecycleRuleNoncurrentVersionTransition s)])
                  TF.validator
           P.<> TF.settingsValidator "_transition"
                  (_transition
                      :: S3BucketLifecycleRule s -> TF.Attr s [TF.Attr s (LifecycleRuleTransition s)])
                  TF.validator

instance P.HasAbortIncompleteMultipartUploadDays (S3BucketLifecycleRule s) (TF.Attr s P.Integer) where
    abortIncompleteMultipartUploadDays =
        P.lens (_abortIncompleteMultipartUploadDays :: S3BucketLifecycleRule s -> TF.Attr s P.Integer)
               (\s a -> s { _abortIncompleteMultipartUploadDays = a } :: S3BucketLifecycleRule s)

instance P.HasEnabled (S3BucketLifecycleRule s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: S3BucketLifecycleRule s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: S3BucketLifecycleRule s)

instance P.HasExpiration (S3BucketLifecycleRule s) (TF.Attr s [TF.Attr s (LifecycleRuleExpiration s)]) where
    expiration =
        P.lens (_expiration :: S3BucketLifecycleRule s -> TF.Attr s [TF.Attr s (LifecycleRuleExpiration s)])
               (\s a -> s { _expiration = a } :: S3BucketLifecycleRule s)

instance P.HasNoncurrentVersionExpiration (S3BucketLifecycleRule s) (TF.Attr s [TF.Attr s (LifecycleRuleNoncurrentVersionExpiration s)]) where
    noncurrentVersionExpiration =
        P.lens (_noncurrentVersionExpiration :: S3BucketLifecycleRule s -> TF.Attr s [TF.Attr s (LifecycleRuleNoncurrentVersionExpiration s)])
               (\s a -> s { _noncurrentVersionExpiration = a } :: S3BucketLifecycleRule s)

instance P.HasNoncurrentVersionTransition (S3BucketLifecycleRule s) (TF.Attr s [TF.Attr s (LifecycleRuleNoncurrentVersionTransition s)]) where
    noncurrentVersionTransition =
        P.lens (_noncurrentVersionTransition :: S3BucketLifecycleRule s -> TF.Attr s [TF.Attr s (LifecycleRuleNoncurrentVersionTransition s)])
               (\s a -> s { _noncurrentVersionTransition = a } :: S3BucketLifecycleRule s)

instance P.HasPrefix (S3BucketLifecycleRule s) (TF.Attr s P.Text) where
    prefix =
        P.lens (_prefix :: S3BucketLifecycleRule s -> TF.Attr s P.Text)
               (\s a -> s { _prefix = a } :: S3BucketLifecycleRule s)

instance P.HasTags (S3BucketLifecycleRule s) (TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))) where
    tags =
        P.lens (_tags :: S3BucketLifecycleRule s -> TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text)))
               (\s a -> s { _tags = a } :: S3BucketLifecycleRule s)

instance P.HasTransition (S3BucketLifecycleRule s) (TF.Attr s [TF.Attr s (LifecycleRuleTransition s)]) where
    transition =
        P.lens (_transition :: S3BucketLifecycleRule s -> TF.Attr s [TF.Attr s (LifecycleRuleTransition s)])
               (\s a -> s { _transition = a } :: S3BucketLifecycleRule s)

instance s ~ s' => P.HasComputedId (TF.Ref s' (S3BucketLifecycleRule s)) (TF.Attr s P.Text) where
    computedId x = TF.compute (TF.refKey x) "id"

-- | @opsworks_instance_ephemeral_block_device@ nested settings.
data OpsworksInstanceEphemeralBlockDevice s = OpsworksInstanceEphemeralBlockDevice'
    { _deviceName  :: TF.Attr s P.Text
    -- ^ @device_name@ - (Required)
    --
    , _virtualName :: TF.Attr s P.Text
    -- ^ @virtual_name@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newOpsworksInstanceEphemeralBlockDevice
    :: TF.Attr s P.Text -- ^ @device_name@ - 'P.deviceName'
    -> TF.Attr s P.Text -- ^ @virtual_name@ - 'P.virtualName'
    -> OpsworksInstanceEphemeralBlockDevice s
newOpsworksInstanceEphemeralBlockDevice _deviceName _virtualName =
    OpsworksInstanceEphemeralBlockDevice'
        { _deviceName = _deviceName
        , _virtualName = _virtualName
        }

instance P.Hashable  (OpsworksInstanceEphemeralBlockDevice s)
instance TF.IsValue  (OpsworksInstanceEphemeralBlockDevice s)
instance TF.IsObject (OpsworksInstanceEphemeralBlockDevice s) where
    toObject OpsworksInstanceEphemeralBlockDevice'{..} = P.catMaybes
        [ TF.assign "device_name" <$> TF.attribute _deviceName
        , TF.assign "virtual_name" <$> TF.attribute _virtualName
        ]

instance TF.IsValid (OpsworksInstanceEphemeralBlockDevice s) where
    validator = P.mempty

instance P.HasDeviceName (OpsworksInstanceEphemeralBlockDevice s) (TF.Attr s P.Text) where
    deviceName =
        P.lens (_deviceName :: OpsworksInstanceEphemeralBlockDevice s -> TF.Attr s P.Text)
               (\s a -> s { _deviceName = a } :: OpsworksInstanceEphemeralBlockDevice s)

instance P.HasVirtualName (OpsworksInstanceEphemeralBlockDevice s) (TF.Attr s P.Text) where
    virtualName =
        P.lens (_virtualName :: OpsworksInstanceEphemeralBlockDevice s -> TF.Attr s P.Text)
               (\s a -> s { _virtualName = a } :: OpsworksInstanceEphemeralBlockDevice s)

-- | @wafregional_rate_based_rule_predicate@ nested settings.
data WafregionalRateBasedRulePredicate s = WafregionalRateBasedRulePredicate'
    { _dataId  :: TF.Attr s P.Text
    -- ^ @data_id@ - (Required)
    --
    , _negated :: TF.Attr s P.Bool
    -- ^ @negated@ - (Required)
    --
    , _type'   :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafregionalRateBasedRulePredicate
    :: TF.Attr s P.Text -- ^ @data_id@ - 'P.dataId'
    -> TF.Attr s P.Bool -- ^ @negated@ - 'P.negated'
    -> TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> WafregionalRateBasedRulePredicate s
newWafregionalRateBasedRulePredicate _dataId _negated _type' =
    WafregionalRateBasedRulePredicate'
        { _dataId = _dataId
        , _negated = _negated
        , _type' = _type'
        }

instance P.Hashable  (WafregionalRateBasedRulePredicate s)
instance TF.IsValue  (WafregionalRateBasedRulePredicate s)
instance TF.IsObject (WafregionalRateBasedRulePredicate s) where
    toObject WafregionalRateBasedRulePredicate'{..} = P.catMaybes
        [ TF.assign "data_id" <$> TF.attribute _dataId
        , TF.assign "negated" <$> TF.attribute _negated
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (WafregionalRateBasedRulePredicate s) where
    validator = P.mempty

instance P.HasDataId (WafregionalRateBasedRulePredicate s) (TF.Attr s P.Text) where
    dataId =
        P.lens (_dataId :: WafregionalRateBasedRulePredicate s -> TF.Attr s P.Text)
               (\s a -> s { _dataId = a } :: WafregionalRateBasedRulePredicate s)

instance P.HasNegated (WafregionalRateBasedRulePredicate s) (TF.Attr s P.Bool) where
    negated =
        P.lens (_negated :: WafregionalRateBasedRulePredicate s -> TF.Attr s P.Bool)
               (\s a -> s { _negated = a } :: WafregionalRateBasedRulePredicate s)

instance P.HasType' (WafregionalRateBasedRulePredicate s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: WafregionalRateBasedRulePredicate s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: WafregionalRateBasedRulePredicate s)

-- | @eks_cluster_certificate_authority@ nested settings.
data EksClusterCertificateAuthority s = EksClusterCertificateAuthority'
    deriving (P.Show, P.Eq, P.Generic)

newEksClusterCertificateAuthority
    :: EksClusterCertificateAuthority s
newEksClusterCertificateAuthority =
    EksClusterCertificateAuthority'

instance P.Hashable  (EksClusterCertificateAuthority s)
instance TF.IsValue  (EksClusterCertificateAuthority s)
instance TF.IsObject (EksClusterCertificateAuthority s) where
    toObject EksClusterCertificateAuthority' = []

instance TF.IsValid (EksClusterCertificateAuthority s) where
    validator = P.mempty

instance s ~ s' => P.HasComputedData (TF.Ref s' (EksClusterCertificateAuthority s)) (TF.Attr s P.Text) where
    computedData x = TF.compute (TF.refKey x) "data"

-- | @vpn_connection_routes@ nested settings.
data VpnConnectionRoutes s = VpnConnectionRoutes'
    deriving (P.Show, P.Eq, P.Generic)

newVpnConnectionRoutes
    :: VpnConnectionRoutes s
newVpnConnectionRoutes =
    VpnConnectionRoutes'

instance P.Hashable  (VpnConnectionRoutes s)
instance TF.IsValue  (VpnConnectionRoutes s)
instance TF.IsObject (VpnConnectionRoutes s) where
    toObject VpnConnectionRoutes' = []

instance TF.IsValid (VpnConnectionRoutes s) where
    validator = P.mempty

instance s ~ s' => P.HasComputedDestinationCidrBlock (TF.Ref s' (VpnConnectionRoutes s)) (TF.Attr s P.Text) where
    computedDestinationCidrBlock x = TF.compute (TF.refKey x) "destination_cidr_block"

instance s ~ s' => P.HasComputedSource (TF.Ref s' (VpnConnectionRoutes s)) (TF.Attr s P.Text) where
    computedSource x = TF.compute (TF.refKey x) "source"

instance s ~ s' => P.HasComputedState (TF.Ref s' (VpnConnectionRoutes s)) (TF.Attr s P.Text) where
    computedState x = TF.compute (TF.refKey x) "state"

-- | @cloudwatch_event_target_kinesis_target@ nested settings.
data CloudwatchEventTargetKinesisTarget s = CloudwatchEventTargetKinesisTarget'
    { _partitionKeyPath :: TF.Attr s P.Text
    -- ^ @partition_key_path@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCloudwatchEventTargetKinesisTarget
    :: CloudwatchEventTargetKinesisTarget s
newCloudwatchEventTargetKinesisTarget =
    CloudwatchEventTargetKinesisTarget'
        { _partitionKeyPath = TF.Nil
        }

instance P.Hashable  (CloudwatchEventTargetKinesisTarget s)
instance TF.IsValue  (CloudwatchEventTargetKinesisTarget s)
instance TF.IsObject (CloudwatchEventTargetKinesisTarget s) where
    toObject CloudwatchEventTargetKinesisTarget'{..} = P.catMaybes
        [ TF.assign "partition_key_path" <$> TF.attribute _partitionKeyPath
        ]

instance TF.IsValid (CloudwatchEventTargetKinesisTarget s) where
    validator = P.mempty

instance P.HasPartitionKeyPath (CloudwatchEventTargetKinesisTarget s) (TF.Attr s P.Text) where
    partitionKeyPath =
        P.lens (_partitionKeyPath :: CloudwatchEventTargetKinesisTarget s -> TF.Attr s P.Text)
               (\s a -> s { _partitionKeyPath = a } :: CloudwatchEventTargetKinesisTarget s)

-- | @event_selector_data_resource@ nested settings.
data EventSelectorDataResource s = EventSelectorDataResource'
    { _type'  :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newEventSelectorDataResource
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> EventSelectorDataResource s
newEventSelectorDataResource _type' _values =
    EventSelectorDataResource'
        { _type' = _type'
        , _values = _values
        }

instance P.Hashable  (EventSelectorDataResource s)
instance TF.IsValue  (EventSelectorDataResource s)
instance TF.IsObject (EventSelectorDataResource s) where
    toObject EventSelectorDataResource'{..} = P.catMaybes
        [ TF.assign "type" <$> TF.attribute _type'
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (EventSelectorDataResource s) where
    validator = P.mempty

instance P.HasType' (EventSelectorDataResource s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: EventSelectorDataResource s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: EventSelectorDataResource s)

instance P.HasValues (EventSelectorDataResource s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: EventSelectorDataResource s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: EventSelectorDataResource s)

-- | @dynamodb_table_ttl@ nested settings.
data DynamodbTableTtl s = DynamodbTableTtl'
    { _attributeName :: TF.Attr s P.Text
    -- ^ @attribute_name@ - (Required)
    --
    , _enabled       :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDynamodbTableTtl
    :: TF.Attr s P.Text -- ^ @attribute_name@ - 'P.attributeName'
    -> TF.Attr s P.Bool -- ^ @enabled@ - 'P.enabled'
    -> DynamodbTableTtl s
newDynamodbTableTtl _attributeName _enabled =
    DynamodbTableTtl'
        { _attributeName = _attributeName
        , _enabled = _enabled
        }

instance P.Hashable  (DynamodbTableTtl s)
instance TF.IsValue  (DynamodbTableTtl s)
instance TF.IsObject (DynamodbTableTtl s) where
    toObject DynamodbTableTtl'{..} = P.catMaybes
        [ TF.assign "attribute_name" <$> TF.attribute _attributeName
        , TF.assign "enabled" <$> TF.attribute _enabled
        ]

instance TF.IsValid (DynamodbTableTtl s) where
    validator = P.mempty

instance P.HasAttributeName (DynamodbTableTtl s) (TF.Attr s P.Text) where
    attributeName =
        P.lens (_attributeName :: DynamodbTableTtl s -> TF.Attr s P.Text)
               (\s a -> s { _attributeName = a } :: DynamodbTableTtl s)

instance P.HasEnabled (DynamodbTableTtl s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: DynamodbTableTtl s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: DynamodbTableTtl s)

instance s ~ s' => P.HasComputedAttributeName (TF.Ref s' (DynamodbTableTtl s)) (TF.Attr s P.Text) where
    computedAttributeName x = TF.compute (TF.refKey x) "attribute_name"

instance s ~ s' => P.HasComputedEnabled (TF.Ref s' (DynamodbTableTtl s)) (TF.Attr s P.Bool) where
    computedEnabled x = TF.compute (TF.refKey x) "enabled"

-- | @rules_action@ nested settings.
data RulesAction s = RulesAction'
    { _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRulesAction
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> RulesAction s
newRulesAction _type' =
    RulesAction'
        { _type' = _type'
        }

instance P.Hashable  (RulesAction s)
instance TF.IsValue  (RulesAction s)
instance TF.IsObject (RulesAction s) where
    toObject RulesAction'{..} = P.catMaybes
        [ TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (RulesAction s) where
    validator = P.mempty

instance P.HasType' (RulesAction s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: RulesAction s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: RulesAction s)

-- | @waf_rule_predicates@ nested settings.
data WafRulePredicates s = WafRulePredicates'
    { _dataId  :: TF.Attr s P.Text
    -- ^ @data_id@ - (Required)
    --
    , _negated :: TF.Attr s P.Bool
    -- ^ @negated@ - (Required)
    --
    , _type'   :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafRulePredicates
    :: TF.Attr s P.Text -- ^ @data_id@ - 'P.dataId'
    -> TF.Attr s P.Bool -- ^ @negated@ - 'P.negated'
    -> TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> WafRulePredicates s
newWafRulePredicates _dataId _negated _type' =
    WafRulePredicates'
        { _dataId = _dataId
        , _negated = _negated
        , _type' = _type'
        }

instance P.Hashable  (WafRulePredicates s)
instance TF.IsValue  (WafRulePredicates s)
instance TF.IsObject (WafRulePredicates s) where
    toObject WafRulePredicates'{..} = P.catMaybes
        [ TF.assign "data_id" <$> TF.attribute _dataId
        , TF.assign "negated" <$> TF.attribute _negated
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (WafRulePredicates s) where
    validator = P.mempty

instance P.HasDataId (WafRulePredicates s) (TF.Attr s P.Text) where
    dataId =
        P.lens (_dataId :: WafRulePredicates s -> TF.Attr s P.Text)
               (\s a -> s { _dataId = a } :: WafRulePredicates s)

instance P.HasNegated (WafRulePredicates s) (TF.Attr s P.Bool) where
    negated =
        P.lens (_negated :: WafRulePredicates s -> TF.Attr s P.Bool)
               (\s a -> s { _negated = a } :: WafRulePredicates s)

instance P.HasType' (WafRulePredicates s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: WafRulePredicates s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: WafRulePredicates s)

-- | @ebs_volume_filter@ nested settings.
data EbsVolumeFilter s = EbsVolumeFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newEbsVolumeFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> EbsVolumeFilter s
newEbsVolumeFilter _name _values =
    EbsVolumeFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (EbsVolumeFilter s)
instance TF.IsValue  (EbsVolumeFilter s)
instance TF.IsObject (EbsVolumeFilter s) where
    toObject EbsVolumeFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (EbsVolumeFilter s) where
    validator = P.mempty

instance P.HasName (EbsVolumeFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: EbsVolumeFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: EbsVolumeFilter s)

instance P.HasValues (EbsVolumeFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: EbsVolumeFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: EbsVolumeFilter s)

-- | @alb_access_logs@ nested settings.
data AlbAccessLogs s = AlbAccessLogs'
    { _bucket  :: TF.Attr s P.Text
    -- ^ @bucket@ - (Required)
    --
    , _enabled :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Optional)
    --
    , _prefix  :: TF.Attr s P.Text
    -- ^ @prefix@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAlbAccessLogs
    :: TF.Attr s P.Text -- ^ @bucket@ - 'P.bucket'
    -> AlbAccessLogs s
newAlbAccessLogs _bucket =
    AlbAccessLogs'
        { _bucket = _bucket
        , _enabled = TF.Nil
        , _prefix = TF.Nil
        }

instance P.Hashable  (AlbAccessLogs s)
instance TF.IsValue  (AlbAccessLogs s)
instance TF.IsObject (AlbAccessLogs s) where
    toObject AlbAccessLogs'{..} = P.catMaybes
        [ TF.assign "bucket" <$> TF.attribute _bucket
        , TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "prefix" <$> TF.attribute _prefix
        ]

instance TF.IsValid (AlbAccessLogs s) where
    validator = P.mempty

instance P.HasBucket (AlbAccessLogs s) (TF.Attr s P.Text) where
    bucket =
        P.lens (_bucket :: AlbAccessLogs s -> TF.Attr s P.Text)
               (\s a -> s { _bucket = a } :: AlbAccessLogs s)

instance P.HasEnabled (AlbAccessLogs s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: AlbAccessLogs s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: AlbAccessLogs s)

instance P.HasPrefix (AlbAccessLogs s) (TF.Attr s P.Text) where
    prefix =
        P.lens (_prefix :: AlbAccessLogs s -> TF.Attr s P.Text)
               (\s a -> s { _prefix = a } :: AlbAccessLogs s)

instance s ~ s' => P.HasComputedBucket (TF.Ref s' (AlbAccessLogs s)) (TF.Attr s P.Text) where
    computedBucket x = TF.compute (TF.refKey x) "bucket"

instance s ~ s' => P.HasComputedEnabled (TF.Ref s' (AlbAccessLogs s)) (TF.Attr s P.Bool) where
    computedEnabled x = TF.compute (TF.refKey x) "enabled"

instance s ~ s' => P.HasComputedPrefix (TF.Ref s' (AlbAccessLogs s)) (TF.Attr s P.Text) where
    computedPrefix x = TF.compute (TF.refKey x) "prefix"

-- | @customized_metric_specification_metric_dimension@ nested settings.
data CustomizedMetricSpecificationMetricDimension s = CustomizedMetricSpecificationMetricDimension'
    { _name  :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _value :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCustomizedMetricSpecificationMetricDimension
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> CustomizedMetricSpecificationMetricDimension s
newCustomizedMetricSpecificationMetricDimension _name _value =
    CustomizedMetricSpecificationMetricDimension'
        { _name = _name
        , _value = _value
        }

instance P.Hashable  (CustomizedMetricSpecificationMetricDimension s)
instance TF.IsValue  (CustomizedMetricSpecificationMetricDimension s)
instance TF.IsObject (CustomizedMetricSpecificationMetricDimension s) where
    toObject CustomizedMetricSpecificationMetricDimension'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (CustomizedMetricSpecificationMetricDimension s) where
    validator = P.mempty

instance P.HasName (CustomizedMetricSpecificationMetricDimension s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: CustomizedMetricSpecificationMetricDimension s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: CustomizedMetricSpecificationMetricDimension s)

instance P.HasValue (CustomizedMetricSpecificationMetricDimension s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: CustomizedMetricSpecificationMetricDimension s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: CustomizedMetricSpecificationMetricDimension s)

-- | @api_gateway_account_throttle_settings@ nested settings.
data ApiGatewayAccountThrottleSettings s = ApiGatewayAccountThrottleSettings'
    deriving (P.Show, P.Eq, P.Generic)

newApiGatewayAccountThrottleSettings
    :: ApiGatewayAccountThrottleSettings s
newApiGatewayAccountThrottleSettings =
    ApiGatewayAccountThrottleSettings'

instance P.Hashable  (ApiGatewayAccountThrottleSettings s)
instance TF.IsValue  (ApiGatewayAccountThrottleSettings s)
instance TF.IsObject (ApiGatewayAccountThrottleSettings s) where
    toObject ApiGatewayAccountThrottleSettings' = []

instance TF.IsValid (ApiGatewayAccountThrottleSettings s) where
    validator = P.mempty

instance s ~ s' => P.HasComputedBurstLimit (TF.Ref s' (ApiGatewayAccountThrottleSettings s)) (TF.Attr s P.Integer) where
    computedBurstLimit x = TF.compute (TF.refKey x) "burst_limit"

instance s ~ s' => P.HasComputedRateLimit (TF.Ref s' (ApiGatewayAccountThrottleSettings s)) (TF.Attr s P.Double) where
    computedRateLimit x = TF.compute (TF.refKey x) "rate_limit"

-- | @mq_broker_maintenance_window_start_time@ nested settings.
data MqBrokerMaintenanceWindowStartTime s = MqBrokerMaintenanceWindowStartTime'
    { _dayOfWeek :: TF.Attr s P.Text
    -- ^ @day_of_week@ - (Required)
    --
    , _timeOfDay :: TF.Attr s P.Text
    -- ^ @time_of_day@ - (Required)
    --
    , _timeZone  :: TF.Attr s P.Text
    -- ^ @time_zone@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newMqBrokerMaintenanceWindowStartTime
    :: TF.Attr s P.Text -- ^ @day_of_week@ - 'P.dayOfWeek'
    -> TF.Attr s P.Text -- ^ @time_of_day@ - 'P.timeOfDay'
    -> TF.Attr s P.Text -- ^ @time_zone@ - 'P.timeZone'
    -> MqBrokerMaintenanceWindowStartTime s
newMqBrokerMaintenanceWindowStartTime _dayOfWeek _timeOfDay _timeZone =
    MqBrokerMaintenanceWindowStartTime'
        { _dayOfWeek = _dayOfWeek
        , _timeOfDay = _timeOfDay
        , _timeZone = _timeZone
        }

instance P.Hashable  (MqBrokerMaintenanceWindowStartTime s)
instance TF.IsValue  (MqBrokerMaintenanceWindowStartTime s)
instance TF.IsObject (MqBrokerMaintenanceWindowStartTime s) where
    toObject MqBrokerMaintenanceWindowStartTime'{..} = P.catMaybes
        [ TF.assign "day_of_week" <$> TF.attribute _dayOfWeek
        , TF.assign "time_of_day" <$> TF.attribute _timeOfDay
        , TF.assign "time_zone" <$> TF.attribute _timeZone
        ]

instance TF.IsValid (MqBrokerMaintenanceWindowStartTime s) where
    validator = P.mempty

instance P.HasDayOfWeek (MqBrokerMaintenanceWindowStartTime s) (TF.Attr s P.Text) where
    dayOfWeek =
        P.lens (_dayOfWeek :: MqBrokerMaintenanceWindowStartTime s -> TF.Attr s P.Text)
               (\s a -> s { _dayOfWeek = a } :: MqBrokerMaintenanceWindowStartTime s)

instance P.HasTimeOfDay (MqBrokerMaintenanceWindowStartTime s) (TF.Attr s P.Text) where
    timeOfDay =
        P.lens (_timeOfDay :: MqBrokerMaintenanceWindowStartTime s -> TF.Attr s P.Text)
               (\s a -> s { _timeOfDay = a } :: MqBrokerMaintenanceWindowStartTime s)

instance P.HasTimeZone (MqBrokerMaintenanceWindowStartTime s) (TF.Attr s P.Text) where
    timeZone =
        P.lens (_timeZone :: MqBrokerMaintenanceWindowStartTime s -> TF.Attr s P.Text)
               (\s a -> s { _timeZone = a } :: MqBrokerMaintenanceWindowStartTime s)

instance s ~ s' => P.HasComputedDayOfWeek (TF.Ref s' (MqBrokerMaintenanceWindowStartTime s)) (TF.Attr s P.Text) where
    computedDayOfWeek x = TF.compute (TF.refKey x) "day_of_week"

instance s ~ s' => P.HasComputedTimeOfDay (TF.Ref s' (MqBrokerMaintenanceWindowStartTime s)) (TF.Attr s P.Text) where
    computedTimeOfDay x = TF.compute (TF.refKey x) "time_of_day"

instance s ~ s' => P.HasComputedTimeZone (TF.Ref s' (MqBrokerMaintenanceWindowStartTime s)) (TF.Attr s P.Text) where
    computedTimeZone x = TF.compute (TF.refKey x) "time_zone"

-- | @emr_cluster_ec2_attributes@ nested settings.
data EmrClusterEc2Attributes s = EmrClusterEc2Attributes'
    { _additionalMasterSecurityGroups :: TF.Attr s P.Text
    -- ^ @additional_master_security_groups@ - (Optional, Forces New)
    --
    , _additionalSlaveSecurityGroups  :: TF.Attr s P.Text
    -- ^ @additional_slave_security_groups@ - (Optional, Forces New)
    --
    , _emrManagedMasterSecurityGroup  :: TF.Attr s P.Text
    -- ^ @emr_managed_master_security_group@ - (Optional, Forces New)
    --
    , _emrManagedSlaveSecurityGroup   :: TF.Attr s P.Text
    -- ^ @emr_managed_slave_security_group@ - (Optional, Forces New)
    --
    , _instanceProfile                :: TF.Attr s P.Text
    -- ^ @instance_profile@ - (Required, Forces New)
    --
    , _keyName                        :: TF.Attr s P.Text
    -- ^ @key_name@ - (Optional, Forces New)
    --
    , _serviceAccessSecurityGroup     :: TF.Attr s P.Text
    -- ^ @service_access_security_group@ - (Optional, Forces New)
    --
    , _subnetId                       :: TF.Attr s P.Text
    -- ^ @subnet_id@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newEmrClusterEc2Attributes
    :: TF.Attr s P.Text -- ^ @instance_profile@ - 'P.instanceProfile'
    -> EmrClusterEc2Attributes s
newEmrClusterEc2Attributes _instanceProfile =
    EmrClusterEc2Attributes'
        { _additionalMasterSecurityGroups = TF.Nil
        , _additionalSlaveSecurityGroups = TF.Nil
        , _emrManagedMasterSecurityGroup = TF.Nil
        , _emrManagedSlaveSecurityGroup = TF.Nil
        , _instanceProfile = _instanceProfile
        , _keyName = TF.Nil
        , _serviceAccessSecurityGroup = TF.Nil
        , _subnetId = TF.Nil
        }

instance P.Hashable  (EmrClusterEc2Attributes s)
instance TF.IsValue  (EmrClusterEc2Attributes s)
instance TF.IsObject (EmrClusterEc2Attributes s) where
    toObject EmrClusterEc2Attributes'{..} = P.catMaybes
        [ TF.assign "additional_master_security_groups" <$> TF.attribute _additionalMasterSecurityGroups
        , TF.assign "additional_slave_security_groups" <$> TF.attribute _additionalSlaveSecurityGroups
        , TF.assign "emr_managed_master_security_group" <$> TF.attribute _emrManagedMasterSecurityGroup
        , TF.assign "emr_managed_slave_security_group" <$> TF.attribute _emrManagedSlaveSecurityGroup
        , TF.assign "instance_profile" <$> TF.attribute _instanceProfile
        , TF.assign "key_name" <$> TF.attribute _keyName
        , TF.assign "service_access_security_group" <$> TF.attribute _serviceAccessSecurityGroup
        , TF.assign "subnet_id" <$> TF.attribute _subnetId
        ]

instance TF.IsValid (EmrClusterEc2Attributes s) where
    validator = P.mempty

instance P.HasAdditionalMasterSecurityGroups (EmrClusterEc2Attributes s) (TF.Attr s P.Text) where
    additionalMasterSecurityGroups =
        P.lens (_additionalMasterSecurityGroups :: EmrClusterEc2Attributes s -> TF.Attr s P.Text)
               (\s a -> s { _additionalMasterSecurityGroups = a } :: EmrClusterEc2Attributes s)

instance P.HasAdditionalSlaveSecurityGroups (EmrClusterEc2Attributes s) (TF.Attr s P.Text) where
    additionalSlaveSecurityGroups =
        P.lens (_additionalSlaveSecurityGroups :: EmrClusterEc2Attributes s -> TF.Attr s P.Text)
               (\s a -> s { _additionalSlaveSecurityGroups = a } :: EmrClusterEc2Attributes s)

instance P.HasEmrManagedMasterSecurityGroup (EmrClusterEc2Attributes s) (TF.Attr s P.Text) where
    emrManagedMasterSecurityGroup =
        P.lens (_emrManagedMasterSecurityGroup :: EmrClusterEc2Attributes s -> TF.Attr s P.Text)
               (\s a -> s { _emrManagedMasterSecurityGroup = a } :: EmrClusterEc2Attributes s)

instance P.HasEmrManagedSlaveSecurityGroup (EmrClusterEc2Attributes s) (TF.Attr s P.Text) where
    emrManagedSlaveSecurityGroup =
        P.lens (_emrManagedSlaveSecurityGroup :: EmrClusterEc2Attributes s -> TF.Attr s P.Text)
               (\s a -> s { _emrManagedSlaveSecurityGroup = a } :: EmrClusterEc2Attributes s)

instance P.HasInstanceProfile (EmrClusterEc2Attributes s) (TF.Attr s P.Text) where
    instanceProfile =
        P.lens (_instanceProfile :: EmrClusterEc2Attributes s -> TF.Attr s P.Text)
               (\s a -> s { _instanceProfile = a } :: EmrClusterEc2Attributes s)

instance P.HasKeyName (EmrClusterEc2Attributes s) (TF.Attr s P.Text) where
    keyName =
        P.lens (_keyName :: EmrClusterEc2Attributes s -> TF.Attr s P.Text)
               (\s a -> s { _keyName = a } :: EmrClusterEc2Attributes s)

instance P.HasServiceAccessSecurityGroup (EmrClusterEc2Attributes s) (TF.Attr s P.Text) where
    serviceAccessSecurityGroup =
        P.lens (_serviceAccessSecurityGroup :: EmrClusterEc2Attributes s -> TF.Attr s P.Text)
               (\s a -> s { _serviceAccessSecurityGroup = a } :: EmrClusterEc2Attributes s)

instance P.HasSubnetId (EmrClusterEc2Attributes s) (TF.Attr s P.Text) where
    subnetId =
        P.lens (_subnetId :: EmrClusterEc2Attributes s -> TF.Attr s P.Text)
               (\s a -> s { _subnetId = a } :: EmrClusterEc2Attributes s)

-- | @autoscaling_policy_target_tracking_configuration@ nested settings.
data AutoscalingPolicyTargetTrackingConfiguration s = AutoscalingPolicyTargetTrackingConfiguration'
    { _customizedMetricSpecification :: TF.Attr s (TargetTrackingConfigurationCustomizedMetricSpecification s)
    -- ^ @customized_metric_specification@ - (Optional)
    --
    -- Conflicts with:
    --
    -- * 'predefinedMetricSpecification'
    , _disableScaleIn :: TF.Attr s P.Bool
    -- ^ @disable_scale_in@ - (Optional)
    --
    , _predefinedMetricSpecification :: TF.Attr s (TargetTrackingConfigurationPredefinedMetricSpecification s)
    -- ^ @predefined_metric_specification@ - (Optional)
    --
    -- Conflicts with:
    --
    -- * 'customizedMetricSpecification'
    , _targetValue :: TF.Attr s P.Double
    -- ^ @target_value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAutoscalingPolicyTargetTrackingConfiguration
    :: TF.Attr s P.Double -- ^ @target_value@ - 'P.targetValue'
    -> AutoscalingPolicyTargetTrackingConfiguration s
newAutoscalingPolicyTargetTrackingConfiguration _targetValue =
    AutoscalingPolicyTargetTrackingConfiguration'
        { _customizedMetricSpecification = TF.Nil
        , _disableScaleIn = TF.value P.False
        , _predefinedMetricSpecification = TF.Nil
        , _targetValue = _targetValue
        }

instance P.Hashable  (AutoscalingPolicyTargetTrackingConfiguration s)
instance TF.IsValue  (AutoscalingPolicyTargetTrackingConfiguration s)
instance TF.IsObject (AutoscalingPolicyTargetTrackingConfiguration s) where
    toObject AutoscalingPolicyTargetTrackingConfiguration'{..} = P.catMaybes
        [ TF.assign "customized_metric_specification" <$> TF.attribute _customizedMetricSpecification
        , TF.assign "disable_scale_in" <$> TF.attribute _disableScaleIn
        , TF.assign "predefined_metric_specification" <$> TF.attribute _predefinedMetricSpecification
        , TF.assign "target_value" <$> TF.attribute _targetValue
        ]

instance TF.IsValid (AutoscalingPolicyTargetTrackingConfiguration s) where
    validator = TF.fieldsValidator (\AutoscalingPolicyTargetTrackingConfiguration'{..} -> Map.fromList $ P.catMaybes
        [ if (_customizedMetricSpecification P.== TF.Nil)
              then P.Nothing
              else P.Just ("_customizedMetricSpecification",
                            [ "_predefinedMetricSpecification"
                            ])
        , if (_predefinedMetricSpecification P.== TF.Nil)
              then P.Nothing
              else P.Just ("_predefinedMetricSpecification",
                            [ "_customizedMetricSpecification"
                            ])
        ])
           P.<> TF.settingsValidator "_customizedMetricSpecification"
                  (_customizedMetricSpecification
                      :: AutoscalingPolicyTargetTrackingConfiguration s -> TF.Attr s (TargetTrackingConfigurationCustomizedMetricSpecification s))
                  TF.validator
           P.<> TF.settingsValidator "_predefinedMetricSpecification"
                  (_predefinedMetricSpecification
                      :: AutoscalingPolicyTargetTrackingConfiguration s -> TF.Attr s (TargetTrackingConfigurationPredefinedMetricSpecification s))
                  TF.validator

instance P.HasCustomizedMetricSpecification (AutoscalingPolicyTargetTrackingConfiguration s) (TF.Attr s (TargetTrackingConfigurationCustomizedMetricSpecification s)) where
    customizedMetricSpecification =
        P.lens (_customizedMetricSpecification :: AutoscalingPolicyTargetTrackingConfiguration s -> TF.Attr s (TargetTrackingConfigurationCustomizedMetricSpecification s))
               (\s a -> s { _customizedMetricSpecification = a } :: AutoscalingPolicyTargetTrackingConfiguration s)

instance P.HasDisableScaleIn (AutoscalingPolicyTargetTrackingConfiguration s) (TF.Attr s P.Bool) where
    disableScaleIn =
        P.lens (_disableScaleIn :: AutoscalingPolicyTargetTrackingConfiguration s -> TF.Attr s P.Bool)
               (\s a -> s { _disableScaleIn = a } :: AutoscalingPolicyTargetTrackingConfiguration s)

instance P.HasPredefinedMetricSpecification (AutoscalingPolicyTargetTrackingConfiguration s) (TF.Attr s (TargetTrackingConfigurationPredefinedMetricSpecification s)) where
    predefinedMetricSpecification =
        P.lens (_predefinedMetricSpecification :: AutoscalingPolicyTargetTrackingConfiguration s -> TF.Attr s (TargetTrackingConfigurationPredefinedMetricSpecification s))
               (\s a -> s { _predefinedMetricSpecification = a } :: AutoscalingPolicyTargetTrackingConfiguration s)

instance P.HasTargetValue (AutoscalingPolicyTargetTrackingConfiguration s) (TF.Attr s P.Double) where
    targetValue =
        P.lens (_targetValue :: AutoscalingPolicyTargetTrackingConfiguration s -> TF.Attr s P.Double)
               (\s a -> s { _targetValue = a } :: AutoscalingPolicyTargetTrackingConfiguration s)

-- | @route53_record_alias@ nested settings.
data Route53RecordAlias s = Route53RecordAlias'
    { _evaluateTargetHealth :: TF.Attr s P.Bool
    -- ^ @evaluate_target_health@ - (Required)
    --
    , _name                 :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _zoneId               :: TF.Attr s P.Text
    -- ^ @zone_id@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRoute53RecordAlias
    :: TF.Attr s P.Bool -- ^ @evaluate_target_health@ - 'P.evaluateTargetHealth'
    -> TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @zone_id@ - 'P.zoneId'
    -> Route53RecordAlias s
newRoute53RecordAlias _evaluateTargetHealth _name _zoneId =
    Route53RecordAlias'
        { _evaluateTargetHealth = _evaluateTargetHealth
        , _name = _name
        , _zoneId = _zoneId
        }

instance P.Hashable  (Route53RecordAlias s)
instance TF.IsValue  (Route53RecordAlias s)
instance TF.IsObject (Route53RecordAlias s) where
    toObject Route53RecordAlias'{..} = P.catMaybes
        [ TF.assign "evaluate_target_health" <$> TF.attribute _evaluateTargetHealth
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "zone_id" <$> TF.attribute _zoneId
        ]

instance TF.IsValid (Route53RecordAlias s) where
    validator = P.mempty

instance P.HasEvaluateTargetHealth (Route53RecordAlias s) (TF.Attr s P.Bool) where
    evaluateTargetHealth =
        P.lens (_evaluateTargetHealth :: Route53RecordAlias s -> TF.Attr s P.Bool)
               (\s a -> s { _evaluateTargetHealth = a } :: Route53RecordAlias s)

instance P.HasName (Route53RecordAlias s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: Route53RecordAlias s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: Route53RecordAlias s)

instance P.HasZoneId (Route53RecordAlias s) (TF.Attr s P.Text) where
    zoneId =
        P.lens (_zoneId :: Route53RecordAlias s -> TF.Attr s P.Text)
               (\s a -> s { _zoneId = a } :: Route53RecordAlias s)

-- | @opsworks_haproxy_layer_ebs_volume@ nested settings.
data OpsworksHaproxyLayerEbsVolume s = OpsworksHaproxyLayerEbsVolume'
    { _iops          :: TF.Attr s P.Integer
    -- ^ @iops@ - (Optional)
    --
    , _mountPoint    :: TF.Attr s P.Text
    -- ^ @mount_point@ - (Required)
    --
    , _numberOfDisks :: TF.Attr s P.Integer
    -- ^ @number_of_disks@ - (Required)
    --
    , _raidLevel     :: TF.Attr s P.Text
    -- ^ @raid_level@ - (Optional)
    --
    , _size          :: TF.Attr s P.Integer
    -- ^ @size@ - (Required)
    --
    , _type'         :: TF.Attr s P.Text
    -- ^ @type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newOpsworksHaproxyLayerEbsVolume
    :: TF.Attr s P.Text -- ^ @mount_point@ - 'P.mountPoint'
    -> TF.Attr s P.Integer -- ^ @number_of_disks@ - 'P.numberOfDisks'
    -> TF.Attr s P.Integer -- ^ @size@ - 'P.size'
    -> OpsworksHaproxyLayerEbsVolume s
newOpsworksHaproxyLayerEbsVolume _mountPoint _numberOfDisks _size =
    OpsworksHaproxyLayerEbsVolume'
        { _iops = TF.value 0
        , _mountPoint = _mountPoint
        , _numberOfDisks = _numberOfDisks
        , _raidLevel = TF.Nil
        , _size = _size
        , _type' = TF.value "standard"
        }

instance P.Hashable  (OpsworksHaproxyLayerEbsVolume s)
instance TF.IsValue  (OpsworksHaproxyLayerEbsVolume s)
instance TF.IsObject (OpsworksHaproxyLayerEbsVolume s) where
    toObject OpsworksHaproxyLayerEbsVolume'{..} = P.catMaybes
        [ TF.assign "iops" <$> TF.attribute _iops
        , TF.assign "mount_point" <$> TF.attribute _mountPoint
        , TF.assign "number_of_disks" <$> TF.attribute _numberOfDisks
        , TF.assign "raid_level" <$> TF.attribute _raidLevel
        , TF.assign "size" <$> TF.attribute _size
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (OpsworksHaproxyLayerEbsVolume s) where
    validator = P.mempty

instance P.HasIops (OpsworksHaproxyLayerEbsVolume s) (TF.Attr s P.Integer) where
    iops =
        P.lens (_iops :: OpsworksHaproxyLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _iops = a } :: OpsworksHaproxyLayerEbsVolume s)

instance P.HasMountPoint (OpsworksHaproxyLayerEbsVolume s) (TF.Attr s P.Text) where
    mountPoint =
        P.lens (_mountPoint :: OpsworksHaproxyLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _mountPoint = a } :: OpsworksHaproxyLayerEbsVolume s)

instance P.HasNumberOfDisks (OpsworksHaproxyLayerEbsVolume s) (TF.Attr s P.Integer) where
    numberOfDisks =
        P.lens (_numberOfDisks :: OpsworksHaproxyLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _numberOfDisks = a } :: OpsworksHaproxyLayerEbsVolume s)

instance P.HasRaidLevel (OpsworksHaproxyLayerEbsVolume s) (TF.Attr s P.Text) where
    raidLevel =
        P.lens (_raidLevel :: OpsworksHaproxyLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _raidLevel = a } :: OpsworksHaproxyLayerEbsVolume s)

instance P.HasSize (OpsworksHaproxyLayerEbsVolume s) (TF.Attr s P.Integer) where
    size =
        P.lens (_size :: OpsworksHaproxyLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _size = a } :: OpsworksHaproxyLayerEbsVolume s)

instance P.HasType' (OpsworksHaproxyLayerEbsVolume s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: OpsworksHaproxyLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: OpsworksHaproxyLayerEbsVolume s)

-- | @api_gateway_rest_api_endpoint_configuration@ nested settings.
data ApiGatewayRestApiEndpointConfiguration s = ApiGatewayRestApiEndpointConfiguration'
    { _types :: TF.Attr s P.Text
    -- ^ @types@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newApiGatewayRestApiEndpointConfiguration
    :: TF.Attr s P.Text -- ^ @types@ - 'P.types'
    -> ApiGatewayRestApiEndpointConfiguration s
newApiGatewayRestApiEndpointConfiguration _types =
    ApiGatewayRestApiEndpointConfiguration'
        { _types = _types
        }

instance P.Hashable  (ApiGatewayRestApiEndpointConfiguration s)
instance TF.IsValue  (ApiGatewayRestApiEndpointConfiguration s)
instance TF.IsObject (ApiGatewayRestApiEndpointConfiguration s) where
    toObject ApiGatewayRestApiEndpointConfiguration'{..} = P.catMaybes
        [ TF.assign "types" <$> TF.attribute _types
        ]

instance TF.IsValid (ApiGatewayRestApiEndpointConfiguration s) where
    validator = P.mempty

instance P.HasTypes (ApiGatewayRestApiEndpointConfiguration s) (TF.Attr s P.Text) where
    types =
        P.lens (_types :: ApiGatewayRestApiEndpointConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _types = a } :: ApiGatewayRestApiEndpointConfiguration s)

-- | @lambda_function_tracing_config@ nested settings.
data LambdaFunctionTracingConfig s = LambdaFunctionTracingConfig'
    { _mode :: TF.Attr s P.Text
    -- ^ @mode@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLambdaFunctionTracingConfig
    :: TF.Attr s P.Text -- ^ @mode@ - 'P.mode'
    -> LambdaFunctionTracingConfig s
newLambdaFunctionTracingConfig _mode =
    LambdaFunctionTracingConfig'
        { _mode = _mode
        }

instance P.Hashable  (LambdaFunctionTracingConfig s)
instance TF.IsValue  (LambdaFunctionTracingConfig s)
instance TF.IsObject (LambdaFunctionTracingConfig s) where
    toObject LambdaFunctionTracingConfig'{..} = P.catMaybes
        [ TF.assign "mode" <$> TF.attribute _mode
        ]

instance TF.IsValid (LambdaFunctionTracingConfig s) where
    validator = P.mempty

instance P.HasMode (LambdaFunctionTracingConfig s) (TF.Attr s P.Text) where
    mode =
        P.lens (_mode :: LambdaFunctionTracingConfig s -> TF.Attr s P.Text)
               (\s a -> s { _mode = a } :: LambdaFunctionTracingConfig s)

instance s ~ s' => P.HasComputedMode (TF.Ref s' (LambdaFunctionTracingConfig s)) (TF.Attr s P.Text) where
    computedMode x = TF.compute (TF.refKey x) "mode"

-- | @ami_block_device_mappings@ nested settings.
data AmiBlockDeviceMappings s = AmiBlockDeviceMappings'
    deriving (P.Show, P.Eq, P.Generic)

newAmiBlockDeviceMappings
    :: AmiBlockDeviceMappings s
newAmiBlockDeviceMappings =
    AmiBlockDeviceMappings'

instance P.Hashable  (AmiBlockDeviceMappings s)
instance TF.IsValue  (AmiBlockDeviceMappings s)
instance TF.IsObject (AmiBlockDeviceMappings s) where
    toObject AmiBlockDeviceMappings' = []

instance TF.IsValid (AmiBlockDeviceMappings s) where
    validator = P.mempty

instance s ~ s' => P.HasComputedDeviceName (TF.Ref s' (AmiBlockDeviceMappings s)) (TF.Attr s P.Text) where
    computedDeviceName x = TF.compute (TF.refKey x) "device_name"

instance s ~ s' => P.HasComputedEbs (TF.Ref s' (AmiBlockDeviceMappings s)) (TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))) where
    computedEbs x = TF.compute (TF.refKey x) "ebs"

instance s ~ s' => P.HasComputedNoDevice (TF.Ref s' (AmiBlockDeviceMappings s)) (TF.Attr s P.Text) where
    computedNoDevice x = TF.compute (TF.refKey x) "no_device"

instance s ~ s' => P.HasComputedVirtualName (TF.Ref s' (AmiBlockDeviceMappings s)) (TF.Attr s P.Text) where
    computedVirtualName x = TF.compute (TF.refKey x) "virtual_name"

-- | @splunk_configuration_cloudwatch_logging_options@ nested settings.
data SplunkConfigurationCloudwatchLoggingOptions s = SplunkConfigurationCloudwatchLoggingOptions'
    { _enabled       :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Optional)
    --
    , _logGroupName  :: TF.Attr s P.Text
    -- ^ @log_group_name@ - (Optional)
    --
    , _logStreamName :: TF.Attr s P.Text
    -- ^ @log_stream_name@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSplunkConfigurationCloudwatchLoggingOptions
    :: SplunkConfigurationCloudwatchLoggingOptions s
newSplunkConfigurationCloudwatchLoggingOptions =
    SplunkConfigurationCloudwatchLoggingOptions'
        { _enabled = TF.value P.False
        , _logGroupName = TF.Nil
        , _logStreamName = TF.Nil
        }

instance P.Hashable  (SplunkConfigurationCloudwatchLoggingOptions s)
instance TF.IsValue  (SplunkConfigurationCloudwatchLoggingOptions s)
instance TF.IsObject (SplunkConfigurationCloudwatchLoggingOptions s) where
    toObject SplunkConfigurationCloudwatchLoggingOptions'{..} = P.catMaybes
        [ TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "log_group_name" <$> TF.attribute _logGroupName
        , TF.assign "log_stream_name" <$> TF.attribute _logStreamName
        ]

instance TF.IsValid (SplunkConfigurationCloudwatchLoggingOptions s) where
    validator = P.mempty

instance P.HasEnabled (SplunkConfigurationCloudwatchLoggingOptions s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: SplunkConfigurationCloudwatchLoggingOptions s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: SplunkConfigurationCloudwatchLoggingOptions s)

instance P.HasLogGroupName (SplunkConfigurationCloudwatchLoggingOptions s) (TF.Attr s P.Text) where
    logGroupName =
        P.lens (_logGroupName :: SplunkConfigurationCloudwatchLoggingOptions s -> TF.Attr s P.Text)
               (\s a -> s { _logGroupName = a } :: SplunkConfigurationCloudwatchLoggingOptions s)

instance P.HasLogStreamName (SplunkConfigurationCloudwatchLoggingOptions s) (TF.Attr s P.Text) where
    logStreamName =
        P.lens (_logStreamName :: SplunkConfigurationCloudwatchLoggingOptions s -> TF.Attr s P.Text)
               (\s a -> s { _logStreamName = a } :: SplunkConfigurationCloudwatchLoggingOptions s)

-- | @dynamodb_table_attribute@ nested settings.
data DynamodbTableAttribute s = DynamodbTableAttribute'
    { _name  :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _type' :: TF.Attr s P.DynamodbTableAttributeType
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDynamodbTableAttribute
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.DynamodbTableAttributeType -- ^ @type@ - 'P.type''
    -> DynamodbTableAttribute s
newDynamodbTableAttribute _name _type' =
    DynamodbTableAttribute'
        { _name = _name
        , _type' = _type'
        }

instance P.Hashable  (DynamodbTableAttribute s)
instance TF.IsValue  (DynamodbTableAttribute s)
instance TF.IsObject (DynamodbTableAttribute s) where
    toObject DynamodbTableAttribute'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (DynamodbTableAttribute s) where
    validator = P.mempty

instance P.HasName (DynamodbTableAttribute s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: DynamodbTableAttribute s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: DynamodbTableAttribute s)

instance P.HasType' (DynamodbTableAttribute s) (TF.Attr s P.DynamodbTableAttributeType) where
    type' =
        P.lens (_type' :: DynamodbTableAttribute s -> TF.Attr s P.DynamodbTableAttributeType)
               (\s a -> s { _type' = a } :: DynamodbTableAttribute s)

instance s ~ s' => P.HasComputedName (TF.Ref s' (DynamodbTableAttribute s)) (TF.Attr s P.Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance s ~ s' => P.HasComputedType (TF.Ref s' (DynamodbTableAttribute s)) (TF.Attr s P.DynamodbTableAttributeType) where
    computedType x = TF.compute (TF.refKey x) "type"

-- | @gamelift_build_storage_location@ nested settings.
data GameliftBuildStorageLocation s = GameliftBuildStorageLocation'
    { _bucket  :: TF.Attr s P.Text
    -- ^ @bucket@ - (Required, Forces New)
    --
    , _key     :: TF.Attr s P.Text
    -- ^ @key@ - (Required, Forces New)
    --
    , _roleArn :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newGameliftBuildStorageLocation
    :: TF.Attr s P.Text -- ^ @bucket@ - 'P.bucket'
    -> TF.Attr s P.Text -- ^ @key@ - 'P.key'
    -> TF.Attr s P.Text -- ^ @role_arn@ - 'P.roleArn'
    -> GameliftBuildStorageLocation s
newGameliftBuildStorageLocation _bucket _key _roleArn =
    GameliftBuildStorageLocation'
        { _bucket = _bucket
        , _key = _key
        , _roleArn = _roleArn
        }

instance P.Hashable  (GameliftBuildStorageLocation s)
instance TF.IsValue  (GameliftBuildStorageLocation s)
instance TF.IsObject (GameliftBuildStorageLocation s) where
    toObject GameliftBuildStorageLocation'{..} = P.catMaybes
        [ TF.assign "bucket" <$> TF.attribute _bucket
        , TF.assign "key" <$> TF.attribute _key
        , TF.assign "role_arn" <$> TF.attribute _roleArn
        ]

instance TF.IsValid (GameliftBuildStorageLocation s) where
    validator = P.mempty

instance P.HasBucket (GameliftBuildStorageLocation s) (TF.Attr s P.Text) where
    bucket =
        P.lens (_bucket :: GameliftBuildStorageLocation s -> TF.Attr s P.Text)
               (\s a -> s { _bucket = a } :: GameliftBuildStorageLocation s)

instance P.HasKey (GameliftBuildStorageLocation s) (TF.Attr s P.Text) where
    key =
        P.lens (_key :: GameliftBuildStorageLocation s -> TF.Attr s P.Text)
               (\s a -> s { _key = a } :: GameliftBuildStorageLocation s)

instance P.HasRoleArn (GameliftBuildStorageLocation s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: GameliftBuildStorageLocation s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: GameliftBuildStorageLocation s)

-- | @customized_metric_specification_dimensions@ nested settings.
data CustomizedMetricSpecificationDimensions s = CustomizedMetricSpecificationDimensions'
    { _name  :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _value :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCustomizedMetricSpecificationDimensions
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> CustomizedMetricSpecificationDimensions s
newCustomizedMetricSpecificationDimensions _name _value =
    CustomizedMetricSpecificationDimensions'
        { _name = _name
        , _value = _value
        }

instance P.Hashable  (CustomizedMetricSpecificationDimensions s)
instance TF.IsValue  (CustomizedMetricSpecificationDimensions s)
instance TF.IsObject (CustomizedMetricSpecificationDimensions s) where
    toObject CustomizedMetricSpecificationDimensions'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (CustomizedMetricSpecificationDimensions s) where
    validator = P.mempty

instance P.HasName (CustomizedMetricSpecificationDimensions s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: CustomizedMetricSpecificationDimensions s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: CustomizedMetricSpecificationDimensions s)

instance P.HasValue (CustomizedMetricSpecificationDimensions s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: CustomizedMetricSpecificationDimensions s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: CustomizedMetricSpecificationDimensions s)

-- | @dynamodb_global_table_replica@ nested settings.
data DynamodbGlobalTableReplica s = DynamodbGlobalTableReplica'
    { _regionName :: TF.Attr s P.Text
    -- ^ @region_name@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDynamodbGlobalTableReplica
    :: TF.Attr s P.Text -- ^ @region_name@ - 'P.regionName'
    -> DynamodbGlobalTableReplica s
newDynamodbGlobalTableReplica _regionName =
    DynamodbGlobalTableReplica'
        { _regionName = _regionName
        }

instance P.Hashable  (DynamodbGlobalTableReplica s)
instance TF.IsValue  (DynamodbGlobalTableReplica s)
instance TF.IsObject (DynamodbGlobalTableReplica s) where
    toObject DynamodbGlobalTableReplica'{..} = P.catMaybes
        [ TF.assign "region_name" <$> TF.attribute _regionName
        ]

instance TF.IsValid (DynamodbGlobalTableReplica s) where
    validator = P.mempty

instance P.HasRegionName (DynamodbGlobalTableReplica s) (TF.Attr s P.Text) where
    regionName =
        P.lens (_regionName :: DynamodbGlobalTableReplica s -> TF.Attr s P.Text)
               (\s a -> s { _regionName = a } :: DynamodbGlobalTableReplica s)

-- | @neptune_cluster_parameter_group_parameter@ nested settings.
data NeptuneClusterParameterGroupParameter s = NeptuneClusterParameterGroupParameter'
    { _applyMethod :: TF.Attr s P.Text
    -- ^ @apply_method@ - (Optional)
    --
    , _name        :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _value       :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newNeptuneClusterParameterGroupParameter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> NeptuneClusterParameterGroupParameter s
newNeptuneClusterParameterGroupParameter _name _value =
    NeptuneClusterParameterGroupParameter'
        { _applyMethod = TF.value "pending-reboot"
        , _name = _name
        , _value = _value
        }

instance P.Hashable  (NeptuneClusterParameterGroupParameter s)
instance TF.IsValue  (NeptuneClusterParameterGroupParameter s)
instance TF.IsObject (NeptuneClusterParameterGroupParameter s) where
    toObject NeptuneClusterParameterGroupParameter'{..} = P.catMaybes
        [ TF.assign "apply_method" <$> TF.attribute _applyMethod
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (NeptuneClusterParameterGroupParameter s) where
    validator = P.mempty

instance P.HasApplyMethod (NeptuneClusterParameterGroupParameter s) (TF.Attr s P.Text) where
    applyMethod =
        P.lens (_applyMethod :: NeptuneClusterParameterGroupParameter s -> TF.Attr s P.Text)
               (\s a -> s { _applyMethod = a } :: NeptuneClusterParameterGroupParameter s)

instance P.HasName (NeptuneClusterParameterGroupParameter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: NeptuneClusterParameterGroupParameter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: NeptuneClusterParameterGroupParameter s)

instance P.HasValue (NeptuneClusterParameterGroupParameter s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: NeptuneClusterParameterGroupParameter s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: NeptuneClusterParameterGroupParameter s)

-- | @glue_classifier_json_classifier@ nested settings.
data GlueClassifierJsonClassifier s = GlueClassifierJsonClassifier'
    { _jsonPath :: TF.Attr s P.Text
    -- ^ @json_path@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newGlueClassifierJsonClassifier
    :: TF.Attr s P.Text -- ^ @json_path@ - 'P.jsonPath'
    -> GlueClassifierJsonClassifier s
newGlueClassifierJsonClassifier _jsonPath =
    GlueClassifierJsonClassifier'
        { _jsonPath = _jsonPath
        }

instance P.Hashable  (GlueClassifierJsonClassifier s)
instance TF.IsValue  (GlueClassifierJsonClassifier s)
instance TF.IsObject (GlueClassifierJsonClassifier s) where
    toObject GlueClassifierJsonClassifier'{..} = P.catMaybes
        [ TF.assign "json_path" <$> TF.attribute _jsonPath
        ]

instance TF.IsValid (GlueClassifierJsonClassifier s) where
    validator = P.mempty

instance P.HasJsonPath (GlueClassifierJsonClassifier s) (TF.Attr s P.Text) where
    jsonPath =
        P.lens (_jsonPath :: GlueClassifierJsonClassifier s -> TF.Attr s P.Text)
               (\s a -> s { _jsonPath = a } :: GlueClassifierJsonClassifier s)

-- | @elasticsearch_domain_cluster_config@ nested settings.
data ElasticsearchDomainClusterConfig s = ElasticsearchDomainClusterConfig'
    { _dedicatedMasterCount   :: TF.Attr s P.Integer
    -- ^ @dedicated_master_count@ - (Optional)
    --
    , _dedicatedMasterEnabled :: TF.Attr s P.Bool
    -- ^ @dedicated_master_enabled@ - (Optional)
    --
    , _dedicatedMasterType    :: TF.Attr s P.Text
    -- ^ @dedicated_master_type@ - (Optional)
    --
    , _instanceCount          :: TF.Attr s P.Integer
    -- ^ @instance_count@ - (Optional)
    --
    , _instanceType           :: TF.Attr s P.Text
    -- ^ @instance_type@ - (Optional)
    --
    , _zoneAwarenessEnabled   :: TF.Attr s P.Bool
    -- ^ @zone_awareness_enabled@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElasticsearchDomainClusterConfig
    :: ElasticsearchDomainClusterConfig s
newElasticsearchDomainClusterConfig =
    ElasticsearchDomainClusterConfig'
        { _dedicatedMasterCount = TF.Nil
        , _dedicatedMasterEnabled = TF.value P.False
        , _dedicatedMasterType = TF.Nil
        , _instanceCount = TF.value 1
        , _instanceType = TF.value "m3.medium.elasticsearch"
        , _zoneAwarenessEnabled = TF.Nil
        }

instance P.Hashable  (ElasticsearchDomainClusterConfig s)
instance TF.IsValue  (ElasticsearchDomainClusterConfig s)
instance TF.IsObject (ElasticsearchDomainClusterConfig s) where
    toObject ElasticsearchDomainClusterConfig'{..} = P.catMaybes
        [ TF.assign "dedicated_master_count" <$> TF.attribute _dedicatedMasterCount
        , TF.assign "dedicated_master_enabled" <$> TF.attribute _dedicatedMasterEnabled
        , TF.assign "dedicated_master_type" <$> TF.attribute _dedicatedMasterType
        , TF.assign "instance_count" <$> TF.attribute _instanceCount
        , TF.assign "instance_type" <$> TF.attribute _instanceType
        , TF.assign "zone_awareness_enabled" <$> TF.attribute _zoneAwarenessEnabled
        ]

instance TF.IsValid (ElasticsearchDomainClusterConfig s) where
    validator = P.mempty

instance P.HasDedicatedMasterCount (ElasticsearchDomainClusterConfig s) (TF.Attr s P.Integer) where
    dedicatedMasterCount =
        P.lens (_dedicatedMasterCount :: ElasticsearchDomainClusterConfig s -> TF.Attr s P.Integer)
               (\s a -> s { _dedicatedMasterCount = a } :: ElasticsearchDomainClusterConfig s)

instance P.HasDedicatedMasterEnabled (ElasticsearchDomainClusterConfig s) (TF.Attr s P.Bool) where
    dedicatedMasterEnabled =
        P.lens (_dedicatedMasterEnabled :: ElasticsearchDomainClusterConfig s -> TF.Attr s P.Bool)
               (\s a -> s { _dedicatedMasterEnabled = a } :: ElasticsearchDomainClusterConfig s)

instance P.HasDedicatedMasterType (ElasticsearchDomainClusterConfig s) (TF.Attr s P.Text) where
    dedicatedMasterType =
        P.lens (_dedicatedMasterType :: ElasticsearchDomainClusterConfig s -> TF.Attr s P.Text)
               (\s a -> s { _dedicatedMasterType = a } :: ElasticsearchDomainClusterConfig s)

instance P.HasInstanceCount (ElasticsearchDomainClusterConfig s) (TF.Attr s P.Integer) where
    instanceCount =
        P.lens (_instanceCount :: ElasticsearchDomainClusterConfig s -> TF.Attr s P.Integer)
               (\s a -> s { _instanceCount = a } :: ElasticsearchDomainClusterConfig s)

instance P.HasInstanceType (ElasticsearchDomainClusterConfig s) (TF.Attr s P.Text) where
    instanceType =
        P.lens (_instanceType :: ElasticsearchDomainClusterConfig s -> TF.Attr s P.Text)
               (\s a -> s { _instanceType = a } :: ElasticsearchDomainClusterConfig s)

instance P.HasZoneAwarenessEnabled (ElasticsearchDomainClusterConfig s) (TF.Attr s P.Bool) where
    zoneAwarenessEnabled =
        P.lens (_zoneAwarenessEnabled :: ElasticsearchDomainClusterConfig s -> TF.Attr s P.Bool)
               (\s a -> s { _zoneAwarenessEnabled = a } :: ElasticsearchDomainClusterConfig s)

-- | @wafregional_byte_match_set_byte_match_tuples@ nested settings.
data WafregionalByteMatchSetByteMatchTuples s = WafregionalByteMatchSetByteMatchTuples'
    { _fieldToMatch         :: TF.Attr s (ByteMatchTuplesFieldToMatch s)
    -- ^ @field_to_match@ - (Required)
    --
    , _positionalConstraint :: TF.Attr s P.Text
    -- ^ @positional_constraint@ - (Required)
    --
    , _targetString         :: TF.Attr s P.Text
    -- ^ @target_string@ - (Optional)
    --
    , _textTransformation   :: TF.Attr s P.Text
    -- ^ @text_transformation@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafregionalByteMatchSetByteMatchTuples
    :: TF.Attr s (ByteMatchTuplesFieldToMatch s) -- ^ @field_to_match@ - 'P.fieldToMatch'
    -> TF.Attr s P.Text -- ^ @positional_constraint@ - 'P.positionalConstraint'
    -> TF.Attr s P.Text -- ^ @text_transformation@ - 'P.textTransformation'
    -> WafregionalByteMatchSetByteMatchTuples s
newWafregionalByteMatchSetByteMatchTuples _fieldToMatch _positionalConstraint _textTransformation =
    WafregionalByteMatchSetByteMatchTuples'
        { _fieldToMatch = _fieldToMatch
        , _positionalConstraint = _positionalConstraint
        , _targetString = TF.Nil
        , _textTransformation = _textTransformation
        }

instance P.Hashable  (WafregionalByteMatchSetByteMatchTuples s)
instance TF.IsValue  (WafregionalByteMatchSetByteMatchTuples s)
instance TF.IsObject (WafregionalByteMatchSetByteMatchTuples s) where
    toObject WafregionalByteMatchSetByteMatchTuples'{..} = P.catMaybes
        [ TF.assign "field_to_match" <$> TF.attribute _fieldToMatch
        , TF.assign "positional_constraint" <$> TF.attribute _positionalConstraint
        , TF.assign "target_string" <$> TF.attribute _targetString
        , TF.assign "text_transformation" <$> TF.attribute _textTransformation
        ]

instance TF.IsValid (WafregionalByteMatchSetByteMatchTuples s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_fieldToMatch"
                  (_fieldToMatch
                      :: WafregionalByteMatchSetByteMatchTuples s -> TF.Attr s (ByteMatchTuplesFieldToMatch s))
                  TF.validator

instance P.HasFieldToMatch (WafregionalByteMatchSetByteMatchTuples s) (TF.Attr s (ByteMatchTuplesFieldToMatch s)) where
    fieldToMatch =
        P.lens (_fieldToMatch :: WafregionalByteMatchSetByteMatchTuples s -> TF.Attr s (ByteMatchTuplesFieldToMatch s))
               (\s a -> s { _fieldToMatch = a } :: WafregionalByteMatchSetByteMatchTuples s)

instance P.HasPositionalConstraint (WafregionalByteMatchSetByteMatchTuples s) (TF.Attr s P.Text) where
    positionalConstraint =
        P.lens (_positionalConstraint :: WafregionalByteMatchSetByteMatchTuples s -> TF.Attr s P.Text)
               (\s a -> s { _positionalConstraint = a } :: WafregionalByteMatchSetByteMatchTuples s)

instance P.HasTargetString (WafregionalByteMatchSetByteMatchTuples s) (TF.Attr s P.Text) where
    targetString =
        P.lens (_targetString :: WafregionalByteMatchSetByteMatchTuples s -> TF.Attr s P.Text)
               (\s a -> s { _targetString = a } :: WafregionalByteMatchSetByteMatchTuples s)

instance P.HasTextTransformation (WafregionalByteMatchSetByteMatchTuples s) (TF.Attr s P.Text) where
    textTransformation =
        P.lens (_textTransformation :: WafregionalByteMatchSetByteMatchTuples s -> TF.Attr s P.Text)
               (\s a -> s { _textTransformation = a } :: WafregionalByteMatchSetByteMatchTuples s)

-- | @cognito_user_pool_schema@ nested settings.
data CognitoUserPoolSchema s = CognitoUserPoolSchema'
    { _attributeDataType :: TF.Attr s P.Text
    -- ^ @attribute_data_type@ - (Required, Forces New)
    --
    , _developerOnlyAttribute :: TF.Attr s P.Bool
    -- ^ @developer_only_attribute@ - (Optional, Forces New)
    --
    , _mutable :: TF.Attr s P.Bool
    -- ^ @mutable@ - (Optional, Forces New)
    --
    , _name :: TF.Attr s P.Text
    -- ^ @name@ - (Required, Forces New)
    --
    , _numberAttributeConstraints :: TF.Attr s (SchemaNumberAttributeConstraints s)
    -- ^ @number_attribute_constraints@ - (Optional, Forces New)
    --
    , _required :: TF.Attr s P.Bool
    -- ^ @required@ - (Optional, Forces New)
    --
    , _stringAttributeConstraints :: TF.Attr s (SchemaStringAttributeConstraints s)
    -- ^ @string_attribute_constraints@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCognitoUserPoolSchema
    :: TF.Attr s P.Text -- ^ @attribute_data_type@ - 'P.attributeDataType'
    -> TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> CognitoUserPoolSchema s
newCognitoUserPoolSchema _attributeDataType _name =
    CognitoUserPoolSchema'
        { _attributeDataType = _attributeDataType
        , _developerOnlyAttribute = TF.Nil
        , _mutable = TF.Nil
        , _name = _name
        , _numberAttributeConstraints = TF.Nil
        , _required = TF.Nil
        , _stringAttributeConstraints = TF.Nil
        }

instance P.Hashable  (CognitoUserPoolSchema s)
instance TF.IsValue  (CognitoUserPoolSchema s)
instance TF.IsObject (CognitoUserPoolSchema s) where
    toObject CognitoUserPoolSchema'{..} = P.catMaybes
        [ TF.assign "attribute_data_type" <$> TF.attribute _attributeDataType
        , TF.assign "developer_only_attribute" <$> TF.attribute _developerOnlyAttribute
        , TF.assign "mutable" <$> TF.attribute _mutable
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "number_attribute_constraints" <$> TF.attribute _numberAttributeConstraints
        , TF.assign "required" <$> TF.attribute _required
        , TF.assign "string_attribute_constraints" <$> TF.attribute _stringAttributeConstraints
        ]

instance TF.IsValid (CognitoUserPoolSchema s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_numberAttributeConstraints"
                  (_numberAttributeConstraints
                      :: CognitoUserPoolSchema s -> TF.Attr s (SchemaNumberAttributeConstraints s))
                  TF.validator
           P.<> TF.settingsValidator "_stringAttributeConstraints"
                  (_stringAttributeConstraints
                      :: CognitoUserPoolSchema s -> TF.Attr s (SchemaStringAttributeConstraints s))
                  TF.validator

instance P.HasAttributeDataType (CognitoUserPoolSchema s) (TF.Attr s P.Text) where
    attributeDataType =
        P.lens (_attributeDataType :: CognitoUserPoolSchema s -> TF.Attr s P.Text)
               (\s a -> s { _attributeDataType = a } :: CognitoUserPoolSchema s)

instance P.HasDeveloperOnlyAttribute (CognitoUserPoolSchema s) (TF.Attr s P.Bool) where
    developerOnlyAttribute =
        P.lens (_developerOnlyAttribute :: CognitoUserPoolSchema s -> TF.Attr s P.Bool)
               (\s a -> s { _developerOnlyAttribute = a } :: CognitoUserPoolSchema s)

instance P.HasMutable (CognitoUserPoolSchema s) (TF.Attr s P.Bool) where
    mutable =
        P.lens (_mutable :: CognitoUserPoolSchema s -> TF.Attr s P.Bool)
               (\s a -> s { _mutable = a } :: CognitoUserPoolSchema s)

instance P.HasName (CognitoUserPoolSchema s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: CognitoUserPoolSchema s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: CognitoUserPoolSchema s)

instance P.HasNumberAttributeConstraints (CognitoUserPoolSchema s) (TF.Attr s (SchemaNumberAttributeConstraints s)) where
    numberAttributeConstraints =
        P.lens (_numberAttributeConstraints :: CognitoUserPoolSchema s -> TF.Attr s (SchemaNumberAttributeConstraints s))
               (\s a -> s { _numberAttributeConstraints = a } :: CognitoUserPoolSchema s)

instance P.HasRequired (CognitoUserPoolSchema s) (TF.Attr s P.Bool) where
    required =
        P.lens (_required :: CognitoUserPoolSchema s -> TF.Attr s P.Bool)
               (\s a -> s { _required = a } :: CognitoUserPoolSchema s)

instance P.HasStringAttributeConstraints (CognitoUserPoolSchema s) (TF.Attr s (SchemaStringAttributeConstraints s)) where
    stringAttributeConstraints =
        P.lens (_stringAttributeConstraints :: CognitoUserPoolSchema s -> TF.Attr s (SchemaStringAttributeConstraints s))
               (\s a -> s { _stringAttributeConstraints = a } :: CognitoUserPoolSchema s)

-- | @iot_topic_rule_sns@ nested settings.
data IotTopicRuleSns s = IotTopicRuleSns'
    { _messageFormat :: TF.Attr s P.Text
    -- ^ @message_format@ - (Optional)
    --
    , _roleArn       :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Required)
    --
    , _targetArn     :: TF.Attr s P.Text
    -- ^ @target_arn@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newIotTopicRuleSns
    :: TF.Attr s P.Text -- ^ @role_arn@ - 'P.roleArn'
    -> TF.Attr s P.Text -- ^ @target_arn@ - 'P.targetArn'
    -> IotTopicRuleSns s
newIotTopicRuleSns _roleArn _targetArn =
    IotTopicRuleSns'
        { _messageFormat = TF.value "RAW"
        , _roleArn = _roleArn
        , _targetArn = _targetArn
        }

instance P.Hashable  (IotTopicRuleSns s)
instance TF.IsValue  (IotTopicRuleSns s)
instance TF.IsObject (IotTopicRuleSns s) where
    toObject IotTopicRuleSns'{..} = P.catMaybes
        [ TF.assign "message_format" <$> TF.attribute _messageFormat
        , TF.assign "role_arn" <$> TF.attribute _roleArn
        , TF.assign "target_arn" <$> TF.attribute _targetArn
        ]

instance TF.IsValid (IotTopicRuleSns s) where
    validator = P.mempty

instance P.HasMessageFormat (IotTopicRuleSns s) (TF.Attr s P.Text) where
    messageFormat =
        P.lens (_messageFormat :: IotTopicRuleSns s -> TF.Attr s P.Text)
               (\s a -> s { _messageFormat = a } :: IotTopicRuleSns s)

instance P.HasRoleArn (IotTopicRuleSns s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: IotTopicRuleSns s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: IotTopicRuleSns s)

instance P.HasTargetArn (IotTopicRuleSns s) (TF.Attr s P.Text) where
    targetArn =
        P.lens (_targetArn :: IotTopicRuleSns s -> TF.Attr s P.Text)
               (\s a -> s { _targetArn = a } :: IotTopicRuleSns s)

-- | @opsworks_memcached_layer_ebs_volume@ nested settings.
data OpsworksMemcachedLayerEbsVolume s = OpsworksMemcachedLayerEbsVolume'
    { _iops          :: TF.Attr s P.Integer
    -- ^ @iops@ - (Optional)
    --
    , _mountPoint    :: TF.Attr s P.Text
    -- ^ @mount_point@ - (Required)
    --
    , _numberOfDisks :: TF.Attr s P.Integer
    -- ^ @number_of_disks@ - (Required)
    --
    , _raidLevel     :: TF.Attr s P.Text
    -- ^ @raid_level@ - (Optional)
    --
    , _size          :: TF.Attr s P.Integer
    -- ^ @size@ - (Required)
    --
    , _type'         :: TF.Attr s P.Text
    -- ^ @type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newOpsworksMemcachedLayerEbsVolume
    :: TF.Attr s P.Text -- ^ @mount_point@ - 'P.mountPoint'
    -> TF.Attr s P.Integer -- ^ @number_of_disks@ - 'P.numberOfDisks'
    -> TF.Attr s P.Integer -- ^ @size@ - 'P.size'
    -> OpsworksMemcachedLayerEbsVolume s
newOpsworksMemcachedLayerEbsVolume _mountPoint _numberOfDisks _size =
    OpsworksMemcachedLayerEbsVolume'
        { _iops = TF.value 0
        , _mountPoint = _mountPoint
        , _numberOfDisks = _numberOfDisks
        , _raidLevel = TF.Nil
        , _size = _size
        , _type' = TF.value "standard"
        }

instance P.Hashable  (OpsworksMemcachedLayerEbsVolume s)
instance TF.IsValue  (OpsworksMemcachedLayerEbsVolume s)
instance TF.IsObject (OpsworksMemcachedLayerEbsVolume s) where
    toObject OpsworksMemcachedLayerEbsVolume'{..} = P.catMaybes
        [ TF.assign "iops" <$> TF.attribute _iops
        , TF.assign "mount_point" <$> TF.attribute _mountPoint
        , TF.assign "number_of_disks" <$> TF.attribute _numberOfDisks
        , TF.assign "raid_level" <$> TF.attribute _raidLevel
        , TF.assign "size" <$> TF.attribute _size
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (OpsworksMemcachedLayerEbsVolume s) where
    validator = P.mempty

instance P.HasIops (OpsworksMemcachedLayerEbsVolume s) (TF.Attr s P.Integer) where
    iops =
        P.lens (_iops :: OpsworksMemcachedLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _iops = a } :: OpsworksMemcachedLayerEbsVolume s)

instance P.HasMountPoint (OpsworksMemcachedLayerEbsVolume s) (TF.Attr s P.Text) where
    mountPoint =
        P.lens (_mountPoint :: OpsworksMemcachedLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _mountPoint = a } :: OpsworksMemcachedLayerEbsVolume s)

instance P.HasNumberOfDisks (OpsworksMemcachedLayerEbsVolume s) (TF.Attr s P.Integer) where
    numberOfDisks =
        P.lens (_numberOfDisks :: OpsworksMemcachedLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _numberOfDisks = a } :: OpsworksMemcachedLayerEbsVolume s)

instance P.HasRaidLevel (OpsworksMemcachedLayerEbsVolume s) (TF.Attr s P.Text) where
    raidLevel =
        P.lens (_raidLevel :: OpsworksMemcachedLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _raidLevel = a } :: OpsworksMemcachedLayerEbsVolume s)

instance P.HasSize (OpsworksMemcachedLayerEbsVolume s) (TF.Attr s P.Integer) where
    size =
        P.lens (_size :: OpsworksMemcachedLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _size = a } :: OpsworksMemcachedLayerEbsVolume s)

instance P.HasType' (OpsworksMemcachedLayerEbsVolume s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: OpsworksMemcachedLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: OpsworksMemcachedLayerEbsVolume s)

-- | @iot_topic_rule_dynamodb@ nested settings.
data IotTopicRuleDynamodb s = IotTopicRuleDynamodb'
    { _hashKeyField  :: TF.Attr s P.Text
    -- ^ @hash_key_field@ - (Required)
    --
    , _hashKeyType   :: TF.Attr s P.Text
    -- ^ @hash_key_type@ - (Optional)
    --
    , _hashKeyValue  :: TF.Attr s P.Text
    -- ^ @hash_key_value@ - (Required)
    --
    , _payloadField  :: TF.Attr s P.Text
    -- ^ @payload_field@ - (Optional)
    --
    , _rangeKeyField :: TF.Attr s P.Text
    -- ^ @range_key_field@ - (Required)
    --
    , _rangeKeyType  :: TF.Attr s P.Text
    -- ^ @range_key_type@ - (Optional)
    --
    , _rangeKeyValue :: TF.Attr s P.Text
    -- ^ @range_key_value@ - (Required)
    --
    , _roleArn       :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Required)
    --
    , _tableName     :: TF.Attr s P.Text
    -- ^ @table_name@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newIotTopicRuleDynamodb
    :: TF.Attr s P.Text -- ^ @hash_key_field@ - 'P.hashKeyField'
    -> TF.Attr s P.Text -- ^ @hash_key_value@ - 'P.hashKeyValue'
    -> TF.Attr s P.Text -- ^ @range_key_field@ - 'P.rangeKeyField'
    -> TF.Attr s P.Text -- ^ @range_key_value@ - 'P.rangeKeyValue'
    -> TF.Attr s P.Text -- ^ @role_arn@ - 'P.roleArn'
    -> TF.Attr s P.Text -- ^ @table_name@ - 'P.tableName'
    -> IotTopicRuleDynamodb s
newIotTopicRuleDynamodb _hashKeyField _hashKeyValue _rangeKeyField _rangeKeyValue _roleArn _tableName =
    IotTopicRuleDynamodb'
        { _hashKeyField = _hashKeyField
        , _hashKeyType = TF.Nil
        , _hashKeyValue = _hashKeyValue
        , _payloadField = TF.Nil
        , _rangeKeyField = _rangeKeyField
        , _rangeKeyType = TF.Nil
        , _rangeKeyValue = _rangeKeyValue
        , _roleArn = _roleArn
        , _tableName = _tableName
        }

instance P.Hashable  (IotTopicRuleDynamodb s)
instance TF.IsValue  (IotTopicRuleDynamodb s)
instance TF.IsObject (IotTopicRuleDynamodb s) where
    toObject IotTopicRuleDynamodb'{..} = P.catMaybes
        [ TF.assign "hash_key_field" <$> TF.attribute _hashKeyField
        , TF.assign "hash_key_type" <$> TF.attribute _hashKeyType
        , TF.assign "hash_key_value" <$> TF.attribute _hashKeyValue
        , TF.assign "payload_field" <$> TF.attribute _payloadField
        , TF.assign "range_key_field" <$> TF.attribute _rangeKeyField
        , TF.assign "range_key_type" <$> TF.attribute _rangeKeyType
        , TF.assign "range_key_value" <$> TF.attribute _rangeKeyValue
        , TF.assign "role_arn" <$> TF.attribute _roleArn
        , TF.assign "table_name" <$> TF.attribute _tableName
        ]

instance TF.IsValid (IotTopicRuleDynamodb s) where
    validator = P.mempty

instance P.HasHashKeyField (IotTopicRuleDynamodb s) (TF.Attr s P.Text) where
    hashKeyField =
        P.lens (_hashKeyField :: IotTopicRuleDynamodb s -> TF.Attr s P.Text)
               (\s a -> s { _hashKeyField = a } :: IotTopicRuleDynamodb s)

instance P.HasHashKeyType (IotTopicRuleDynamodb s) (TF.Attr s P.Text) where
    hashKeyType =
        P.lens (_hashKeyType :: IotTopicRuleDynamodb s -> TF.Attr s P.Text)
               (\s a -> s { _hashKeyType = a } :: IotTopicRuleDynamodb s)

instance P.HasHashKeyValue (IotTopicRuleDynamodb s) (TF.Attr s P.Text) where
    hashKeyValue =
        P.lens (_hashKeyValue :: IotTopicRuleDynamodb s -> TF.Attr s P.Text)
               (\s a -> s { _hashKeyValue = a } :: IotTopicRuleDynamodb s)

instance P.HasPayloadField (IotTopicRuleDynamodb s) (TF.Attr s P.Text) where
    payloadField =
        P.lens (_payloadField :: IotTopicRuleDynamodb s -> TF.Attr s P.Text)
               (\s a -> s { _payloadField = a } :: IotTopicRuleDynamodb s)

instance P.HasRangeKeyField (IotTopicRuleDynamodb s) (TF.Attr s P.Text) where
    rangeKeyField =
        P.lens (_rangeKeyField :: IotTopicRuleDynamodb s -> TF.Attr s P.Text)
               (\s a -> s { _rangeKeyField = a } :: IotTopicRuleDynamodb s)

instance P.HasRangeKeyType (IotTopicRuleDynamodb s) (TF.Attr s P.Text) where
    rangeKeyType =
        P.lens (_rangeKeyType :: IotTopicRuleDynamodb s -> TF.Attr s P.Text)
               (\s a -> s { _rangeKeyType = a } :: IotTopicRuleDynamodb s)

instance P.HasRangeKeyValue (IotTopicRuleDynamodb s) (TF.Attr s P.Text) where
    rangeKeyValue =
        P.lens (_rangeKeyValue :: IotTopicRuleDynamodb s -> TF.Attr s P.Text)
               (\s a -> s { _rangeKeyValue = a } :: IotTopicRuleDynamodb s)

instance P.HasRoleArn (IotTopicRuleDynamodb s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: IotTopicRuleDynamodb s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: IotTopicRuleDynamodb s)

instance P.HasTableName (IotTopicRuleDynamodb s) (TF.Attr s P.Text) where
    tableName =
        P.lens (_tableName :: IotTopicRuleDynamodb s -> TF.Attr s P.Text)
               (\s a -> s { _tableName = a } :: IotTopicRuleDynamodb s)

-- | @subnet_filter@ nested settings.
data SubnetFilter s = SubnetFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSubnetFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> SubnetFilter s
newSubnetFilter _name _values =
    SubnetFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (SubnetFilter s)
instance TF.IsValue  (SubnetFilter s)
instance TF.IsObject (SubnetFilter s) where
    toObject SubnetFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (SubnetFilter s) where
    validator = P.mempty

instance P.HasName (SubnetFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: SubnetFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: SubnetFilter s)

instance P.HasValues (SubnetFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: SubnetFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: SubnetFilter s)

-- | @cognito_user_pool_lambda_config@ nested settings.
data CognitoUserPoolLambdaConfig s = CognitoUserPoolLambdaConfig'
    { _createAuthChallenge         :: TF.Attr s P.Text
    -- ^ @create_auth_challenge@ - (Optional)
    --
    , _customMessage               :: TF.Attr s P.Text
    -- ^ @custom_message@ - (Optional)
    --
    , _defineAuthChallenge         :: TF.Attr s P.Text
    -- ^ @define_auth_challenge@ - (Optional)
    --
    , _postAuthentication          :: TF.Attr s P.Text
    -- ^ @post_authentication@ - (Optional)
    --
    , _postConfirmation            :: TF.Attr s P.Text
    -- ^ @post_confirmation@ - (Optional)
    --
    , _preAuthentication           :: TF.Attr s P.Text
    -- ^ @pre_authentication@ - (Optional)
    --
    , _preSignUp                   :: TF.Attr s P.Text
    -- ^ @pre_sign_up@ - (Optional)
    --
    , _preTokenGeneration          :: TF.Attr s P.Text
    -- ^ @pre_token_generation@ - (Optional)
    --
    , _userMigration               :: TF.Attr s P.Text
    -- ^ @user_migration@ - (Optional)
    --
    , _verifyAuthChallengeResponse :: TF.Attr s P.Text
    -- ^ @verify_auth_challenge_response@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCognitoUserPoolLambdaConfig
    :: CognitoUserPoolLambdaConfig s
newCognitoUserPoolLambdaConfig =
    CognitoUserPoolLambdaConfig'
        { _createAuthChallenge = TF.Nil
        , _customMessage = TF.Nil
        , _defineAuthChallenge = TF.Nil
        , _postAuthentication = TF.Nil
        , _postConfirmation = TF.Nil
        , _preAuthentication = TF.Nil
        , _preSignUp = TF.Nil
        , _preTokenGeneration = TF.Nil
        , _userMigration = TF.Nil
        , _verifyAuthChallengeResponse = TF.Nil
        }

instance P.Hashable  (CognitoUserPoolLambdaConfig s)
instance TF.IsValue  (CognitoUserPoolLambdaConfig s)
instance TF.IsObject (CognitoUserPoolLambdaConfig s) where
    toObject CognitoUserPoolLambdaConfig'{..} = P.catMaybes
        [ TF.assign "create_auth_challenge" <$> TF.attribute _createAuthChallenge
        , TF.assign "custom_message" <$> TF.attribute _customMessage
        , TF.assign "define_auth_challenge" <$> TF.attribute _defineAuthChallenge
        , TF.assign "post_authentication" <$> TF.attribute _postAuthentication
        , TF.assign "post_confirmation" <$> TF.attribute _postConfirmation
        , TF.assign "pre_authentication" <$> TF.attribute _preAuthentication
        , TF.assign "pre_sign_up" <$> TF.attribute _preSignUp
        , TF.assign "pre_token_generation" <$> TF.attribute _preTokenGeneration
        , TF.assign "user_migration" <$> TF.attribute _userMigration
        , TF.assign "verify_auth_challenge_response" <$> TF.attribute _verifyAuthChallengeResponse
        ]

instance TF.IsValid (CognitoUserPoolLambdaConfig s) where
    validator = P.mempty

instance P.HasCreateAuthChallenge (CognitoUserPoolLambdaConfig s) (TF.Attr s P.Text) where
    createAuthChallenge =
        P.lens (_createAuthChallenge :: CognitoUserPoolLambdaConfig s -> TF.Attr s P.Text)
               (\s a -> s { _createAuthChallenge = a } :: CognitoUserPoolLambdaConfig s)

instance P.HasCustomMessage (CognitoUserPoolLambdaConfig s) (TF.Attr s P.Text) where
    customMessage =
        P.lens (_customMessage :: CognitoUserPoolLambdaConfig s -> TF.Attr s P.Text)
               (\s a -> s { _customMessage = a } :: CognitoUserPoolLambdaConfig s)

instance P.HasDefineAuthChallenge (CognitoUserPoolLambdaConfig s) (TF.Attr s P.Text) where
    defineAuthChallenge =
        P.lens (_defineAuthChallenge :: CognitoUserPoolLambdaConfig s -> TF.Attr s P.Text)
               (\s a -> s { _defineAuthChallenge = a } :: CognitoUserPoolLambdaConfig s)

instance P.HasPostAuthentication (CognitoUserPoolLambdaConfig s) (TF.Attr s P.Text) where
    postAuthentication =
        P.lens (_postAuthentication :: CognitoUserPoolLambdaConfig s -> TF.Attr s P.Text)
               (\s a -> s { _postAuthentication = a } :: CognitoUserPoolLambdaConfig s)

instance P.HasPostConfirmation (CognitoUserPoolLambdaConfig s) (TF.Attr s P.Text) where
    postConfirmation =
        P.lens (_postConfirmation :: CognitoUserPoolLambdaConfig s -> TF.Attr s P.Text)
               (\s a -> s { _postConfirmation = a } :: CognitoUserPoolLambdaConfig s)

instance P.HasPreAuthentication (CognitoUserPoolLambdaConfig s) (TF.Attr s P.Text) where
    preAuthentication =
        P.lens (_preAuthentication :: CognitoUserPoolLambdaConfig s -> TF.Attr s P.Text)
               (\s a -> s { _preAuthentication = a } :: CognitoUserPoolLambdaConfig s)

instance P.HasPreSignUp (CognitoUserPoolLambdaConfig s) (TF.Attr s P.Text) where
    preSignUp =
        P.lens (_preSignUp :: CognitoUserPoolLambdaConfig s -> TF.Attr s P.Text)
               (\s a -> s { _preSignUp = a } :: CognitoUserPoolLambdaConfig s)

instance P.HasPreTokenGeneration (CognitoUserPoolLambdaConfig s) (TF.Attr s P.Text) where
    preTokenGeneration =
        P.lens (_preTokenGeneration :: CognitoUserPoolLambdaConfig s -> TF.Attr s P.Text)
               (\s a -> s { _preTokenGeneration = a } :: CognitoUserPoolLambdaConfig s)

instance P.HasUserMigration (CognitoUserPoolLambdaConfig s) (TF.Attr s P.Text) where
    userMigration =
        P.lens (_userMigration :: CognitoUserPoolLambdaConfig s -> TF.Attr s P.Text)
               (\s a -> s { _userMigration = a } :: CognitoUserPoolLambdaConfig s)

instance P.HasVerifyAuthChallengeResponse (CognitoUserPoolLambdaConfig s) (TF.Attr s P.Text) where
    verifyAuthChallengeResponse =
        P.lens (_verifyAuthChallengeResponse :: CognitoUserPoolLambdaConfig s -> TF.Attr s P.Text)
               (\s a -> s { _verifyAuthChallengeResponse = a } :: CognitoUserPoolLambdaConfig s)

-- | @ses_event_destination_sns_destination@ nested settings.
data SesEventDestinationSnsDestination s = SesEventDestinationSnsDestination'
    { _topicArn :: TF.Attr s P.Text
    -- ^ @topic_arn@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSesEventDestinationSnsDestination
    :: TF.Attr s P.Text -- ^ @topic_arn@ - 'P.topicArn'
    -> SesEventDestinationSnsDestination s
newSesEventDestinationSnsDestination _topicArn =
    SesEventDestinationSnsDestination'
        { _topicArn = _topicArn
        }

instance P.Hashable  (SesEventDestinationSnsDestination s)
instance TF.IsValue  (SesEventDestinationSnsDestination s)
instance TF.IsObject (SesEventDestinationSnsDestination s) where
    toObject SesEventDestinationSnsDestination'{..} = P.catMaybes
        [ TF.assign "topic_arn" <$> TF.attribute _topicArn
        ]

instance TF.IsValid (SesEventDestinationSnsDestination s) where
    validator = P.mempty

instance P.HasTopicArn (SesEventDestinationSnsDestination s) (TF.Attr s P.Text) where
    topicArn =
        P.lens (_topicArn :: SesEventDestinationSnsDestination s -> TF.Attr s P.Text)
               (\s a -> s { _topicArn = a } :: SesEventDestinationSnsDestination s)

-- | @assume_role@ nested settings.
data AssumeRole = AssumeRole'
    { _externalId  :: P.Maybe P.Text
    -- ^ @external_id@ - (Optional)
    -- The external ID to use when assuming the role. If omitted, no external ID is
    -- passed to the AssumeRole call.
    --
    , _policy      :: P.Maybe P.Document
    -- ^ @policy@ - (Optional)
    -- The permissions applied when assuming a role. You cannot use, this policy to
    -- grant further permissions that are in excess to those of the,  role that is
    -- being assumed.
    --
    , _roleArn     :: P.Maybe P.Text
    -- ^ @role_arn@ - (Optional)
    -- The ARN of an IAM role to assume prior to making API calls.
    --
    , _sessionName :: P.Maybe P.Text
    -- ^ @session_name@ - (Optional)
    -- The session name to use when assuming the role. If omitted, no session name
    -- is passed to the AssumeRole call.
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAssumeRole
    :: AssumeRole
newAssumeRole =
    AssumeRole'
        { _externalId = P.Nothing
        , _policy = P.Nothing
        , _roleArn = P.Nothing
        , _sessionName = P.Nothing
        }

instance P.Hashable  (AssumeRole)
instance TF.IsValue  (AssumeRole)
instance TF.IsObject (AssumeRole) where
    toObject AssumeRole'{..} = P.catMaybes
        [ TF.assign "external_id" <$> _externalId
        , TF.assign "policy" <$> _policy
        , TF.assign "role_arn" <$> _roleArn
        , TF.assign "session_name" <$> _sessionName
        ]

instance TF.IsValid (AssumeRole) where
    validator = P.mempty

instance P.HasExternalId (AssumeRole) (P.Maybe P.Text) where
    externalId =
        P.lens (_externalId :: AssumeRole -> P.Maybe P.Text)
               (\s a -> s { _externalId = a } :: AssumeRole)

instance P.HasPolicy (AssumeRole) (P.Maybe P.Document) where
    policy =
        P.lens (_policy :: AssumeRole -> P.Maybe P.Document)
               (\s a -> s { _policy = a } :: AssumeRole)

instance P.HasRoleArn (AssumeRole) (P.Maybe P.Text) where
    roleArn =
        P.lens (_roleArn :: AssumeRole -> P.Maybe P.Text)
               (\s a -> s { _roleArn = a } :: AssumeRole)

instance P.HasSessionName (AssumeRole) (P.Maybe P.Text) where
    sessionName =
        P.lens (_sessionName :: AssumeRole -> P.Maybe P.Text)
               (\s a -> s { _sessionName = a } :: AssumeRole)

-- | @elasticsearch_configuration_processing_configuration@ nested settings.
data ElasticsearchConfigurationProcessingConfiguration s = ElasticsearchConfigurationProcessingConfiguration'
    { _enabled    :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Optional)
    --
    , _processors :: TF.Attr s [TF.Attr s (ProcessingConfigurationProcessors s)]
    -- ^ @processors@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElasticsearchConfigurationProcessingConfiguration
    :: ElasticsearchConfigurationProcessingConfiguration s
newElasticsearchConfigurationProcessingConfiguration =
    ElasticsearchConfigurationProcessingConfiguration'
        { _enabled = TF.Nil
        , _processors = TF.Nil
        }

instance P.Hashable  (ElasticsearchConfigurationProcessingConfiguration s)
instance TF.IsValue  (ElasticsearchConfigurationProcessingConfiguration s)
instance TF.IsObject (ElasticsearchConfigurationProcessingConfiguration s) where
    toObject ElasticsearchConfigurationProcessingConfiguration'{..} = P.catMaybes
        [ TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "processors" <$> TF.attribute _processors
        ]

instance TF.IsValid (ElasticsearchConfigurationProcessingConfiguration s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_processors"
                  (_processors
                      :: ElasticsearchConfigurationProcessingConfiguration s -> TF.Attr s [TF.Attr s (ProcessingConfigurationProcessors s)])
                  TF.validator

instance P.HasEnabled (ElasticsearchConfigurationProcessingConfiguration s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: ElasticsearchConfigurationProcessingConfiguration s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: ElasticsearchConfigurationProcessingConfiguration s)

instance P.HasProcessors (ElasticsearchConfigurationProcessingConfiguration s) (TF.Attr s [TF.Attr s (ProcessingConfigurationProcessors s)]) where
    processors =
        P.lens (_processors :: ElasticsearchConfigurationProcessingConfiguration s -> TF.Attr s [TF.Attr s (ProcessingConfigurationProcessors s)])
               (\s a -> s { _processors = a } :: ElasticsearchConfigurationProcessingConfiguration s)

-- | @appsync_graphql_api_user_pool_config@ nested settings.
data AppsyncGraphqlApiUserPoolConfig s = AppsyncGraphqlApiUserPoolConfig'
    { _appIdClientRegex :: TF.Attr s P.Text
    -- ^ @app_id_client_regex@ - (Optional)
    --
    , _awsRegion        :: TF.Attr s P.Text
    -- ^ @aws_region@ - (Required)
    --
    , _defaultAction    :: TF.Attr s P.Text
    -- ^ @default_action@ - (Required)
    --
    , _userPoolId       :: TF.Attr s P.Text
    -- ^ @user_pool_id@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAppsyncGraphqlApiUserPoolConfig
    :: TF.Attr s P.Text -- ^ @aws_region@ - 'P.awsRegion'
    -> TF.Attr s P.Text -- ^ @default_action@ - 'P.defaultAction'
    -> TF.Attr s P.Text -- ^ @user_pool_id@ - 'P.userPoolId'
    -> AppsyncGraphqlApiUserPoolConfig s
newAppsyncGraphqlApiUserPoolConfig _awsRegion _defaultAction _userPoolId =
    AppsyncGraphqlApiUserPoolConfig'
        { _appIdClientRegex = TF.Nil
        , _awsRegion = _awsRegion
        , _defaultAction = _defaultAction
        , _userPoolId = _userPoolId
        }

instance P.Hashable  (AppsyncGraphqlApiUserPoolConfig s)
instance TF.IsValue  (AppsyncGraphqlApiUserPoolConfig s)
instance TF.IsObject (AppsyncGraphqlApiUserPoolConfig s) where
    toObject AppsyncGraphqlApiUserPoolConfig'{..} = P.catMaybes
        [ TF.assign "app_id_client_regex" <$> TF.attribute _appIdClientRegex
        , TF.assign "aws_region" <$> TF.attribute _awsRegion
        , TF.assign "default_action" <$> TF.attribute _defaultAction
        , TF.assign "user_pool_id" <$> TF.attribute _userPoolId
        ]

instance TF.IsValid (AppsyncGraphqlApiUserPoolConfig s) where
    validator = P.mempty

instance P.HasAppIdClientRegex (AppsyncGraphqlApiUserPoolConfig s) (TF.Attr s P.Text) where
    appIdClientRegex =
        P.lens (_appIdClientRegex :: AppsyncGraphqlApiUserPoolConfig s -> TF.Attr s P.Text)
               (\s a -> s { _appIdClientRegex = a } :: AppsyncGraphqlApiUserPoolConfig s)

instance P.HasAwsRegion (AppsyncGraphqlApiUserPoolConfig s) (TF.Attr s P.Text) where
    awsRegion =
        P.lens (_awsRegion :: AppsyncGraphqlApiUserPoolConfig s -> TF.Attr s P.Text)
               (\s a -> s { _awsRegion = a } :: AppsyncGraphqlApiUserPoolConfig s)

instance P.HasDefaultAction (AppsyncGraphqlApiUserPoolConfig s) (TF.Attr s P.Text) where
    defaultAction =
        P.lens (_defaultAction :: AppsyncGraphqlApiUserPoolConfig s -> TF.Attr s P.Text)
               (\s a -> s { _defaultAction = a } :: AppsyncGraphqlApiUserPoolConfig s)

instance P.HasUserPoolId (AppsyncGraphqlApiUserPoolConfig s) (TF.Attr s P.Text) where
    userPoolId =
        P.lens (_userPoolId :: AppsyncGraphqlApiUserPoolConfig s -> TF.Attr s P.Text)
               (\s a -> s { _userPoolId = a } :: AppsyncGraphqlApiUserPoolConfig s)

-- | @ses_receipt_rule_sns_action@ nested settings.
data SesReceiptRuleSnsAction s = SesReceiptRuleSnsAction'
    { _position :: TF.Attr s P.Integer
    -- ^ @position@ - (Required)
    --
    , _topicArn :: TF.Attr s P.Text
    -- ^ @topic_arn@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSesReceiptRuleSnsAction
    :: TF.Attr s P.Integer -- ^ @position@ - 'P.position'
    -> TF.Attr s P.Text -- ^ @topic_arn@ - 'P.topicArn'
    -> SesReceiptRuleSnsAction s
newSesReceiptRuleSnsAction _position _topicArn =
    SesReceiptRuleSnsAction'
        { _position = _position
        , _topicArn = _topicArn
        }

instance P.Hashable  (SesReceiptRuleSnsAction s)
instance TF.IsValue  (SesReceiptRuleSnsAction s)
instance TF.IsObject (SesReceiptRuleSnsAction s) where
    toObject SesReceiptRuleSnsAction'{..} = P.catMaybes
        [ TF.assign "position" <$> TF.attribute _position
        , TF.assign "topic_arn" <$> TF.attribute _topicArn
        ]

instance TF.IsValid (SesReceiptRuleSnsAction s) where
    validator = P.mempty

instance P.HasPosition (SesReceiptRuleSnsAction s) (TF.Attr s P.Integer) where
    position =
        P.lens (_position :: SesReceiptRuleSnsAction s -> TF.Attr s P.Integer)
               (\s a -> s { _position = a } :: SesReceiptRuleSnsAction s)

instance P.HasTopicArn (SesReceiptRuleSnsAction s) (TF.Attr s P.Text) where
    topicArn =
        P.lens (_topicArn :: SesReceiptRuleSnsAction s -> TF.Attr s P.Text)
               (\s a -> s { _topicArn = a } :: SesReceiptRuleSnsAction s)

-- | @instance_group_ebs_config@ nested settings.
data InstanceGroupEbsConfig s = InstanceGroupEbsConfig'
    { _iops               :: TF.Attr s P.Integer
    -- ^ @iops@ - (Optional)
    --
    , _size               :: TF.Attr s P.Integer
    -- ^ @size@ - (Required)
    --
    , _type'              :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    , _volumesPerInstance :: TF.Attr s P.Integer
    -- ^ @volumes_per_instance@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newInstanceGroupEbsConfig
    :: TF.Attr s P.Integer -- ^ @size@ - 'P.size'
    -> TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> InstanceGroupEbsConfig s
newInstanceGroupEbsConfig _size _type' =
    InstanceGroupEbsConfig'
        { _iops = TF.Nil
        , _size = _size
        , _type' = _type'
        , _volumesPerInstance = TF.value 1
        }

instance P.Hashable  (InstanceGroupEbsConfig s)
instance TF.IsValue  (InstanceGroupEbsConfig s)
instance TF.IsObject (InstanceGroupEbsConfig s) where
    toObject InstanceGroupEbsConfig'{..} = P.catMaybes
        [ TF.assign "iops" <$> TF.attribute _iops
        , TF.assign "size" <$> TF.attribute _size
        , TF.assign "type" <$> TF.attribute _type'
        , TF.assign "volumes_per_instance" <$> TF.attribute _volumesPerInstance
        ]

instance TF.IsValid (InstanceGroupEbsConfig s) where
    validator = P.mempty

instance P.HasIops (InstanceGroupEbsConfig s) (TF.Attr s P.Integer) where
    iops =
        P.lens (_iops :: InstanceGroupEbsConfig s -> TF.Attr s P.Integer)
               (\s a -> s { _iops = a } :: InstanceGroupEbsConfig s)

instance P.HasSize (InstanceGroupEbsConfig s) (TF.Attr s P.Integer) where
    size =
        P.lens (_size :: InstanceGroupEbsConfig s -> TF.Attr s P.Integer)
               (\s a -> s { _size = a } :: InstanceGroupEbsConfig s)

instance P.HasType' (InstanceGroupEbsConfig s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: InstanceGroupEbsConfig s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: InstanceGroupEbsConfig s)

instance P.HasVolumesPerInstance (InstanceGroupEbsConfig s) (TF.Attr s P.Integer) where
    volumesPerInstance =
        P.lens (_volumesPerInstance :: InstanceGroupEbsConfig s -> TF.Attr s P.Integer)
               (\s a -> s { _volumesPerInstance = a } :: InstanceGroupEbsConfig s)

-- | @autoscaling_group_launch_template@ nested settings.
data AutoscalingGroupLaunchTemplate s = AutoscalingGroupLaunchTemplate'
    { _version :: TF.Attr s P.Text
    -- ^ @version@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAutoscalingGroupLaunchTemplate
    :: AutoscalingGroupLaunchTemplate s
newAutoscalingGroupLaunchTemplate =
    AutoscalingGroupLaunchTemplate'
        { _version = TF.Nil
        }

instance P.Hashable  (AutoscalingGroupLaunchTemplate s)
instance TF.IsValue  (AutoscalingGroupLaunchTemplate s)
instance TF.IsObject (AutoscalingGroupLaunchTemplate s) where
    toObject AutoscalingGroupLaunchTemplate'{..} = P.catMaybes
        [ TF.assign "version" <$> TF.attribute _version
        ]

instance TF.IsValid (AutoscalingGroupLaunchTemplate s) where
    validator = P.mempty

instance P.HasVersion (AutoscalingGroupLaunchTemplate s) (TF.Attr s P.Text) where
    version =
        P.lens (_version :: AutoscalingGroupLaunchTemplate s -> TF.Attr s P.Text)
               (\s a -> s { _version = a } :: AutoscalingGroupLaunchTemplate s)

instance s ~ s' => P.HasComputedId (TF.Ref s' (AutoscalingGroupLaunchTemplate s)) (TF.Attr s P.Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance s ~ s' => P.HasComputedName (TF.Ref s' (AutoscalingGroupLaunchTemplate s)) (TF.Attr s P.Text) where
    computedName x = TF.compute (TF.refKey x) "name"

-- | @launch_specification_root_block_device@ nested settings.
data LaunchSpecificationRootBlockDevice s = LaunchSpecificationRootBlockDevice'
    { _deleteOnTermination :: TF.Attr s P.Bool
    -- ^ @delete_on_termination@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLaunchSpecificationRootBlockDevice
    :: LaunchSpecificationRootBlockDevice s
newLaunchSpecificationRootBlockDevice =
    LaunchSpecificationRootBlockDevice'
        { _deleteOnTermination = TF.value P.True
        }

instance P.Hashable  (LaunchSpecificationRootBlockDevice s)
instance TF.IsValue  (LaunchSpecificationRootBlockDevice s)
instance TF.IsObject (LaunchSpecificationRootBlockDevice s) where
    toObject LaunchSpecificationRootBlockDevice'{..} = P.catMaybes
        [ TF.assign "delete_on_termination" <$> TF.attribute _deleteOnTermination
        ]

instance TF.IsValid (LaunchSpecificationRootBlockDevice s) where
    validator = P.mempty

instance P.HasDeleteOnTermination (LaunchSpecificationRootBlockDevice s) (TF.Attr s P.Bool) where
    deleteOnTermination =
        P.lens (_deleteOnTermination :: LaunchSpecificationRootBlockDevice s -> TF.Attr s P.Bool)
               (\s a -> s { _deleteOnTermination = a } :: LaunchSpecificationRootBlockDevice s)

instance s ~ s' => P.HasComputedIops (TF.Ref s' (LaunchSpecificationRootBlockDevice s)) (TF.Attr s P.Integer) where
    computedIops x = TF.compute (TF.refKey x) "iops"

instance s ~ s' => P.HasComputedVolumeSize (TF.Ref s' (LaunchSpecificationRootBlockDevice s)) (TF.Attr s P.Integer) where
    computedVolumeSize x = TF.compute (TF.refKey x) "volume_size"

instance s ~ s' => P.HasComputedVolumeType (TF.Ref s' (LaunchSpecificationRootBlockDevice s)) (TF.Attr s P.Text) where
    computedVolumeType x = TF.compute (TF.refKey x) "volume_type"

-- | @lb_listener_rule_action@ nested settings.
data LbListenerRuleAction s = LbListenerRuleAction'
    { _targetGroupArn :: TF.Attr s P.Text
    -- ^ @target_group_arn@ - (Required)
    --
    , _type'          :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLbListenerRuleAction
    :: TF.Attr s P.Text -- ^ @target_group_arn@ - 'P.targetGroupArn'
    -> TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> LbListenerRuleAction s
newLbListenerRuleAction _targetGroupArn _type' =
    LbListenerRuleAction'
        { _targetGroupArn = _targetGroupArn
        , _type' = _type'
        }

instance P.Hashable  (LbListenerRuleAction s)
instance TF.IsValue  (LbListenerRuleAction s)
instance TF.IsObject (LbListenerRuleAction s) where
    toObject LbListenerRuleAction'{..} = P.catMaybes
        [ TF.assign "target_group_arn" <$> TF.attribute _targetGroupArn
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (LbListenerRuleAction s) where
    validator = P.mempty

instance P.HasTargetGroupArn (LbListenerRuleAction s) (TF.Attr s P.Text) where
    targetGroupArn =
        P.lens (_targetGroupArn :: LbListenerRuleAction s -> TF.Attr s P.Text)
               (\s a -> s { _targetGroupArn = a } :: LbListenerRuleAction s)

instance P.HasType' (LbListenerRuleAction s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: LbListenerRuleAction s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: LbListenerRuleAction s)

-- | @glue_crawler_dynamodb_target@ nested settings.
data GlueCrawlerDynamodbTarget s = GlueCrawlerDynamodbTarget'
    { _path :: TF.Attr s P.Text
    -- ^ @path@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newGlueCrawlerDynamodbTarget
    :: TF.Attr s P.Text -- ^ @path@ - 'P.path'
    -> GlueCrawlerDynamodbTarget s
newGlueCrawlerDynamodbTarget _path =
    GlueCrawlerDynamodbTarget'
        { _path = _path
        }

instance P.Hashable  (GlueCrawlerDynamodbTarget s)
instance TF.IsValue  (GlueCrawlerDynamodbTarget s)
instance TF.IsObject (GlueCrawlerDynamodbTarget s) where
    toObject GlueCrawlerDynamodbTarget'{..} = P.catMaybes
        [ TF.assign "path" <$> TF.attribute _path
        ]

instance TF.IsValid (GlueCrawlerDynamodbTarget s) where
    validator = P.mempty

instance P.HasPath (GlueCrawlerDynamodbTarget s) (TF.Attr s P.Text) where
    path =
        P.lens (_path :: GlueCrawlerDynamodbTarget s -> TF.Attr s P.Text)
               (\s a -> s { _path = a } :: GlueCrawlerDynamodbTarget s)

-- | @encryption_sse_kms@ nested settings.
data EncryptionSseKms s = EncryptionSseKms'
    { _keyId :: TF.Attr s P.Text
    -- ^ @key_id@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newEncryptionSseKms
    :: TF.Attr s P.Text -- ^ @key_id@ - 'P.keyId'
    -> EncryptionSseKms s
newEncryptionSseKms _keyId =
    EncryptionSseKms'
        { _keyId = _keyId
        }

instance P.Hashable  (EncryptionSseKms s)
instance TF.IsValue  (EncryptionSseKms s)
instance TF.IsObject (EncryptionSseKms s) where
    toObject EncryptionSseKms'{..} = P.catMaybes
        [ TF.assign "key_id" <$> TF.attribute _keyId
        ]

instance TF.IsValid (EncryptionSseKms s) where
    validator = P.mempty

instance P.HasKeyId (EncryptionSseKms s) (TF.Attr s P.Text) where
    keyId =
        P.lens (_keyId :: EncryptionSseKms s -> TF.Attr s P.Text)
               (\s a -> s { _keyId = a } :: EncryptionSseKms s)

-- | @opsworks_php_app_layer_ebs_volume@ nested settings.
data OpsworksPhpAppLayerEbsVolume s = OpsworksPhpAppLayerEbsVolume'
    { _iops          :: TF.Attr s P.Integer
    -- ^ @iops@ - (Optional)
    --
    , _mountPoint    :: TF.Attr s P.Text
    -- ^ @mount_point@ - (Required)
    --
    , _numberOfDisks :: TF.Attr s P.Integer
    -- ^ @number_of_disks@ - (Required)
    --
    , _raidLevel     :: TF.Attr s P.Text
    -- ^ @raid_level@ - (Optional)
    --
    , _size          :: TF.Attr s P.Integer
    -- ^ @size@ - (Required)
    --
    , _type'         :: TF.Attr s P.Text
    -- ^ @type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newOpsworksPhpAppLayerEbsVolume
    :: TF.Attr s P.Text -- ^ @mount_point@ - 'P.mountPoint'
    -> TF.Attr s P.Integer -- ^ @number_of_disks@ - 'P.numberOfDisks'
    -> TF.Attr s P.Integer -- ^ @size@ - 'P.size'
    -> OpsworksPhpAppLayerEbsVolume s
newOpsworksPhpAppLayerEbsVolume _mountPoint _numberOfDisks _size =
    OpsworksPhpAppLayerEbsVolume'
        { _iops = TF.value 0
        , _mountPoint = _mountPoint
        , _numberOfDisks = _numberOfDisks
        , _raidLevel = TF.Nil
        , _size = _size
        , _type' = TF.value "standard"
        }

instance P.Hashable  (OpsworksPhpAppLayerEbsVolume s)
instance TF.IsValue  (OpsworksPhpAppLayerEbsVolume s)
instance TF.IsObject (OpsworksPhpAppLayerEbsVolume s) where
    toObject OpsworksPhpAppLayerEbsVolume'{..} = P.catMaybes
        [ TF.assign "iops" <$> TF.attribute _iops
        , TF.assign "mount_point" <$> TF.attribute _mountPoint
        , TF.assign "number_of_disks" <$> TF.attribute _numberOfDisks
        , TF.assign "raid_level" <$> TF.attribute _raidLevel
        , TF.assign "size" <$> TF.attribute _size
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (OpsworksPhpAppLayerEbsVolume s) where
    validator = P.mempty

instance P.HasIops (OpsworksPhpAppLayerEbsVolume s) (TF.Attr s P.Integer) where
    iops =
        P.lens (_iops :: OpsworksPhpAppLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _iops = a } :: OpsworksPhpAppLayerEbsVolume s)

instance P.HasMountPoint (OpsworksPhpAppLayerEbsVolume s) (TF.Attr s P.Text) where
    mountPoint =
        P.lens (_mountPoint :: OpsworksPhpAppLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _mountPoint = a } :: OpsworksPhpAppLayerEbsVolume s)

instance P.HasNumberOfDisks (OpsworksPhpAppLayerEbsVolume s) (TF.Attr s P.Integer) where
    numberOfDisks =
        P.lens (_numberOfDisks :: OpsworksPhpAppLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _numberOfDisks = a } :: OpsworksPhpAppLayerEbsVolume s)

instance P.HasRaidLevel (OpsworksPhpAppLayerEbsVolume s) (TF.Attr s P.Text) where
    raidLevel =
        P.lens (_raidLevel :: OpsworksPhpAppLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _raidLevel = a } :: OpsworksPhpAppLayerEbsVolume s)

instance P.HasSize (OpsworksPhpAppLayerEbsVolume s) (TF.Attr s P.Integer) where
    size =
        P.lens (_size :: OpsworksPhpAppLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _size = a } :: OpsworksPhpAppLayerEbsVolume s)

instance P.HasType' (OpsworksPhpAppLayerEbsVolume s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: OpsworksPhpAppLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: OpsworksPhpAppLayerEbsVolume s)

-- | @gamelift_alias_routing_strategy@ nested settings.
data GameliftAliasRoutingStrategy s = GameliftAliasRoutingStrategy'
    { _fleetId :: TF.Attr s P.Text
    -- ^ @fleet_id@ - (Optional)
    --
    , _message :: TF.Attr s P.Text
    -- ^ @message@ - (Optional)
    --
    , _type'   :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newGameliftAliasRoutingStrategy
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> GameliftAliasRoutingStrategy s
newGameliftAliasRoutingStrategy _type' =
    GameliftAliasRoutingStrategy'
        { _fleetId = TF.Nil
        , _message = TF.Nil
        , _type' = _type'
        }

instance P.Hashable  (GameliftAliasRoutingStrategy s)
instance TF.IsValue  (GameliftAliasRoutingStrategy s)
instance TF.IsObject (GameliftAliasRoutingStrategy s) where
    toObject GameliftAliasRoutingStrategy'{..} = P.catMaybes
        [ TF.assign "fleet_id" <$> TF.attribute _fleetId
        , TF.assign "message" <$> TF.attribute _message
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (GameliftAliasRoutingStrategy s) where
    validator = P.mempty

instance P.HasFleetId (GameliftAliasRoutingStrategy s) (TF.Attr s P.Text) where
    fleetId =
        P.lens (_fleetId :: GameliftAliasRoutingStrategy s -> TF.Attr s P.Text)
               (\s a -> s { _fleetId = a } :: GameliftAliasRoutingStrategy s)

instance P.HasMessage (GameliftAliasRoutingStrategy s) (TF.Attr s P.Text) where
    message =
        P.lens (_message :: GameliftAliasRoutingStrategy s -> TF.Attr s P.Text)
               (\s a -> s { _message = a } :: GameliftAliasRoutingStrategy s)

instance P.HasType' (GameliftAliasRoutingStrategy s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: GameliftAliasRoutingStrategy s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: GameliftAliasRoutingStrategy s)

-- | @rule_action@ nested settings.
data RuleAction s = RuleAction'
    { _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRuleAction
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> RuleAction s
newRuleAction _type' =
    RuleAction'
        { _type' = _type'
        }

instance P.Hashable  (RuleAction s)
instance TF.IsValue  (RuleAction s)
instance TF.IsObject (RuleAction s) where
    toObject RuleAction'{..} = P.catMaybes
        [ TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (RuleAction s) where
    validator = P.mempty

instance P.HasType' (RuleAction s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: RuleAction s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: RuleAction s)

-- | @blue_green_deployment_config_deployment_ready_option@ nested settings.
data BlueGreenDeploymentConfigDeploymentReadyOption s = BlueGreenDeploymentConfigDeploymentReadyOption'
    { _actionOnTimeout   :: TF.Attr s P.Text
    -- ^ @action_on_timeout@ - (Optional)
    --
    , _waitTimeInMinutes :: TF.Attr s P.Integer
    -- ^ @wait_time_in_minutes@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newBlueGreenDeploymentConfigDeploymentReadyOption
    :: BlueGreenDeploymentConfigDeploymentReadyOption s
newBlueGreenDeploymentConfigDeploymentReadyOption =
    BlueGreenDeploymentConfigDeploymentReadyOption'
        { _actionOnTimeout = TF.Nil
        , _waitTimeInMinutes = TF.Nil
        }

instance P.Hashable  (BlueGreenDeploymentConfigDeploymentReadyOption s)
instance TF.IsValue  (BlueGreenDeploymentConfigDeploymentReadyOption s)
instance TF.IsObject (BlueGreenDeploymentConfigDeploymentReadyOption s) where
    toObject BlueGreenDeploymentConfigDeploymentReadyOption'{..} = P.catMaybes
        [ TF.assign "action_on_timeout" <$> TF.attribute _actionOnTimeout
        , TF.assign "wait_time_in_minutes" <$> TF.attribute _waitTimeInMinutes
        ]

instance TF.IsValid (BlueGreenDeploymentConfigDeploymentReadyOption s) where
    validator = P.mempty

instance P.HasActionOnTimeout (BlueGreenDeploymentConfigDeploymentReadyOption s) (TF.Attr s P.Text) where
    actionOnTimeout =
        P.lens (_actionOnTimeout :: BlueGreenDeploymentConfigDeploymentReadyOption s -> TF.Attr s P.Text)
               (\s a -> s { _actionOnTimeout = a } :: BlueGreenDeploymentConfigDeploymentReadyOption s)

instance P.HasWaitTimeInMinutes (BlueGreenDeploymentConfigDeploymentReadyOption s) (TF.Attr s P.Integer) where
    waitTimeInMinutes =
        P.lens (_waitTimeInMinutes :: BlueGreenDeploymentConfigDeploymentReadyOption s -> TF.Attr s P.Integer)
               (\s a -> s { _waitTimeInMinutes = a } :: BlueGreenDeploymentConfigDeploymentReadyOption s)

-- | @cognito_user_pool_verification_message_template@ nested settings.
data CognitoUserPoolVerificationMessageTemplate s = CognitoUserPoolVerificationMessageTemplate'
    { _defaultEmailOption :: TF.Attr s P.Text
    -- ^ @default_email_option@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCognitoUserPoolVerificationMessageTemplate
    :: CognitoUserPoolVerificationMessageTemplate s
newCognitoUserPoolVerificationMessageTemplate =
    CognitoUserPoolVerificationMessageTemplate'
        { _defaultEmailOption = TF.value "CONFIRM_WITH_CODE"
        }

instance P.Hashable  (CognitoUserPoolVerificationMessageTemplate s)
instance TF.IsValue  (CognitoUserPoolVerificationMessageTemplate s)
instance TF.IsObject (CognitoUserPoolVerificationMessageTemplate s) where
    toObject CognitoUserPoolVerificationMessageTemplate'{..} = P.catMaybes
        [ TF.assign "default_email_option" <$> TF.attribute _defaultEmailOption
        ]

instance TF.IsValid (CognitoUserPoolVerificationMessageTemplate s) where
    validator = P.mempty

instance P.HasDefaultEmailOption (CognitoUserPoolVerificationMessageTemplate s) (TF.Attr s P.Text) where
    defaultEmailOption =
        P.lens (_defaultEmailOption :: CognitoUserPoolVerificationMessageTemplate s -> TF.Attr s P.Text)
               (\s a -> s { _defaultEmailOption = a } :: CognitoUserPoolVerificationMessageTemplate s)

instance s ~ s' => P.HasComputedEmailMessage (TF.Ref s' (CognitoUserPoolVerificationMessageTemplate s)) (TF.Attr s P.Text) where
    computedEmailMessage x = TF.compute (TF.refKey x) "email_message"

instance s ~ s' => P.HasComputedEmailMessageByLink (TF.Ref s' (CognitoUserPoolVerificationMessageTemplate s)) (TF.Attr s P.Text) where
    computedEmailMessageByLink x = TF.compute (TF.refKey x) "email_message_by_link"

instance s ~ s' => P.HasComputedEmailSubject (TF.Ref s' (CognitoUserPoolVerificationMessageTemplate s)) (TF.Attr s P.Text) where
    computedEmailSubject x = TF.compute (TF.refKey x) "email_subject"

instance s ~ s' => P.HasComputedEmailSubjectByLink (TF.Ref s' (CognitoUserPoolVerificationMessageTemplate s)) (TF.Attr s P.Text) where
    computedEmailSubjectByLink x = TF.compute (TF.refKey x) "email_subject_by_link"

instance s ~ s' => P.HasComputedSmsMessage (TF.Ref s' (CognitoUserPoolVerificationMessageTemplate s)) (TF.Attr s P.Text) where
    computedSmsMessage x = TF.compute (TF.refKey x) "sms_message"

-- | @redshift_configuration_processing_configuration@ nested settings.
data RedshiftConfigurationProcessingConfiguration s = RedshiftConfigurationProcessingConfiguration'
    { _enabled    :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Optional)
    --
    , _processors :: TF.Attr s [TF.Attr s (ProcessingConfigurationProcessors s)]
    -- ^ @processors@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRedshiftConfigurationProcessingConfiguration
    :: RedshiftConfigurationProcessingConfiguration s
newRedshiftConfigurationProcessingConfiguration =
    RedshiftConfigurationProcessingConfiguration'
        { _enabled = TF.Nil
        , _processors = TF.Nil
        }

instance P.Hashable  (RedshiftConfigurationProcessingConfiguration s)
instance TF.IsValue  (RedshiftConfigurationProcessingConfiguration s)
instance TF.IsObject (RedshiftConfigurationProcessingConfiguration s) where
    toObject RedshiftConfigurationProcessingConfiguration'{..} = P.catMaybes
        [ TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "processors" <$> TF.attribute _processors
        ]

instance TF.IsValid (RedshiftConfigurationProcessingConfiguration s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_processors"
                  (_processors
                      :: RedshiftConfigurationProcessingConfiguration s -> TF.Attr s [TF.Attr s (ProcessingConfigurationProcessors s)])
                  TF.validator

instance P.HasEnabled (RedshiftConfigurationProcessingConfiguration s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: RedshiftConfigurationProcessingConfiguration s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: RedshiftConfigurationProcessingConfiguration s)

instance P.HasProcessors (RedshiftConfigurationProcessingConfiguration s) (TF.Attr s [TF.Attr s (ProcessingConfigurationProcessors s)]) where
    processors =
        P.lens (_processors :: RedshiftConfigurationProcessingConfiguration s -> TF.Attr s [TF.Attr s (ProcessingConfigurationProcessors s)])
               (\s a -> s { _processors = a } :: RedshiftConfigurationProcessingConfiguration s)

-- | @eks_cluster_vpc_config@ nested settings.
data EksClusterVpcConfig s = EksClusterVpcConfig'
    { _securityGroupIds :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @security_group_ids@ - (Optional, Forces New)
    --
    , _subnetIds        :: TF.Attr s (P.NonEmpty (TF.Attr s P.Text))
    -- ^ @subnet_ids@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newEksClusterVpcConfig
    :: TF.Attr s (P.NonEmpty (TF.Attr s P.Text)) -- ^ @subnet_ids@ - 'P.subnetIds'
    -> EksClusterVpcConfig s
newEksClusterVpcConfig _subnetIds =
    EksClusterVpcConfig'
        { _securityGroupIds = TF.Nil
        , _subnetIds = _subnetIds
        }

instance P.Hashable  (EksClusterVpcConfig s)
instance TF.IsValue  (EksClusterVpcConfig s)
instance TF.IsObject (EksClusterVpcConfig s) where
    toObject EksClusterVpcConfig'{..} = P.catMaybes
        [ TF.assign "security_group_ids" <$> TF.attribute _securityGroupIds
        , TF.assign "subnet_ids" <$> TF.attribute _subnetIds
        ]

instance TF.IsValid (EksClusterVpcConfig s) where
    validator = P.mempty

instance P.HasSecurityGroupIds (EksClusterVpcConfig s) (TF.Attr s [TF.Attr s P.Text]) where
    securityGroupIds =
        P.lens (_securityGroupIds :: EksClusterVpcConfig s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _securityGroupIds = a } :: EksClusterVpcConfig s)

instance P.HasSubnetIds (EksClusterVpcConfig s) (TF.Attr s (P.NonEmpty (TF.Attr s P.Text))) where
    subnetIds =
        P.lens (_subnetIds :: EksClusterVpcConfig s -> TF.Attr s (P.NonEmpty (TF.Attr s P.Text)))
               (\s a -> s { _subnetIds = a } :: EksClusterVpcConfig s)

instance s ~ s' => P.HasComputedVpcId (TF.Ref s' (EksClusterVpcConfig s)) (TF.Attr s P.Text) where
    computedVpcId x = TF.compute (TF.refKey x) "vpc_id"

instance s ~ s' => P.HasComputedSecurityGroupIds (TF.Ref s' (EksClusterVpcConfig s)) (TF.Attr s [TF.Attr s P.Text]) where
    computedSecurityGroupIds x = TF.compute (TF.refKey x) "security_group_ids"

instance s ~ s' => P.HasComputedSubnetIds (TF.Ref s' (EksClusterVpcConfig s)) (TF.Attr s [TF.Attr s P.Text]) where
    computedSubnetIds x = TF.compute (TF.refKey x) "subnet_ids"

-- | @wafregional_xss_match_set_xss_match_tuple@ nested settings.
data WafregionalXssMatchSetXssMatchTuple s = WafregionalXssMatchSetXssMatchTuple'
    { _fieldToMatch       :: TF.Attr s (XssMatchTupleFieldToMatch s)
    -- ^ @field_to_match@ - (Required)
    --
    , _textTransformation :: TF.Attr s P.Text
    -- ^ @text_transformation@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafregionalXssMatchSetXssMatchTuple
    :: TF.Attr s (XssMatchTupleFieldToMatch s) -- ^ @field_to_match@ - 'P.fieldToMatch'
    -> TF.Attr s P.Text -- ^ @text_transformation@ - 'P.textTransformation'
    -> WafregionalXssMatchSetXssMatchTuple s
newWafregionalXssMatchSetXssMatchTuple _fieldToMatch _textTransformation =
    WafregionalXssMatchSetXssMatchTuple'
        { _fieldToMatch = _fieldToMatch
        , _textTransformation = _textTransformation
        }

instance P.Hashable  (WafregionalXssMatchSetXssMatchTuple s)
instance TF.IsValue  (WafregionalXssMatchSetXssMatchTuple s)
instance TF.IsObject (WafregionalXssMatchSetXssMatchTuple s) where
    toObject WafregionalXssMatchSetXssMatchTuple'{..} = P.catMaybes
        [ TF.assign "field_to_match" <$> TF.attribute _fieldToMatch
        , TF.assign "text_transformation" <$> TF.attribute _textTransformation
        ]

instance TF.IsValid (WafregionalXssMatchSetXssMatchTuple s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_fieldToMatch"
                  (_fieldToMatch
                      :: WafregionalXssMatchSetXssMatchTuple s -> TF.Attr s (XssMatchTupleFieldToMatch s))
                  TF.validator

instance P.HasFieldToMatch (WafregionalXssMatchSetXssMatchTuple s) (TF.Attr s (XssMatchTupleFieldToMatch s)) where
    fieldToMatch =
        P.lens (_fieldToMatch :: WafregionalXssMatchSetXssMatchTuple s -> TF.Attr s (XssMatchTupleFieldToMatch s))
               (\s a -> s { _fieldToMatch = a } :: WafregionalXssMatchSetXssMatchTuple s)

instance P.HasTextTransformation (WafregionalXssMatchSetXssMatchTuple s) (TF.Attr s P.Text) where
    textTransformation =
        P.lens (_textTransformation :: WafregionalXssMatchSetXssMatchTuple s -> TF.Attr s P.Text)
               (\s a -> s { _textTransformation = a } :: WafregionalXssMatchSetXssMatchTuple s)

-- | @lifecycle_rule_noncurrent_version_expiration@ nested settings.
data LifecycleRuleNoncurrentVersionExpiration s = LifecycleRuleNoncurrentVersionExpiration'
    { _days :: TF.Attr s P.Integer
    -- ^ @days@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLifecycleRuleNoncurrentVersionExpiration
    :: LifecycleRuleNoncurrentVersionExpiration s
newLifecycleRuleNoncurrentVersionExpiration =
    LifecycleRuleNoncurrentVersionExpiration'
        { _days = TF.Nil
        }

instance P.Hashable  (LifecycleRuleNoncurrentVersionExpiration s)
instance TF.IsValue  (LifecycleRuleNoncurrentVersionExpiration s)
instance TF.IsObject (LifecycleRuleNoncurrentVersionExpiration s) where
    toObject LifecycleRuleNoncurrentVersionExpiration'{..} = P.catMaybes
        [ TF.assign "days" <$> TF.attribute _days
        ]

instance TF.IsValid (LifecycleRuleNoncurrentVersionExpiration s) where
    validator = P.mempty

instance P.HasDays (LifecycleRuleNoncurrentVersionExpiration s) (TF.Attr s P.Integer) where
    days =
        P.lens (_days :: LifecycleRuleNoncurrentVersionExpiration s -> TF.Attr s P.Integer)
               (\s a -> s { _days = a } :: LifecycleRuleNoncurrentVersionExpiration s)

-- | @lifecycle_rule_transition@ nested settings.
data LifecycleRuleTransition s = LifecycleRuleTransition'
    { _date         :: TF.Attr s P.Text
    -- ^ @date@ - (Optional)
    --
    , _days         :: TF.Attr s P.Integer
    -- ^ @days@ - (Optional)
    --
    , _storageClass :: TF.Attr s P.Text
    -- ^ @storage_class@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLifecycleRuleTransition
    :: TF.Attr s P.Text -- ^ @storage_class@ - 'P.storageClass'
    -> LifecycleRuleTransition s
newLifecycleRuleTransition _storageClass =
    LifecycleRuleTransition'
        { _date = TF.Nil
        , _days = TF.Nil
        , _storageClass = _storageClass
        }

instance P.Hashable  (LifecycleRuleTransition s)
instance TF.IsValue  (LifecycleRuleTransition s)
instance TF.IsObject (LifecycleRuleTransition s) where
    toObject LifecycleRuleTransition'{..} = P.catMaybes
        [ TF.assign "date" <$> TF.attribute _date
        , TF.assign "days" <$> TF.attribute _days
        , TF.assign "storage_class" <$> TF.attribute _storageClass
        ]

instance TF.IsValid (LifecycleRuleTransition s) where
    validator = P.mempty

instance P.HasDate (LifecycleRuleTransition s) (TF.Attr s P.Text) where
    date =
        P.lens (_date :: LifecycleRuleTransition s -> TF.Attr s P.Text)
               (\s a -> s { _date = a } :: LifecycleRuleTransition s)

instance P.HasDays (LifecycleRuleTransition s) (TF.Attr s P.Integer) where
    days =
        P.lens (_days :: LifecycleRuleTransition s -> TF.Attr s P.Integer)
               (\s a -> s { _days = a } :: LifecycleRuleTransition s)

instance P.HasStorageClass (LifecycleRuleTransition s) (TF.Attr s P.Text) where
    storageClass =
        P.lens (_storageClass :: LifecycleRuleTransition s -> TF.Attr s P.Text)
               (\s a -> s { _storageClass = a } :: LifecycleRuleTransition s)

-- | @rules_override_action@ nested settings.
data RulesOverrideAction s = RulesOverrideAction'
    { _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRulesOverrideAction
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> RulesOverrideAction s
newRulesOverrideAction _type' =
    RulesOverrideAction'
        { _type' = _type'
        }

instance P.Hashable  (RulesOverrideAction s)
instance TF.IsValue  (RulesOverrideAction s)
instance TF.IsObject (RulesOverrideAction s) where
    toObject RulesOverrideAction'{..} = P.catMaybes
        [ TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (RulesOverrideAction s) where
    validator = P.mempty

instance P.HasType' (RulesOverrideAction s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: RulesOverrideAction s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: RulesOverrideAction s)

-- | @spot_fleet_request_launch_specification@ nested settings.
data SpotFleetRequestLaunchSpecification s = SpotFleetRequestLaunchSpecification'
    { _ami :: TF.Attr s P.Text
    -- ^ @ami@ - (Required, Forces New)
    --
    , _associatePublicIpAddress :: TF.Attr s P.Bool
    -- ^ @associate_public_ip_address@ - (Optional)
    --
    , _ebsOptimized :: TF.Attr s P.Bool
    -- ^ @ebs_optimized@ - (Optional)
    --
    , _iamInstanceProfile :: TF.Attr s P.Text
    -- ^ @iam_instance_profile@ - (Optional, Forces New)
    --
    , _iamInstanceProfileArn :: TF.Attr s P.Text
    -- ^ @iam_instance_profile_arn@ - (Optional, Forces New)
    --
    , _instanceType :: TF.Attr s P.Text
    -- ^ @instance_type@ - (Required, Forces New)
    --
    , _monitoring :: TF.Attr s P.Bool
    -- ^ @monitoring@ - (Optional)
    --
    , _placementTenancy :: TF.Attr s P.Text
    -- ^ @placement_tenancy@ - (Optional, Forces New)
    --
    , _spotPrice :: TF.Attr s P.Text
    -- ^ @spot_price@ - (Optional, Forces New)
    --
    , _tags :: TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))
    -- ^ @tags@ - (Optional, Forces New)
    --
    , _userData :: TF.Attr s P.Text
    -- ^ @user_data@ - (Optional, Forces New)
    --
    , _weightedCapacity :: TF.Attr s P.Text
    -- ^ @weighted_capacity@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSpotFleetRequestLaunchSpecification
    :: TF.Attr s P.Text -- ^ @ami@ - 'P.ami'
    -> TF.Attr s P.Text -- ^ @instance_type@ - 'P.instanceType'
    -> SpotFleetRequestLaunchSpecification s
newSpotFleetRequestLaunchSpecification _ami _instanceType =
    SpotFleetRequestLaunchSpecification'
        { _ami = _ami
        , _associatePublicIpAddress = TF.value P.False
        , _ebsOptimized = TF.value P.False
        , _iamInstanceProfile = TF.Nil
        , _iamInstanceProfileArn = TF.Nil
        , _instanceType = _instanceType
        , _monitoring = TF.value P.False
        , _placementTenancy = TF.Nil
        , _spotPrice = TF.Nil
        , _tags = TF.Nil
        , _userData = TF.Nil
        , _weightedCapacity = TF.Nil
        }

instance P.Hashable  (SpotFleetRequestLaunchSpecification s)
instance TF.IsValue  (SpotFleetRequestLaunchSpecification s)
instance TF.IsObject (SpotFleetRequestLaunchSpecification s) where
    toObject SpotFleetRequestLaunchSpecification'{..} = P.catMaybes
        [ TF.assign "ami" <$> TF.attribute _ami
        , TF.assign "associate_public_ip_address" <$> TF.attribute _associatePublicIpAddress
        , TF.assign "ebs_optimized" <$> TF.attribute _ebsOptimized
        , TF.assign "iam_instance_profile" <$> TF.attribute _iamInstanceProfile
        , TF.assign "iam_instance_profile_arn" <$> TF.attribute _iamInstanceProfileArn
        , TF.assign "instance_type" <$> TF.attribute _instanceType
        , TF.assign "monitoring" <$> TF.attribute _monitoring
        , TF.assign "placement_tenancy" <$> TF.attribute _placementTenancy
        , TF.assign "spot_price" <$> TF.attribute _spotPrice
        , TF.assign "tags" <$> TF.attribute _tags
        , TF.assign "user_data" <$> TF.attribute _userData
        , TF.assign "weighted_capacity" <$> TF.attribute _weightedCapacity
        ]

instance TF.IsValid (SpotFleetRequestLaunchSpecification s) where
    validator = P.mempty

instance P.HasAmi (SpotFleetRequestLaunchSpecification s) (TF.Attr s P.Text) where
    ami =
        P.lens (_ami :: SpotFleetRequestLaunchSpecification s -> TF.Attr s P.Text)
               (\s a -> s { _ami = a } :: SpotFleetRequestLaunchSpecification s)

instance P.HasAssociatePublicIpAddress (SpotFleetRequestLaunchSpecification s) (TF.Attr s P.Bool) where
    associatePublicIpAddress =
        P.lens (_associatePublicIpAddress :: SpotFleetRequestLaunchSpecification s -> TF.Attr s P.Bool)
               (\s a -> s { _associatePublicIpAddress = a } :: SpotFleetRequestLaunchSpecification s)

instance P.HasEbsOptimized (SpotFleetRequestLaunchSpecification s) (TF.Attr s P.Bool) where
    ebsOptimized =
        P.lens (_ebsOptimized :: SpotFleetRequestLaunchSpecification s -> TF.Attr s P.Bool)
               (\s a -> s { _ebsOptimized = a } :: SpotFleetRequestLaunchSpecification s)

instance P.HasIamInstanceProfile (SpotFleetRequestLaunchSpecification s) (TF.Attr s P.Text) where
    iamInstanceProfile =
        P.lens (_iamInstanceProfile :: SpotFleetRequestLaunchSpecification s -> TF.Attr s P.Text)
               (\s a -> s { _iamInstanceProfile = a } :: SpotFleetRequestLaunchSpecification s)

instance P.HasIamInstanceProfileArn (SpotFleetRequestLaunchSpecification s) (TF.Attr s P.Text) where
    iamInstanceProfileArn =
        P.lens (_iamInstanceProfileArn :: SpotFleetRequestLaunchSpecification s -> TF.Attr s P.Text)
               (\s a -> s { _iamInstanceProfileArn = a } :: SpotFleetRequestLaunchSpecification s)

instance P.HasInstanceType (SpotFleetRequestLaunchSpecification s) (TF.Attr s P.Text) where
    instanceType =
        P.lens (_instanceType :: SpotFleetRequestLaunchSpecification s -> TF.Attr s P.Text)
               (\s a -> s { _instanceType = a } :: SpotFleetRequestLaunchSpecification s)

instance P.HasMonitoring (SpotFleetRequestLaunchSpecification s) (TF.Attr s P.Bool) where
    monitoring =
        P.lens (_monitoring :: SpotFleetRequestLaunchSpecification s -> TF.Attr s P.Bool)
               (\s a -> s { _monitoring = a } :: SpotFleetRequestLaunchSpecification s)

instance P.HasPlacementTenancy (SpotFleetRequestLaunchSpecification s) (TF.Attr s P.Text) where
    placementTenancy =
        P.lens (_placementTenancy :: SpotFleetRequestLaunchSpecification s -> TF.Attr s P.Text)
               (\s a -> s { _placementTenancy = a } :: SpotFleetRequestLaunchSpecification s)

instance P.HasSpotPrice (SpotFleetRequestLaunchSpecification s) (TF.Attr s P.Text) where
    spotPrice =
        P.lens (_spotPrice :: SpotFleetRequestLaunchSpecification s -> TF.Attr s P.Text)
               (\s a -> s { _spotPrice = a } :: SpotFleetRequestLaunchSpecification s)

instance P.HasTags (SpotFleetRequestLaunchSpecification s) (TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))) where
    tags =
        P.lens (_tags :: SpotFleetRequestLaunchSpecification s -> TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text)))
               (\s a -> s { _tags = a } :: SpotFleetRequestLaunchSpecification s)

instance P.HasUserData (SpotFleetRequestLaunchSpecification s) (TF.Attr s P.Text) where
    userData =
        P.lens (_userData :: SpotFleetRequestLaunchSpecification s -> TF.Attr s P.Text)
               (\s a -> s { _userData = a } :: SpotFleetRequestLaunchSpecification s)

instance P.HasWeightedCapacity (SpotFleetRequestLaunchSpecification s) (TF.Attr s P.Text) where
    weightedCapacity =
        P.lens (_weightedCapacity :: SpotFleetRequestLaunchSpecification s -> TF.Attr s P.Text)
               (\s a -> s { _weightedCapacity = a } :: SpotFleetRequestLaunchSpecification s)

instance s ~ s' => P.HasComputedAvailabilityZone (TF.Ref s' (SpotFleetRequestLaunchSpecification s)) (TF.Attr s P.Zone) where
    computedAvailabilityZone x = TF.compute (TF.refKey x) "availability_zone"

instance s ~ s' => P.HasComputedEbsBlockDevice (TF.Ref s' (SpotFleetRequestLaunchSpecification s)) (TF.Attr s [TF.Attr s (LaunchSpecificationEbsBlockDevice s)]) where
    computedEbsBlockDevice x = TF.compute (TF.refKey x) "ebs_block_device"

instance s ~ s' => P.HasComputedEphemeralBlockDevice (TF.Ref s' (SpotFleetRequestLaunchSpecification s)) (TF.Attr s [TF.Attr s (LaunchSpecificationEphemeralBlockDevice s)]) where
    computedEphemeralBlockDevice x = TF.compute (TF.refKey x) "ephemeral_block_device"

instance s ~ s' => P.HasComputedKeyName (TF.Ref s' (SpotFleetRequestLaunchSpecification s)) (TF.Attr s P.Text) where
    computedKeyName x = TF.compute (TF.refKey x) "key_name"

instance s ~ s' => P.HasComputedPlacementGroup (TF.Ref s' (SpotFleetRequestLaunchSpecification s)) (TF.Attr s P.Text) where
    computedPlacementGroup x = TF.compute (TF.refKey x) "placement_group"

instance s ~ s' => P.HasComputedRootBlockDevice (TF.Ref s' (SpotFleetRequestLaunchSpecification s)) (TF.Attr s [TF.Attr s (LaunchSpecificationRootBlockDevice s)]) where
    computedRootBlockDevice x = TF.compute (TF.refKey x) "root_block_device"

instance s ~ s' => P.HasComputedSubnetId (TF.Ref s' (SpotFleetRequestLaunchSpecification s)) (TF.Attr s P.Text) where
    computedSubnetId x = TF.compute (TF.refKey x) "subnet_id"

instance s ~ s' => P.HasComputedVpcSecurityGroupIds (TF.Ref s' (SpotFleetRequestLaunchSpecification s)) (TF.Attr s [TF.Attr s P.Text]) where
    computedVpcSecurityGroupIds x = TF.compute (TF.refKey x) "vpc_security_group_ids"

-- | @wafregional_regex_match_set_regex_match_tuple@ nested settings.
data WafregionalRegexMatchSetRegexMatchTuple s = WafregionalRegexMatchSetRegexMatchTuple'
    { _fieldToMatch       :: TF.Attr s (RegexMatchTupleFieldToMatch s)
    -- ^ @field_to_match@ - (Required)
    --
    , _regexPatternSetId  :: TF.Attr s P.Text
    -- ^ @regex_pattern_set_id@ - (Required)
    --
    , _textTransformation :: TF.Attr s P.Text
    -- ^ @text_transformation@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafregionalRegexMatchSetRegexMatchTuple
    :: TF.Attr s (RegexMatchTupleFieldToMatch s) -- ^ @field_to_match@ - 'P.fieldToMatch'
    -> TF.Attr s P.Text -- ^ @regex_pattern_set_id@ - 'P.regexPatternSetId'
    -> TF.Attr s P.Text -- ^ @text_transformation@ - 'P.textTransformation'
    -> WafregionalRegexMatchSetRegexMatchTuple s
newWafregionalRegexMatchSetRegexMatchTuple _fieldToMatch _regexPatternSetId _textTransformation =
    WafregionalRegexMatchSetRegexMatchTuple'
        { _fieldToMatch = _fieldToMatch
        , _regexPatternSetId = _regexPatternSetId
        , _textTransformation = _textTransformation
        }

instance P.Hashable  (WafregionalRegexMatchSetRegexMatchTuple s)
instance TF.IsValue  (WafregionalRegexMatchSetRegexMatchTuple s)
instance TF.IsObject (WafregionalRegexMatchSetRegexMatchTuple s) where
    toObject WafregionalRegexMatchSetRegexMatchTuple'{..} = P.catMaybes
        [ TF.assign "field_to_match" <$> TF.attribute _fieldToMatch
        , TF.assign "regex_pattern_set_id" <$> TF.attribute _regexPatternSetId
        , TF.assign "text_transformation" <$> TF.attribute _textTransformation
        ]

instance TF.IsValid (WafregionalRegexMatchSetRegexMatchTuple s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_fieldToMatch"
                  (_fieldToMatch
                      :: WafregionalRegexMatchSetRegexMatchTuple s -> TF.Attr s (RegexMatchTupleFieldToMatch s))
                  TF.validator

instance P.HasFieldToMatch (WafregionalRegexMatchSetRegexMatchTuple s) (TF.Attr s (RegexMatchTupleFieldToMatch s)) where
    fieldToMatch =
        P.lens (_fieldToMatch :: WafregionalRegexMatchSetRegexMatchTuple s -> TF.Attr s (RegexMatchTupleFieldToMatch s))
               (\s a -> s { _fieldToMatch = a } :: WafregionalRegexMatchSetRegexMatchTuple s)

instance P.HasRegexPatternSetId (WafregionalRegexMatchSetRegexMatchTuple s) (TF.Attr s P.Text) where
    regexPatternSetId =
        P.lens (_regexPatternSetId :: WafregionalRegexMatchSetRegexMatchTuple s -> TF.Attr s P.Text)
               (\s a -> s { _regexPatternSetId = a } :: WafregionalRegexMatchSetRegexMatchTuple s)

instance P.HasTextTransformation (WafregionalRegexMatchSetRegexMatchTuple s) (TF.Attr s P.Text) where
    textTransformation =
        P.lens (_textTransformation :: WafregionalRegexMatchSetRegexMatchTuple s -> TF.Attr s P.Text)
               (\s a -> s { _textTransformation = a } :: WafregionalRegexMatchSetRegexMatchTuple s)

-- | @waf_rate_based_rule_predicates@ nested settings.
data WafRateBasedRulePredicates s = WafRateBasedRulePredicates'
    { _dataId  :: TF.Attr s P.Text
    -- ^ @data_id@ - (Required)
    --
    , _negated :: TF.Attr s P.Bool
    -- ^ @negated@ - (Required)
    --
    , _type'   :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafRateBasedRulePredicates
    :: TF.Attr s P.Text -- ^ @data_id@ - 'P.dataId'
    -> TF.Attr s P.Bool -- ^ @negated@ - 'P.negated'
    -> TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> WafRateBasedRulePredicates s
newWafRateBasedRulePredicates _dataId _negated _type' =
    WafRateBasedRulePredicates'
        { _dataId = _dataId
        , _negated = _negated
        , _type' = _type'
        }

instance P.Hashable  (WafRateBasedRulePredicates s)
instance TF.IsValue  (WafRateBasedRulePredicates s)
instance TF.IsObject (WafRateBasedRulePredicates s) where
    toObject WafRateBasedRulePredicates'{..} = P.catMaybes
        [ TF.assign "data_id" <$> TF.attribute _dataId
        , TF.assign "negated" <$> TF.attribute _negated
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (WafRateBasedRulePredicates s) where
    validator = P.mempty

instance P.HasDataId (WafRateBasedRulePredicates s) (TF.Attr s P.Text) where
    dataId =
        P.lens (_dataId :: WafRateBasedRulePredicates s -> TF.Attr s P.Text)
               (\s a -> s { _dataId = a } :: WafRateBasedRulePredicates s)

instance P.HasNegated (WafRateBasedRulePredicates s) (TF.Attr s P.Bool) where
    negated =
        P.lens (_negated :: WafRateBasedRulePredicates s -> TF.Attr s P.Bool)
               (\s a -> s { _negated = a } :: WafRateBasedRulePredicates s)

instance P.HasType' (WafRateBasedRulePredicates s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: WafRateBasedRulePredicates s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: WafRateBasedRulePredicates s)

-- | @wafregional_sql_injection_match_set_sql_injection_match_tuple@ nested settings.
data WafregionalSqlInjectionMatchSetSqlInjectionMatchTuple s = WafregionalSqlInjectionMatchSetSqlInjectionMatchTuple'
    { _fieldToMatch       :: TF.Attr s (SqlInjectionMatchTupleFieldToMatch s)
    -- ^ @field_to_match@ - (Required)
    --
    , _textTransformation :: TF.Attr s P.Text
    -- ^ @text_transformation@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafregionalSqlInjectionMatchSetSqlInjectionMatchTuple
    :: TF.Attr s (SqlInjectionMatchTupleFieldToMatch s) -- ^ @field_to_match@ - 'P.fieldToMatch'
    -> TF.Attr s P.Text -- ^ @text_transformation@ - 'P.textTransformation'
    -> WafregionalSqlInjectionMatchSetSqlInjectionMatchTuple s
newWafregionalSqlInjectionMatchSetSqlInjectionMatchTuple _fieldToMatch _textTransformation =
    WafregionalSqlInjectionMatchSetSqlInjectionMatchTuple'
        { _fieldToMatch = _fieldToMatch
        , _textTransformation = _textTransformation
        }

instance P.Hashable  (WafregionalSqlInjectionMatchSetSqlInjectionMatchTuple s)
instance TF.IsValue  (WafregionalSqlInjectionMatchSetSqlInjectionMatchTuple s)
instance TF.IsObject (WafregionalSqlInjectionMatchSetSqlInjectionMatchTuple s) where
    toObject WafregionalSqlInjectionMatchSetSqlInjectionMatchTuple'{..} = P.catMaybes
        [ TF.assign "field_to_match" <$> TF.attribute _fieldToMatch
        , TF.assign "text_transformation" <$> TF.attribute _textTransformation
        ]

instance TF.IsValid (WafregionalSqlInjectionMatchSetSqlInjectionMatchTuple s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_fieldToMatch"
                  (_fieldToMatch
                      :: WafregionalSqlInjectionMatchSetSqlInjectionMatchTuple s -> TF.Attr s (SqlInjectionMatchTupleFieldToMatch s))
                  TF.validator

instance P.HasFieldToMatch (WafregionalSqlInjectionMatchSetSqlInjectionMatchTuple s) (TF.Attr s (SqlInjectionMatchTupleFieldToMatch s)) where
    fieldToMatch =
        P.lens (_fieldToMatch :: WafregionalSqlInjectionMatchSetSqlInjectionMatchTuple s -> TF.Attr s (SqlInjectionMatchTupleFieldToMatch s))
               (\s a -> s { _fieldToMatch = a } :: WafregionalSqlInjectionMatchSetSqlInjectionMatchTuple s)

instance P.HasTextTransformation (WafregionalSqlInjectionMatchSetSqlInjectionMatchTuple s) (TF.Attr s P.Text) where
    textTransformation =
        P.lens (_textTransformation :: WafregionalSqlInjectionMatchSetSqlInjectionMatchTuple s -> TF.Attr s P.Text)
               (\s a -> s { _textTransformation = a } :: WafregionalSqlInjectionMatchSetSqlInjectionMatchTuple s)

-- | @opsworks_application_ssl_configuration@ nested settings.
data OpsworksApplicationSslConfiguration s = OpsworksApplicationSslConfiguration'
    { _certificate :: TF.Attr s P.Text
    -- ^ @certificate@ - (Required)
    --
    , _chain       :: TF.Attr s P.Text
    -- ^ @chain@ - (Optional)
    --
    , _privateKey  :: TF.Attr s P.Text
    -- ^ @private_key@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newOpsworksApplicationSslConfiguration
    :: TF.Attr s P.Text -- ^ @certificate@ - 'P.certificate'
    -> TF.Attr s P.Text -- ^ @private_key@ - 'P.privateKey'
    -> OpsworksApplicationSslConfiguration s
newOpsworksApplicationSslConfiguration _certificate _privateKey =
    OpsworksApplicationSslConfiguration'
        { _certificate = _certificate
        , _chain = TF.Nil
        , _privateKey = _privateKey
        }

instance P.Hashable  (OpsworksApplicationSslConfiguration s)
instance TF.IsValue  (OpsworksApplicationSslConfiguration s)
instance TF.IsObject (OpsworksApplicationSslConfiguration s) where
    toObject OpsworksApplicationSslConfiguration'{..} = P.catMaybes
        [ TF.assign "certificate" <$> TF.attribute _certificate
        , TF.assign "chain" <$> TF.attribute _chain
        , TF.assign "private_key" <$> TF.attribute _privateKey
        ]

instance TF.IsValid (OpsworksApplicationSslConfiguration s) where
    validator = P.mempty

instance P.HasCertificate (OpsworksApplicationSslConfiguration s) (TF.Attr s P.Text) where
    certificate =
        P.lens (_certificate :: OpsworksApplicationSslConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _certificate = a } :: OpsworksApplicationSslConfiguration s)

instance P.HasChain (OpsworksApplicationSslConfiguration s) (TF.Attr s P.Text) where
    chain =
        P.lens (_chain :: OpsworksApplicationSslConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _chain = a } :: OpsworksApplicationSslConfiguration s)

instance P.HasPrivateKey (OpsworksApplicationSslConfiguration s) (TF.Attr s P.Text) where
    privateKey =
        P.lens (_privateKey :: OpsworksApplicationSslConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _privateKey = a } :: OpsworksApplicationSslConfiguration s)

-- | @certificate_authority_configuration_subject@ nested settings.
data CertificateAuthorityConfigurationSubject s = CertificateAuthorityConfigurationSubject'
    { _commonName                 :: TF.Attr s P.Text
    -- ^ @common_name@ - (Optional, Forces New)
    --
    , _country                    :: TF.Attr s P.Text
    -- ^ @country@ - (Optional, Forces New)
    --
    , _distinguishedNameQualifier :: TF.Attr s P.Text
    -- ^ @distinguished_name_qualifier@ - (Optional, Forces New)
    --
    , _generationQualifier        :: TF.Attr s P.Text
    -- ^ @generation_qualifier@ - (Optional, Forces New)
    --
    , _givenName                  :: TF.Attr s P.Text
    -- ^ @given_name@ - (Optional, Forces New)
    --
    , _initials                   :: TF.Attr s P.Text
    -- ^ @initials@ - (Optional, Forces New)
    --
    , _locality                   :: TF.Attr s P.Text
    -- ^ @locality@ - (Optional, Forces New)
    --
    , _organization               :: TF.Attr s P.Text
    -- ^ @organization@ - (Optional, Forces New)
    --
    , _organizationalUnit         :: TF.Attr s P.Text
    -- ^ @organizational_unit@ - (Optional, Forces New)
    --
    , _pseudonym                  :: TF.Attr s P.Text
    -- ^ @pseudonym@ - (Optional, Forces New)
    --
    , _state                      :: TF.Attr s P.Text
    -- ^ @state@ - (Optional, Forces New)
    --
    , _surname                    :: TF.Attr s P.Text
    -- ^ @surname@ - (Optional, Forces New)
    --
    , _title                      :: TF.Attr s P.Text
    -- ^ @title@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCertificateAuthorityConfigurationSubject
    :: CertificateAuthorityConfigurationSubject s
newCertificateAuthorityConfigurationSubject =
    CertificateAuthorityConfigurationSubject'
        { _commonName = TF.Nil
        , _country = TF.Nil
        , _distinguishedNameQualifier = TF.Nil
        , _generationQualifier = TF.Nil
        , _givenName = TF.Nil
        , _initials = TF.Nil
        , _locality = TF.Nil
        , _organization = TF.Nil
        , _organizationalUnit = TF.Nil
        , _pseudonym = TF.Nil
        , _state = TF.Nil
        , _surname = TF.Nil
        , _title = TF.Nil
        }

instance P.Hashable  (CertificateAuthorityConfigurationSubject s)
instance TF.IsValue  (CertificateAuthorityConfigurationSubject s)
instance TF.IsObject (CertificateAuthorityConfigurationSubject s) where
    toObject CertificateAuthorityConfigurationSubject'{..} = P.catMaybes
        [ TF.assign "common_name" <$> TF.attribute _commonName
        , TF.assign "country" <$> TF.attribute _country
        , TF.assign "distinguished_name_qualifier" <$> TF.attribute _distinguishedNameQualifier
        , TF.assign "generation_qualifier" <$> TF.attribute _generationQualifier
        , TF.assign "given_name" <$> TF.attribute _givenName
        , TF.assign "initials" <$> TF.attribute _initials
        , TF.assign "locality" <$> TF.attribute _locality
        , TF.assign "organization" <$> TF.attribute _organization
        , TF.assign "organizational_unit" <$> TF.attribute _organizationalUnit
        , TF.assign "pseudonym" <$> TF.attribute _pseudonym
        , TF.assign "state" <$> TF.attribute _state
        , TF.assign "surname" <$> TF.attribute _surname
        , TF.assign "title" <$> TF.attribute _title
        ]

instance TF.IsValid (CertificateAuthorityConfigurationSubject s) where
    validator = P.mempty

instance P.HasCommonName (CertificateAuthorityConfigurationSubject s) (TF.Attr s P.Text) where
    commonName =
        P.lens (_commonName :: CertificateAuthorityConfigurationSubject s -> TF.Attr s P.Text)
               (\s a -> s { _commonName = a } :: CertificateAuthorityConfigurationSubject s)

instance P.HasCountry (CertificateAuthorityConfigurationSubject s) (TF.Attr s P.Text) where
    country =
        P.lens (_country :: CertificateAuthorityConfigurationSubject s -> TF.Attr s P.Text)
               (\s a -> s { _country = a } :: CertificateAuthorityConfigurationSubject s)

instance P.HasDistinguishedNameQualifier (CertificateAuthorityConfigurationSubject s) (TF.Attr s P.Text) where
    distinguishedNameQualifier =
        P.lens (_distinguishedNameQualifier :: CertificateAuthorityConfigurationSubject s -> TF.Attr s P.Text)
               (\s a -> s { _distinguishedNameQualifier = a } :: CertificateAuthorityConfigurationSubject s)

instance P.HasGenerationQualifier (CertificateAuthorityConfigurationSubject s) (TF.Attr s P.Text) where
    generationQualifier =
        P.lens (_generationQualifier :: CertificateAuthorityConfigurationSubject s -> TF.Attr s P.Text)
               (\s a -> s { _generationQualifier = a } :: CertificateAuthorityConfigurationSubject s)

instance P.HasGivenName (CertificateAuthorityConfigurationSubject s) (TF.Attr s P.Text) where
    givenName =
        P.lens (_givenName :: CertificateAuthorityConfigurationSubject s -> TF.Attr s P.Text)
               (\s a -> s { _givenName = a } :: CertificateAuthorityConfigurationSubject s)

instance P.HasInitials (CertificateAuthorityConfigurationSubject s) (TF.Attr s P.Text) where
    initials =
        P.lens (_initials :: CertificateAuthorityConfigurationSubject s -> TF.Attr s P.Text)
               (\s a -> s { _initials = a } :: CertificateAuthorityConfigurationSubject s)

instance P.HasLocality (CertificateAuthorityConfigurationSubject s) (TF.Attr s P.Text) where
    locality =
        P.lens (_locality :: CertificateAuthorityConfigurationSubject s -> TF.Attr s P.Text)
               (\s a -> s { _locality = a } :: CertificateAuthorityConfigurationSubject s)

instance P.HasOrganization (CertificateAuthorityConfigurationSubject s) (TF.Attr s P.Text) where
    organization =
        P.lens (_organization :: CertificateAuthorityConfigurationSubject s -> TF.Attr s P.Text)
               (\s a -> s { _organization = a } :: CertificateAuthorityConfigurationSubject s)

instance P.HasOrganizationalUnit (CertificateAuthorityConfigurationSubject s) (TF.Attr s P.Text) where
    organizationalUnit =
        P.lens (_organizationalUnit :: CertificateAuthorityConfigurationSubject s -> TF.Attr s P.Text)
               (\s a -> s { _organizationalUnit = a } :: CertificateAuthorityConfigurationSubject s)

instance P.HasPseudonym (CertificateAuthorityConfigurationSubject s) (TF.Attr s P.Text) where
    pseudonym =
        P.lens (_pseudonym :: CertificateAuthorityConfigurationSubject s -> TF.Attr s P.Text)
               (\s a -> s { _pseudonym = a } :: CertificateAuthorityConfigurationSubject s)

instance P.HasState (CertificateAuthorityConfigurationSubject s) (TF.Attr s P.Text) where
    state =
        P.lens (_state :: CertificateAuthorityConfigurationSubject s -> TF.Attr s P.Text)
               (\s a -> s { _state = a } :: CertificateAuthorityConfigurationSubject s)

instance P.HasSurname (CertificateAuthorityConfigurationSubject s) (TF.Attr s P.Text) where
    surname =
        P.lens (_surname :: CertificateAuthorityConfigurationSubject s -> TF.Attr s P.Text)
               (\s a -> s { _surname = a } :: CertificateAuthorityConfigurationSubject s)

instance P.HasTitle (CertificateAuthorityConfigurationSubject s) (TF.Attr s P.Text) where
    title =
        P.lens (_title :: CertificateAuthorityConfigurationSubject s -> TF.Attr s P.Text)
               (\s a -> s { _title = a } :: CertificateAuthorityConfigurationSubject s)

-- | @elasticache_parameter_group_parameter@ nested settings.
data ElasticacheParameterGroupParameter s = ElasticacheParameterGroupParameter'
    { _name  :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _value :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElasticacheParameterGroupParameter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> ElasticacheParameterGroupParameter s
newElasticacheParameterGroupParameter _name _value =
    ElasticacheParameterGroupParameter'
        { _name = _name
        , _value = _value
        }

instance P.Hashable  (ElasticacheParameterGroupParameter s)
instance TF.IsValue  (ElasticacheParameterGroupParameter s)
instance TF.IsObject (ElasticacheParameterGroupParameter s) where
    toObject ElasticacheParameterGroupParameter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (ElasticacheParameterGroupParameter s) where
    validator = P.mempty

instance P.HasName (ElasticacheParameterGroupParameter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: ElasticacheParameterGroupParameter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: ElasticacheParameterGroupParameter s)

instance P.HasValue (ElasticacheParameterGroupParameter s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: ElasticacheParameterGroupParameter s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: ElasticacheParameterGroupParameter s)

-- | @iot_topic_rule_s3@ nested settings.
data IotTopicRuleS3 s = IotTopicRuleS3'
    { _bucketName :: TF.Attr s P.Text
    -- ^ @bucket_name@ - (Required)
    --
    , _key        :: TF.Attr s P.Text
    -- ^ @key@ - (Required)
    --
    , _roleArn    :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newIotTopicRuleS3
    :: TF.Attr s P.Text -- ^ @bucket_name@ - 'P.bucketName'
    -> TF.Attr s P.Text -- ^ @key@ - 'P.key'
    -> TF.Attr s P.Text -- ^ @role_arn@ - 'P.roleArn'
    -> IotTopicRuleS3 s
newIotTopicRuleS3 _bucketName _key _roleArn =
    IotTopicRuleS3'
        { _bucketName = _bucketName
        , _key = _key
        , _roleArn = _roleArn
        }

instance P.Hashable  (IotTopicRuleS3 s)
instance TF.IsValue  (IotTopicRuleS3 s)
instance TF.IsObject (IotTopicRuleS3 s) where
    toObject IotTopicRuleS3'{..} = P.catMaybes
        [ TF.assign "bucket_name" <$> TF.attribute _bucketName
        , TF.assign "key" <$> TF.attribute _key
        , TF.assign "role_arn" <$> TF.attribute _roleArn
        ]

instance TF.IsValid (IotTopicRuleS3 s) where
    validator = P.mempty

instance P.HasBucketName (IotTopicRuleS3 s) (TF.Attr s P.Text) where
    bucketName =
        P.lens (_bucketName :: IotTopicRuleS3 s -> TF.Attr s P.Text)
               (\s a -> s { _bucketName = a } :: IotTopicRuleS3 s)

instance P.HasKey (IotTopicRuleS3 s) (TF.Attr s P.Text) where
    key =
        P.lens (_key :: IotTopicRuleS3 s -> TF.Attr s P.Text)
               (\s a -> s { _key = a } :: IotTopicRuleS3 s)

instance P.HasRoleArn (IotTopicRuleS3 s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: IotTopicRuleS3 s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: IotTopicRuleS3 s)

-- | @source_auth@ nested settings.
data SourceAuth s = SourceAuth'
    { _resource :: TF.Attr s P.Text
    -- ^ @resource@ - (Optional)
    --
    , _type'    :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSourceAuth
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> SourceAuth s
newSourceAuth _type' =
    SourceAuth'
        { _resource = TF.Nil
        , _type' = _type'
        }

instance P.Hashable  (SourceAuth s)
instance TF.IsValue  (SourceAuth s)
instance TF.IsObject (SourceAuth s) where
    toObject SourceAuth'{..} = P.catMaybes
        [ TF.assign "resource" <$> TF.attribute _resource
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (SourceAuth s) where
    validator = P.mempty

instance P.HasResource (SourceAuth s) (TF.Attr s P.Text) where
    resource =
        P.lens (_resource :: SourceAuth s -> TF.Attr s P.Text)
               (\s a -> s { _resource = a } :: SourceAuth s)

instance P.HasType' (SourceAuth s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: SourceAuth s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: SourceAuth s)

-- | @ecs_task_definition_placement_constraints@ nested settings.
data EcsTaskDefinitionPlacementConstraints s = EcsTaskDefinitionPlacementConstraints'
    { _expression :: TF.Attr s P.Text
    -- ^ @expression@ - (Optional, Forces New)
    --
    , _type'      :: TF.Attr s P.Text
    -- ^ @type@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newEcsTaskDefinitionPlacementConstraints
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> EcsTaskDefinitionPlacementConstraints s
newEcsTaskDefinitionPlacementConstraints _type' =
    EcsTaskDefinitionPlacementConstraints'
        { _expression = TF.Nil
        , _type' = _type'
        }

instance P.Hashable  (EcsTaskDefinitionPlacementConstraints s)
instance TF.IsValue  (EcsTaskDefinitionPlacementConstraints s)
instance TF.IsObject (EcsTaskDefinitionPlacementConstraints s) where
    toObject EcsTaskDefinitionPlacementConstraints'{..} = P.catMaybes
        [ TF.assign "expression" <$> TF.attribute _expression
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (EcsTaskDefinitionPlacementConstraints s) where
    validator = P.mempty

instance P.HasExpression (EcsTaskDefinitionPlacementConstraints s) (TF.Attr s P.Text) where
    expression =
        P.lens (_expression :: EcsTaskDefinitionPlacementConstraints s -> TF.Attr s P.Text)
               (\s a -> s { _expression = a } :: EcsTaskDefinitionPlacementConstraints s)

instance P.HasType' (EcsTaskDefinitionPlacementConstraints s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: EcsTaskDefinitionPlacementConstraints s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: EcsTaskDefinitionPlacementConstraints s)

-- | @storage_descriptor_sort_columns@ nested settings.
data StorageDescriptorSortColumns s = StorageDescriptorSortColumns'
    { _column    :: TF.Attr s P.Text
    -- ^ @column@ - (Required)
    --
    , _sortOrder :: TF.Attr s P.Integer
    -- ^ @sort_order@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newStorageDescriptorSortColumns
    :: TF.Attr s P.Text -- ^ @column@ - 'P.column'
    -> TF.Attr s P.Integer -- ^ @sort_order@ - 'P.sortOrder'
    -> StorageDescriptorSortColumns s
newStorageDescriptorSortColumns _column _sortOrder =
    StorageDescriptorSortColumns'
        { _column = _column
        , _sortOrder = _sortOrder
        }

instance P.Hashable  (StorageDescriptorSortColumns s)
instance TF.IsValue  (StorageDescriptorSortColumns s)
instance TF.IsObject (StorageDescriptorSortColumns s) where
    toObject StorageDescriptorSortColumns'{..} = P.catMaybes
        [ TF.assign "column" <$> TF.attribute _column
        , TF.assign "sort_order" <$> TF.attribute _sortOrder
        ]

instance TF.IsValid (StorageDescriptorSortColumns s) where
    validator = P.mempty

instance P.HasColumn (StorageDescriptorSortColumns s) (TF.Attr s P.Text) where
    column =
        P.lens (_column :: StorageDescriptorSortColumns s -> TF.Attr s P.Text)
               (\s a -> s { _column = a } :: StorageDescriptorSortColumns s)

instance P.HasSortOrder (StorageDescriptorSortColumns s) (TF.Attr s P.Integer) where
    sortOrder =
        P.lens (_sortOrder :: StorageDescriptorSortColumns s -> TF.Attr s P.Integer)
               (\s a -> s { _sortOrder = a } :: StorageDescriptorSortColumns s)

-- | @iot_topic_rule_kinesis@ nested settings.
data IotTopicRuleKinesis s = IotTopicRuleKinesis'
    { _partitionKey :: TF.Attr s P.Text
    -- ^ @partition_key@ - (Optional)
    --
    , _roleArn      :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Required)
    --
    , _streamName   :: TF.Attr s P.Text
    -- ^ @stream_name@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newIotTopicRuleKinesis
    :: TF.Attr s P.Text -- ^ @role_arn@ - 'P.roleArn'
    -> TF.Attr s P.Text -- ^ @stream_name@ - 'P.streamName'
    -> IotTopicRuleKinesis s
newIotTopicRuleKinesis _roleArn _streamName =
    IotTopicRuleKinesis'
        { _partitionKey = TF.Nil
        , _roleArn = _roleArn
        , _streamName = _streamName
        }

instance P.Hashable  (IotTopicRuleKinesis s)
instance TF.IsValue  (IotTopicRuleKinesis s)
instance TF.IsObject (IotTopicRuleKinesis s) where
    toObject IotTopicRuleKinesis'{..} = P.catMaybes
        [ TF.assign "partition_key" <$> TF.attribute _partitionKey
        , TF.assign "role_arn" <$> TF.attribute _roleArn
        , TF.assign "stream_name" <$> TF.attribute _streamName
        ]

instance TF.IsValid (IotTopicRuleKinesis s) where
    validator = P.mempty

instance P.HasPartitionKey (IotTopicRuleKinesis s) (TF.Attr s P.Text) where
    partitionKey =
        P.lens (_partitionKey :: IotTopicRuleKinesis s -> TF.Attr s P.Text)
               (\s a -> s { _partitionKey = a } :: IotTopicRuleKinesis s)

instance P.HasRoleArn (IotTopicRuleKinesis s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: IotTopicRuleKinesis s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: IotTopicRuleKinesis s)

instance P.HasStreamName (IotTopicRuleKinesis s) (TF.Attr s P.Text) where
    streamName =
        P.lens (_streamName :: IotTopicRuleKinesis s -> TF.Attr s P.Text)
               (\s a -> s { _streamName = a } :: IotTopicRuleKinesis s)

-- | @waf_regex_match_set_regex_match_tuple@ nested settings.
data WafRegexMatchSetRegexMatchTuple s = WafRegexMatchSetRegexMatchTuple'
    { _fieldToMatch       :: TF.Attr s (RegexMatchTupleFieldToMatch s)
    -- ^ @field_to_match@ - (Required)
    --
    , _regexPatternSetId  :: TF.Attr s P.Text
    -- ^ @regex_pattern_set_id@ - (Required)
    --
    , _textTransformation :: TF.Attr s P.Text
    -- ^ @text_transformation@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafRegexMatchSetRegexMatchTuple
    :: TF.Attr s (RegexMatchTupleFieldToMatch s) -- ^ @field_to_match@ - 'P.fieldToMatch'
    -> TF.Attr s P.Text -- ^ @regex_pattern_set_id@ - 'P.regexPatternSetId'
    -> TF.Attr s P.Text -- ^ @text_transformation@ - 'P.textTransformation'
    -> WafRegexMatchSetRegexMatchTuple s
newWafRegexMatchSetRegexMatchTuple _fieldToMatch _regexPatternSetId _textTransformation =
    WafRegexMatchSetRegexMatchTuple'
        { _fieldToMatch = _fieldToMatch
        , _regexPatternSetId = _regexPatternSetId
        , _textTransformation = _textTransformation
        }

instance P.Hashable  (WafRegexMatchSetRegexMatchTuple s)
instance TF.IsValue  (WafRegexMatchSetRegexMatchTuple s)
instance TF.IsObject (WafRegexMatchSetRegexMatchTuple s) where
    toObject WafRegexMatchSetRegexMatchTuple'{..} = P.catMaybes
        [ TF.assign "field_to_match" <$> TF.attribute _fieldToMatch
        , TF.assign "regex_pattern_set_id" <$> TF.attribute _regexPatternSetId
        , TF.assign "text_transformation" <$> TF.attribute _textTransformation
        ]

instance TF.IsValid (WafRegexMatchSetRegexMatchTuple s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_fieldToMatch"
                  (_fieldToMatch
                      :: WafRegexMatchSetRegexMatchTuple s -> TF.Attr s (RegexMatchTupleFieldToMatch s))
                  TF.validator

instance P.HasFieldToMatch (WafRegexMatchSetRegexMatchTuple s) (TF.Attr s (RegexMatchTupleFieldToMatch s)) where
    fieldToMatch =
        P.lens (_fieldToMatch :: WafRegexMatchSetRegexMatchTuple s -> TF.Attr s (RegexMatchTupleFieldToMatch s))
               (\s a -> s { _fieldToMatch = a } :: WafRegexMatchSetRegexMatchTuple s)

instance P.HasRegexPatternSetId (WafRegexMatchSetRegexMatchTuple s) (TF.Attr s P.Text) where
    regexPatternSetId =
        P.lens (_regexPatternSetId :: WafRegexMatchSetRegexMatchTuple s -> TF.Attr s P.Text)
               (\s a -> s { _regexPatternSetId = a } :: WafRegexMatchSetRegexMatchTuple s)

instance P.HasTextTransformation (WafRegexMatchSetRegexMatchTuple s) (TF.Attr s P.Text) where
    textTransformation =
        P.lens (_textTransformation :: WafRegexMatchSetRegexMatchTuple s -> TF.Attr s P.Text)
               (\s a -> s { _textTransformation = a } :: WafRegexMatchSetRegexMatchTuple s)

-- | @api_gateway_usage_plan_quota_settings@ nested settings.
data ApiGatewayUsagePlanQuotaSettings s = ApiGatewayUsagePlanQuotaSettings'
    { _limit  :: TF.Attr s P.Integer
    -- ^ @limit@ - (Required)
    --
    , _offset :: TF.Attr s P.Integer
    -- ^ @offset@ - (Optional)
    --
    , _period :: TF.Attr s P.Text
    -- ^ @period@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newApiGatewayUsagePlanQuotaSettings
    :: TF.Attr s P.Integer -- ^ @limit@ - 'P.limit'
    -> TF.Attr s P.Text -- ^ @period@ - 'P.period'
    -> ApiGatewayUsagePlanQuotaSettings s
newApiGatewayUsagePlanQuotaSettings _limit _period =
    ApiGatewayUsagePlanQuotaSettings'
        { _limit = _limit
        , _offset = TF.value 0
        , _period = _period
        }

instance P.Hashable  (ApiGatewayUsagePlanQuotaSettings s)
instance TF.IsValue  (ApiGatewayUsagePlanQuotaSettings s)
instance TF.IsObject (ApiGatewayUsagePlanQuotaSettings s) where
    toObject ApiGatewayUsagePlanQuotaSettings'{..} = P.catMaybes
        [ TF.assign "limit" <$> TF.attribute _limit
        , TF.assign "offset" <$> TF.attribute _offset
        , TF.assign "period" <$> TF.attribute _period
        ]

instance TF.IsValid (ApiGatewayUsagePlanQuotaSettings s) where
    validator = P.mempty

instance P.HasLimit (ApiGatewayUsagePlanQuotaSettings s) (TF.Attr s P.Integer) where
    limit =
        P.lens (_limit :: ApiGatewayUsagePlanQuotaSettings s -> TF.Attr s P.Integer)
               (\s a -> s { _limit = a } :: ApiGatewayUsagePlanQuotaSettings s)

instance P.HasOffset (ApiGatewayUsagePlanQuotaSettings s) (TF.Attr s P.Integer) where
    offset =
        P.lens (_offset :: ApiGatewayUsagePlanQuotaSettings s -> TF.Attr s P.Integer)
               (\s a -> s { _offset = a } :: ApiGatewayUsagePlanQuotaSettings s)

instance P.HasPeriod (ApiGatewayUsagePlanQuotaSettings s) (TF.Attr s P.Text) where
    period =
        P.lens (_period :: ApiGatewayUsagePlanQuotaSettings s -> TF.Attr s P.Text)
               (\s a -> s { _period = a } :: ApiGatewayUsagePlanQuotaSettings s)

-- | @config_configuration_recorder_recording_group@ nested settings.
data ConfigConfigurationRecorderRecordingGroup s = ConfigConfigurationRecorderRecordingGroup'
    { _allSupported               :: TF.Attr s P.Bool
    -- ^ @all_supported@ - (Optional)
    --
    , _includeGlobalResourceTypes :: TF.Attr s P.Bool
    -- ^ @include_global_resource_types@ - (Optional)
    --
    , _resourceTypes              :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @resource_types@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newConfigConfigurationRecorderRecordingGroup
    :: ConfigConfigurationRecorderRecordingGroup s
newConfigConfigurationRecorderRecordingGroup =
    ConfigConfigurationRecorderRecordingGroup'
        { _allSupported = TF.value P.True
        , _includeGlobalResourceTypes = TF.Nil
        , _resourceTypes = TF.Nil
        }

instance P.Hashable  (ConfigConfigurationRecorderRecordingGroup s)
instance TF.IsValue  (ConfigConfigurationRecorderRecordingGroup s)
instance TF.IsObject (ConfigConfigurationRecorderRecordingGroup s) where
    toObject ConfigConfigurationRecorderRecordingGroup'{..} = P.catMaybes
        [ TF.assign "all_supported" <$> TF.attribute _allSupported
        , TF.assign "include_global_resource_types" <$> TF.attribute _includeGlobalResourceTypes
        , TF.assign "resource_types" <$> TF.attribute _resourceTypes
        ]

instance TF.IsValid (ConfigConfigurationRecorderRecordingGroup s) where
    validator = P.mempty

instance P.HasAllSupported (ConfigConfigurationRecorderRecordingGroup s) (TF.Attr s P.Bool) where
    allSupported =
        P.lens (_allSupported :: ConfigConfigurationRecorderRecordingGroup s -> TF.Attr s P.Bool)
               (\s a -> s { _allSupported = a } :: ConfigConfigurationRecorderRecordingGroup s)

instance P.HasIncludeGlobalResourceTypes (ConfigConfigurationRecorderRecordingGroup s) (TF.Attr s P.Bool) where
    includeGlobalResourceTypes =
        P.lens (_includeGlobalResourceTypes :: ConfigConfigurationRecorderRecordingGroup s -> TF.Attr s P.Bool)
               (\s a -> s { _includeGlobalResourceTypes = a } :: ConfigConfigurationRecorderRecordingGroup s)

instance P.HasResourceTypes (ConfigConfigurationRecorderRecordingGroup s) (TF.Attr s [TF.Attr s P.Text]) where
    resourceTypes =
        P.lens (_resourceTypes :: ConfigConfigurationRecorderRecordingGroup s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _resourceTypes = a } :: ConfigConfigurationRecorderRecordingGroup s)

-- | @instance_network_interface@ nested settings.
data InstanceNetworkInterface s = InstanceNetworkInterface'
    { _deleteOnTermination :: TF.Attr s P.Bool
    -- ^ @delete_on_termination@ - (Optional, Forces New)
    --
    , _deviceIndex         :: TF.Attr s P.Integer
    -- ^ @device_index@ - (Required, Forces New)
    --
    , _networkInterfaceId  :: TF.Attr s P.Text
    -- ^ @network_interface_id@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newInstanceNetworkInterface
    :: TF.Attr s P.Integer -- ^ @device_index@ - 'P.deviceIndex'
    -> TF.Attr s P.Text -- ^ @network_interface_id@ - 'P.networkInterfaceId'
    -> InstanceNetworkInterface s
newInstanceNetworkInterface _deviceIndex _networkInterfaceId =
    InstanceNetworkInterface'
        { _deleteOnTermination = TF.value P.False
        , _deviceIndex = _deviceIndex
        , _networkInterfaceId = _networkInterfaceId
        }

instance P.Hashable  (InstanceNetworkInterface s)
instance TF.IsValue  (InstanceNetworkInterface s)
instance TF.IsObject (InstanceNetworkInterface s) where
    toObject InstanceNetworkInterface'{..} = P.catMaybes
        [ TF.assign "delete_on_termination" <$> TF.attribute _deleteOnTermination
        , TF.assign "device_index" <$> TF.attribute _deviceIndex
        , TF.assign "network_interface_id" <$> TF.attribute _networkInterfaceId
        ]

instance TF.IsValid (InstanceNetworkInterface s) where
    validator = P.mempty

instance P.HasDeleteOnTermination (InstanceNetworkInterface s) (TF.Attr s P.Bool) where
    deleteOnTermination =
        P.lens (_deleteOnTermination :: InstanceNetworkInterface s -> TF.Attr s P.Bool)
               (\s a -> s { _deleteOnTermination = a } :: InstanceNetworkInterface s)

instance P.HasDeviceIndex (InstanceNetworkInterface s) (TF.Attr s P.Integer) where
    deviceIndex =
        P.lens (_deviceIndex :: InstanceNetworkInterface s -> TF.Attr s P.Integer)
               (\s a -> s { _deviceIndex = a } :: InstanceNetworkInterface s)

instance P.HasNetworkInterfaceId (InstanceNetworkInterface s) (TF.Attr s P.Text) where
    networkInterfaceId =
        P.lens (_networkInterfaceId :: InstanceNetworkInterface s -> TF.Attr s P.Text)
               (\s a -> s { _networkInterfaceId = a } :: InstanceNetworkInterface s)

-- | @ssm_document_permissions@ nested settings.
data SsmDocumentPermissions s = SsmDocumentPermissions'
    { _accountIds :: TF.Attr s P.Text
    -- ^ @account_ids@ - (Required)
    --
    , _type'      :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSsmDocumentPermissions
    :: TF.Attr s P.Text -- ^ @account_ids@ - 'P.accountIds'
    -> TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> SsmDocumentPermissions s
newSsmDocumentPermissions _accountIds _type' =
    SsmDocumentPermissions'
        { _accountIds = _accountIds
        , _type' = _type'
        }

instance P.Hashable  (SsmDocumentPermissions s)
instance TF.IsValue  (SsmDocumentPermissions s)
instance TF.IsObject (SsmDocumentPermissions s) where
    toObject SsmDocumentPermissions'{..} = P.catMaybes
        [ TF.assign "account_ids" <$> TF.attribute _accountIds
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (SsmDocumentPermissions s) where
    validator = P.mempty

instance P.HasAccountIds (SsmDocumentPermissions s) (TF.Attr s P.Text) where
    accountIds =
        P.lens (_accountIds :: SsmDocumentPermissions s -> TF.Attr s P.Text)
               (\s a -> s { _accountIds = a } :: SsmDocumentPermissions s)

instance P.HasType' (SsmDocumentPermissions s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: SsmDocumentPermissions s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: SsmDocumentPermissions s)

-- | @launch_template_network_interfaces@ nested settings.
data LaunchTemplateNetworkInterfaces s = LaunchTemplateNetworkInterfaces'
    { _associatePublicIpAddress :: TF.Attr s P.Bool
    -- ^ @associate_public_ip_address@ - (Optional)
    --
    , _deleteOnTermination      :: TF.Attr s P.Bool
    -- ^ @delete_on_termination@ - (Optional)
    --
    , _description              :: TF.Attr s P.Text
    -- ^ @description@ - (Optional)
    --
    , _deviceIndex              :: TF.Attr s P.Integer
    -- ^ @device_index@ - (Optional)
    --
    , _ipv4Addresses            :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @ipv4_addresses@ - (Optional)
    --
    , _ipv6Addresses            :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @ipv6_addresses@ - (Optional)
    --
    , _networkInterfaceId       :: TF.Attr s P.Text
    -- ^ @network_interface_id@ - (Optional)
    --
    , _privateIpAddress         :: TF.Attr s P.Text
    -- ^ @private_ip_address@ - (Optional)
    --
    , _securityGroups           :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @security_groups@ - (Optional)
    --
    , _subnetId                 :: TF.Attr s P.Text
    -- ^ @subnet_id@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLaunchTemplateNetworkInterfaces
    :: LaunchTemplateNetworkInterfaces s
newLaunchTemplateNetworkInterfaces =
    LaunchTemplateNetworkInterfaces'
        { _associatePublicIpAddress = TF.Nil
        , _deleteOnTermination = TF.Nil
        , _description = TF.Nil
        , _deviceIndex = TF.Nil
        , _ipv4Addresses = TF.Nil
        , _ipv6Addresses = TF.Nil
        , _networkInterfaceId = TF.Nil
        , _privateIpAddress = TF.Nil
        , _securityGroups = TF.Nil
        , _subnetId = TF.Nil
        }

instance P.Hashable  (LaunchTemplateNetworkInterfaces s)
instance TF.IsValue  (LaunchTemplateNetworkInterfaces s)
instance TF.IsObject (LaunchTemplateNetworkInterfaces s) where
    toObject LaunchTemplateNetworkInterfaces'{..} = P.catMaybes
        [ TF.assign "associate_public_ip_address" <$> TF.attribute _associatePublicIpAddress
        , TF.assign "delete_on_termination" <$> TF.attribute _deleteOnTermination
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "device_index" <$> TF.attribute _deviceIndex
        , TF.assign "ipv4_addresses" <$> TF.attribute _ipv4Addresses
        , TF.assign "ipv6_addresses" <$> TF.attribute _ipv6Addresses
        , TF.assign "network_interface_id" <$> TF.attribute _networkInterfaceId
        , TF.assign "private_ip_address" <$> TF.attribute _privateIpAddress
        , TF.assign "security_groups" <$> TF.attribute _securityGroups
        , TF.assign "subnet_id" <$> TF.attribute _subnetId
        ]

instance TF.IsValid (LaunchTemplateNetworkInterfaces s) where
    validator = P.mempty

instance P.HasAssociatePublicIpAddress (LaunchTemplateNetworkInterfaces s) (TF.Attr s P.Bool) where
    associatePublicIpAddress =
        P.lens (_associatePublicIpAddress :: LaunchTemplateNetworkInterfaces s -> TF.Attr s P.Bool)
               (\s a -> s { _associatePublicIpAddress = a } :: LaunchTemplateNetworkInterfaces s)

instance P.HasDeleteOnTermination (LaunchTemplateNetworkInterfaces s) (TF.Attr s P.Bool) where
    deleteOnTermination =
        P.lens (_deleteOnTermination :: LaunchTemplateNetworkInterfaces s -> TF.Attr s P.Bool)
               (\s a -> s { _deleteOnTermination = a } :: LaunchTemplateNetworkInterfaces s)

instance P.HasDescription (LaunchTemplateNetworkInterfaces s) (TF.Attr s P.Text) where
    description =
        P.lens (_description :: LaunchTemplateNetworkInterfaces s -> TF.Attr s P.Text)
               (\s a -> s { _description = a } :: LaunchTemplateNetworkInterfaces s)

instance P.HasDeviceIndex (LaunchTemplateNetworkInterfaces s) (TF.Attr s P.Integer) where
    deviceIndex =
        P.lens (_deviceIndex :: LaunchTemplateNetworkInterfaces s -> TF.Attr s P.Integer)
               (\s a -> s { _deviceIndex = a } :: LaunchTemplateNetworkInterfaces s)

instance P.HasIpv4Addresses (LaunchTemplateNetworkInterfaces s) (TF.Attr s [TF.Attr s P.Text]) where
    ipv4Addresses =
        P.lens (_ipv4Addresses :: LaunchTemplateNetworkInterfaces s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _ipv4Addresses = a } :: LaunchTemplateNetworkInterfaces s)

instance P.HasIpv6Addresses (LaunchTemplateNetworkInterfaces s) (TF.Attr s [TF.Attr s P.Text]) where
    ipv6Addresses =
        P.lens (_ipv6Addresses :: LaunchTemplateNetworkInterfaces s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _ipv6Addresses = a } :: LaunchTemplateNetworkInterfaces s)

instance P.HasNetworkInterfaceId (LaunchTemplateNetworkInterfaces s) (TF.Attr s P.Text) where
    networkInterfaceId =
        P.lens (_networkInterfaceId :: LaunchTemplateNetworkInterfaces s -> TF.Attr s P.Text)
               (\s a -> s { _networkInterfaceId = a } :: LaunchTemplateNetworkInterfaces s)

instance P.HasPrivateIpAddress (LaunchTemplateNetworkInterfaces s) (TF.Attr s P.Text) where
    privateIpAddress =
        P.lens (_privateIpAddress :: LaunchTemplateNetworkInterfaces s -> TF.Attr s P.Text)
               (\s a -> s { _privateIpAddress = a } :: LaunchTemplateNetworkInterfaces s)

instance P.HasSecurityGroups (LaunchTemplateNetworkInterfaces s) (TF.Attr s [TF.Attr s P.Text]) where
    securityGroups =
        P.lens (_securityGroups :: LaunchTemplateNetworkInterfaces s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _securityGroups = a } :: LaunchTemplateNetworkInterfaces s)

instance P.HasSubnetId (LaunchTemplateNetworkInterfaces s) (TF.Attr s P.Text) where
    subnetId =
        P.lens (_subnetId :: LaunchTemplateNetworkInterfaces s -> TF.Attr s P.Text)
               (\s a -> s { _subnetId = a } :: LaunchTemplateNetworkInterfaces s)

instance s ~ s' => P.HasComputedIpv4AddressCount (TF.Ref s' (LaunchTemplateNetworkInterfaces s)) (TF.Attr s P.Integer) where
    computedIpv4AddressCount x = TF.compute (TF.refKey x) "ipv4_address_count"

instance s ~ s' => P.HasComputedIpv6AddressCount (TF.Ref s' (LaunchTemplateNetworkInterfaces s)) (TF.Attr s P.Integer) where
    computedIpv6AddressCount x = TF.compute (TF.refKey x) "ipv6_address_count"

-- | @network_interface_attachment@ nested settings.
data NetworkInterfaceAttachment s = NetworkInterfaceAttachment'
    { _deviceIndex :: TF.Attr s P.Integer
    -- ^ @device_index@ - (Required)
    --
    , _instance'   :: TF.Attr s P.Text
    -- ^ @instance@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newNetworkInterfaceAttachment
    :: TF.Attr s P.Integer -- ^ @device_index@ - 'P.deviceIndex'
    -> TF.Attr s P.Text -- ^ @instance@ - 'P.instance''
    -> NetworkInterfaceAttachment s
newNetworkInterfaceAttachment _deviceIndex _instance' =
    NetworkInterfaceAttachment'
        { _deviceIndex = _deviceIndex
        , _instance' = _instance'
        }

instance P.Hashable  (NetworkInterfaceAttachment s)
instance TF.IsValue  (NetworkInterfaceAttachment s)
instance TF.IsObject (NetworkInterfaceAttachment s) where
    toObject NetworkInterfaceAttachment'{..} = P.catMaybes
        [ TF.assign "device_index" <$> TF.attribute _deviceIndex
        , TF.assign "instance" <$> TF.attribute _instance'
        ]

instance TF.IsValid (NetworkInterfaceAttachment s) where
    validator = P.mempty

instance P.HasDeviceIndex (NetworkInterfaceAttachment s) (TF.Attr s P.Integer) where
    deviceIndex =
        P.lens (_deviceIndex :: NetworkInterfaceAttachment s -> TF.Attr s P.Integer)
               (\s a -> s { _deviceIndex = a } :: NetworkInterfaceAttachment s)

instance P.HasInstance' (NetworkInterfaceAttachment s) (TF.Attr s P.Text) where
    instance' =
        P.lens (_instance' :: NetworkInterfaceAttachment s -> TF.Attr s P.Text)
               (\s a -> s { _instance' = a } :: NetworkInterfaceAttachment s)

instance s ~ s' => P.HasComputedAttachmentId (TF.Ref s' (NetworkInterfaceAttachment s)) (TF.Attr s P.Text) where
    computedAttachmentId x = TF.compute (TF.refKey x) "attachment_id"

instance s ~ s' => P.HasComputedDeviceIndex (TF.Ref s' (NetworkInterfaceAttachment s)) (TF.Attr s P.Integer) where
    computedDeviceIndex x = TF.compute (TF.refKey x) "device_index"

instance s ~ s' => P.HasComputedInstanceId (TF.Ref s' (NetworkInterfaceAttachment s)) (TF.Attr s P.Text) where
    computedInstanceId x = TF.compute (TF.refKey x) "instance_id"

instance s ~ s' => P.HasComputedInstanceOwnerId (TF.Ref s' (NetworkInterfaceAttachment s)) (TF.Attr s P.Text) where
    computedInstanceOwnerId x = TF.compute (TF.refKey x) "instance_owner_id"

-- | @route53_record_failover_routing_policy@ nested settings.
data Route53RecordFailoverRoutingPolicy s = Route53RecordFailoverRoutingPolicy'
    { _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRoute53RecordFailoverRoutingPolicy
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> Route53RecordFailoverRoutingPolicy s
newRoute53RecordFailoverRoutingPolicy _type' =
    Route53RecordFailoverRoutingPolicy'
        { _type' = _type'
        }

instance P.Hashable  (Route53RecordFailoverRoutingPolicy s)
instance TF.IsValue  (Route53RecordFailoverRoutingPolicy s)
instance TF.IsObject (Route53RecordFailoverRoutingPolicy s) where
    toObject Route53RecordFailoverRoutingPolicy'{..} = P.catMaybes
        [ TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (Route53RecordFailoverRoutingPolicy s) where
    validator = P.mempty

instance P.HasType' (Route53RecordFailoverRoutingPolicy s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: Route53RecordFailoverRoutingPolicy s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: Route53RecordFailoverRoutingPolicy s)

-- | @wafregional_geo_match_set_geo_match_constraint@ nested settings.
data WafregionalGeoMatchSetGeoMatchConstraint s = WafregionalGeoMatchSetGeoMatchConstraint'
    { _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    , _value :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafregionalGeoMatchSetGeoMatchConstraint
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> WafregionalGeoMatchSetGeoMatchConstraint s
newWafregionalGeoMatchSetGeoMatchConstraint _type' _value =
    WafregionalGeoMatchSetGeoMatchConstraint'
        { _type' = _type'
        , _value = _value
        }

instance P.Hashable  (WafregionalGeoMatchSetGeoMatchConstraint s)
instance TF.IsValue  (WafregionalGeoMatchSetGeoMatchConstraint s)
instance TF.IsObject (WafregionalGeoMatchSetGeoMatchConstraint s) where
    toObject WafregionalGeoMatchSetGeoMatchConstraint'{..} = P.catMaybes
        [ TF.assign "type" <$> TF.attribute _type'
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (WafregionalGeoMatchSetGeoMatchConstraint s) where
    validator = P.mempty

instance P.HasType' (WafregionalGeoMatchSetGeoMatchConstraint s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: WafregionalGeoMatchSetGeoMatchConstraint s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: WafregionalGeoMatchSetGeoMatchConstraint s)

instance P.HasValue (WafregionalGeoMatchSetGeoMatchConstraint s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: WafregionalGeoMatchSetGeoMatchConstraint s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: WafregionalGeoMatchSetGeoMatchConstraint s)

-- | @s3_bucket_cors_rule@ nested settings.
data S3BucketCorsRule s = S3BucketCorsRule'
    { _allowedHeaders :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @allowed_headers@ - (Optional)
    --
    , _allowedMethods :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @allowed_methods@ - (Required)
    --
    , _allowedOrigins :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @allowed_origins@ - (Required)
    --
    , _exposeHeaders  :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @expose_headers@ - (Optional)
    --
    , _maxAgeSeconds  :: TF.Attr s P.Integer
    -- ^ @max_age_seconds@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newS3BucketCorsRule
    :: TF.Attr s [TF.Attr s P.Text] -- ^ @allowed_methods@ - 'P.allowedMethods'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @allowed_origins@ - 'P.allowedOrigins'
    -> S3BucketCorsRule s
newS3BucketCorsRule _allowedMethods _allowedOrigins =
    S3BucketCorsRule'
        { _allowedHeaders = TF.Nil
        , _allowedMethods = _allowedMethods
        , _allowedOrigins = _allowedOrigins
        , _exposeHeaders = TF.Nil
        , _maxAgeSeconds = TF.Nil
        }

instance P.Hashable  (S3BucketCorsRule s)
instance TF.IsValue  (S3BucketCorsRule s)
instance TF.IsObject (S3BucketCorsRule s) where
    toObject S3BucketCorsRule'{..} = P.catMaybes
        [ TF.assign "allowed_headers" <$> TF.attribute _allowedHeaders
        , TF.assign "allowed_methods" <$> TF.attribute _allowedMethods
        , TF.assign "allowed_origins" <$> TF.attribute _allowedOrigins
        , TF.assign "expose_headers" <$> TF.attribute _exposeHeaders
        , TF.assign "max_age_seconds" <$> TF.attribute _maxAgeSeconds
        ]

instance TF.IsValid (S3BucketCorsRule s) where
    validator = P.mempty

instance P.HasAllowedHeaders (S3BucketCorsRule s) (TF.Attr s [TF.Attr s P.Text]) where
    allowedHeaders =
        P.lens (_allowedHeaders :: S3BucketCorsRule s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _allowedHeaders = a } :: S3BucketCorsRule s)

instance P.HasAllowedMethods (S3BucketCorsRule s) (TF.Attr s [TF.Attr s P.Text]) where
    allowedMethods =
        P.lens (_allowedMethods :: S3BucketCorsRule s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _allowedMethods = a } :: S3BucketCorsRule s)

instance P.HasAllowedOrigins (S3BucketCorsRule s) (TF.Attr s [TF.Attr s P.Text]) where
    allowedOrigins =
        P.lens (_allowedOrigins :: S3BucketCorsRule s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _allowedOrigins = a } :: S3BucketCorsRule s)

instance P.HasExposeHeaders (S3BucketCorsRule s) (TF.Attr s [TF.Attr s P.Text]) where
    exposeHeaders =
        P.lens (_exposeHeaders :: S3BucketCorsRule s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _exposeHeaders = a } :: S3BucketCorsRule s)

instance P.HasMaxAgeSeconds (S3BucketCorsRule s) (TF.Attr s P.Integer) where
    maxAgeSeconds =
        P.lens (_maxAgeSeconds :: S3BucketCorsRule s -> TF.Attr s P.Integer)
               (\s a -> s { _maxAgeSeconds = a } :: S3BucketCorsRule s)

-- | @default_security_group_ingress@ nested settings.
data DefaultSecurityGroupIngress s = DefaultSecurityGroupIngress'
    { _cidrBlocks     :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @cidr_blocks@ - (Optional)
    --
    , _description    :: TF.Attr s P.Text
    -- ^ @description@ - (Optional)
    --
    , _fromPort       :: TF.Attr s P.Integer
    -- ^ @from_port@ - (Required)
    --
    , _ipv6CidrBlocks :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @ipv6_cidr_blocks@ - (Optional)
    --
    , _protocol       :: TF.Attr s P.Text
    -- ^ @protocol@ - (Required)
    --
    , _securityGroups :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @security_groups@ - (Optional)
    --
    , _self           :: TF.Attr s P.Bool
    -- ^ @self@ - (Optional)
    --
    , _toPort         :: TF.Attr s P.Integer
    -- ^ @to_port@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDefaultSecurityGroupIngress
    :: TF.Attr s P.Integer -- ^ @from_port@ - 'P.fromPort'
    -> TF.Attr s P.Text -- ^ @protocol@ - 'P.protocol'
    -> TF.Attr s P.Integer -- ^ @to_port@ - 'P.toPort'
    -> DefaultSecurityGroupIngress s
newDefaultSecurityGroupIngress _fromPort _protocol _toPort =
    DefaultSecurityGroupIngress'
        { _cidrBlocks = TF.Nil
        , _description = TF.Nil
        , _fromPort = _fromPort
        , _ipv6CidrBlocks = TF.Nil
        , _protocol = _protocol
        , _securityGroups = TF.Nil
        , _self = TF.value P.False
        , _toPort = _toPort
        }

instance P.Hashable  (DefaultSecurityGroupIngress s)
instance TF.IsValue  (DefaultSecurityGroupIngress s)
instance TF.IsObject (DefaultSecurityGroupIngress s) where
    toObject DefaultSecurityGroupIngress'{..} = P.catMaybes
        [ TF.assign "cidr_blocks" <$> TF.attribute _cidrBlocks
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "from_port" <$> TF.attribute _fromPort
        , TF.assign "ipv6_cidr_blocks" <$> TF.attribute _ipv6CidrBlocks
        , TF.assign "protocol" <$> TF.attribute _protocol
        , TF.assign "security_groups" <$> TF.attribute _securityGroups
        , TF.assign "self" <$> TF.attribute _self
        , TF.assign "to_port" <$> TF.attribute _toPort
        ]

instance TF.IsValid (DefaultSecurityGroupIngress s) where
    validator = P.mempty

instance P.HasCidrBlocks (DefaultSecurityGroupIngress s) (TF.Attr s [TF.Attr s P.Text]) where
    cidrBlocks =
        P.lens (_cidrBlocks :: DefaultSecurityGroupIngress s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _cidrBlocks = a } :: DefaultSecurityGroupIngress s)

instance P.HasDescription (DefaultSecurityGroupIngress s) (TF.Attr s P.Text) where
    description =
        P.lens (_description :: DefaultSecurityGroupIngress s -> TF.Attr s P.Text)
               (\s a -> s { _description = a } :: DefaultSecurityGroupIngress s)

instance P.HasFromPort (DefaultSecurityGroupIngress s) (TF.Attr s P.Integer) where
    fromPort =
        P.lens (_fromPort :: DefaultSecurityGroupIngress s -> TF.Attr s P.Integer)
               (\s a -> s { _fromPort = a } :: DefaultSecurityGroupIngress s)

instance P.HasIpv6CidrBlocks (DefaultSecurityGroupIngress s) (TF.Attr s [TF.Attr s P.Text]) where
    ipv6CidrBlocks =
        P.lens (_ipv6CidrBlocks :: DefaultSecurityGroupIngress s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _ipv6CidrBlocks = a } :: DefaultSecurityGroupIngress s)

instance P.HasProtocol (DefaultSecurityGroupIngress s) (TF.Attr s P.Text) where
    protocol =
        P.lens (_protocol :: DefaultSecurityGroupIngress s -> TF.Attr s P.Text)
               (\s a -> s { _protocol = a } :: DefaultSecurityGroupIngress s)

instance P.HasSecurityGroups (DefaultSecurityGroupIngress s) (TF.Attr s [TF.Attr s P.Text]) where
    securityGroups =
        P.lens (_securityGroups :: DefaultSecurityGroupIngress s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _securityGroups = a } :: DefaultSecurityGroupIngress s)

instance P.HasSelf (DefaultSecurityGroupIngress s) (TF.Attr s P.Bool) where
    self =
        P.lens (_self :: DefaultSecurityGroupIngress s -> TF.Attr s P.Bool)
               (\s a -> s { _self = a } :: DefaultSecurityGroupIngress s)

instance P.HasToPort (DefaultSecurityGroupIngress s) (TF.Attr s P.Integer) where
    toPort =
        P.lens (_toPort :: DefaultSecurityGroupIngress s -> TF.Attr s P.Integer)
               (\s a -> s { _toPort = a } :: DefaultSecurityGroupIngress s)

-- | @cloudwatch_log_metric_filter_metric_transformation@ nested settings.
data CloudwatchLogMetricFilterMetricTransformation s = CloudwatchLogMetricFilterMetricTransformation'
    { _defaultValue :: TF.Attr s P.Double
    -- ^ @default_value@ - (Optional)
    --
    , _name         :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _namespace    :: TF.Attr s P.Text
    -- ^ @namespace@ - (Required)
    --
    , _value        :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCloudwatchLogMetricFilterMetricTransformation
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @namespace@ - 'P.namespace'
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> CloudwatchLogMetricFilterMetricTransformation s
newCloudwatchLogMetricFilterMetricTransformation _name _namespace _value =
    CloudwatchLogMetricFilterMetricTransformation'
        { _defaultValue = TF.Nil
        , _name = _name
        , _namespace = _namespace
        , _value = _value
        }

instance P.Hashable  (CloudwatchLogMetricFilterMetricTransformation s)
instance TF.IsValue  (CloudwatchLogMetricFilterMetricTransformation s)
instance TF.IsObject (CloudwatchLogMetricFilterMetricTransformation s) where
    toObject CloudwatchLogMetricFilterMetricTransformation'{..} = P.catMaybes
        [ TF.assign "default_value" <$> TF.attribute _defaultValue
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "namespace" <$> TF.attribute _namespace
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (CloudwatchLogMetricFilterMetricTransformation s) where
    validator = P.mempty

instance P.HasDefaultValue (CloudwatchLogMetricFilterMetricTransformation s) (TF.Attr s P.Double) where
    defaultValue =
        P.lens (_defaultValue :: CloudwatchLogMetricFilterMetricTransformation s -> TF.Attr s P.Double)
               (\s a -> s { _defaultValue = a } :: CloudwatchLogMetricFilterMetricTransformation s)

instance P.HasName (CloudwatchLogMetricFilterMetricTransformation s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: CloudwatchLogMetricFilterMetricTransformation s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: CloudwatchLogMetricFilterMetricTransformation s)

instance P.HasNamespace (CloudwatchLogMetricFilterMetricTransformation s) (TF.Attr s P.Text) where
    namespace =
        P.lens (_namespace :: CloudwatchLogMetricFilterMetricTransformation s -> TF.Attr s P.Text)
               (\s a -> s { _namespace = a } :: CloudwatchLogMetricFilterMetricTransformation s)

instance P.HasValue (CloudwatchLogMetricFilterMetricTransformation s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: CloudwatchLogMetricFilterMetricTransformation s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: CloudwatchLogMetricFilterMetricTransformation s)

-- | @launch_configuration_root_block_device@ nested settings.
data LaunchConfigurationRootBlockDevice s = LaunchConfigurationRootBlockDevice'
    { _deleteOnTermination :: TF.Attr s P.Bool
    -- ^ @delete_on_termination@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLaunchConfigurationRootBlockDevice
    :: LaunchConfigurationRootBlockDevice s
newLaunchConfigurationRootBlockDevice =
    LaunchConfigurationRootBlockDevice'
        { _deleteOnTermination = TF.value P.True
        }

instance P.Hashable  (LaunchConfigurationRootBlockDevice s)
instance TF.IsValue  (LaunchConfigurationRootBlockDevice s)
instance TF.IsObject (LaunchConfigurationRootBlockDevice s) where
    toObject LaunchConfigurationRootBlockDevice'{..} = P.catMaybes
        [ TF.assign "delete_on_termination" <$> TF.attribute _deleteOnTermination
        ]

instance TF.IsValid (LaunchConfigurationRootBlockDevice s) where
    validator = P.mempty

instance P.HasDeleteOnTermination (LaunchConfigurationRootBlockDevice s) (TF.Attr s P.Bool) where
    deleteOnTermination =
        P.lens (_deleteOnTermination :: LaunchConfigurationRootBlockDevice s -> TF.Attr s P.Bool)
               (\s a -> s { _deleteOnTermination = a } :: LaunchConfigurationRootBlockDevice s)

instance s ~ s' => P.HasComputedIops (TF.Ref s' (LaunchConfigurationRootBlockDevice s)) (TF.Attr s P.Integer) where
    computedIops x = TF.compute (TF.refKey x) "iops"

instance s ~ s' => P.HasComputedVolumeSize (TF.Ref s' (LaunchConfigurationRootBlockDevice s)) (TF.Attr s P.Integer) where
    computedVolumeSize x = TF.compute (TF.refKey x) "volume_size"

instance s ~ s' => P.HasComputedVolumeType (TF.Ref s' (LaunchConfigurationRootBlockDevice s)) (TF.Attr s P.Text) where
    computedVolumeType x = TF.compute (TF.refKey x) "volume_type"

instance s ~ s' => P.HasComputedDeleteOnTermination (TF.Ref s' (LaunchConfigurationRootBlockDevice s)) (TF.Attr s P.Bool) where
    computedDeleteOnTermination x = TF.compute (TF.refKey x) "delete_on_termination"

-- | @batch_job_definition_timeout@ nested settings.
data BatchJobDefinitionTimeout s = BatchJobDefinitionTimeout'
    { _attemptDurationSeconds :: TF.Attr s P.Integer
    -- ^ @attempt_duration_seconds@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newBatchJobDefinitionTimeout
    :: BatchJobDefinitionTimeout s
newBatchJobDefinitionTimeout =
    BatchJobDefinitionTimeout'
        { _attemptDurationSeconds = TF.Nil
        }

instance P.Hashable  (BatchJobDefinitionTimeout s)
instance TF.IsValue  (BatchJobDefinitionTimeout s)
instance TF.IsObject (BatchJobDefinitionTimeout s) where
    toObject BatchJobDefinitionTimeout'{..} = P.catMaybes
        [ TF.assign "attempt_duration_seconds" <$> TF.attribute _attemptDurationSeconds
        ]

instance TF.IsValid (BatchJobDefinitionTimeout s) where
    validator = P.mempty

instance P.HasAttemptDurationSeconds (BatchJobDefinitionTimeout s) (TF.Attr s P.Integer) where
    attemptDurationSeconds =
        P.lens (_attemptDurationSeconds :: BatchJobDefinitionTimeout s -> TF.Attr s P.Integer)
               (\s a -> s { _attemptDurationSeconds = a } :: BatchJobDefinitionTimeout s)

-- | @glue_trigger_predicate@ nested settings.
data GlueTriggerPredicate s = GlueTriggerPredicate'
    { _conditions :: TF.Attr s (P.NonEmpty (TF.Attr s (PredicateConditions s)))
    -- ^ @conditions@ - (Required)
    --
    , _logical    :: TF.Attr s P.Text
    -- ^ @logical@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newGlueTriggerPredicate
    :: TF.Attr s (P.NonEmpty (TF.Attr s (PredicateConditions s))) -- ^ @conditions@ - 'P.conditions'
    -> GlueTriggerPredicate s
newGlueTriggerPredicate _conditions =
    GlueTriggerPredicate'
        { _conditions = _conditions
        , _logical = TF.value "AND"
        }

instance P.Hashable  (GlueTriggerPredicate s)
instance TF.IsValue  (GlueTriggerPredicate s)
instance TF.IsObject (GlueTriggerPredicate s) where
    toObject GlueTriggerPredicate'{..} = P.catMaybes
        [ TF.assign "conditions" <$> TF.attribute _conditions
        , TF.assign "logical" <$> TF.attribute _logical
        ]

instance TF.IsValid (GlueTriggerPredicate s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_conditions"
                  (_conditions
                      :: GlueTriggerPredicate s -> TF.Attr s (P.NonEmpty (TF.Attr s (PredicateConditions s))))
                  TF.validator

instance P.HasConditions (GlueTriggerPredicate s) (TF.Attr s (P.NonEmpty (TF.Attr s (PredicateConditions s)))) where
    conditions =
        P.lens (_conditions :: GlueTriggerPredicate s -> TF.Attr s (P.NonEmpty (TF.Attr s (PredicateConditions s))))
               (\s a -> s { _conditions = a } :: GlueTriggerPredicate s)

instance P.HasLogical (GlueTriggerPredicate s) (TF.Attr s P.Text) where
    logical =
        P.lens (_logical :: GlueTriggerPredicate s -> TF.Attr s P.Text)
               (\s a -> s { _logical = a } :: GlueTriggerPredicate s)

-- | @opsworks_rails_app_layer_ebs_volume@ nested settings.
data OpsworksRailsAppLayerEbsVolume s = OpsworksRailsAppLayerEbsVolume'
    { _iops          :: TF.Attr s P.Integer
    -- ^ @iops@ - (Optional)
    --
    , _mountPoint    :: TF.Attr s P.Text
    -- ^ @mount_point@ - (Required)
    --
    , _numberOfDisks :: TF.Attr s P.Integer
    -- ^ @number_of_disks@ - (Required)
    --
    , _raidLevel     :: TF.Attr s P.Text
    -- ^ @raid_level@ - (Optional)
    --
    , _size          :: TF.Attr s P.Integer
    -- ^ @size@ - (Required)
    --
    , _type'         :: TF.Attr s P.Text
    -- ^ @type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newOpsworksRailsAppLayerEbsVolume
    :: TF.Attr s P.Text -- ^ @mount_point@ - 'P.mountPoint'
    -> TF.Attr s P.Integer -- ^ @number_of_disks@ - 'P.numberOfDisks'
    -> TF.Attr s P.Integer -- ^ @size@ - 'P.size'
    -> OpsworksRailsAppLayerEbsVolume s
newOpsworksRailsAppLayerEbsVolume _mountPoint _numberOfDisks _size =
    OpsworksRailsAppLayerEbsVolume'
        { _iops = TF.value 0
        , _mountPoint = _mountPoint
        , _numberOfDisks = _numberOfDisks
        , _raidLevel = TF.Nil
        , _size = _size
        , _type' = TF.value "standard"
        }

instance P.Hashable  (OpsworksRailsAppLayerEbsVolume s)
instance TF.IsValue  (OpsworksRailsAppLayerEbsVolume s)
instance TF.IsObject (OpsworksRailsAppLayerEbsVolume s) where
    toObject OpsworksRailsAppLayerEbsVolume'{..} = P.catMaybes
        [ TF.assign "iops" <$> TF.attribute _iops
        , TF.assign "mount_point" <$> TF.attribute _mountPoint
        , TF.assign "number_of_disks" <$> TF.attribute _numberOfDisks
        , TF.assign "raid_level" <$> TF.attribute _raidLevel
        , TF.assign "size" <$> TF.attribute _size
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (OpsworksRailsAppLayerEbsVolume s) where
    validator = P.mempty

instance P.HasIops (OpsworksRailsAppLayerEbsVolume s) (TF.Attr s P.Integer) where
    iops =
        P.lens (_iops :: OpsworksRailsAppLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _iops = a } :: OpsworksRailsAppLayerEbsVolume s)

instance P.HasMountPoint (OpsworksRailsAppLayerEbsVolume s) (TF.Attr s P.Text) where
    mountPoint =
        P.lens (_mountPoint :: OpsworksRailsAppLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _mountPoint = a } :: OpsworksRailsAppLayerEbsVolume s)

instance P.HasNumberOfDisks (OpsworksRailsAppLayerEbsVolume s) (TF.Attr s P.Integer) where
    numberOfDisks =
        P.lens (_numberOfDisks :: OpsworksRailsAppLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _numberOfDisks = a } :: OpsworksRailsAppLayerEbsVolume s)

instance P.HasRaidLevel (OpsworksRailsAppLayerEbsVolume s) (TF.Attr s P.Text) where
    raidLevel =
        P.lens (_raidLevel :: OpsworksRailsAppLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _raidLevel = a } :: OpsworksRailsAppLayerEbsVolume s)

instance P.HasSize (OpsworksRailsAppLayerEbsVolume s) (TF.Attr s P.Integer) where
    size =
        P.lens (_size :: OpsworksRailsAppLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _size = a } :: OpsworksRailsAppLayerEbsVolume s)

instance P.HasType' (OpsworksRailsAppLayerEbsVolume s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: OpsworksRailsAppLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: OpsworksRailsAppLayerEbsVolume s)

-- | @elastic_beanstalk_configuration_template_setting@ nested settings.
data ElasticBeanstalkConfigurationTemplateSetting s = ElasticBeanstalkConfigurationTemplateSetting'
    { _name      :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _namespace :: TF.Attr s P.Text
    -- ^ @namespace@ - (Required)
    --
    , _resource  :: TF.Attr s P.Text
    -- ^ @resource@ - (Optional)
    --
    , _value     :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElasticBeanstalkConfigurationTemplateSetting
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @namespace@ - 'P.namespace'
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> ElasticBeanstalkConfigurationTemplateSetting s
newElasticBeanstalkConfigurationTemplateSetting _name _namespace _value =
    ElasticBeanstalkConfigurationTemplateSetting'
        { _name = _name
        , _namespace = _namespace
        , _resource = TF.Nil
        , _value = _value
        }

instance P.Hashable  (ElasticBeanstalkConfigurationTemplateSetting s)
instance TF.IsValue  (ElasticBeanstalkConfigurationTemplateSetting s)
instance TF.IsObject (ElasticBeanstalkConfigurationTemplateSetting s) where
    toObject ElasticBeanstalkConfigurationTemplateSetting'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "namespace" <$> TF.attribute _namespace
        , TF.assign "resource" <$> TF.attribute _resource
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (ElasticBeanstalkConfigurationTemplateSetting s) where
    validator = P.mempty

instance P.HasName (ElasticBeanstalkConfigurationTemplateSetting s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: ElasticBeanstalkConfigurationTemplateSetting s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: ElasticBeanstalkConfigurationTemplateSetting s)

instance P.HasNamespace (ElasticBeanstalkConfigurationTemplateSetting s) (TF.Attr s P.Text) where
    namespace =
        P.lens (_namespace :: ElasticBeanstalkConfigurationTemplateSetting s -> TF.Attr s P.Text)
               (\s a -> s { _namespace = a } :: ElasticBeanstalkConfigurationTemplateSetting s)

instance P.HasResource (ElasticBeanstalkConfigurationTemplateSetting s) (TF.Attr s P.Text) where
    resource =
        P.lens (_resource :: ElasticBeanstalkConfigurationTemplateSetting s -> TF.Attr s P.Text)
               (\s a -> s { _resource = a } :: ElasticBeanstalkConfigurationTemplateSetting s)

instance P.HasValue (ElasticBeanstalkConfigurationTemplateSetting s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: ElasticBeanstalkConfigurationTemplateSetting s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: ElasticBeanstalkConfigurationTemplateSetting s)

-- | @cloudtrail_event_selector@ nested settings.
data CloudtrailEventSelector s = CloudtrailEventSelector'
    { _dataResource :: TF.Attr s [TF.Attr s (EventSelectorDataResource s)]
    -- ^ @data_resource@ - (Optional)
    --
    , _includeManagementEvents :: TF.Attr s P.Bool
    -- ^ @include_management_events@ - (Optional)
    --
    , _readWriteType :: TF.Attr s P.Text
    -- ^ @read_write_type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCloudtrailEventSelector
    :: CloudtrailEventSelector s
newCloudtrailEventSelector =
    CloudtrailEventSelector'
        { _dataResource = TF.Nil
        , _includeManagementEvents = TF.value P.True
        , _readWriteType = TF.value "All"
        }

instance P.Hashable  (CloudtrailEventSelector s)
instance TF.IsValue  (CloudtrailEventSelector s)
instance TF.IsObject (CloudtrailEventSelector s) where
    toObject CloudtrailEventSelector'{..} = P.catMaybes
        [ TF.assign "data_resource" <$> TF.attribute _dataResource
        , TF.assign "include_management_events" <$> TF.attribute _includeManagementEvents
        , TF.assign "read_write_type" <$> TF.attribute _readWriteType
        ]

instance TF.IsValid (CloudtrailEventSelector s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_dataResource"
                  (_dataResource
                      :: CloudtrailEventSelector s -> TF.Attr s [TF.Attr s (EventSelectorDataResource s)])
                  TF.validator

instance P.HasDataResource (CloudtrailEventSelector s) (TF.Attr s [TF.Attr s (EventSelectorDataResource s)]) where
    dataResource =
        P.lens (_dataResource :: CloudtrailEventSelector s -> TF.Attr s [TF.Attr s (EventSelectorDataResource s)])
               (\s a -> s { _dataResource = a } :: CloudtrailEventSelector s)

instance P.HasIncludeManagementEvents (CloudtrailEventSelector s) (TF.Attr s P.Bool) where
    includeManagementEvents =
        P.lens (_includeManagementEvents :: CloudtrailEventSelector s -> TF.Attr s P.Bool)
               (\s a -> s { _includeManagementEvents = a } :: CloudtrailEventSelector s)

instance P.HasReadWriteType (CloudtrailEventSelector s) (TF.Attr s P.Text) where
    readWriteType =
        P.lens (_readWriteType :: CloudtrailEventSelector s -> TF.Attr s P.Text)
               (\s a -> s { _readWriteType = a } :: CloudtrailEventSelector s)

-- | @storagegateway_gateway_smb_active_directory_settings@ nested settings.
data StoragegatewayGatewaySmbActiveDirectorySettings s = StoragegatewayGatewaySmbActiveDirectorySettings'
    { _domainName :: TF.Attr s P.Text
    -- ^ @domain_name@ - (Required)
    --
    , _password   :: TF.Attr s P.Text
    -- ^ @password@ - (Required)
    --
    , _username   :: TF.Attr s P.Text
    -- ^ @username@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newStoragegatewayGatewaySmbActiveDirectorySettings
    :: TF.Attr s P.Text -- ^ @domain_name@ - 'P.domainName'
    -> TF.Attr s P.Text -- ^ @password@ - 'P.password'
    -> TF.Attr s P.Text -- ^ @username@ - 'P.username'
    -> StoragegatewayGatewaySmbActiveDirectorySettings s
newStoragegatewayGatewaySmbActiveDirectorySettings _domainName _password _username =
    StoragegatewayGatewaySmbActiveDirectorySettings'
        { _domainName = _domainName
        , _password = _password
        , _username = _username
        }

instance P.Hashable  (StoragegatewayGatewaySmbActiveDirectorySettings s)
instance TF.IsValue  (StoragegatewayGatewaySmbActiveDirectorySettings s)
instance TF.IsObject (StoragegatewayGatewaySmbActiveDirectorySettings s) where
    toObject StoragegatewayGatewaySmbActiveDirectorySettings'{..} = P.catMaybes
        [ TF.assign "domain_name" <$> TF.attribute _domainName
        , TF.assign "password" <$> TF.attribute _password
        , TF.assign "username" <$> TF.attribute _username
        ]

instance TF.IsValid (StoragegatewayGatewaySmbActiveDirectorySettings s) where
    validator = P.mempty

instance P.HasDomainName (StoragegatewayGatewaySmbActiveDirectorySettings s) (TF.Attr s P.Text) where
    domainName =
        P.lens (_domainName :: StoragegatewayGatewaySmbActiveDirectorySettings s -> TF.Attr s P.Text)
               (\s a -> s { _domainName = a } :: StoragegatewayGatewaySmbActiveDirectorySettings s)

instance P.HasPassword (StoragegatewayGatewaySmbActiveDirectorySettings s) (TF.Attr s P.Text) where
    password =
        P.lens (_password :: StoragegatewayGatewaySmbActiveDirectorySettings s -> TF.Attr s P.Text)
               (\s a -> s { _password = a } :: StoragegatewayGatewaySmbActiveDirectorySettings s)

instance P.HasUsername (StoragegatewayGatewaySmbActiveDirectorySettings s) (TF.Attr s P.Text) where
    username =
        P.lens (_username :: StoragegatewayGatewaySmbActiveDirectorySettings s -> TF.Attr s P.Text)
               (\s a -> s { _username = a } :: StoragegatewayGatewaySmbActiveDirectorySettings s)

-- | @ecs_task_definition_volume@ nested settings.
data EcsTaskDefinitionVolume s = EcsTaskDefinitionVolume'
    { _hostPath :: TF.Attr s P.Text
    -- ^ @host_path@ - (Optional, Forces New)
    --
    , _name     :: TF.Attr s P.Text
    -- ^ @name@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newEcsTaskDefinitionVolume
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> EcsTaskDefinitionVolume s
newEcsTaskDefinitionVolume _name =
    EcsTaskDefinitionVolume'
        { _hostPath = TF.Nil
        , _name = _name
        }

instance P.Hashable  (EcsTaskDefinitionVolume s)
instance TF.IsValue  (EcsTaskDefinitionVolume s)
instance TF.IsObject (EcsTaskDefinitionVolume s) where
    toObject EcsTaskDefinitionVolume'{..} = P.catMaybes
        [ TF.assign "host_path" <$> TF.attribute _hostPath
        , TF.assign "name" <$> TF.attribute _name
        ]

instance TF.IsValid (EcsTaskDefinitionVolume s) where
    validator = P.mempty

instance P.HasHostPath (EcsTaskDefinitionVolume s) (TF.Attr s P.Text) where
    hostPath =
        P.lens (_hostPath :: EcsTaskDefinitionVolume s -> TF.Attr s P.Text)
               (\s a -> s { _hostPath = a } :: EcsTaskDefinitionVolume s)

instance P.HasName (EcsTaskDefinitionVolume s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: EcsTaskDefinitionVolume s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: EcsTaskDefinitionVolume s)

-- | @wafregional_web_acl_rule@ nested settings.
data WafregionalWebAclRule s = WafregionalWebAclRule'
    { _action         :: TF.Attr s (RuleAction s)
    -- ^ @action@ - (Optional)
    --
    , _overrideAction :: TF.Attr s (RuleOverrideAction s)
    -- ^ @override_action@ - (Optional)
    --
    , _priority       :: TF.Attr s P.Integer
    -- ^ @priority@ - (Required)
    --
    , _ruleId         :: TF.Attr s P.Text
    -- ^ @rule_id@ - (Required)
    --
    , _type'          :: TF.Attr s P.Text
    -- ^ @type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafregionalWebAclRule
    :: TF.Attr s P.Integer -- ^ @priority@ - 'P.priority'
    -> TF.Attr s P.Text -- ^ @rule_id@ - 'P.ruleId'
    -> WafregionalWebAclRule s
newWafregionalWebAclRule _priority _ruleId =
    WafregionalWebAclRule'
        { _action = TF.Nil
        , _overrideAction = TF.Nil
        , _priority = _priority
        , _ruleId = _ruleId
        , _type' = TF.value "REGULAR"
        }

instance P.Hashable  (WafregionalWebAclRule s)
instance TF.IsValue  (WafregionalWebAclRule s)
instance TF.IsObject (WafregionalWebAclRule s) where
    toObject WafregionalWebAclRule'{..} = P.catMaybes
        [ TF.assign "action" <$> TF.attribute _action
        , TF.assign "override_action" <$> TF.attribute _overrideAction
        , TF.assign "priority" <$> TF.attribute _priority
        , TF.assign "rule_id" <$> TF.attribute _ruleId
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (WafregionalWebAclRule s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_action"
                  (_action
                      :: WafregionalWebAclRule s -> TF.Attr s (RuleAction s))
                  TF.validator
           P.<> TF.settingsValidator "_overrideAction"
                  (_overrideAction
                      :: WafregionalWebAclRule s -> TF.Attr s (RuleOverrideAction s))
                  TF.validator

instance P.HasAction (WafregionalWebAclRule s) (TF.Attr s (RuleAction s)) where
    action =
        P.lens (_action :: WafregionalWebAclRule s -> TF.Attr s (RuleAction s))
               (\s a -> s { _action = a } :: WafregionalWebAclRule s)

instance P.HasOverrideAction (WafregionalWebAclRule s) (TF.Attr s (RuleOverrideAction s)) where
    overrideAction =
        P.lens (_overrideAction :: WafregionalWebAclRule s -> TF.Attr s (RuleOverrideAction s))
               (\s a -> s { _overrideAction = a } :: WafregionalWebAclRule s)

instance P.HasPriority (WafregionalWebAclRule s) (TF.Attr s P.Integer) where
    priority =
        P.lens (_priority :: WafregionalWebAclRule s -> TF.Attr s P.Integer)
               (\s a -> s { _priority = a } :: WafregionalWebAclRule s)

instance P.HasRuleId (WafregionalWebAclRule s) (TF.Attr s P.Text) where
    ruleId =
        P.lens (_ruleId :: WafregionalWebAclRule s -> TF.Attr s P.Text)
               (\s a -> s { _ruleId = a } :: WafregionalWebAclRule s)

instance P.HasType' (WafregionalWebAclRule s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: WafregionalWebAclRule s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: WafregionalWebAclRule s)

-- | @network_interface_association@ nested settings.
data NetworkInterfaceAssociation s = NetworkInterfaceAssociation'
    deriving (P.Show, P.Eq, P.Generic)

newNetworkInterfaceAssociation
    :: NetworkInterfaceAssociation s
newNetworkInterfaceAssociation =
    NetworkInterfaceAssociation'

instance P.Hashable  (NetworkInterfaceAssociation s)
instance TF.IsValue  (NetworkInterfaceAssociation s)
instance TF.IsObject (NetworkInterfaceAssociation s) where
    toObject NetworkInterfaceAssociation' = []

instance TF.IsValid (NetworkInterfaceAssociation s) where
    validator = P.mempty

instance s ~ s' => P.HasComputedAllocationId (TF.Ref s' (NetworkInterfaceAssociation s)) (TF.Attr s P.Text) where
    computedAllocationId x = TF.compute (TF.refKey x) "allocation_id"

instance s ~ s' => P.HasComputedAssociationId (TF.Ref s' (NetworkInterfaceAssociation s)) (TF.Attr s P.Text) where
    computedAssociationId x = TF.compute (TF.refKey x) "association_id"

instance s ~ s' => P.HasComputedIpOwnerId (TF.Ref s' (NetworkInterfaceAssociation s)) (TF.Attr s P.Text) where
    computedIpOwnerId x = TF.compute (TF.refKey x) "ip_owner_id"

instance s ~ s' => P.HasComputedPublicDnsName (TF.Ref s' (NetworkInterfaceAssociation s)) (TF.Attr s P.Text) where
    computedPublicDnsName x = TF.compute (TF.refKey x) "public_dns_name"

instance s ~ s' => P.HasComputedPublicIp (TF.Ref s' (NetworkInterfaceAssociation s)) (TF.Attr s P.Text) where
    computedPublicIp x = TF.compute (TF.refKey x) "public_ip"

-- | @spot_instance_request_ebs_block_device@ nested settings.
data SpotInstanceRequestEbsBlockDevice s = SpotInstanceRequestEbsBlockDevice'
    { _deleteOnTermination :: TF.Attr s P.Bool
    -- ^ @delete_on_termination@ - (Optional, Forces New)
    --
    , _deviceName          :: TF.Attr s P.Text
    -- ^ @device_name@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSpotInstanceRequestEbsBlockDevice
    :: TF.Attr s P.Text -- ^ @device_name@ - 'P.deviceName'
    -> SpotInstanceRequestEbsBlockDevice s
newSpotInstanceRequestEbsBlockDevice _deviceName =
    SpotInstanceRequestEbsBlockDevice'
        { _deleteOnTermination = TF.value P.True
        , _deviceName = _deviceName
        }

instance P.Hashable  (SpotInstanceRequestEbsBlockDevice s)
instance TF.IsValue  (SpotInstanceRequestEbsBlockDevice s)
instance TF.IsObject (SpotInstanceRequestEbsBlockDevice s) where
    toObject SpotInstanceRequestEbsBlockDevice'{..} = P.catMaybes
        [ TF.assign "delete_on_termination" <$> TF.attribute _deleteOnTermination
        , TF.assign "device_name" <$> TF.attribute _deviceName
        ]

instance TF.IsValid (SpotInstanceRequestEbsBlockDevice s) where
    validator = P.mempty

instance P.HasDeleteOnTermination (SpotInstanceRequestEbsBlockDevice s) (TF.Attr s P.Bool) where
    deleteOnTermination =
        P.lens (_deleteOnTermination :: SpotInstanceRequestEbsBlockDevice s -> TF.Attr s P.Bool)
               (\s a -> s { _deleteOnTermination = a } :: SpotInstanceRequestEbsBlockDevice s)

instance P.HasDeviceName (SpotInstanceRequestEbsBlockDevice s) (TF.Attr s P.Text) where
    deviceName =
        P.lens (_deviceName :: SpotInstanceRequestEbsBlockDevice s -> TF.Attr s P.Text)
               (\s a -> s { _deviceName = a } :: SpotInstanceRequestEbsBlockDevice s)

instance s ~ s' => P.HasComputedEncrypted (TF.Ref s' (SpotInstanceRequestEbsBlockDevice s)) (TF.Attr s P.Bool) where
    computedEncrypted x = TF.compute (TF.refKey x) "encrypted"

instance s ~ s' => P.HasComputedIops (TF.Ref s' (SpotInstanceRequestEbsBlockDevice s)) (TF.Attr s P.Integer) where
    computedIops x = TF.compute (TF.refKey x) "iops"

instance s ~ s' => P.HasComputedSnapshotId (TF.Ref s' (SpotInstanceRequestEbsBlockDevice s)) (TF.Attr s P.Text) where
    computedSnapshotId x = TF.compute (TF.refKey x) "snapshot_id"

instance s ~ s' => P.HasComputedVolumeId (TF.Ref s' (SpotInstanceRequestEbsBlockDevice s)) (TF.Attr s P.Text) where
    computedVolumeId x = TF.compute (TF.refKey x) "volume_id"

instance s ~ s' => P.HasComputedVolumeSize (TF.Ref s' (SpotInstanceRequestEbsBlockDevice s)) (TF.Attr s P.Integer) where
    computedVolumeSize x = TF.compute (TF.refKey x) "volume_size"

instance s ~ s' => P.HasComputedVolumeType (TF.Ref s' (SpotInstanceRequestEbsBlockDevice s)) (TF.Attr s P.Text) where
    computedVolumeType x = TF.compute (TF.refKey x) "volume_type"

-- | @admin_create_user_config_invite_message_template@ nested settings.
data AdminCreateUserConfigInviteMessageTemplate s = AdminCreateUserConfigInviteMessageTemplate'
    { _emailMessage :: TF.Attr s P.Text
    -- ^ @email_message@ - (Optional)
    --
    , _emailSubject :: TF.Attr s P.Text
    -- ^ @email_subject@ - (Optional)
    --
    , _smsMessage   :: TF.Attr s P.Text
    -- ^ @sms_message@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAdminCreateUserConfigInviteMessageTemplate
    :: AdminCreateUserConfigInviteMessageTemplate s
newAdminCreateUserConfigInviteMessageTemplate =
    AdminCreateUserConfigInviteMessageTemplate'
        { _emailMessage = TF.Nil
        , _emailSubject = TF.Nil
        , _smsMessage = TF.Nil
        }

instance P.Hashable  (AdminCreateUserConfigInviteMessageTemplate s)
instance TF.IsValue  (AdminCreateUserConfigInviteMessageTemplate s)
instance TF.IsObject (AdminCreateUserConfigInviteMessageTemplate s) where
    toObject AdminCreateUserConfigInviteMessageTemplate'{..} = P.catMaybes
        [ TF.assign "email_message" <$> TF.attribute _emailMessage
        , TF.assign "email_subject" <$> TF.attribute _emailSubject
        , TF.assign "sms_message" <$> TF.attribute _smsMessage
        ]

instance TF.IsValid (AdminCreateUserConfigInviteMessageTemplate s) where
    validator = P.mempty

instance P.HasEmailMessage (AdminCreateUserConfigInviteMessageTemplate s) (TF.Attr s P.Text) where
    emailMessage =
        P.lens (_emailMessage :: AdminCreateUserConfigInviteMessageTemplate s -> TF.Attr s P.Text)
               (\s a -> s { _emailMessage = a } :: AdminCreateUserConfigInviteMessageTemplate s)

instance P.HasEmailSubject (AdminCreateUserConfigInviteMessageTemplate s) (TF.Attr s P.Text) where
    emailSubject =
        P.lens (_emailSubject :: AdminCreateUserConfigInviteMessageTemplate s -> TF.Attr s P.Text)
               (\s a -> s { _emailSubject = a } :: AdminCreateUserConfigInviteMessageTemplate s)

instance P.HasSmsMessage (AdminCreateUserConfigInviteMessageTemplate s) (TF.Attr s P.Text) where
    smsMessage =
        P.lens (_smsMessage :: AdminCreateUserConfigInviteMessageTemplate s -> TF.Attr s P.Text)
               (\s a -> s { _smsMessage = a } :: AdminCreateUserConfigInviteMessageTemplate s)

-- | @alb_target_group_stickiness@ nested settings.
data AlbTargetGroupStickiness s = AlbTargetGroupStickiness'
    { _cookieDuration :: TF.Attr s P.Integer
    -- ^ @cookie_duration@ - (Optional)
    --
    , _enabled        :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Optional)
    --
    , _type'          :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAlbTargetGroupStickiness
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> AlbTargetGroupStickiness s
newAlbTargetGroupStickiness _type' =
    AlbTargetGroupStickiness'
        { _cookieDuration = TF.value 86400
        , _enabled = TF.value P.True
        , _type' = _type'
        }

instance P.Hashable  (AlbTargetGroupStickiness s)
instance TF.IsValue  (AlbTargetGroupStickiness s)
instance TF.IsObject (AlbTargetGroupStickiness s) where
    toObject AlbTargetGroupStickiness'{..} = P.catMaybes
        [ TF.assign "cookie_duration" <$> TF.attribute _cookieDuration
        , TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (AlbTargetGroupStickiness s) where
    validator = P.mempty

instance P.HasCookieDuration (AlbTargetGroupStickiness s) (TF.Attr s P.Integer) where
    cookieDuration =
        P.lens (_cookieDuration :: AlbTargetGroupStickiness s -> TF.Attr s P.Integer)
               (\s a -> s { _cookieDuration = a } :: AlbTargetGroupStickiness s)

instance P.HasEnabled (AlbTargetGroupStickiness s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: AlbTargetGroupStickiness s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: AlbTargetGroupStickiness s)

instance P.HasType' (AlbTargetGroupStickiness s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: AlbTargetGroupStickiness s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: AlbTargetGroupStickiness s)

instance s ~ s' => P.HasComputedCookieDuration (TF.Ref s' (AlbTargetGroupStickiness s)) (TF.Attr s P.Integer) where
    computedCookieDuration x = TF.compute (TF.refKey x) "cookie_duration"

instance s ~ s' => P.HasComputedEnabled (TF.Ref s' (AlbTargetGroupStickiness s)) (TF.Attr s P.Bool) where
    computedEnabled x = TF.compute (TF.refKey x) "enabled"

instance s ~ s' => P.HasComputedType (TF.Ref s' (AlbTargetGroupStickiness s)) (TF.Attr s P.Text) where
    computedType x = TF.compute (TF.refKey x) "type"

-- | @lb_listener_default_action@ nested settings.
data LbListenerDefaultAction s = LbListenerDefaultAction'
    { _targetGroupArn :: TF.Attr s P.Text
    -- ^ @target_group_arn@ - (Required)
    --
    , _type'          :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLbListenerDefaultAction
    :: TF.Attr s P.Text -- ^ @target_group_arn@ - 'P.targetGroupArn'
    -> TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> LbListenerDefaultAction s
newLbListenerDefaultAction _targetGroupArn _type' =
    LbListenerDefaultAction'
        { _targetGroupArn = _targetGroupArn
        , _type' = _type'
        }

instance P.Hashable  (LbListenerDefaultAction s)
instance TF.IsValue  (LbListenerDefaultAction s)
instance TF.IsObject (LbListenerDefaultAction s) where
    toObject LbListenerDefaultAction'{..} = P.catMaybes
        [ TF.assign "target_group_arn" <$> TF.attribute _targetGroupArn
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (LbListenerDefaultAction s) where
    validator = P.mempty

instance P.HasTargetGroupArn (LbListenerDefaultAction s) (TF.Attr s P.Text) where
    targetGroupArn =
        P.lens (_targetGroupArn :: LbListenerDefaultAction s -> TF.Attr s P.Text)
               (\s a -> s { _targetGroupArn = a } :: LbListenerDefaultAction s)

instance P.HasType' (LbListenerDefaultAction s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: LbListenerDefaultAction s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: LbListenerDefaultAction s)

instance s ~ s' => P.HasComputedTargetGroupArn (TF.Ref s' (LbListenerDefaultAction s)) (TF.Attr s P.Text) where
    computedTargetGroupArn x = TF.compute (TF.refKey x) "target_group_arn"

instance s ~ s' => P.HasComputedType (TF.Ref s' (LbListenerDefaultAction s)) (TF.Attr s P.Text) where
    computedType x = TF.compute (TF.refKey x) "type"

-- | @ami_filter@ nested settings.
data AmiFilter s = AmiFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAmiFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> AmiFilter s
newAmiFilter _name _values =
    AmiFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (AmiFilter s)
instance TF.IsValue  (AmiFilter s)
instance TF.IsObject (AmiFilter s) where
    toObject AmiFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (AmiFilter s) where
    validator = P.mempty

instance P.HasName (AmiFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: AmiFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: AmiFilter s)

instance P.HasValues (AmiFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: AmiFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: AmiFilter s)

-- | @launch_template_iam_instance_profile@ nested settings.
data LaunchTemplateIamInstanceProfile s = LaunchTemplateIamInstanceProfile'
    { _arn  :: TF.Attr s P.Text
    -- ^ @arn@ - (Optional)
    --
    -- Conflicts with:
    --
    -- * 'name'
    , _name :: TF.Attr s P.Text
    -- ^ @name@ - (Optional)
    --
    -- Conflicts with:
    --
    -- * 'arn'
    } deriving (P.Show, P.Eq, P.Generic)

newLaunchTemplateIamInstanceProfile
    :: LaunchTemplateIamInstanceProfile s
newLaunchTemplateIamInstanceProfile =
    LaunchTemplateIamInstanceProfile'
        { _arn = TF.Nil
        , _name = TF.Nil
        }

instance P.Hashable  (LaunchTemplateIamInstanceProfile s)
instance TF.IsValue  (LaunchTemplateIamInstanceProfile s)
instance TF.IsObject (LaunchTemplateIamInstanceProfile s) where
    toObject LaunchTemplateIamInstanceProfile'{..} = P.catMaybes
        [ TF.assign "arn" <$> TF.attribute _arn
        , TF.assign "name" <$> TF.attribute _name
        ]

instance TF.IsValid (LaunchTemplateIamInstanceProfile s) where
    validator = TF.fieldsValidator (\LaunchTemplateIamInstanceProfile'{..} -> Map.fromList $ P.catMaybes
        [ if (_arn P.== TF.Nil)
              then P.Nothing
              else P.Just ("_arn",
                            [ "_name"
                            ])
        , if (_name P.== TF.Nil)
              then P.Nothing
              else P.Just ("_name",
                            [ "_arn"
                            ])
        ])

instance P.HasArn (LaunchTemplateIamInstanceProfile s) (TF.Attr s P.Text) where
    arn =
        P.lens (_arn :: LaunchTemplateIamInstanceProfile s -> TF.Attr s P.Text)
               (\s a -> s { _arn = a } :: LaunchTemplateIamInstanceProfile s)

instance P.HasName (LaunchTemplateIamInstanceProfile s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: LaunchTemplateIamInstanceProfile s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: LaunchTemplateIamInstanceProfile s)

-- | @instances_filter@ nested settings.
data InstancesFilter s = InstancesFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newInstancesFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> InstancesFilter s
newInstancesFilter _name _values =
    InstancesFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (InstancesFilter s)
instance TF.IsValue  (InstancesFilter s)
instance TF.IsObject (InstancesFilter s) where
    toObject InstancesFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (InstancesFilter s) where
    validator = P.mempty

instance P.HasName (InstancesFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: InstancesFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: InstancesFilter s)

instance P.HasValues (InstancesFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: InstancesFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: InstancesFilter s)

-- | @cloudfront_distribution_ordered_cache_behavior@ nested settings.
data CloudfrontDistributionOrderedCacheBehavior s = CloudfrontDistributionOrderedCacheBehavior'
    { _allowedMethods :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @allowed_methods@ - (Required)
    --
    , _cachedMethods :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @cached_methods@ - (Required)
    --
    , _compress :: TF.Attr s P.Bool
    -- ^ @compress@ - (Optional)
    --
    , _defaultTtl :: TF.Attr s P.Integer
    -- ^ @default_ttl@ - (Optional)
    --
    , _fieldLevelEncryptionId :: TF.Attr s P.Text
    -- ^ @field_level_encryption_id@ - (Optional)
    --
    , _forwardedValues :: TF.Attr s (OrderedCacheBehaviorForwardedValues s)
    -- ^ @forwarded_values@ - (Required)
    --
    , _lambdaFunctionAssociation :: TF.Attr s [TF.Attr s (OrderedCacheBehaviorLambdaFunctionAssociation s)]
    -- ^ @lambda_function_association@ - (Optional)
    --
    , _maxTtl :: TF.Attr s P.Integer
    -- ^ @max_ttl@ - (Optional)
    --
    , _minTtl :: TF.Attr s P.Integer
    -- ^ @min_ttl@ - (Optional)
    --
    , _pathPattern :: TF.Attr s P.Text
    -- ^ @path_pattern@ - (Required)
    --
    , _smoothStreaming :: TF.Attr s P.Bool
    -- ^ @smooth_streaming@ - (Optional)
    --
    , _targetOriginId :: TF.Attr s P.Text
    -- ^ @target_origin_id@ - (Required)
    --
    , _trustedSigners :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @trusted_signers@ - (Optional)
    --
    , _viewerProtocolPolicy :: TF.Attr s P.Text
    -- ^ @viewer_protocol_policy@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCloudfrontDistributionOrderedCacheBehavior
    :: TF.Attr s [TF.Attr s P.Text] -- ^ @allowed_methods@ - 'P.allowedMethods'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @cached_methods@ - 'P.cachedMethods'
    -> TF.Attr s (OrderedCacheBehaviorForwardedValues s) -- ^ @forwarded_values@ - 'P.forwardedValues'
    -> TF.Attr s P.Text -- ^ @path_pattern@ - 'P.pathPattern'
    -> TF.Attr s P.Text -- ^ @target_origin_id@ - 'P.targetOriginId'
    -> TF.Attr s P.Text -- ^ @viewer_protocol_policy@ - 'P.viewerProtocolPolicy'
    -> CloudfrontDistributionOrderedCacheBehavior s
newCloudfrontDistributionOrderedCacheBehavior _allowedMethods _cachedMethods _forwardedValues _pathPattern _targetOriginId _viewerProtocolPolicy =
    CloudfrontDistributionOrderedCacheBehavior'
        { _allowedMethods = _allowedMethods
        , _cachedMethods = _cachedMethods
        , _compress = TF.value P.False
        , _defaultTtl = TF.value 86400
        , _fieldLevelEncryptionId = TF.Nil
        , _forwardedValues = _forwardedValues
        , _lambdaFunctionAssociation = TF.Nil
        , _maxTtl = TF.value 31536000
        , _minTtl = TF.value 0
        , _pathPattern = _pathPattern
        , _smoothStreaming = TF.Nil
        , _targetOriginId = _targetOriginId
        , _trustedSigners = TF.Nil
        , _viewerProtocolPolicy = _viewerProtocolPolicy
        }

instance P.Hashable  (CloudfrontDistributionOrderedCacheBehavior s)
instance TF.IsValue  (CloudfrontDistributionOrderedCacheBehavior s)
instance TF.IsObject (CloudfrontDistributionOrderedCacheBehavior s) where
    toObject CloudfrontDistributionOrderedCacheBehavior'{..} = P.catMaybes
        [ TF.assign "allowed_methods" <$> TF.attribute _allowedMethods
        , TF.assign "cached_methods" <$> TF.attribute _cachedMethods
        , TF.assign "compress" <$> TF.attribute _compress
        , TF.assign "default_ttl" <$> TF.attribute _defaultTtl
        , TF.assign "field_level_encryption_id" <$> TF.attribute _fieldLevelEncryptionId
        , TF.assign "forwarded_values" <$> TF.attribute _forwardedValues
        , TF.assign "lambda_function_association" <$> TF.attribute _lambdaFunctionAssociation
        , TF.assign "max_ttl" <$> TF.attribute _maxTtl
        , TF.assign "min_ttl" <$> TF.attribute _minTtl
        , TF.assign "path_pattern" <$> TF.attribute _pathPattern
        , TF.assign "smooth_streaming" <$> TF.attribute _smoothStreaming
        , TF.assign "target_origin_id" <$> TF.attribute _targetOriginId
        , TF.assign "trusted_signers" <$> TF.attribute _trustedSigners
        , TF.assign "viewer_protocol_policy" <$> TF.attribute _viewerProtocolPolicy
        ]

instance TF.IsValid (CloudfrontDistributionOrderedCacheBehavior s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_forwardedValues"
                  (_forwardedValues
                      :: CloudfrontDistributionOrderedCacheBehavior s -> TF.Attr s (OrderedCacheBehaviorForwardedValues s))
                  TF.validator
           P.<> TF.settingsValidator "_lambdaFunctionAssociation"
                  (_lambdaFunctionAssociation
                      :: CloudfrontDistributionOrderedCacheBehavior s -> TF.Attr s [TF.Attr s (OrderedCacheBehaviorLambdaFunctionAssociation s)])
                  TF.validator

instance P.HasAllowedMethods (CloudfrontDistributionOrderedCacheBehavior s) (TF.Attr s [TF.Attr s P.Text]) where
    allowedMethods =
        P.lens (_allowedMethods :: CloudfrontDistributionOrderedCacheBehavior s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _allowedMethods = a } :: CloudfrontDistributionOrderedCacheBehavior s)

instance P.HasCachedMethods (CloudfrontDistributionOrderedCacheBehavior s) (TF.Attr s [TF.Attr s P.Text]) where
    cachedMethods =
        P.lens (_cachedMethods :: CloudfrontDistributionOrderedCacheBehavior s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _cachedMethods = a } :: CloudfrontDistributionOrderedCacheBehavior s)

instance P.HasCompress (CloudfrontDistributionOrderedCacheBehavior s) (TF.Attr s P.Bool) where
    compress =
        P.lens (_compress :: CloudfrontDistributionOrderedCacheBehavior s -> TF.Attr s P.Bool)
               (\s a -> s { _compress = a } :: CloudfrontDistributionOrderedCacheBehavior s)

instance P.HasDefaultTtl (CloudfrontDistributionOrderedCacheBehavior s) (TF.Attr s P.Integer) where
    defaultTtl =
        P.lens (_defaultTtl :: CloudfrontDistributionOrderedCacheBehavior s -> TF.Attr s P.Integer)
               (\s a -> s { _defaultTtl = a } :: CloudfrontDistributionOrderedCacheBehavior s)

instance P.HasFieldLevelEncryptionId (CloudfrontDistributionOrderedCacheBehavior s) (TF.Attr s P.Text) where
    fieldLevelEncryptionId =
        P.lens (_fieldLevelEncryptionId :: CloudfrontDistributionOrderedCacheBehavior s -> TF.Attr s P.Text)
               (\s a -> s { _fieldLevelEncryptionId = a } :: CloudfrontDistributionOrderedCacheBehavior s)

instance P.HasForwardedValues (CloudfrontDistributionOrderedCacheBehavior s) (TF.Attr s (OrderedCacheBehaviorForwardedValues s)) where
    forwardedValues =
        P.lens (_forwardedValues :: CloudfrontDistributionOrderedCacheBehavior s -> TF.Attr s (OrderedCacheBehaviorForwardedValues s))
               (\s a -> s { _forwardedValues = a } :: CloudfrontDistributionOrderedCacheBehavior s)

instance P.HasLambdaFunctionAssociation (CloudfrontDistributionOrderedCacheBehavior s) (TF.Attr s [TF.Attr s (OrderedCacheBehaviorLambdaFunctionAssociation s)]) where
    lambdaFunctionAssociation =
        P.lens (_lambdaFunctionAssociation :: CloudfrontDistributionOrderedCacheBehavior s -> TF.Attr s [TF.Attr s (OrderedCacheBehaviorLambdaFunctionAssociation s)])
               (\s a -> s { _lambdaFunctionAssociation = a } :: CloudfrontDistributionOrderedCacheBehavior s)

instance P.HasMaxTtl (CloudfrontDistributionOrderedCacheBehavior s) (TF.Attr s P.Integer) where
    maxTtl =
        P.lens (_maxTtl :: CloudfrontDistributionOrderedCacheBehavior s -> TF.Attr s P.Integer)
               (\s a -> s { _maxTtl = a } :: CloudfrontDistributionOrderedCacheBehavior s)

instance P.HasMinTtl (CloudfrontDistributionOrderedCacheBehavior s) (TF.Attr s P.Integer) where
    minTtl =
        P.lens (_minTtl :: CloudfrontDistributionOrderedCacheBehavior s -> TF.Attr s P.Integer)
               (\s a -> s { _minTtl = a } :: CloudfrontDistributionOrderedCacheBehavior s)

instance P.HasPathPattern (CloudfrontDistributionOrderedCacheBehavior s) (TF.Attr s P.Text) where
    pathPattern =
        P.lens (_pathPattern :: CloudfrontDistributionOrderedCacheBehavior s -> TF.Attr s P.Text)
               (\s a -> s { _pathPattern = a } :: CloudfrontDistributionOrderedCacheBehavior s)

instance P.HasSmoothStreaming (CloudfrontDistributionOrderedCacheBehavior s) (TF.Attr s P.Bool) where
    smoothStreaming =
        P.lens (_smoothStreaming :: CloudfrontDistributionOrderedCacheBehavior s -> TF.Attr s P.Bool)
               (\s a -> s { _smoothStreaming = a } :: CloudfrontDistributionOrderedCacheBehavior s)

instance P.HasTargetOriginId (CloudfrontDistributionOrderedCacheBehavior s) (TF.Attr s P.Text) where
    targetOriginId =
        P.lens (_targetOriginId :: CloudfrontDistributionOrderedCacheBehavior s -> TF.Attr s P.Text)
               (\s a -> s { _targetOriginId = a } :: CloudfrontDistributionOrderedCacheBehavior s)

instance P.HasTrustedSigners (CloudfrontDistributionOrderedCacheBehavior s) (TF.Attr s [TF.Attr s P.Text]) where
    trustedSigners =
        P.lens (_trustedSigners :: CloudfrontDistributionOrderedCacheBehavior s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _trustedSigners = a } :: CloudfrontDistributionOrderedCacheBehavior s)

instance P.HasViewerProtocolPolicy (CloudfrontDistributionOrderedCacheBehavior s) (TF.Attr s P.Text) where
    viewerProtocolPolicy =
        P.lens (_viewerProtocolPolicy :: CloudfrontDistributionOrderedCacheBehavior s -> TF.Attr s P.Text)
               (\s a -> s { _viewerProtocolPolicy = a } :: CloudfrontDistributionOrderedCacheBehavior s)

-- | @directory_service_directory_vpc_settings@ nested settings.
data DirectoryServiceDirectoryVpcSettings s = DirectoryServiceDirectoryVpcSettings'
    { _subnetIds :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @subnet_ids@ - (Required, Forces New)
    --
    , _vpcId     :: TF.Attr s P.Text
    -- ^ @vpc_id@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDirectoryServiceDirectoryVpcSettings
    :: TF.Attr s [TF.Attr s P.Text] -- ^ @subnet_ids@ - 'P.subnetIds'
    -> TF.Attr s P.Text -- ^ @vpc_id@ - 'P.vpcId'
    -> DirectoryServiceDirectoryVpcSettings s
newDirectoryServiceDirectoryVpcSettings _subnetIds _vpcId =
    DirectoryServiceDirectoryVpcSettings'
        { _subnetIds = _subnetIds
        , _vpcId = _vpcId
        }

instance P.Hashable  (DirectoryServiceDirectoryVpcSettings s)
instance TF.IsValue  (DirectoryServiceDirectoryVpcSettings s)
instance TF.IsObject (DirectoryServiceDirectoryVpcSettings s) where
    toObject DirectoryServiceDirectoryVpcSettings'{..} = P.catMaybes
        [ TF.assign "subnet_ids" <$> TF.attribute _subnetIds
        , TF.assign "vpc_id" <$> TF.attribute _vpcId
        ]

instance TF.IsValid (DirectoryServiceDirectoryVpcSettings s) where
    validator = P.mempty

instance P.HasSubnetIds (DirectoryServiceDirectoryVpcSettings s) (TF.Attr s [TF.Attr s P.Text]) where
    subnetIds =
        P.lens (_subnetIds :: DirectoryServiceDirectoryVpcSettings s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _subnetIds = a } :: DirectoryServiceDirectoryVpcSettings s)

instance P.HasVpcId (DirectoryServiceDirectoryVpcSettings s) (TF.Attr s P.Text) where
    vpcId =
        P.lens (_vpcId :: DirectoryServiceDirectoryVpcSettings s -> TF.Attr s P.Text)
               (\s a -> s { _vpcId = a } :: DirectoryServiceDirectoryVpcSettings s)

-- | @s3_bucket_notification_topic@ nested settings.
data S3BucketNotificationTopic s = S3BucketNotificationTopic'
    { _events       :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @events@ - (Required)
    --
    , _filterPrefix :: TF.Attr s P.Text
    -- ^ @filter_prefix@ - (Optional)
    --
    , _filterSuffix :: TF.Attr s P.Text
    -- ^ @filter_suffix@ - (Optional)
    --
    , _topicArn     :: TF.Attr s P.Text
    -- ^ @topic_arn@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newS3BucketNotificationTopic
    :: TF.Attr s [TF.Attr s P.Text] -- ^ @events@ - 'P.events'
    -> TF.Attr s P.Text -- ^ @topic_arn@ - 'P.topicArn'
    -> S3BucketNotificationTopic s
newS3BucketNotificationTopic _events _topicArn =
    S3BucketNotificationTopic'
        { _events = _events
        , _filterPrefix = TF.Nil
        , _filterSuffix = TF.Nil
        , _topicArn = _topicArn
        }

instance P.Hashable  (S3BucketNotificationTopic s)
instance TF.IsValue  (S3BucketNotificationTopic s)
instance TF.IsObject (S3BucketNotificationTopic s) where
    toObject S3BucketNotificationTopic'{..} = P.catMaybes
        [ TF.assign "events" <$> TF.attribute _events
        , TF.assign "filter_prefix" <$> TF.attribute _filterPrefix
        , TF.assign "filter_suffix" <$> TF.attribute _filterSuffix
        , TF.assign "topic_arn" <$> TF.attribute _topicArn
        ]

instance TF.IsValid (S3BucketNotificationTopic s) where
    validator = P.mempty

instance P.HasEvents (S3BucketNotificationTopic s) (TF.Attr s [TF.Attr s P.Text]) where
    events =
        P.lens (_events :: S3BucketNotificationTopic s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _events = a } :: S3BucketNotificationTopic s)

instance P.HasFilterPrefix (S3BucketNotificationTopic s) (TF.Attr s P.Text) where
    filterPrefix =
        P.lens (_filterPrefix :: S3BucketNotificationTopic s -> TF.Attr s P.Text)
               (\s a -> s { _filterPrefix = a } :: S3BucketNotificationTopic s)

instance P.HasFilterSuffix (S3BucketNotificationTopic s) (TF.Attr s P.Text) where
    filterSuffix =
        P.lens (_filterSuffix :: S3BucketNotificationTopic s -> TF.Attr s P.Text)
               (\s a -> s { _filterSuffix = a } :: S3BucketNotificationTopic s)

instance P.HasTopicArn (S3BucketNotificationTopic s) (TF.Attr s P.Text) where
    topicArn =
        P.lens (_topicArn :: S3BucketNotificationTopic s -> TF.Attr s P.Text)
               (\s a -> s { _topicArn = a } :: S3BucketNotificationTopic s)

instance s ~ s' => P.HasComputedId (TF.Ref s' (S3BucketNotificationTopic s)) (TF.Attr s P.Text) where
    computedId x = TF.compute (TF.refKey x) "id"

-- | @lb_access_logs@ nested settings.
data LbAccessLogs s = LbAccessLogs'
    { _bucket  :: TF.Attr s P.Text
    -- ^ @bucket@ - (Required)
    --
    , _enabled :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Optional)
    --
    , _prefix  :: TF.Attr s P.Text
    -- ^ @prefix@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLbAccessLogs
    :: TF.Attr s P.Text -- ^ @bucket@ - 'P.bucket'
    -> LbAccessLogs s
newLbAccessLogs _bucket =
    LbAccessLogs'
        { _bucket = _bucket
        , _enabled = TF.Nil
        , _prefix = TF.Nil
        }

instance P.Hashable  (LbAccessLogs s)
instance TF.IsValue  (LbAccessLogs s)
instance TF.IsObject (LbAccessLogs s) where
    toObject LbAccessLogs'{..} = P.catMaybes
        [ TF.assign "bucket" <$> TF.attribute _bucket
        , TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "prefix" <$> TF.attribute _prefix
        ]

instance TF.IsValid (LbAccessLogs s) where
    validator = P.mempty

instance P.HasBucket (LbAccessLogs s) (TF.Attr s P.Text) where
    bucket =
        P.lens (_bucket :: LbAccessLogs s -> TF.Attr s P.Text)
               (\s a -> s { _bucket = a } :: LbAccessLogs s)

instance P.HasEnabled (LbAccessLogs s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: LbAccessLogs s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: LbAccessLogs s)

instance P.HasPrefix (LbAccessLogs s) (TF.Attr s P.Text) where
    prefix =
        P.lens (_prefix :: LbAccessLogs s -> TF.Attr s P.Text)
               (\s a -> s { _prefix = a } :: LbAccessLogs s)

instance s ~ s' => P.HasComputedBucket (TF.Ref s' (LbAccessLogs s)) (TF.Attr s P.Text) where
    computedBucket x = TF.compute (TF.refKey x) "bucket"

instance s ~ s' => P.HasComputedEnabled (TF.Ref s' (LbAccessLogs s)) (TF.Attr s P.Bool) where
    computedEnabled x = TF.compute (TF.refKey x) "enabled"

instance s ~ s' => P.HasComputedPrefix (TF.Ref s' (LbAccessLogs s)) (TF.Attr s P.Text) where
    computedPrefix x = TF.compute (TF.refKey x) "prefix"

-- | @elastic_beanstalk_environment_all_settings@ nested settings.
data ElasticBeanstalkEnvironmentAllSettings s = ElasticBeanstalkEnvironmentAllSettings'
    { _name      :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _namespace :: TF.Attr s P.Text
    -- ^ @namespace@ - (Required)
    --
    , _resource  :: TF.Attr s P.Text
    -- ^ @resource@ - (Optional)
    --
    , _value     :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElasticBeanstalkEnvironmentAllSettings
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @namespace@ - 'P.namespace'
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> ElasticBeanstalkEnvironmentAllSettings s
newElasticBeanstalkEnvironmentAllSettings _name _namespace _value =
    ElasticBeanstalkEnvironmentAllSettings'
        { _name = _name
        , _namespace = _namespace
        , _resource = TF.Nil
        , _value = _value
        }

instance P.Hashable  (ElasticBeanstalkEnvironmentAllSettings s)
instance TF.IsValue  (ElasticBeanstalkEnvironmentAllSettings s)
instance TF.IsObject (ElasticBeanstalkEnvironmentAllSettings s) where
    toObject ElasticBeanstalkEnvironmentAllSettings'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "namespace" <$> TF.attribute _namespace
        , TF.assign "resource" <$> TF.attribute _resource
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (ElasticBeanstalkEnvironmentAllSettings s) where
    validator = P.mempty

instance P.HasName (ElasticBeanstalkEnvironmentAllSettings s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: ElasticBeanstalkEnvironmentAllSettings s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: ElasticBeanstalkEnvironmentAllSettings s)

instance P.HasNamespace (ElasticBeanstalkEnvironmentAllSettings s) (TF.Attr s P.Text) where
    namespace =
        P.lens (_namespace :: ElasticBeanstalkEnvironmentAllSettings s -> TF.Attr s P.Text)
               (\s a -> s { _namespace = a } :: ElasticBeanstalkEnvironmentAllSettings s)

instance P.HasResource (ElasticBeanstalkEnvironmentAllSettings s) (TF.Attr s P.Text) where
    resource =
        P.lens (_resource :: ElasticBeanstalkEnvironmentAllSettings s -> TF.Attr s P.Text)
               (\s a -> s { _resource = a } :: ElasticBeanstalkEnvironmentAllSettings s)

instance P.HasValue (ElasticBeanstalkEnvironmentAllSettings s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: ElasticBeanstalkEnvironmentAllSettings s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: ElasticBeanstalkEnvironmentAllSettings s)

-- | @s3_bucket_website@ nested settings.
data S3BucketWebsite s = S3BucketWebsite'
    { _errorDocument         :: TF.Attr s P.Text
    -- ^ @error_document@ - (Optional)
    --
    -- Conflicts with:
    --
    -- * 'redirectAllRequestsTo'
    , _indexDocument         :: TF.Attr s P.Text
    -- ^ @index_document@ - (Optional)
    --
    -- Conflicts with:
    --
    -- * 'redirectAllRequestsTo'
    , _redirectAllRequestsTo :: TF.Attr s P.Text
    -- ^ @redirect_all_requests_to@ - (Optional)
    --
    -- Conflicts with:
    --
    -- * 'routingRules'
    -- * 'errorDocument'
    -- * 'indexDocument'
    , _routingRules          :: TF.Attr s P.Text
    -- ^ @routing_rules@ - (Optional)
    --
    -- Conflicts with:
    --
    -- * 'redirectAllRequestsTo'
    } deriving (P.Show, P.Eq, P.Generic)

newS3BucketWebsite
    :: S3BucketWebsite s
newS3BucketWebsite =
    S3BucketWebsite'
        { _errorDocument = TF.Nil
        , _indexDocument = TF.Nil
        , _redirectAllRequestsTo = TF.Nil
        , _routingRules = TF.Nil
        }

instance P.Hashable  (S3BucketWebsite s)
instance TF.IsValue  (S3BucketWebsite s)
instance TF.IsObject (S3BucketWebsite s) where
    toObject S3BucketWebsite'{..} = P.catMaybes
        [ TF.assign "error_document" <$> TF.attribute _errorDocument
        , TF.assign "index_document" <$> TF.attribute _indexDocument
        , TF.assign "redirect_all_requests_to" <$> TF.attribute _redirectAllRequestsTo
        , TF.assign "routing_rules" <$> TF.attribute _routingRules
        ]

instance TF.IsValid (S3BucketWebsite s) where
    validator = TF.fieldsValidator (\S3BucketWebsite'{..} -> Map.fromList $ P.catMaybes
        [ if (_errorDocument P.== TF.Nil)
              then P.Nothing
              else P.Just ("_errorDocument",
                            [ "_redirectAllRequestsTo"
                            ])
        , if (_indexDocument P.== TF.Nil)
              then P.Nothing
              else P.Just ("_indexDocument",
                            [ "_redirectAllRequestsTo"
                            ])
        , if (_redirectAllRequestsTo P.== TF.Nil)
              then P.Nothing
              else P.Just ("_redirectAllRequestsTo",
                            [ "_routingRules"                            , "_errorDocument"                            , "_indexDocument"
                            ])
        , if (_routingRules P.== TF.Nil)
              then P.Nothing
              else P.Just ("_routingRules",
                            [ "_redirectAllRequestsTo"
                            ])
        ])

instance P.HasErrorDocument (S3BucketWebsite s) (TF.Attr s P.Text) where
    errorDocument =
        P.lens (_errorDocument :: S3BucketWebsite s -> TF.Attr s P.Text)
               (\s a -> s { _errorDocument = a } :: S3BucketWebsite s)

instance P.HasIndexDocument (S3BucketWebsite s) (TF.Attr s P.Text) where
    indexDocument =
        P.lens (_indexDocument :: S3BucketWebsite s -> TF.Attr s P.Text)
               (\s a -> s { _indexDocument = a } :: S3BucketWebsite s)

instance P.HasRedirectAllRequestsTo (S3BucketWebsite s) (TF.Attr s P.Text) where
    redirectAllRequestsTo =
        P.lens (_redirectAllRequestsTo :: S3BucketWebsite s -> TF.Attr s P.Text)
               (\s a -> s { _redirectAllRequestsTo = a } :: S3BucketWebsite s)

instance P.HasRoutingRules (S3BucketWebsite s) (TF.Attr s P.Text) where
    routingRules =
        P.lens (_routingRules :: S3BucketWebsite s -> TF.Attr s P.Text)
               (\s a -> s { _routingRules = a } :: S3BucketWebsite s)

-- | @cognito_resource_server_scope@ nested settings.
data CognitoResourceServerScope s = CognitoResourceServerScope'
    { _scopeDescription :: TF.Attr s P.Text
    -- ^ @scope_description@ - (Required)
    --
    , _scopeName        :: TF.Attr s P.Text
    -- ^ @scope_name@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCognitoResourceServerScope
    :: TF.Attr s P.Text -- ^ @scope_description@ - 'P.scopeDescription'
    -> TF.Attr s P.Text -- ^ @scope_name@ - 'P.scopeName'
    -> CognitoResourceServerScope s
newCognitoResourceServerScope _scopeDescription _scopeName =
    CognitoResourceServerScope'
        { _scopeDescription = _scopeDescription
        , _scopeName = _scopeName
        }

instance P.Hashable  (CognitoResourceServerScope s)
instance TF.IsValue  (CognitoResourceServerScope s)
instance TF.IsObject (CognitoResourceServerScope s) where
    toObject CognitoResourceServerScope'{..} = P.catMaybes
        [ TF.assign "scope_description" <$> TF.attribute _scopeDescription
        , TF.assign "scope_name" <$> TF.attribute _scopeName
        ]

instance TF.IsValid (CognitoResourceServerScope s) where
    validator = P.mempty

instance P.HasScopeDescription (CognitoResourceServerScope s) (TF.Attr s P.Text) where
    scopeDescription =
        P.lens (_scopeDescription :: CognitoResourceServerScope s -> TF.Attr s P.Text)
               (\s a -> s { _scopeDescription = a } :: CognitoResourceServerScope s)

instance P.HasScopeName (CognitoResourceServerScope s) (TF.Attr s P.Text) where
    scopeName =
        P.lens (_scopeName :: CognitoResourceServerScope s -> TF.Attr s P.Text)
               (\s a -> s { _scopeName = a } :: CognitoResourceServerScope s)

-- | @instance_market_options_spot_options@ nested settings.
data InstanceMarketOptionsSpotOptions s = InstanceMarketOptionsSpotOptions'
    { _blockDurationMinutes         :: TF.Attr s P.Integer
    -- ^ @block_duration_minutes@ - (Optional)
    --
    , _instanceInterruptionBehavior :: TF.Attr s P.Text
    -- ^ @instance_interruption_behavior@ - (Optional)
    --
    , _maxPrice                     :: TF.Attr s P.Text
    -- ^ @max_price@ - (Optional)
    --
    , _spotInstanceType             :: TF.Attr s P.Text
    -- ^ @spot_instance_type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newInstanceMarketOptionsSpotOptions
    :: InstanceMarketOptionsSpotOptions s
newInstanceMarketOptionsSpotOptions =
    InstanceMarketOptionsSpotOptions'
        { _blockDurationMinutes = TF.Nil
        , _instanceInterruptionBehavior = TF.Nil
        , _maxPrice = TF.Nil
        , _spotInstanceType = TF.Nil
        }

instance P.Hashable  (InstanceMarketOptionsSpotOptions s)
instance TF.IsValue  (InstanceMarketOptionsSpotOptions s)
instance TF.IsObject (InstanceMarketOptionsSpotOptions s) where
    toObject InstanceMarketOptionsSpotOptions'{..} = P.catMaybes
        [ TF.assign "block_duration_minutes" <$> TF.attribute _blockDurationMinutes
        , TF.assign "instance_interruption_behavior" <$> TF.attribute _instanceInterruptionBehavior
        , TF.assign "max_price" <$> TF.attribute _maxPrice
        , TF.assign "spot_instance_type" <$> TF.attribute _spotInstanceType
        ]

instance TF.IsValid (InstanceMarketOptionsSpotOptions s) where
    validator = P.mempty

instance P.HasBlockDurationMinutes (InstanceMarketOptionsSpotOptions s) (TF.Attr s P.Integer) where
    blockDurationMinutes =
        P.lens (_blockDurationMinutes :: InstanceMarketOptionsSpotOptions s -> TF.Attr s P.Integer)
               (\s a -> s { _blockDurationMinutes = a } :: InstanceMarketOptionsSpotOptions s)

instance P.HasInstanceInterruptionBehavior (InstanceMarketOptionsSpotOptions s) (TF.Attr s P.Text) where
    instanceInterruptionBehavior =
        P.lens (_instanceInterruptionBehavior :: InstanceMarketOptionsSpotOptions s -> TF.Attr s P.Text)
               (\s a -> s { _instanceInterruptionBehavior = a } :: InstanceMarketOptionsSpotOptions s)

instance P.HasMaxPrice (InstanceMarketOptionsSpotOptions s) (TF.Attr s P.Text) where
    maxPrice =
        P.lens (_maxPrice :: InstanceMarketOptionsSpotOptions s -> TF.Attr s P.Text)
               (\s a -> s { _maxPrice = a } :: InstanceMarketOptionsSpotOptions s)

instance P.HasSpotInstanceType (InstanceMarketOptionsSpotOptions s) (TF.Attr s P.Text) where
    spotInstanceType =
        P.lens (_spotInstanceType :: InstanceMarketOptionsSpotOptions s -> TF.Attr s P.Text)
               (\s a -> s { _spotInstanceType = a } :: InstanceMarketOptionsSpotOptions s)

instance s ~ s' => P.HasComputedValidUntil (TF.Ref s' (InstanceMarketOptionsSpotOptions s)) (TF.Attr s P.Text) where
    computedValidUntil x = TF.compute (TF.refKey x) "valid_until"

-- | @appsync_datasource_elasticsearch_config@ nested settings.
data AppsyncDatasourceElasticsearchConfig s = AppsyncDatasourceElasticsearchConfig'
    { _endpoint :: TF.Attr s P.Text
    -- ^ @endpoint@ - (Required)
    --
    , _region   :: TF.Attr s P.Text
    -- ^ @region@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAppsyncDatasourceElasticsearchConfig
    :: TF.Attr s P.Text -- ^ @endpoint@ - 'P.endpoint'
    -> TF.Attr s P.Text -- ^ @region@ - 'P.region'
    -> AppsyncDatasourceElasticsearchConfig s
newAppsyncDatasourceElasticsearchConfig _endpoint _region =
    AppsyncDatasourceElasticsearchConfig'
        { _endpoint = _endpoint
        , _region = _region
        }

instance P.Hashable  (AppsyncDatasourceElasticsearchConfig s)
instance TF.IsValue  (AppsyncDatasourceElasticsearchConfig s)
instance TF.IsObject (AppsyncDatasourceElasticsearchConfig s) where
    toObject AppsyncDatasourceElasticsearchConfig'{..} = P.catMaybes
        [ TF.assign "endpoint" <$> TF.attribute _endpoint
        , TF.assign "region" <$> TF.attribute _region
        ]

instance TF.IsValid (AppsyncDatasourceElasticsearchConfig s) where
    validator = P.mempty

instance P.HasEndpoint (AppsyncDatasourceElasticsearchConfig s) (TF.Attr s P.Text) where
    endpoint =
        P.lens (_endpoint :: AppsyncDatasourceElasticsearchConfig s -> TF.Attr s P.Text)
               (\s a -> s { _endpoint = a } :: AppsyncDatasourceElasticsearchConfig s)

instance P.HasRegion (AppsyncDatasourceElasticsearchConfig s) (TF.Attr s P.Text) where
    region =
        P.lens (_region :: AppsyncDatasourceElasticsearchConfig s -> TF.Attr s P.Text)
               (\s a -> s { _region = a } :: AppsyncDatasourceElasticsearchConfig s)

-- | @kms_secret_secret@ nested settings.
data KmsSecretSecret s = KmsSecretSecret'
    { _context     :: TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))
    -- ^ @context@ - (Optional)
    --
    , _grantTokens :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @grant_tokens@ - (Optional)
    --
    , _name        :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _payload     :: TF.Attr s P.Text
    -- ^ @payload@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newKmsSecretSecret
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @payload@ - 'P.payload'
    -> KmsSecretSecret s
newKmsSecretSecret _name _payload =
    KmsSecretSecret'
        { _context = TF.Nil
        , _grantTokens = TF.Nil
        , _name = _name
        , _payload = _payload
        }

instance P.Hashable  (KmsSecretSecret s)
instance TF.IsValue  (KmsSecretSecret s)
instance TF.IsObject (KmsSecretSecret s) where
    toObject KmsSecretSecret'{..} = P.catMaybes
        [ TF.assign "context" <$> TF.attribute _context
        , TF.assign "grant_tokens" <$> TF.attribute _grantTokens
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "payload" <$> TF.attribute _payload
        ]

instance TF.IsValid (KmsSecretSecret s) where
    validator = P.mempty

instance P.HasContext (KmsSecretSecret s) (TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))) where
    context =
        P.lens (_context :: KmsSecretSecret s -> TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text)))
               (\s a -> s { _context = a } :: KmsSecretSecret s)

instance P.HasGrantTokens (KmsSecretSecret s) (TF.Attr s [TF.Attr s P.Text]) where
    grantTokens =
        P.lens (_grantTokens :: KmsSecretSecret s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _grantTokens = a } :: KmsSecretSecret s)

instance P.HasName (KmsSecretSecret s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: KmsSecretSecret s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: KmsSecretSecret s)

instance P.HasPayload (KmsSecretSecret s) (TF.Attr s P.Text) where
    payload =
        P.lens (_payload :: KmsSecretSecret s -> TF.Attr s P.Text)
               (\s a -> s { _payload = a } :: KmsSecretSecret s)

-- | @s3_bucket_notification_queue@ nested settings.
data S3BucketNotificationQueue s = S3BucketNotificationQueue'
    { _events       :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @events@ - (Required)
    --
    , _filterPrefix :: TF.Attr s P.Text
    -- ^ @filter_prefix@ - (Optional)
    --
    , _filterSuffix :: TF.Attr s P.Text
    -- ^ @filter_suffix@ - (Optional)
    --
    , _queueArn     :: TF.Attr s P.Text
    -- ^ @queue_arn@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newS3BucketNotificationQueue
    :: TF.Attr s [TF.Attr s P.Text] -- ^ @events@ - 'P.events'
    -> TF.Attr s P.Text -- ^ @queue_arn@ - 'P.queueArn'
    -> S3BucketNotificationQueue s
newS3BucketNotificationQueue _events _queueArn =
    S3BucketNotificationQueue'
        { _events = _events
        , _filterPrefix = TF.Nil
        , _filterSuffix = TF.Nil
        , _queueArn = _queueArn
        }

instance P.Hashable  (S3BucketNotificationQueue s)
instance TF.IsValue  (S3BucketNotificationQueue s)
instance TF.IsObject (S3BucketNotificationQueue s) where
    toObject S3BucketNotificationQueue'{..} = P.catMaybes
        [ TF.assign "events" <$> TF.attribute _events
        , TF.assign "filter_prefix" <$> TF.attribute _filterPrefix
        , TF.assign "filter_suffix" <$> TF.attribute _filterSuffix
        , TF.assign "queue_arn" <$> TF.attribute _queueArn
        ]

instance TF.IsValid (S3BucketNotificationQueue s) where
    validator = P.mempty

instance P.HasEvents (S3BucketNotificationQueue s) (TF.Attr s [TF.Attr s P.Text]) where
    events =
        P.lens (_events :: S3BucketNotificationQueue s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _events = a } :: S3BucketNotificationQueue s)

instance P.HasFilterPrefix (S3BucketNotificationQueue s) (TF.Attr s P.Text) where
    filterPrefix =
        P.lens (_filterPrefix :: S3BucketNotificationQueue s -> TF.Attr s P.Text)
               (\s a -> s { _filterPrefix = a } :: S3BucketNotificationQueue s)

instance P.HasFilterSuffix (S3BucketNotificationQueue s) (TF.Attr s P.Text) where
    filterSuffix =
        P.lens (_filterSuffix :: S3BucketNotificationQueue s -> TF.Attr s P.Text)
               (\s a -> s { _filterSuffix = a } :: S3BucketNotificationQueue s)

instance P.HasQueueArn (S3BucketNotificationQueue s) (TF.Attr s P.Text) where
    queueArn =
        P.lens (_queueArn :: S3BucketNotificationQueue s -> TF.Attr s P.Text)
               (\s a -> s { _queueArn = a } :: S3BucketNotificationQueue s)

instance s ~ s' => P.HasComputedId (TF.Ref s' (S3BucketNotificationQueue s)) (TF.Attr s P.Text) where
    computedId x = TF.compute (TF.refKey x) "id"

-- | @db_instance_s3_import@ nested settings.
data DbInstanceS3Import s = DbInstanceS3Import'
    { _bucketName          :: TF.Attr s P.Text
    -- ^ @bucket_name@ - (Required, Forces New)
    --
    , _bucketPrefix        :: TF.Attr s P.Text
    -- ^ @bucket_prefix@ - (Optional, Forces New)
    --
    , _ingestionRole       :: TF.Attr s P.Text
    -- ^ @ingestion_role@ - (Required, Forces New)
    --
    , _sourceEngine        :: TF.Attr s P.Text
    -- ^ @source_engine@ - (Required, Forces New)
    --
    , _sourceEngineVersion :: TF.Attr s P.Text
    -- ^ @source_engine_version@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDbInstanceS3Import
    :: TF.Attr s P.Text -- ^ @bucket_name@ - 'P.bucketName'
    -> TF.Attr s P.Text -- ^ @ingestion_role@ - 'P.ingestionRole'
    -> TF.Attr s P.Text -- ^ @source_engine@ - 'P.sourceEngine'
    -> TF.Attr s P.Text -- ^ @source_engine_version@ - 'P.sourceEngineVersion'
    -> DbInstanceS3Import s
newDbInstanceS3Import _bucketName _ingestionRole _sourceEngine _sourceEngineVersion =
    DbInstanceS3Import'
        { _bucketName = _bucketName
        , _bucketPrefix = TF.Nil
        , _ingestionRole = _ingestionRole
        , _sourceEngine = _sourceEngine
        , _sourceEngineVersion = _sourceEngineVersion
        }

instance P.Hashable  (DbInstanceS3Import s)
instance TF.IsValue  (DbInstanceS3Import s)
instance TF.IsObject (DbInstanceS3Import s) where
    toObject DbInstanceS3Import'{..} = P.catMaybes
        [ TF.assign "bucket_name" <$> TF.attribute _bucketName
        , TF.assign "bucket_prefix" <$> TF.attribute _bucketPrefix
        , TF.assign "ingestion_role" <$> TF.attribute _ingestionRole
        , TF.assign "source_engine" <$> TF.attribute _sourceEngine
        , TF.assign "source_engine_version" <$> TF.attribute _sourceEngineVersion
        ]

instance TF.IsValid (DbInstanceS3Import s) where
    validator = P.mempty

instance P.HasBucketName (DbInstanceS3Import s) (TF.Attr s P.Text) where
    bucketName =
        P.lens (_bucketName :: DbInstanceS3Import s -> TF.Attr s P.Text)
               (\s a -> s { _bucketName = a } :: DbInstanceS3Import s)

instance P.HasBucketPrefix (DbInstanceS3Import s) (TF.Attr s P.Text) where
    bucketPrefix =
        P.lens (_bucketPrefix :: DbInstanceS3Import s -> TF.Attr s P.Text)
               (\s a -> s { _bucketPrefix = a } :: DbInstanceS3Import s)

instance P.HasIngestionRole (DbInstanceS3Import s) (TF.Attr s P.Text) where
    ingestionRole =
        P.lens (_ingestionRole :: DbInstanceS3Import s -> TF.Attr s P.Text)
               (\s a -> s { _ingestionRole = a } :: DbInstanceS3Import s)

instance P.HasSourceEngine (DbInstanceS3Import s) (TF.Attr s P.Text) where
    sourceEngine =
        P.lens (_sourceEngine :: DbInstanceS3Import s -> TF.Attr s P.Text)
               (\s a -> s { _sourceEngine = a } :: DbInstanceS3Import s)

instance P.HasSourceEngineVersion (DbInstanceS3Import s) (TF.Attr s P.Text) where
    sourceEngineVersion =
        P.lens (_sourceEngineVersion :: DbInstanceS3Import s -> TF.Attr s P.Text)
               (\s a -> s { _sourceEngineVersion = a } :: DbInstanceS3Import s)

-- | @iot_topic_rule_lambda@ nested settings.
data IotTopicRuleLambda s = IotTopicRuleLambda'
    { _functionArn :: TF.Attr s P.Text
    -- ^ @function_arn@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newIotTopicRuleLambda
    :: TF.Attr s P.Text -- ^ @function_arn@ - 'P.functionArn'
    -> IotTopicRuleLambda s
newIotTopicRuleLambda _functionArn =
    IotTopicRuleLambda'
        { _functionArn = _functionArn
        }

instance P.Hashable  (IotTopicRuleLambda s)
instance TF.IsValue  (IotTopicRuleLambda s)
instance TF.IsObject (IotTopicRuleLambda s) where
    toObject IotTopicRuleLambda'{..} = P.catMaybes
        [ TF.assign "function_arn" <$> TF.attribute _functionArn
        ]

instance TF.IsValid (IotTopicRuleLambda s) where
    validator = P.mempty

instance P.HasFunctionArn (IotTopicRuleLambda s) (TF.Attr s P.Text) where
    functionArn =
        P.lens (_functionArn :: IotTopicRuleLambda s -> TF.Attr s P.Text)
               (\s a -> s { _functionArn = a } :: IotTopicRuleLambda s)

-- | @route_table_routes@ nested settings.
data RouteTableRoutes s = RouteTableRoutes'
    deriving (P.Show, P.Eq, P.Generic)

newRouteTableRoutes
    :: RouteTableRoutes s
newRouteTableRoutes =
    RouteTableRoutes'

instance P.Hashable  (RouteTableRoutes s)
instance TF.IsValue  (RouteTableRoutes s)
instance TF.IsObject (RouteTableRoutes s) where
    toObject RouteTableRoutes' = []

instance TF.IsValid (RouteTableRoutes s) where
    validator = P.mempty

instance s ~ s' => P.HasComputedCidrBlock (TF.Ref s' (RouteTableRoutes s)) (TF.Attr s P.Text) where
    computedCidrBlock x = TF.compute (TF.refKey x) "cidr_block"

instance s ~ s' => P.HasComputedEgressOnlyGatewayId (TF.Ref s' (RouteTableRoutes s)) (TF.Attr s P.Text) where
    computedEgressOnlyGatewayId x = TF.compute (TF.refKey x) "egress_only_gateway_id"

instance s ~ s' => P.HasComputedGatewayId (TF.Ref s' (RouteTableRoutes s)) (TF.Attr s P.Text) where
    computedGatewayId x = TF.compute (TF.refKey x) "gateway_id"

instance s ~ s' => P.HasComputedInstanceId (TF.Ref s' (RouteTableRoutes s)) (TF.Attr s P.Text) where
    computedInstanceId x = TF.compute (TF.refKey x) "instance_id"

instance s ~ s' => P.HasComputedIpv6CidrBlock (TF.Ref s' (RouteTableRoutes s)) (TF.Attr s P.Text) where
    computedIpv6CidrBlock x = TF.compute (TF.refKey x) "ipv6_cidr_block"

instance s ~ s' => P.HasComputedNatGatewayId (TF.Ref s' (RouteTableRoutes s)) (TF.Attr s P.Text) where
    computedNatGatewayId x = TF.compute (TF.refKey x) "nat_gateway_id"

instance s ~ s' => P.HasComputedNetworkInterfaceId (TF.Ref s' (RouteTableRoutes s)) (TF.Attr s P.Text) where
    computedNetworkInterfaceId x = TF.compute (TF.refKey x) "network_interface_id"

instance s ~ s' => P.HasComputedVpcPeeringConnectionId (TF.Ref s' (RouteTableRoutes s)) (TF.Attr s P.Text) where
    computedVpcPeeringConnectionId x = TF.compute (TF.refKey x) "vpc_peering_connection_id"

-- | @lambda_function_vpc_config@ nested settings.
data LambdaFunctionVpcConfig s = LambdaFunctionVpcConfig'
    { _securityGroupIds :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @security_group_ids@ - (Required)
    --
    , _subnetIds        :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @subnet_ids@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLambdaFunctionVpcConfig
    :: TF.Attr s [TF.Attr s P.Text] -- ^ @security_group_ids@ - 'P.securityGroupIds'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @subnet_ids@ - 'P.subnetIds'
    -> LambdaFunctionVpcConfig s
newLambdaFunctionVpcConfig _securityGroupIds _subnetIds =
    LambdaFunctionVpcConfig'
        { _securityGroupIds = _securityGroupIds
        , _subnetIds = _subnetIds
        }

instance P.Hashable  (LambdaFunctionVpcConfig s)
instance TF.IsValue  (LambdaFunctionVpcConfig s)
instance TF.IsObject (LambdaFunctionVpcConfig s) where
    toObject LambdaFunctionVpcConfig'{..} = P.catMaybes
        [ TF.assign "security_group_ids" <$> TF.attribute _securityGroupIds
        , TF.assign "subnet_ids" <$> TF.attribute _subnetIds
        ]

instance TF.IsValid (LambdaFunctionVpcConfig s) where
    validator = P.mempty

instance P.HasSecurityGroupIds (LambdaFunctionVpcConfig s) (TF.Attr s [TF.Attr s P.Text]) where
    securityGroupIds =
        P.lens (_securityGroupIds :: LambdaFunctionVpcConfig s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _securityGroupIds = a } :: LambdaFunctionVpcConfig s)

instance P.HasSubnetIds (LambdaFunctionVpcConfig s) (TF.Attr s [TF.Attr s P.Text]) where
    subnetIds =
        P.lens (_subnetIds :: LambdaFunctionVpcConfig s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _subnetIds = a } :: LambdaFunctionVpcConfig s)

instance s ~ s' => P.HasComputedVpcId (TF.Ref s' (LambdaFunctionVpcConfig s)) (TF.Attr s P.Text) where
    computedVpcId x = TF.compute (TF.refKey x) "vpc_id"

instance s ~ s' => P.HasComputedSecurityGroupIds (TF.Ref s' (LambdaFunctionVpcConfig s)) (TF.Attr s [TF.Attr s P.Text]) where
    computedSecurityGroupIds x = TF.compute (TF.refKey x) "security_group_ids"

instance s ~ s' => P.HasComputedSubnetIds (TF.Ref s' (LambdaFunctionVpcConfig s)) (TF.Attr s [TF.Attr s P.Text]) where
    computedSubnetIds x = TF.compute (TF.refKey x) "subnet_ids"

-- | @activated_rule_action@ nested settings.
data ActivatedRuleAction s = ActivatedRuleAction'
    { _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newActivatedRuleAction
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> ActivatedRuleAction s
newActivatedRuleAction _type' =
    ActivatedRuleAction'
        { _type' = _type'
        }

instance P.Hashable  (ActivatedRuleAction s)
instance TF.IsValue  (ActivatedRuleAction s)
instance TF.IsObject (ActivatedRuleAction s) where
    toObject ActivatedRuleAction'{..} = P.catMaybes
        [ TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (ActivatedRuleAction s) where
    validator = P.mempty

instance P.HasType' (ActivatedRuleAction s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: ActivatedRuleAction s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: ActivatedRuleAction s)

-- | @dag_node_args@ nested settings.
data DagNodeArgs s = DagNodeArgs'
    { _name  :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _param :: TF.Attr s P.Bool
    -- ^ @param@ - (Optional)
    --
    , _value :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDagNodeArgs
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> DagNodeArgs s
newDagNodeArgs _name _value =
    DagNodeArgs'
        { _name = _name
        , _param = TF.Nil
        , _value = _value
        }

instance P.Hashable  (DagNodeArgs s)
instance TF.IsValue  (DagNodeArgs s)
instance TF.IsObject (DagNodeArgs s) where
    toObject DagNodeArgs'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "param" <$> TF.attribute _param
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (DagNodeArgs s) where
    validator = P.mempty

instance P.HasName (DagNodeArgs s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: DagNodeArgs s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: DagNodeArgs s)

instance P.HasParam (DagNodeArgs s) (TF.Attr s P.Bool) where
    param =
        P.lens (_param :: DagNodeArgs s -> TF.Attr s P.Bool)
               (\s a -> s { _param = a } :: DagNodeArgs s)

instance P.HasValue (DagNodeArgs s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: DagNodeArgs s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: DagNodeArgs s)

-- | @origin_s3_origin_config@ nested settings.
data OriginS3OriginConfig s = OriginS3OriginConfig'
    { _originAccessIdentity :: TF.Attr s P.Text
    -- ^ @origin_access_identity@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newOriginS3OriginConfig
    :: TF.Attr s P.Text -- ^ @origin_access_identity@ - 'P.originAccessIdentity'
    -> OriginS3OriginConfig s
newOriginS3OriginConfig _originAccessIdentity =
    OriginS3OriginConfig'
        { _originAccessIdentity = _originAccessIdentity
        }

instance P.Hashable  (OriginS3OriginConfig s)
instance TF.IsValue  (OriginS3OriginConfig s)
instance TF.IsObject (OriginS3OriginConfig s) where
    toObject OriginS3OriginConfig'{..} = P.catMaybes
        [ TF.assign "origin_access_identity" <$> TF.attribute _originAccessIdentity
        ]

instance TF.IsValid (OriginS3OriginConfig s) where
    validator = P.mempty

instance P.HasOriginAccessIdentity (OriginS3OriginConfig s) (TF.Attr s P.Text) where
    originAccessIdentity =
        P.lens (_originAccessIdentity :: OriginS3OriginConfig s -> TF.Attr s P.Text)
               (\s a -> s { _originAccessIdentity = a } :: OriginS3OriginConfig s)

-- | @s3_bucket_replication_configuration@ nested settings.
data S3BucketReplicationConfiguration s = S3BucketReplicationConfiguration'
    { _role  :: TF.Attr s P.Text
    -- ^ @role@ - (Required)
    --
    , _rules :: TF.Attr s [TF.Attr s (ReplicationConfigurationRules s)]
    -- ^ @rules@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newS3BucketReplicationConfiguration
    :: TF.Attr s P.Text -- ^ @role@ - 'P.role'
    -> TF.Attr s [TF.Attr s (ReplicationConfigurationRules s)] -- ^ @rules@ - 'P.rules'
    -> S3BucketReplicationConfiguration s
newS3BucketReplicationConfiguration _role _rules =
    S3BucketReplicationConfiguration'
        { _role = _role
        , _rules = _rules
        }

instance P.Hashable  (S3BucketReplicationConfiguration s)
instance TF.IsValue  (S3BucketReplicationConfiguration s)
instance TF.IsObject (S3BucketReplicationConfiguration s) where
    toObject S3BucketReplicationConfiguration'{..} = P.catMaybes
        [ TF.assign "role" <$> TF.attribute _role
        , TF.assign "rules" <$> TF.attribute _rules
        ]

instance TF.IsValid (S3BucketReplicationConfiguration s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_rules"
                  (_rules
                      :: S3BucketReplicationConfiguration s -> TF.Attr s [TF.Attr s (ReplicationConfigurationRules s)])
                  TF.validator

instance P.HasRole (S3BucketReplicationConfiguration s) (TF.Attr s P.Text) where
    role =
        P.lens (_role :: S3BucketReplicationConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _role = a } :: S3BucketReplicationConfiguration s)

instance P.HasRules (S3BucketReplicationConfiguration s) (TF.Attr s [TF.Attr s (ReplicationConfigurationRules s)]) where
    rules =
        P.lens (_rules :: S3BucketReplicationConfiguration s -> TF.Attr s [TF.Attr s (ReplicationConfigurationRules s)])
               (\s a -> s { _rules = a } :: S3BucketReplicationConfiguration s)

-- | @lambda_function_dead_letter_config@ nested settings.
data LambdaFunctionDeadLetterConfig s = LambdaFunctionDeadLetterConfig'
    { _targetArn :: TF.Attr s P.Text
    -- ^ @target_arn@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLambdaFunctionDeadLetterConfig
    :: TF.Attr s P.Text -- ^ @target_arn@ - 'P.targetArn'
    -> LambdaFunctionDeadLetterConfig s
newLambdaFunctionDeadLetterConfig _targetArn =
    LambdaFunctionDeadLetterConfig'
        { _targetArn = _targetArn
        }

instance P.Hashable  (LambdaFunctionDeadLetterConfig s)
instance TF.IsValue  (LambdaFunctionDeadLetterConfig s)
instance TF.IsObject (LambdaFunctionDeadLetterConfig s) where
    toObject LambdaFunctionDeadLetterConfig'{..} = P.catMaybes
        [ TF.assign "target_arn" <$> TF.attribute _targetArn
        ]

instance TF.IsValid (LambdaFunctionDeadLetterConfig s) where
    validator = P.mempty

instance P.HasTargetArn (LambdaFunctionDeadLetterConfig s) (TF.Attr s P.Text) where
    targetArn =
        P.lens (_targetArn :: LambdaFunctionDeadLetterConfig s -> TF.Attr s P.Text)
               (\s a -> s { _targetArn = a } :: LambdaFunctionDeadLetterConfig s)

instance s ~ s' => P.HasComputedTargetArn (TF.Ref s' (LambdaFunctionDeadLetterConfig s)) (TF.Attr s P.Text) where
    computedTargetArn x = TF.compute (TF.refKey x) "target_arn"

-- | @forwarded_values_cookies@ nested settings.
data ForwardedValuesCookies s = ForwardedValuesCookies'
    { _forward          :: TF.Attr s P.Text
    -- ^ @forward@ - (Required)
    --
    , _whitelistedNames :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @whitelisted_names@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newForwardedValuesCookies
    :: TF.Attr s P.Text -- ^ @forward@ - 'P.forward'
    -> ForwardedValuesCookies s
newForwardedValuesCookies _forward =
    ForwardedValuesCookies'
        { _forward = _forward
        , _whitelistedNames = TF.Nil
        }

instance P.Hashable  (ForwardedValuesCookies s)
instance TF.IsValue  (ForwardedValuesCookies s)
instance TF.IsObject (ForwardedValuesCookies s) where
    toObject ForwardedValuesCookies'{..} = P.catMaybes
        [ TF.assign "forward" <$> TF.attribute _forward
        , TF.assign "whitelisted_names" <$> TF.attribute _whitelistedNames
        ]

instance TF.IsValid (ForwardedValuesCookies s) where
    validator = P.mempty

instance P.HasForward (ForwardedValuesCookies s) (TF.Attr s P.Text) where
    forward =
        P.lens (_forward :: ForwardedValuesCookies s -> TF.Attr s P.Text)
               (\s a -> s { _forward = a } :: ForwardedValuesCookies s)

instance P.HasWhitelistedNames (ForwardedValuesCookies s) (TF.Attr s [TF.Attr s P.Text]) where
    whitelistedNames =
        P.lens (_whitelistedNames :: ForwardedValuesCookies s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _whitelistedNames = a } :: ForwardedValuesCookies s)

-- | @step_scaling_policy_configuration_step_adjustment@ nested settings.
data StepScalingPolicyConfigurationStepAdjustment s = StepScalingPolicyConfigurationStepAdjustment'
    { _metricIntervalLowerBound :: TF.Attr s P.Double
    -- ^ @metric_interval_lower_bound@ - (Optional)
    --
    , _metricIntervalUpperBound :: TF.Attr s P.Double
    -- ^ @metric_interval_upper_bound@ - (Optional)
    --
    , _scalingAdjustment        :: TF.Attr s P.Integer
    -- ^ @scaling_adjustment@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newStepScalingPolicyConfigurationStepAdjustment
    :: TF.Attr s P.Integer -- ^ @scaling_adjustment@ - 'P.scalingAdjustment'
    -> StepScalingPolicyConfigurationStepAdjustment s
newStepScalingPolicyConfigurationStepAdjustment _scalingAdjustment =
    StepScalingPolicyConfigurationStepAdjustment'
        { _metricIntervalLowerBound = TF.value (-1.0)
        , _metricIntervalUpperBound = TF.value (-1.0)
        , _scalingAdjustment = _scalingAdjustment
        }

instance P.Hashable  (StepScalingPolicyConfigurationStepAdjustment s)
instance TF.IsValue  (StepScalingPolicyConfigurationStepAdjustment s)
instance TF.IsObject (StepScalingPolicyConfigurationStepAdjustment s) where
    toObject StepScalingPolicyConfigurationStepAdjustment'{..} = P.catMaybes
        [ TF.assign "metric_interval_lower_bound" <$> TF.attribute _metricIntervalLowerBound
        , TF.assign "metric_interval_upper_bound" <$> TF.attribute _metricIntervalUpperBound
        , TF.assign "scaling_adjustment" <$> TF.attribute _scalingAdjustment
        ]

instance TF.IsValid (StepScalingPolicyConfigurationStepAdjustment s) where
    validator = P.mempty

instance P.HasMetricIntervalLowerBound (StepScalingPolicyConfigurationStepAdjustment s) (TF.Attr s P.Double) where
    metricIntervalLowerBound =
        P.lens (_metricIntervalLowerBound :: StepScalingPolicyConfigurationStepAdjustment s -> TF.Attr s P.Double)
               (\s a -> s { _metricIntervalLowerBound = a } :: StepScalingPolicyConfigurationStepAdjustment s)

instance P.HasMetricIntervalUpperBound (StepScalingPolicyConfigurationStepAdjustment s) (TF.Attr s P.Double) where
    metricIntervalUpperBound =
        P.lens (_metricIntervalUpperBound :: StepScalingPolicyConfigurationStepAdjustment s -> TF.Attr s P.Double)
               (\s a -> s { _metricIntervalUpperBound = a } :: StepScalingPolicyConfigurationStepAdjustment s)

instance P.HasScalingAdjustment (StepScalingPolicyConfigurationStepAdjustment s) (TF.Attr s P.Integer) where
    scalingAdjustment =
        P.lens (_scalingAdjustment :: StepScalingPolicyConfigurationStepAdjustment s -> TF.Attr s P.Integer)
               (\s a -> s { _scalingAdjustment = a } :: StepScalingPolicyConfigurationStepAdjustment s)

-- | @role_mapping_mapping_rule@ nested settings.
data RoleMappingMappingRule s = RoleMappingMappingRule'
    { _claim     :: TF.Attr s P.Text
    -- ^ @claim@ - (Required)
    --
    , _matchType :: TF.Attr s P.Text
    -- ^ @match_type@ - (Required)
    --
    , _roleArn   :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Required)
    --
    , _value     :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRoleMappingMappingRule
    :: TF.Attr s P.Text -- ^ @claim@ - 'P.claim'
    -> TF.Attr s P.Text -- ^ @match_type@ - 'P.matchType'
    -> TF.Attr s P.Text -- ^ @role_arn@ - 'P.roleArn'
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> RoleMappingMappingRule s
newRoleMappingMappingRule _claim _matchType _roleArn _value =
    RoleMappingMappingRule'
        { _claim = _claim
        , _matchType = _matchType
        , _roleArn = _roleArn
        , _value = _value
        }

instance P.Hashable  (RoleMappingMappingRule s)
instance TF.IsValue  (RoleMappingMappingRule s)
instance TF.IsObject (RoleMappingMappingRule s) where
    toObject RoleMappingMappingRule'{..} = P.catMaybes
        [ TF.assign "claim" <$> TF.attribute _claim
        , TF.assign "match_type" <$> TF.attribute _matchType
        , TF.assign "role_arn" <$> TF.attribute _roleArn
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (RoleMappingMappingRule s) where
    validator = P.mempty

instance P.HasClaim (RoleMappingMappingRule s) (TF.Attr s P.Text) where
    claim =
        P.lens (_claim :: RoleMappingMappingRule s -> TF.Attr s P.Text)
               (\s a -> s { _claim = a } :: RoleMappingMappingRule s)

instance P.HasMatchType (RoleMappingMappingRule s) (TF.Attr s P.Text) where
    matchType =
        P.lens (_matchType :: RoleMappingMappingRule s -> TF.Attr s P.Text)
               (\s a -> s { _matchType = a } :: RoleMappingMappingRule s)

instance P.HasRoleArn (RoleMappingMappingRule s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: RoleMappingMappingRule s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: RoleMappingMappingRule s)

instance P.HasValue (RoleMappingMappingRule s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: RoleMappingMappingRule s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: RoleMappingMappingRule s)

-- | @subnet_ids_filter@ nested settings.
data SubnetIdsFilter s = SubnetIdsFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSubnetIdsFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> SubnetIdsFilter s
newSubnetIdsFilter _name _values =
    SubnetIdsFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (SubnetIdsFilter s)
instance TF.IsValue  (SubnetIdsFilter s)
instance TF.IsObject (SubnetIdsFilter s) where
    toObject SubnetIdsFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (SubnetIdsFilter s) where
    validator = P.mempty

instance P.HasName (SubnetIdsFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: SubnetIdsFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: SubnetIdsFilter s)

instance P.HasValues (SubnetIdsFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: SubnetIdsFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: SubnetIdsFilter s)

-- | @kinesis_firehose_delivery_stream_elasticsearch_configuration@ nested settings.
data KinesisFirehoseDeliveryStreamElasticsearchConfiguration s = KinesisFirehoseDeliveryStreamElasticsearchConfiguration'
    { _bufferingInterval :: TF.Attr s P.Integer
    -- ^ @buffering_interval@ - (Optional)
    --
    , _bufferingSize :: TF.Attr s P.Integer
    -- ^ @buffering_size@ - (Optional)
    --
    , _domainArn :: TF.Attr s P.Text
    -- ^ @domain_arn@ - (Required)
    --
    , _indexName :: TF.Attr s P.Text
    -- ^ @index_name@ - (Required)
    --
    , _indexRotationPeriod :: TF.Attr s P.Text
    -- ^ @index_rotation_period@ - (Optional)
    --
    , _processingConfiguration :: TF.Attr s (ElasticsearchConfigurationProcessingConfiguration s)
    -- ^ @processing_configuration@ - (Optional)
    --
    , _retryDuration :: TF.Attr s P.Integer
    -- ^ @retry_duration@ - (Optional)
    --
    , _roleArn :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Required)
    --
    , _s3BackupMode :: TF.Attr s P.Text
    -- ^ @s3_backup_mode@ - (Optional)
    --
    , _typeName :: TF.Attr s P.Text
    -- ^ @type_name@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newKinesisFirehoseDeliveryStreamElasticsearchConfiguration
    :: TF.Attr s P.Text -- ^ @domain_arn@ - 'P.domainArn'
    -> TF.Attr s P.Text -- ^ @index_name@ - 'P.indexName'
    -> TF.Attr s P.Text -- ^ @role_arn@ - 'P.roleArn'
    -> KinesisFirehoseDeliveryStreamElasticsearchConfiguration s
newKinesisFirehoseDeliveryStreamElasticsearchConfiguration _domainArn _indexName _roleArn =
    KinesisFirehoseDeliveryStreamElasticsearchConfiguration'
        { _bufferingInterval = TF.value 300
        , _bufferingSize = TF.value 5
        , _domainArn = _domainArn
        , _indexName = _indexName
        , _indexRotationPeriod = TF.value "OneDay"
        , _processingConfiguration = TF.Nil
        , _retryDuration = TF.value 300
        , _roleArn = _roleArn
        , _s3BackupMode = TF.value "FailedDocumentsOnly"
        , _typeName = TF.Nil
        }

instance P.Hashable  (KinesisFirehoseDeliveryStreamElasticsearchConfiguration s)
instance TF.IsValue  (KinesisFirehoseDeliveryStreamElasticsearchConfiguration s)
instance TF.IsObject (KinesisFirehoseDeliveryStreamElasticsearchConfiguration s) where
    toObject KinesisFirehoseDeliveryStreamElasticsearchConfiguration'{..} = P.catMaybes
        [ TF.assign "buffering_interval" <$> TF.attribute _bufferingInterval
        , TF.assign "buffering_size" <$> TF.attribute _bufferingSize
        , TF.assign "domain_arn" <$> TF.attribute _domainArn
        , TF.assign "index_name" <$> TF.attribute _indexName
        , TF.assign "index_rotation_period" <$> TF.attribute _indexRotationPeriod
        , TF.assign "processing_configuration" <$> TF.attribute _processingConfiguration
        , TF.assign "retry_duration" <$> TF.attribute _retryDuration
        , TF.assign "role_arn" <$> TF.attribute _roleArn
        , TF.assign "s3_backup_mode" <$> TF.attribute _s3BackupMode
        , TF.assign "type_name" <$> TF.attribute _typeName
        ]

instance TF.IsValid (KinesisFirehoseDeliveryStreamElasticsearchConfiguration s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_processingConfiguration"
                  (_processingConfiguration
                      :: KinesisFirehoseDeliveryStreamElasticsearchConfiguration s -> TF.Attr s (ElasticsearchConfigurationProcessingConfiguration s))
                  TF.validator

instance P.HasBufferingInterval (KinesisFirehoseDeliveryStreamElasticsearchConfiguration s) (TF.Attr s P.Integer) where
    bufferingInterval =
        P.lens (_bufferingInterval :: KinesisFirehoseDeliveryStreamElasticsearchConfiguration s -> TF.Attr s P.Integer)
               (\s a -> s { _bufferingInterval = a } :: KinesisFirehoseDeliveryStreamElasticsearchConfiguration s)

instance P.HasBufferingSize (KinesisFirehoseDeliveryStreamElasticsearchConfiguration s) (TF.Attr s P.Integer) where
    bufferingSize =
        P.lens (_bufferingSize :: KinesisFirehoseDeliveryStreamElasticsearchConfiguration s -> TF.Attr s P.Integer)
               (\s a -> s { _bufferingSize = a } :: KinesisFirehoseDeliveryStreamElasticsearchConfiguration s)

instance P.HasDomainArn (KinesisFirehoseDeliveryStreamElasticsearchConfiguration s) (TF.Attr s P.Text) where
    domainArn =
        P.lens (_domainArn :: KinesisFirehoseDeliveryStreamElasticsearchConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _domainArn = a } :: KinesisFirehoseDeliveryStreamElasticsearchConfiguration s)

instance P.HasIndexName (KinesisFirehoseDeliveryStreamElasticsearchConfiguration s) (TF.Attr s P.Text) where
    indexName =
        P.lens (_indexName :: KinesisFirehoseDeliveryStreamElasticsearchConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _indexName = a } :: KinesisFirehoseDeliveryStreamElasticsearchConfiguration s)

instance P.HasIndexRotationPeriod (KinesisFirehoseDeliveryStreamElasticsearchConfiguration s) (TF.Attr s P.Text) where
    indexRotationPeriod =
        P.lens (_indexRotationPeriod :: KinesisFirehoseDeliveryStreamElasticsearchConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _indexRotationPeriod = a } :: KinesisFirehoseDeliveryStreamElasticsearchConfiguration s)

instance P.HasProcessingConfiguration (KinesisFirehoseDeliveryStreamElasticsearchConfiguration s) (TF.Attr s (ElasticsearchConfigurationProcessingConfiguration s)) where
    processingConfiguration =
        P.lens (_processingConfiguration :: KinesisFirehoseDeliveryStreamElasticsearchConfiguration s -> TF.Attr s (ElasticsearchConfigurationProcessingConfiguration s))
               (\s a -> s { _processingConfiguration = a } :: KinesisFirehoseDeliveryStreamElasticsearchConfiguration s)

instance P.HasRetryDuration (KinesisFirehoseDeliveryStreamElasticsearchConfiguration s) (TF.Attr s P.Integer) where
    retryDuration =
        P.lens (_retryDuration :: KinesisFirehoseDeliveryStreamElasticsearchConfiguration s -> TF.Attr s P.Integer)
               (\s a -> s { _retryDuration = a } :: KinesisFirehoseDeliveryStreamElasticsearchConfiguration s)

instance P.HasRoleArn (KinesisFirehoseDeliveryStreamElasticsearchConfiguration s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: KinesisFirehoseDeliveryStreamElasticsearchConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: KinesisFirehoseDeliveryStreamElasticsearchConfiguration s)

instance P.HasS3BackupMode (KinesisFirehoseDeliveryStreamElasticsearchConfiguration s) (TF.Attr s P.Text) where
    s3BackupMode =
        P.lens (_s3BackupMode :: KinesisFirehoseDeliveryStreamElasticsearchConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _s3BackupMode = a } :: KinesisFirehoseDeliveryStreamElasticsearchConfiguration s)

instance P.HasTypeName (KinesisFirehoseDeliveryStreamElasticsearchConfiguration s) (TF.Attr s P.Text) where
    typeName =
        P.lens (_typeName :: KinesisFirehoseDeliveryStreamElasticsearchConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _typeName = a } :: KinesisFirehoseDeliveryStreamElasticsearchConfiguration s)

instance s ~ s' => P.HasComputedCloudwatchLoggingOptions (TF.Ref s' (KinesisFirehoseDeliveryStreamElasticsearchConfiguration s)) (TF.Attr s (ElasticsearchConfigurationCloudwatchLoggingOptions s)) where
    computedCloudwatchLoggingOptions x = TF.compute (TF.refKey x) "cloudwatch_logging_options"

-- | @launch_specification_ebs_block_device@ nested settings.
data LaunchSpecificationEbsBlockDevice s = LaunchSpecificationEbsBlockDevice'
    { _deleteOnTermination :: TF.Attr s P.Bool
    -- ^ @delete_on_termination@ - (Optional, Forces New)
    --
    , _deviceName          :: TF.Attr s P.Text
    -- ^ @device_name@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLaunchSpecificationEbsBlockDevice
    :: TF.Attr s P.Text -- ^ @device_name@ - 'P.deviceName'
    -> LaunchSpecificationEbsBlockDevice s
newLaunchSpecificationEbsBlockDevice _deviceName =
    LaunchSpecificationEbsBlockDevice'
        { _deleteOnTermination = TF.value P.True
        , _deviceName = _deviceName
        }

instance P.Hashable  (LaunchSpecificationEbsBlockDevice s)
instance TF.IsValue  (LaunchSpecificationEbsBlockDevice s)
instance TF.IsObject (LaunchSpecificationEbsBlockDevice s) where
    toObject LaunchSpecificationEbsBlockDevice'{..} = P.catMaybes
        [ TF.assign "delete_on_termination" <$> TF.attribute _deleteOnTermination
        , TF.assign "device_name" <$> TF.attribute _deviceName
        ]

instance TF.IsValid (LaunchSpecificationEbsBlockDevice s) where
    validator = P.mempty

instance P.HasDeleteOnTermination (LaunchSpecificationEbsBlockDevice s) (TF.Attr s P.Bool) where
    deleteOnTermination =
        P.lens (_deleteOnTermination :: LaunchSpecificationEbsBlockDevice s -> TF.Attr s P.Bool)
               (\s a -> s { _deleteOnTermination = a } :: LaunchSpecificationEbsBlockDevice s)

instance P.HasDeviceName (LaunchSpecificationEbsBlockDevice s) (TF.Attr s P.Text) where
    deviceName =
        P.lens (_deviceName :: LaunchSpecificationEbsBlockDevice s -> TF.Attr s P.Text)
               (\s a -> s { _deviceName = a } :: LaunchSpecificationEbsBlockDevice s)

instance s ~ s' => P.HasComputedEncrypted (TF.Ref s' (LaunchSpecificationEbsBlockDevice s)) (TF.Attr s P.Bool) where
    computedEncrypted x = TF.compute (TF.refKey x) "encrypted"

instance s ~ s' => P.HasComputedIops (TF.Ref s' (LaunchSpecificationEbsBlockDevice s)) (TF.Attr s P.Integer) where
    computedIops x = TF.compute (TF.refKey x) "iops"

instance s ~ s' => P.HasComputedSnapshotId (TF.Ref s' (LaunchSpecificationEbsBlockDevice s)) (TF.Attr s P.Text) where
    computedSnapshotId x = TF.compute (TF.refKey x) "snapshot_id"

instance s ~ s' => P.HasComputedVolumeSize (TF.Ref s' (LaunchSpecificationEbsBlockDevice s)) (TF.Attr s P.Integer) where
    computedVolumeSize x = TF.compute (TF.refKey x) "volume_size"

instance s ~ s' => P.HasComputedVolumeType (TF.Ref s' (LaunchSpecificationEbsBlockDevice s)) (TF.Attr s P.Text) where
    computedVolumeType x = TF.compute (TF.refKey x) "volume_type"

-- | @lambda_alias_routing_config@ nested settings.
data LambdaAliasRoutingConfig s = LambdaAliasRoutingConfig'
    { _additionalVersionWeights :: TF.Attr s (P.HashMap P.Text (TF.Attr s P.Double))
    -- ^ @additional_version_weights@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLambdaAliasRoutingConfig
    :: LambdaAliasRoutingConfig s
newLambdaAliasRoutingConfig =
    LambdaAliasRoutingConfig'
        { _additionalVersionWeights = TF.Nil
        }

instance P.Hashable  (LambdaAliasRoutingConfig s)
instance TF.IsValue  (LambdaAliasRoutingConfig s)
instance TF.IsObject (LambdaAliasRoutingConfig s) where
    toObject LambdaAliasRoutingConfig'{..} = P.catMaybes
        [ TF.assign "additional_version_weights" <$> TF.attribute _additionalVersionWeights
        ]

instance TF.IsValid (LambdaAliasRoutingConfig s) where
    validator = P.mempty

instance P.HasAdditionalVersionWeights (LambdaAliasRoutingConfig s) (TF.Attr s (P.HashMap P.Text (TF.Attr s P.Double))) where
    additionalVersionWeights =
        P.lens (_additionalVersionWeights :: LambdaAliasRoutingConfig s -> TF.Attr s (P.HashMap P.Text (TF.Attr s P.Double)))
               (\s a -> s { _additionalVersionWeights = a } :: LambdaAliasRoutingConfig s)

-- | @instance_ephemeral_block_device@ nested settings.
data InstanceEphemeralBlockDevice s = InstanceEphemeralBlockDevice'
    { _deviceName  :: TF.Attr s P.Text
    -- ^ @device_name@ - (Required)
    --
    , _noDevice    :: TF.Attr s P.Bool
    -- ^ @no_device@ - (Optional)
    --
    , _virtualName :: TF.Attr s P.Text
    -- ^ @virtual_name@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newInstanceEphemeralBlockDevice
    :: TF.Attr s P.Text -- ^ @device_name@ - 'P.deviceName'
    -> InstanceEphemeralBlockDevice s
newInstanceEphemeralBlockDevice _deviceName =
    InstanceEphemeralBlockDevice'
        { _deviceName = _deviceName
        , _noDevice = TF.Nil
        , _virtualName = TF.Nil
        }

instance P.Hashable  (InstanceEphemeralBlockDevice s)
instance TF.IsValue  (InstanceEphemeralBlockDevice s)
instance TF.IsObject (InstanceEphemeralBlockDevice s) where
    toObject InstanceEphemeralBlockDevice'{..} = P.catMaybes
        [ TF.assign "device_name" <$> TF.attribute _deviceName
        , TF.assign "no_device" <$> TF.attribute _noDevice
        , TF.assign "virtual_name" <$> TF.attribute _virtualName
        ]

instance TF.IsValid (InstanceEphemeralBlockDevice s) where
    validator = P.mempty

instance P.HasDeviceName (InstanceEphemeralBlockDevice s) (TF.Attr s P.Text) where
    deviceName =
        P.lens (_deviceName :: InstanceEphemeralBlockDevice s -> TF.Attr s P.Text)
               (\s a -> s { _deviceName = a } :: InstanceEphemeralBlockDevice s)

instance P.HasNoDevice (InstanceEphemeralBlockDevice s) (TF.Attr s P.Bool) where
    noDevice =
        P.lens (_noDevice :: InstanceEphemeralBlockDevice s -> TF.Attr s P.Bool)
               (\s a -> s { _noDevice = a } :: InstanceEphemeralBlockDevice s)

instance P.HasVirtualName (InstanceEphemeralBlockDevice s) (TF.Attr s P.Text) where
    virtualName =
        P.lens (_virtualName :: InstanceEphemeralBlockDevice s -> TF.Attr s P.Text)
               (\s a -> s { _virtualName = a } :: InstanceEphemeralBlockDevice s)

-- | @elasticache_replication_group_cluster_mode@ nested settings.
data ElasticacheReplicationGroupClusterMode s = ElasticacheReplicationGroupClusterMode'
    { _numNodeGroups        :: TF.Attr s P.Integer
    -- ^ @num_node_groups@ - (Required)
    --
    , _replicasPerNodeGroup :: TF.Attr s P.Integer
    -- ^ @replicas_per_node_group@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElasticacheReplicationGroupClusterMode
    :: TF.Attr s P.Integer -- ^ @num_node_groups@ - 'P.numNodeGroups'
    -> TF.Attr s P.Integer -- ^ @replicas_per_node_group@ - 'P.replicasPerNodeGroup'
    -> ElasticacheReplicationGroupClusterMode s
newElasticacheReplicationGroupClusterMode _numNodeGroups _replicasPerNodeGroup =
    ElasticacheReplicationGroupClusterMode'
        { _numNodeGroups = _numNodeGroups
        , _replicasPerNodeGroup = _replicasPerNodeGroup
        }

instance P.Hashable  (ElasticacheReplicationGroupClusterMode s)
instance TF.IsValue  (ElasticacheReplicationGroupClusterMode s)
instance TF.IsObject (ElasticacheReplicationGroupClusterMode s) where
    toObject ElasticacheReplicationGroupClusterMode'{..} = P.catMaybes
        [ TF.assign "num_node_groups" <$> TF.attribute _numNodeGroups
        , TF.assign "replicas_per_node_group" <$> TF.attribute _replicasPerNodeGroup
        ]

instance TF.IsValid (ElasticacheReplicationGroupClusterMode s) where
    validator = P.mempty

instance P.HasNumNodeGroups (ElasticacheReplicationGroupClusterMode s) (TF.Attr s P.Integer) where
    numNodeGroups =
        P.lens (_numNodeGroups :: ElasticacheReplicationGroupClusterMode s -> TF.Attr s P.Integer)
               (\s a -> s { _numNodeGroups = a } :: ElasticacheReplicationGroupClusterMode s)

instance P.HasReplicasPerNodeGroup (ElasticacheReplicationGroupClusterMode s) (TF.Attr s P.Integer) where
    replicasPerNodeGroup =
        P.lens (_replicasPerNodeGroup :: ElasticacheReplicationGroupClusterMode s -> TF.Attr s P.Integer)
               (\s a -> s { _replicasPerNodeGroup = a } :: ElasticacheReplicationGroupClusterMode s)

-- | @elastictranscoder_preset_video_watermarks@ nested settings.
data ElastictranscoderPresetVideoWatermarks s = ElastictranscoderPresetVideoWatermarks'
    { _horizontalAlign  :: TF.Attr s P.Text
    -- ^ @horizontal_align@ - (Optional, Forces New)
    --
    , _horizontalOffset :: TF.Attr s P.Text
    -- ^ @horizontal_offset@ - (Optional, Forces New)
    --
    , _id               :: TF.Attr s P.Text
    -- ^ @id@ - (Optional, Forces New)
    --
    , _maxHeight        :: TF.Attr s P.Text
    -- ^ @max_height@ - (Optional, Forces New)
    --
    , _maxWidth         :: TF.Attr s P.Text
    -- ^ @max_width@ - (Optional, Forces New)
    --
    , _opacity          :: TF.Attr s P.Text
    -- ^ @opacity@ - (Optional, Forces New)
    --
    , _sizingPolicy     :: TF.Attr s P.Text
    -- ^ @sizing_policy@ - (Optional, Forces New)
    --
    , _target           :: TF.Attr s P.Text
    -- ^ @target@ - (Optional, Forces New)
    --
    , _verticalAlign    :: TF.Attr s P.Text
    -- ^ @vertical_align@ - (Optional, Forces New)
    --
    , _verticalOffset   :: TF.Attr s P.Text
    -- ^ @vertical_offset@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElastictranscoderPresetVideoWatermarks
    :: ElastictranscoderPresetVideoWatermarks s
newElastictranscoderPresetVideoWatermarks =
    ElastictranscoderPresetVideoWatermarks'
        { _horizontalAlign = TF.Nil
        , _horizontalOffset = TF.Nil
        , _id = TF.Nil
        , _maxHeight = TF.Nil
        , _maxWidth = TF.Nil
        , _opacity = TF.Nil
        , _sizingPolicy = TF.Nil
        , _target = TF.Nil
        , _verticalAlign = TF.Nil
        , _verticalOffset = TF.Nil
        }

instance P.Hashable  (ElastictranscoderPresetVideoWatermarks s)
instance TF.IsValue  (ElastictranscoderPresetVideoWatermarks s)
instance TF.IsObject (ElastictranscoderPresetVideoWatermarks s) where
    toObject ElastictranscoderPresetVideoWatermarks'{..} = P.catMaybes
        [ TF.assign "horizontal_align" <$> TF.attribute _horizontalAlign
        , TF.assign "horizontal_offset" <$> TF.attribute _horizontalOffset
        , TF.assign "id" <$> TF.attribute _id
        , TF.assign "max_height" <$> TF.attribute _maxHeight
        , TF.assign "max_width" <$> TF.attribute _maxWidth
        , TF.assign "opacity" <$> TF.attribute _opacity
        , TF.assign "sizing_policy" <$> TF.attribute _sizingPolicy
        , TF.assign "target" <$> TF.attribute _target
        , TF.assign "vertical_align" <$> TF.attribute _verticalAlign
        , TF.assign "vertical_offset" <$> TF.attribute _verticalOffset
        ]

instance TF.IsValid (ElastictranscoderPresetVideoWatermarks s) where
    validator = P.mempty

instance P.HasHorizontalAlign (ElastictranscoderPresetVideoWatermarks s) (TF.Attr s P.Text) where
    horizontalAlign =
        P.lens (_horizontalAlign :: ElastictranscoderPresetVideoWatermarks s -> TF.Attr s P.Text)
               (\s a -> s { _horizontalAlign = a } :: ElastictranscoderPresetVideoWatermarks s)

instance P.HasHorizontalOffset (ElastictranscoderPresetVideoWatermarks s) (TF.Attr s P.Text) where
    horizontalOffset =
        P.lens (_horizontalOffset :: ElastictranscoderPresetVideoWatermarks s -> TF.Attr s P.Text)
               (\s a -> s { _horizontalOffset = a } :: ElastictranscoderPresetVideoWatermarks s)

instance P.HasId (ElastictranscoderPresetVideoWatermarks s) (TF.Attr s P.Text) where
    id =
        P.lens (_id :: ElastictranscoderPresetVideoWatermarks s -> TF.Attr s P.Text)
               (\s a -> s { _id = a } :: ElastictranscoderPresetVideoWatermarks s)

instance P.HasMaxHeight (ElastictranscoderPresetVideoWatermarks s) (TF.Attr s P.Text) where
    maxHeight =
        P.lens (_maxHeight :: ElastictranscoderPresetVideoWatermarks s -> TF.Attr s P.Text)
               (\s a -> s { _maxHeight = a } :: ElastictranscoderPresetVideoWatermarks s)

instance P.HasMaxWidth (ElastictranscoderPresetVideoWatermarks s) (TF.Attr s P.Text) where
    maxWidth =
        P.lens (_maxWidth :: ElastictranscoderPresetVideoWatermarks s -> TF.Attr s P.Text)
               (\s a -> s { _maxWidth = a } :: ElastictranscoderPresetVideoWatermarks s)

instance P.HasOpacity (ElastictranscoderPresetVideoWatermarks s) (TF.Attr s P.Text) where
    opacity =
        P.lens (_opacity :: ElastictranscoderPresetVideoWatermarks s -> TF.Attr s P.Text)
               (\s a -> s { _opacity = a } :: ElastictranscoderPresetVideoWatermarks s)

instance P.HasSizingPolicy (ElastictranscoderPresetVideoWatermarks s) (TF.Attr s P.Text) where
    sizingPolicy =
        P.lens (_sizingPolicy :: ElastictranscoderPresetVideoWatermarks s -> TF.Attr s P.Text)
               (\s a -> s { _sizingPolicy = a } :: ElastictranscoderPresetVideoWatermarks s)

instance P.HasTarget (ElastictranscoderPresetVideoWatermarks s) (TF.Attr s P.Text) where
    target =
        P.lens (_target :: ElastictranscoderPresetVideoWatermarks s -> TF.Attr s P.Text)
               (\s a -> s { _target = a } :: ElastictranscoderPresetVideoWatermarks s)

instance P.HasVerticalAlign (ElastictranscoderPresetVideoWatermarks s) (TF.Attr s P.Text) where
    verticalAlign =
        P.lens (_verticalAlign :: ElastictranscoderPresetVideoWatermarks s -> TF.Attr s P.Text)
               (\s a -> s { _verticalAlign = a } :: ElastictranscoderPresetVideoWatermarks s)

instance P.HasVerticalOffset (ElastictranscoderPresetVideoWatermarks s) (TF.Attr s P.Text) where
    verticalOffset =
        P.lens (_verticalOffset :: ElastictranscoderPresetVideoWatermarks s -> TF.Attr s P.Text)
               (\s a -> s { _verticalOffset = a } :: ElastictranscoderPresetVideoWatermarks s)

-- | @rds_cluster_parameter_group_parameter@ nested settings.
data RdsClusterParameterGroupParameter s = RdsClusterParameterGroupParameter'
    { _applyMethod :: TF.Attr s P.Text
    -- ^ @apply_method@ - (Optional)
    --
    , _name        :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _value       :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRdsClusterParameterGroupParameter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> RdsClusterParameterGroupParameter s
newRdsClusterParameterGroupParameter _name _value =
    RdsClusterParameterGroupParameter'
        { _applyMethod = TF.value "immediate"
        , _name = _name
        , _value = _value
        }

instance P.Hashable  (RdsClusterParameterGroupParameter s)
instance TF.IsValue  (RdsClusterParameterGroupParameter s)
instance TF.IsObject (RdsClusterParameterGroupParameter s) where
    toObject RdsClusterParameterGroupParameter'{..} = P.catMaybes
        [ TF.assign "apply_method" <$> TF.attribute _applyMethod
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (RdsClusterParameterGroupParameter s) where
    validator = P.mempty

instance P.HasApplyMethod (RdsClusterParameterGroupParameter s) (TF.Attr s P.Text) where
    applyMethod =
        P.lens (_applyMethod :: RdsClusterParameterGroupParameter s -> TF.Attr s P.Text)
               (\s a -> s { _applyMethod = a } :: RdsClusterParameterGroupParameter s)

instance P.HasName (RdsClusterParameterGroupParameter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: RdsClusterParameterGroupParameter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: RdsClusterParameterGroupParameter s)

instance P.HasValue (RdsClusterParameterGroupParameter s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: RdsClusterParameterGroupParameter s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: RdsClusterParameterGroupParameter s)

-- | @ebs_snapshot_filter@ nested settings.
data EbsSnapshotFilter s = EbsSnapshotFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newEbsSnapshotFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> EbsSnapshotFilter s
newEbsSnapshotFilter _name _values =
    EbsSnapshotFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (EbsSnapshotFilter s)
instance TF.IsValue  (EbsSnapshotFilter s)
instance TF.IsObject (EbsSnapshotFilter s) where
    toObject EbsSnapshotFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (EbsSnapshotFilter s) where
    validator = P.mempty

instance P.HasName (EbsSnapshotFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: EbsSnapshotFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: EbsSnapshotFilter s)

instance P.HasValues (EbsSnapshotFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: EbsSnapshotFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: EbsSnapshotFilter s)

-- | @sql_injection_match_tuple_field_to_match@ nested settings.
data SqlInjectionMatchTupleFieldToMatch s = SqlInjectionMatchTupleFieldToMatch'
    { _data' :: TF.Attr s P.Text
    -- ^ @data@ - (Optional)
    --
    , _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSqlInjectionMatchTupleFieldToMatch
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> SqlInjectionMatchTupleFieldToMatch s
newSqlInjectionMatchTupleFieldToMatch _type' =
    SqlInjectionMatchTupleFieldToMatch'
        { _data' = TF.Nil
        , _type' = _type'
        }

instance P.Hashable  (SqlInjectionMatchTupleFieldToMatch s)
instance TF.IsValue  (SqlInjectionMatchTupleFieldToMatch s)
instance TF.IsObject (SqlInjectionMatchTupleFieldToMatch s) where
    toObject SqlInjectionMatchTupleFieldToMatch'{..} = P.catMaybes
        [ TF.assign "data" <$> TF.attribute _data'
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (SqlInjectionMatchTupleFieldToMatch s) where
    validator = P.mempty

instance P.HasData' (SqlInjectionMatchTupleFieldToMatch s) (TF.Attr s P.Text) where
    data' =
        P.lens (_data' :: SqlInjectionMatchTupleFieldToMatch s -> TF.Attr s P.Text)
               (\s a -> s { _data' = a } :: SqlInjectionMatchTupleFieldToMatch s)

instance P.HasType' (SqlInjectionMatchTupleFieldToMatch s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: SqlInjectionMatchTupleFieldToMatch s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: SqlInjectionMatchTupleFieldToMatch s)

-- | @elasticache_cluster_cache_nodes@ nested settings.
data ElasticacheClusterCacheNodes s = ElasticacheClusterCacheNodes'
    deriving (P.Show, P.Eq, P.Generic)

newElasticacheClusterCacheNodes
    :: ElasticacheClusterCacheNodes s
newElasticacheClusterCacheNodes =
    ElasticacheClusterCacheNodes'

instance P.Hashable  (ElasticacheClusterCacheNodes s)
instance TF.IsValue  (ElasticacheClusterCacheNodes s)
instance TF.IsObject (ElasticacheClusterCacheNodes s) where
    toObject ElasticacheClusterCacheNodes' = []

instance TF.IsValid (ElasticacheClusterCacheNodes s) where
    validator = P.mempty

instance s ~ s' => P.HasComputedAddress (TF.Ref s' (ElasticacheClusterCacheNodes s)) (TF.Attr s P.Text) where
    computedAddress x = TF.compute (TF.refKey x) "address"

instance s ~ s' => P.HasComputedAvailabilityZone (TF.Ref s' (ElasticacheClusterCacheNodes s)) (TF.Attr s P.Zone) where
    computedAvailabilityZone x = TF.compute (TF.refKey x) "availability_zone"

instance s ~ s' => P.HasComputedId (TF.Ref s' (ElasticacheClusterCacheNodes s)) (TF.Attr s P.Text) where
    computedId x = TF.compute (TF.refKey x) "id"

instance s ~ s' => P.HasComputedPort (TF.Ref s' (ElasticacheClusterCacheNodes s)) (TF.Attr s P.Integer) where
    computedPort x = TF.compute (TF.refKey x) "port"

-- | @endpoints@ nested settings.
data Endpoints = Endpoints'
    { _acm              :: P.Maybe P.Text
    -- ^ @acm@ - (Optional)
    --
    , _apigateway       :: P.Maybe P.Text
    -- ^ @apigateway@ - (Optional)
    -- Use this to override the default endpoint URL constructed from the `region`.
    --
    , _autoscaling      :: P.Maybe P.Text
    -- ^ @autoscaling@ - (Optional)
    -- Use this to override the default endpoint URL constructed from the `region`.
    --
    , _cloudformation   :: P.Maybe P.Text
    -- ^ @cloudformation@ - (Optional)
    -- Use this to override the default endpoint URL constructed from the `region`.
    --
    , _cloudwatch       :: P.Maybe P.Text
    -- ^ @cloudwatch@ - (Optional)
    -- Use this to override the default endpoint URL constructed from the `region`.
    --
    , _cloudwatchevents :: P.Maybe P.Text
    -- ^ @cloudwatchevents@ - (Optional)
    -- Use this to override the default endpoint URL constructed from the `region`.
    --
    , _cloudwatchlogs   :: P.Maybe P.Text
    -- ^ @cloudwatchlogs@ - (Optional)
    -- Use this to override the default endpoint URL constructed from the `region`.
    --
    , _devicefarm       :: P.Maybe P.Text
    -- ^ @devicefarm@ - (Optional)
    -- Use this to override the default endpoint URL constructed from the `region`.
    --
    , _dynamodb         :: P.Maybe P.Text
    -- ^ @dynamodb@ - (Optional)
    -- Use this to override the default endpoint URL constructed from the `region`.
    -- It's typically used to connect to dynamodb-local.
    --
    , _ec2              :: P.Maybe P.Text
    -- ^ @ec2@ - (Optional)
    -- Use this to override the default endpoint URL constructed from the `region`.
    --
    , _ecr              :: P.Maybe P.Text
    -- ^ @ecr@ - (Optional)
    --
    , _ecs              :: P.Maybe P.Text
    -- ^ @ecs@ - (Optional)
    --
    , _efs              :: P.Maybe P.Text
    -- ^ @efs@ - (Optional)
    -- Use this to override the default endpoint URL constructed from the `region`.
    --
    , _elb              :: P.Maybe P.Text
    -- ^ @elb@ - (Optional)
    -- Use this to override the default endpoint URL constructed from the `region`.
    --
    , _es               :: P.Maybe P.Text
    -- ^ @es@ - (Optional)
    -- Use this to override the default endpoint URL constructed from the `region`.
    --
    , _iam              :: P.Maybe P.Text
    -- ^ @iam@ - (Optional)
    -- Use this to override the default endpoint URL constructed from the `region`.
    --
    , _kinesis          :: P.Maybe P.Text
    -- ^ @kinesis@ - (Optional)
    -- Use this to override the default endpoint URL constructed from the `region`.
    -- It's typically used to connect to kinesalite.
    --
    , _kms              :: P.Maybe P.Text
    -- ^ @kms@ - (Optional)
    -- Use this to override the default endpoint URL constructed from the `region`.
    --
    , _lambda           :: P.Maybe P.Text
    -- ^ @lambda@ - (Optional)
    -- Use this to override the default endpoint URL constructed from the `region`
    --
    , _r53              :: P.Maybe P.Text
    -- ^ @r53@ - (Optional)
    --
    , _rds              :: P.Maybe P.Text
    -- ^ @rds@ - (Optional)
    -- Use this to override the default endpoint URL constructed from the `region`.
    --
    , _s3               :: P.Maybe P.Text
    -- ^ @s3@ - (Optional)
    -- Use this to override the default endpoint URL constructed from the `region`.
    --
    , _sns              :: P.Maybe P.Text
    -- ^ @sns@ - (Optional)
    -- Use this to override the default endpoint URL constructed from the `region`.
    --
    , _sqs              :: P.Maybe P.Text
    -- ^ @sqs@ - (Optional)
    -- Use this to override the default endpoint URL constructed from the `region`.
    --
    , _ssm              :: P.Maybe P.Text
    -- ^ @ssm@ - (Optional)
    -- Use this to override the default endpoint URL constructed from the `region`.
    --
    , _sts              :: P.Maybe P.Text
    -- ^ @sts@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newEndpoints
    :: Endpoints
newEndpoints =
    Endpoints'
        { _acm = P.Nothing
        , _apigateway = P.Nothing
        , _autoscaling = P.Nothing
        , _cloudformation = P.Nothing
        , _cloudwatch = P.Nothing
        , _cloudwatchevents = P.Nothing
        , _cloudwatchlogs = P.Nothing
        , _devicefarm = P.Nothing
        , _dynamodb = P.Nothing
        , _ec2 = P.Nothing
        , _ecr = P.Nothing
        , _ecs = P.Nothing
        , _efs = P.Nothing
        , _elb = P.Nothing
        , _es = P.Nothing
        , _iam = P.Nothing
        , _kinesis = P.Nothing
        , _kms = P.Nothing
        , _lambda = P.Nothing
        , _r53 = P.Nothing
        , _rds = P.Nothing
        , _s3 = P.Nothing
        , _sns = P.Nothing
        , _sqs = P.Nothing
        , _ssm = P.Nothing
        , _sts = P.Nothing
        }

instance P.Hashable  (Endpoints)
instance TF.IsValue  (Endpoints)
instance TF.IsObject (Endpoints) where
    toObject Endpoints'{..} = P.catMaybes
        [ TF.assign "acm" <$> _acm
        , TF.assign "apigateway" <$> _apigateway
        , TF.assign "autoscaling" <$> _autoscaling
        , TF.assign "cloudformation" <$> _cloudformation
        , TF.assign "cloudwatch" <$> _cloudwatch
        , TF.assign "cloudwatchevents" <$> _cloudwatchevents
        , TF.assign "cloudwatchlogs" <$> _cloudwatchlogs
        , TF.assign "devicefarm" <$> _devicefarm
        , TF.assign "dynamodb" <$> _dynamodb
        , TF.assign "ec2" <$> _ec2
        , TF.assign "ecr" <$> _ecr
        , TF.assign "ecs" <$> _ecs
        , TF.assign "efs" <$> _efs
        , TF.assign "elb" <$> _elb
        , TF.assign "es" <$> _es
        , TF.assign "iam" <$> _iam
        , TF.assign "kinesis" <$> _kinesis
        , TF.assign "kms" <$> _kms
        , TF.assign "lambda" <$> _lambda
        , TF.assign "r53" <$> _r53
        , TF.assign "rds" <$> _rds
        , TF.assign "s3" <$> _s3
        , TF.assign "sns" <$> _sns
        , TF.assign "sqs" <$> _sqs
        , TF.assign "ssm" <$> _ssm
        , TF.assign "sts" <$> _sts
        ]

instance TF.IsValid (Endpoints) where
    validator = P.mempty

instance P.HasAcm (Endpoints) (P.Maybe P.Text) where
    acm =
        P.lens (_acm :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _acm = a } :: Endpoints)

instance P.HasApigateway (Endpoints) (P.Maybe P.Text) where
    apigateway =
        P.lens (_apigateway :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _apigateway = a } :: Endpoints)

instance P.HasAutoscaling (Endpoints) (P.Maybe P.Text) where
    autoscaling =
        P.lens (_autoscaling :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _autoscaling = a } :: Endpoints)

instance P.HasCloudformation (Endpoints) (P.Maybe P.Text) where
    cloudformation =
        P.lens (_cloudformation :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _cloudformation = a } :: Endpoints)

instance P.HasCloudwatch (Endpoints) (P.Maybe P.Text) where
    cloudwatch =
        P.lens (_cloudwatch :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _cloudwatch = a } :: Endpoints)

instance P.HasCloudwatchevents (Endpoints) (P.Maybe P.Text) where
    cloudwatchevents =
        P.lens (_cloudwatchevents :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _cloudwatchevents = a } :: Endpoints)

instance P.HasCloudwatchlogs (Endpoints) (P.Maybe P.Text) where
    cloudwatchlogs =
        P.lens (_cloudwatchlogs :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _cloudwatchlogs = a } :: Endpoints)

instance P.HasDevicefarm (Endpoints) (P.Maybe P.Text) where
    devicefarm =
        P.lens (_devicefarm :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _devicefarm = a } :: Endpoints)

instance P.HasDynamodb (Endpoints) (P.Maybe P.Text) where
    dynamodb =
        P.lens (_dynamodb :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _dynamodb = a } :: Endpoints)

instance P.HasEc2 (Endpoints) (P.Maybe P.Text) where
    ec2 =
        P.lens (_ec2 :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _ec2 = a } :: Endpoints)

instance P.HasEcr (Endpoints) (P.Maybe P.Text) where
    ecr =
        P.lens (_ecr :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _ecr = a } :: Endpoints)

instance P.HasEcs (Endpoints) (P.Maybe P.Text) where
    ecs =
        P.lens (_ecs :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _ecs = a } :: Endpoints)

instance P.HasEfs (Endpoints) (P.Maybe P.Text) where
    efs =
        P.lens (_efs :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _efs = a } :: Endpoints)

instance P.HasElb (Endpoints) (P.Maybe P.Text) where
    elb =
        P.lens (_elb :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _elb = a } :: Endpoints)

instance P.HasEs (Endpoints) (P.Maybe P.Text) where
    es =
        P.lens (_es :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _es = a } :: Endpoints)

instance P.HasIam (Endpoints) (P.Maybe P.Text) where
    iam =
        P.lens (_iam :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _iam = a } :: Endpoints)

instance P.HasKinesis (Endpoints) (P.Maybe P.Text) where
    kinesis =
        P.lens (_kinesis :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _kinesis = a } :: Endpoints)

instance P.HasKms (Endpoints) (P.Maybe P.Text) where
    kms =
        P.lens (_kms :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _kms = a } :: Endpoints)

instance P.HasLambda (Endpoints) (P.Maybe P.Text) where
    lambda =
        P.lens (_lambda :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _lambda = a } :: Endpoints)

instance P.HasR53 (Endpoints) (P.Maybe P.Text) where
    r53 =
        P.lens (_r53 :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _r53 = a } :: Endpoints)

instance P.HasRds (Endpoints) (P.Maybe P.Text) where
    rds =
        P.lens (_rds :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _rds = a } :: Endpoints)

instance P.HasS3 (Endpoints) (P.Maybe P.Text) where
    s3 =
        P.lens (_s3 :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _s3 = a } :: Endpoints)

instance P.HasSns (Endpoints) (P.Maybe P.Text) where
    sns =
        P.lens (_sns :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _sns = a } :: Endpoints)

instance P.HasSqs (Endpoints) (P.Maybe P.Text) where
    sqs =
        P.lens (_sqs :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _sqs = a } :: Endpoints)

instance P.HasSsm (Endpoints) (P.Maybe P.Text) where
    ssm =
        P.lens (_ssm :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _ssm = a } :: Endpoints)

instance P.HasSts (Endpoints) (P.Maybe P.Text) where
    sts =
        P.lens (_sts :: Endpoints -> P.Maybe P.Text)
               (\s a -> s { _sts = a } :: Endpoints)

-- | @opsworks_instance_root_block_device@ nested settings.
data OpsworksInstanceRootBlockDevice s = OpsworksInstanceRootBlockDevice'
    { _deleteOnTermination :: TF.Attr s P.Bool
    -- ^ @delete_on_termination@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newOpsworksInstanceRootBlockDevice
    :: OpsworksInstanceRootBlockDevice s
newOpsworksInstanceRootBlockDevice =
    OpsworksInstanceRootBlockDevice'
        { _deleteOnTermination = TF.value P.True
        }

instance P.Hashable  (OpsworksInstanceRootBlockDevice s)
instance TF.IsValue  (OpsworksInstanceRootBlockDevice s)
instance TF.IsObject (OpsworksInstanceRootBlockDevice s) where
    toObject OpsworksInstanceRootBlockDevice'{..} = P.catMaybes
        [ TF.assign "delete_on_termination" <$> TF.attribute _deleteOnTermination
        ]

instance TF.IsValid (OpsworksInstanceRootBlockDevice s) where
    validator = P.mempty

instance P.HasDeleteOnTermination (OpsworksInstanceRootBlockDevice s) (TF.Attr s P.Bool) where
    deleteOnTermination =
        P.lens (_deleteOnTermination :: OpsworksInstanceRootBlockDevice s -> TF.Attr s P.Bool)
               (\s a -> s { _deleteOnTermination = a } :: OpsworksInstanceRootBlockDevice s)

instance s ~ s' => P.HasComputedIops (TF.Ref s' (OpsworksInstanceRootBlockDevice s)) (TF.Attr s P.Integer) where
    computedIops x = TF.compute (TF.refKey x) "iops"

instance s ~ s' => P.HasComputedVolumeSize (TF.Ref s' (OpsworksInstanceRootBlockDevice s)) (TF.Attr s P.Integer) where
    computedVolumeSize x = TF.compute (TF.refKey x) "volume_size"

instance s ~ s' => P.HasComputedVolumeType (TF.Ref s' (OpsworksInstanceRootBlockDevice s)) (TF.Attr s P.Text) where
    computedVolumeType x = TF.compute (TF.refKey x) "volume_type"

-- | @s3_bucket_server_side_encryption_configuration@ nested settings.
data S3BucketServerSideEncryptionConfiguration s = S3BucketServerSideEncryptionConfiguration'
    { _rule :: TF.Attr s (ServerSideEncryptionConfigurationRule s)
    -- ^ @rule@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newS3BucketServerSideEncryptionConfiguration
    :: TF.Attr s (ServerSideEncryptionConfigurationRule s) -- ^ @rule@ - 'P.rule'
    -> S3BucketServerSideEncryptionConfiguration s
newS3BucketServerSideEncryptionConfiguration _rule =
    S3BucketServerSideEncryptionConfiguration'
        { _rule = _rule
        }

instance P.Hashable  (S3BucketServerSideEncryptionConfiguration s)
instance TF.IsValue  (S3BucketServerSideEncryptionConfiguration s)
instance TF.IsObject (S3BucketServerSideEncryptionConfiguration s) where
    toObject S3BucketServerSideEncryptionConfiguration'{..} = P.catMaybes
        [ TF.assign "rule" <$> TF.attribute _rule
        ]

instance TF.IsValid (S3BucketServerSideEncryptionConfiguration s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_rule"
                  (_rule
                      :: S3BucketServerSideEncryptionConfiguration s -> TF.Attr s (ServerSideEncryptionConfigurationRule s))
                  TF.validator

instance P.HasRule (S3BucketServerSideEncryptionConfiguration s) (TF.Attr s (ServerSideEncryptionConfigurationRule s)) where
    rule =
        P.lens (_rule :: S3BucketServerSideEncryptionConfiguration s -> TF.Attr s (ServerSideEncryptionConfigurationRule s))
               (\s a -> s { _rule = a } :: S3BucketServerSideEncryptionConfiguration s)

-- | @processors_parameters@ nested settings.
data ProcessorsParameters s = ProcessorsParameters'
    { _parameterName  :: TF.Attr s P.Text
    -- ^ @parameter_name@ - (Required)
    --
    , _parameterValue :: TF.Attr s P.Text
    -- ^ @parameter_value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newProcessorsParameters
    :: TF.Attr s P.Text -- ^ @parameter_name@ - 'P.parameterName'
    -> TF.Attr s P.Text -- ^ @parameter_value@ - 'P.parameterValue'
    -> ProcessorsParameters s
newProcessorsParameters _parameterName _parameterValue =
    ProcessorsParameters'
        { _parameterName = _parameterName
        , _parameterValue = _parameterValue
        }

instance P.Hashable  (ProcessorsParameters s)
instance TF.IsValue  (ProcessorsParameters s)
instance TF.IsObject (ProcessorsParameters s) where
    toObject ProcessorsParameters'{..} = P.catMaybes
        [ TF.assign "parameter_name" <$> TF.attribute _parameterName
        , TF.assign "parameter_value" <$> TF.attribute _parameterValue
        ]

instance TF.IsValid (ProcessorsParameters s) where
    validator = P.mempty

instance P.HasParameterName (ProcessorsParameters s) (TF.Attr s P.Text) where
    parameterName =
        P.lens (_parameterName :: ProcessorsParameters s -> TF.Attr s P.Text)
               (\s a -> s { _parameterName = a } :: ProcessorsParameters s)

instance P.HasParameterValue (ProcessorsParameters s) (TF.Attr s P.Text) where
    parameterValue =
        P.lens (_parameterValue :: ProcessorsParameters s -> TF.Attr s P.Text)
               (\s a -> s { _parameterValue = a } :: ProcessorsParameters s)

-- | @pricing_product_filters@ nested settings.
data PricingProductFilters s = PricingProductFilters'
    { _field :: TF.Attr s P.Text
    -- ^ @field@ - (Required)
    --
    , _value :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newPricingProductFilters
    :: TF.Attr s P.Text -- ^ @field@ - 'P.field'
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> PricingProductFilters s
newPricingProductFilters _field _value =
    PricingProductFilters'
        { _field = _field
        , _value = _value
        }

instance P.Hashable  (PricingProductFilters s)
instance TF.IsValue  (PricingProductFilters s)
instance TF.IsObject (PricingProductFilters s) where
    toObject PricingProductFilters'{..} = P.catMaybes
        [ TF.assign "field" <$> TF.attribute _field
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (PricingProductFilters s) where
    validator = P.mempty

instance P.HasField (PricingProductFilters s) (TF.Attr s P.Text) where
    field =
        P.lens (_field :: PricingProductFilters s -> TF.Attr s P.Text)
               (\s a -> s { _field = a } :: PricingProductFilters s)

instance P.HasValue (PricingProductFilters s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: PricingProductFilters s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: PricingProductFilters s)

-- | @elasticsearch_domain_snapshot_options@ nested settings.
data ElasticsearchDomainSnapshotOptions s = ElasticsearchDomainSnapshotOptions'
    { _automatedSnapshotStartHour :: TF.Attr s P.Integer
    -- ^ @automated_snapshot_start_hour@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElasticsearchDomainSnapshotOptions
    :: TF.Attr s P.Integer -- ^ @automated_snapshot_start_hour@ - 'P.automatedSnapshotStartHour'
    -> ElasticsearchDomainSnapshotOptions s
newElasticsearchDomainSnapshotOptions _automatedSnapshotStartHour =
    ElasticsearchDomainSnapshotOptions'
        { _automatedSnapshotStartHour = _automatedSnapshotStartHour
        }

instance P.Hashable  (ElasticsearchDomainSnapshotOptions s)
instance TF.IsValue  (ElasticsearchDomainSnapshotOptions s)
instance TF.IsObject (ElasticsearchDomainSnapshotOptions s) where
    toObject ElasticsearchDomainSnapshotOptions'{..} = P.catMaybes
        [ TF.assign "automated_snapshot_start_hour" <$> TF.attribute _automatedSnapshotStartHour
        ]

instance TF.IsValid (ElasticsearchDomainSnapshotOptions s) where
    validator = P.mempty

instance P.HasAutomatedSnapshotStartHour (ElasticsearchDomainSnapshotOptions s) (TF.Attr s P.Integer) where
    automatedSnapshotStartHour =
        P.lens (_automatedSnapshotStartHour :: ElasticsearchDomainSnapshotOptions s -> TF.Attr s P.Integer)
               (\s a -> s { _automatedSnapshotStartHour = a } :: ElasticsearchDomainSnapshotOptions s)

-- | @appsync_datasource_dynamodb_config@ nested settings.
data AppsyncDatasourceDynamodbConfig s = AppsyncDatasourceDynamodbConfig'
    { _region               :: TF.Attr s P.Text
    -- ^ @region@ - (Required)
    --
    , _tableName            :: TF.Attr s P.Text
    -- ^ @table_name@ - (Required)
    --
    , _useCallerCredentials :: TF.Attr s P.Bool
    -- ^ @use_caller_credentials@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAppsyncDatasourceDynamodbConfig
    :: TF.Attr s P.Text -- ^ @region@ - 'P.region'
    -> TF.Attr s P.Text -- ^ @table_name@ - 'P.tableName'
    -> AppsyncDatasourceDynamodbConfig s
newAppsyncDatasourceDynamodbConfig _region _tableName =
    AppsyncDatasourceDynamodbConfig'
        { _region = _region
        , _tableName = _tableName
        , _useCallerCredentials = TF.Nil
        }

instance P.Hashable  (AppsyncDatasourceDynamodbConfig s)
instance TF.IsValue  (AppsyncDatasourceDynamodbConfig s)
instance TF.IsObject (AppsyncDatasourceDynamodbConfig s) where
    toObject AppsyncDatasourceDynamodbConfig'{..} = P.catMaybes
        [ TF.assign "region" <$> TF.attribute _region
        , TF.assign "table_name" <$> TF.attribute _tableName
        , TF.assign "use_caller_credentials" <$> TF.attribute _useCallerCredentials
        ]

instance TF.IsValid (AppsyncDatasourceDynamodbConfig s) where
    validator = P.mempty

instance P.HasRegion (AppsyncDatasourceDynamodbConfig s) (TF.Attr s P.Text) where
    region =
        P.lens (_region :: AppsyncDatasourceDynamodbConfig s -> TF.Attr s P.Text)
               (\s a -> s { _region = a } :: AppsyncDatasourceDynamodbConfig s)

instance P.HasTableName (AppsyncDatasourceDynamodbConfig s) (TF.Attr s P.Text) where
    tableName =
        P.lens (_tableName :: AppsyncDatasourceDynamodbConfig s -> TF.Attr s P.Text)
               (\s a -> s { _tableName = a } :: AppsyncDatasourceDynamodbConfig s)

instance P.HasUseCallerCredentials (AppsyncDatasourceDynamodbConfig s) (TF.Attr s P.Bool) where
    useCallerCredentials =
        P.lens (_useCallerCredentials :: AppsyncDatasourceDynamodbConfig s -> TF.Attr s P.Bool)
               (\s a -> s { _useCallerCredentials = a } :: AppsyncDatasourceDynamodbConfig s)

-- | @serializer_orc_ser_de@ nested settings.
data SerializerOrcSerDe s = SerializerOrcSerDe'
    { _blockSizeBytes                      :: TF.Attr s P.Integer
    -- ^ @block_size_bytes@ - (Optional)
    --
    , _bloomFilterColumns                  :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @bloom_filter_columns@ - (Optional)
    --
    , _bloomFilterFalsePositiveProbability :: TF.Attr s P.Double
    -- ^ @bloom_filter_false_positive_probability@ - (Optional)
    --
    , _compression                         :: TF.Attr s P.Text
    -- ^ @compression@ - (Optional)
    --
    , _dictionaryKeyThreshold              :: TF.Attr s P.Double
    -- ^ @dictionary_key_threshold@ - (Optional)
    --
    , _enablePadding                       :: TF.Attr s P.Bool
    -- ^ @enable_padding@ - (Optional)
    --
    , _formatVersion                       :: TF.Attr s P.Text
    -- ^ @format_version@ - (Optional)
    --
    , _paddingTolerance                    :: TF.Attr s P.Double
    -- ^ @padding_tolerance@ - (Optional)
    --
    , _rowIndexStride                      :: TF.Attr s P.Integer
    -- ^ @row_index_stride@ - (Optional)
    --
    , _stripeSizeBytes                     :: TF.Attr s P.Integer
    -- ^ @stripe_size_bytes@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSerializerOrcSerDe
    :: SerializerOrcSerDe s
newSerializerOrcSerDe =
    SerializerOrcSerDe'
        { _blockSizeBytes = TF.value 268435456
        , _bloomFilterColumns = TF.Nil
        , _bloomFilterFalsePositiveProbability = TF.value 5.0e-2
        , _compression = TF.value "SNAPPY"
        , _dictionaryKeyThreshold = TF.value 0.0
        , _enablePadding = TF.value P.False
        , _formatVersion = TF.value "V0_12"
        , _paddingTolerance = TF.value 5.0e-2
        , _rowIndexStride = TF.value 10000
        , _stripeSizeBytes = TF.value 67108864
        }

instance P.Hashable  (SerializerOrcSerDe s)
instance TF.IsValue  (SerializerOrcSerDe s)
instance TF.IsObject (SerializerOrcSerDe s) where
    toObject SerializerOrcSerDe'{..} = P.catMaybes
        [ TF.assign "block_size_bytes" <$> TF.attribute _blockSizeBytes
        , TF.assign "bloom_filter_columns" <$> TF.attribute _bloomFilterColumns
        , TF.assign "bloom_filter_false_positive_probability" <$> TF.attribute _bloomFilterFalsePositiveProbability
        , TF.assign "compression" <$> TF.attribute _compression
        , TF.assign "dictionary_key_threshold" <$> TF.attribute _dictionaryKeyThreshold
        , TF.assign "enable_padding" <$> TF.attribute _enablePadding
        , TF.assign "format_version" <$> TF.attribute _formatVersion
        , TF.assign "padding_tolerance" <$> TF.attribute _paddingTolerance
        , TF.assign "row_index_stride" <$> TF.attribute _rowIndexStride
        , TF.assign "stripe_size_bytes" <$> TF.attribute _stripeSizeBytes
        ]

instance TF.IsValid (SerializerOrcSerDe s) where
    validator = P.mempty

instance P.HasBlockSizeBytes (SerializerOrcSerDe s) (TF.Attr s P.Integer) where
    blockSizeBytes =
        P.lens (_blockSizeBytes :: SerializerOrcSerDe s -> TF.Attr s P.Integer)
               (\s a -> s { _blockSizeBytes = a } :: SerializerOrcSerDe s)

instance P.HasBloomFilterColumns (SerializerOrcSerDe s) (TF.Attr s [TF.Attr s P.Text]) where
    bloomFilterColumns =
        P.lens (_bloomFilterColumns :: SerializerOrcSerDe s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _bloomFilterColumns = a } :: SerializerOrcSerDe s)

instance P.HasBloomFilterFalsePositiveProbability (SerializerOrcSerDe s) (TF.Attr s P.Double) where
    bloomFilterFalsePositiveProbability =
        P.lens (_bloomFilterFalsePositiveProbability :: SerializerOrcSerDe s -> TF.Attr s P.Double)
               (\s a -> s { _bloomFilterFalsePositiveProbability = a } :: SerializerOrcSerDe s)

instance P.HasCompression (SerializerOrcSerDe s) (TF.Attr s P.Text) where
    compression =
        P.lens (_compression :: SerializerOrcSerDe s -> TF.Attr s P.Text)
               (\s a -> s { _compression = a } :: SerializerOrcSerDe s)

instance P.HasDictionaryKeyThreshold (SerializerOrcSerDe s) (TF.Attr s P.Double) where
    dictionaryKeyThreshold =
        P.lens (_dictionaryKeyThreshold :: SerializerOrcSerDe s -> TF.Attr s P.Double)
               (\s a -> s { _dictionaryKeyThreshold = a } :: SerializerOrcSerDe s)

instance P.HasEnablePadding (SerializerOrcSerDe s) (TF.Attr s P.Bool) where
    enablePadding =
        P.lens (_enablePadding :: SerializerOrcSerDe s -> TF.Attr s P.Bool)
               (\s a -> s { _enablePadding = a } :: SerializerOrcSerDe s)

instance P.HasFormatVersion (SerializerOrcSerDe s) (TF.Attr s P.Text) where
    formatVersion =
        P.lens (_formatVersion :: SerializerOrcSerDe s -> TF.Attr s P.Text)
               (\s a -> s { _formatVersion = a } :: SerializerOrcSerDe s)

instance P.HasPaddingTolerance (SerializerOrcSerDe s) (TF.Attr s P.Double) where
    paddingTolerance =
        P.lens (_paddingTolerance :: SerializerOrcSerDe s -> TF.Attr s P.Double)
               (\s a -> s { _paddingTolerance = a } :: SerializerOrcSerDe s)

instance P.HasRowIndexStride (SerializerOrcSerDe s) (TF.Attr s P.Integer) where
    rowIndexStride =
        P.lens (_rowIndexStride :: SerializerOrcSerDe s -> TF.Attr s P.Integer)
               (\s a -> s { _rowIndexStride = a } :: SerializerOrcSerDe s)

instance P.HasStripeSizeBytes (SerializerOrcSerDe s) (TF.Attr s P.Integer) where
    stripeSizeBytes =
        P.lens (_stripeSizeBytes :: SerializerOrcSerDe s -> TF.Attr s P.Integer)
               (\s a -> s { _stripeSizeBytes = a } :: SerializerOrcSerDe s)

-- | @default_cache_behavior_lambda_function_association@ nested settings.
data DefaultCacheBehaviorLambdaFunctionAssociation s = DefaultCacheBehaviorLambdaFunctionAssociation'
    { _eventType :: TF.Attr s P.Text
    -- ^ @event_type@ - (Required)
    --
    , _lambdaArn :: TF.Attr s P.Text
    -- ^ @lambda_arn@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDefaultCacheBehaviorLambdaFunctionAssociation
    :: TF.Attr s P.Text -- ^ @event_type@ - 'P.eventType'
    -> TF.Attr s P.Text -- ^ @lambda_arn@ - 'P.lambdaArn'
    -> DefaultCacheBehaviorLambdaFunctionAssociation s
newDefaultCacheBehaviorLambdaFunctionAssociation _eventType _lambdaArn =
    DefaultCacheBehaviorLambdaFunctionAssociation'
        { _eventType = _eventType
        , _lambdaArn = _lambdaArn
        }

instance P.Hashable  (DefaultCacheBehaviorLambdaFunctionAssociation s)
instance TF.IsValue  (DefaultCacheBehaviorLambdaFunctionAssociation s)
instance TF.IsObject (DefaultCacheBehaviorLambdaFunctionAssociation s) where
    toObject DefaultCacheBehaviorLambdaFunctionAssociation'{..} = P.catMaybes
        [ TF.assign "event_type" <$> TF.attribute _eventType
        , TF.assign "lambda_arn" <$> TF.attribute _lambdaArn
        ]

instance TF.IsValid (DefaultCacheBehaviorLambdaFunctionAssociation s) where
    validator = P.mempty

instance P.HasEventType (DefaultCacheBehaviorLambdaFunctionAssociation s) (TF.Attr s P.Text) where
    eventType =
        P.lens (_eventType :: DefaultCacheBehaviorLambdaFunctionAssociation s -> TF.Attr s P.Text)
               (\s a -> s { _eventType = a } :: DefaultCacheBehaviorLambdaFunctionAssociation s)

instance P.HasLambdaArn (DefaultCacheBehaviorLambdaFunctionAssociation s) (TF.Attr s P.Text) where
    lambdaArn =
        P.lens (_lambdaArn :: DefaultCacheBehaviorLambdaFunctionAssociation s -> TF.Attr s P.Text)
               (\s a -> s { _lambdaArn = a } :: DefaultCacheBehaviorLambdaFunctionAssociation s)

-- | @iam_policy_document_statement@ nested settings.
data IamPolicyDocumentStatement s = IamPolicyDocumentStatement'
    { _actions       :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @actions@ - (Optional)
    --
    , _condition     :: TF.Attr s [TF.Attr s (StatementCondition s)]
    -- ^ @condition@ - (Optional)
    --
    , _effect        :: TF.Attr s P.Text
    -- ^ @effect@ - (Optional)
    --
    , _notActions    :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @not_actions@ - (Optional)
    --
    , _notPrincipals :: TF.Attr s [TF.Attr s (StatementNotPrincipals s)]
    -- ^ @not_principals@ - (Optional)
    --
    , _notResources  :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @not_resources@ - (Optional)
    --
    , _principals    :: TF.Attr s [TF.Attr s (StatementPrincipals s)]
    -- ^ @principals@ - (Optional)
    --
    , _resources     :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @resources@ - (Optional)
    --
    , _sid           :: TF.Attr s P.Text
    -- ^ @sid@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newIamPolicyDocumentStatement
    :: IamPolicyDocumentStatement s
newIamPolicyDocumentStatement =
    IamPolicyDocumentStatement'
        { _actions = TF.Nil
        , _condition = TF.Nil
        , _effect = TF.value "Allow"
        , _notActions = TF.Nil
        , _notPrincipals = TF.Nil
        , _notResources = TF.Nil
        , _principals = TF.Nil
        , _resources = TF.Nil
        , _sid = TF.Nil
        }

instance P.Hashable  (IamPolicyDocumentStatement s)
instance TF.IsValue  (IamPolicyDocumentStatement s)
instance TF.IsObject (IamPolicyDocumentStatement s) where
    toObject IamPolicyDocumentStatement'{..} = P.catMaybes
        [ TF.assign "actions" <$> TF.attribute _actions
        , TF.assign "condition" <$> TF.attribute _condition
        , TF.assign "effect" <$> TF.attribute _effect
        , TF.assign "not_actions" <$> TF.attribute _notActions
        , TF.assign "not_principals" <$> TF.attribute _notPrincipals
        , TF.assign "not_resources" <$> TF.attribute _notResources
        , TF.assign "principals" <$> TF.attribute _principals
        , TF.assign "resources" <$> TF.attribute _resources
        , TF.assign "sid" <$> TF.attribute _sid
        ]

instance TF.IsValid (IamPolicyDocumentStatement s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_condition"
                  (_condition
                      :: IamPolicyDocumentStatement s -> TF.Attr s [TF.Attr s (StatementCondition s)])
                  TF.validator
           P.<> TF.settingsValidator "_notPrincipals"
                  (_notPrincipals
                      :: IamPolicyDocumentStatement s -> TF.Attr s [TF.Attr s (StatementNotPrincipals s)])
                  TF.validator
           P.<> TF.settingsValidator "_principals"
                  (_principals
                      :: IamPolicyDocumentStatement s -> TF.Attr s [TF.Attr s (StatementPrincipals s)])
                  TF.validator

instance P.HasActions (IamPolicyDocumentStatement s) (TF.Attr s [TF.Attr s P.Text]) where
    actions =
        P.lens (_actions :: IamPolicyDocumentStatement s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _actions = a } :: IamPolicyDocumentStatement s)

instance P.HasCondition (IamPolicyDocumentStatement s) (TF.Attr s [TF.Attr s (StatementCondition s)]) where
    condition =
        P.lens (_condition :: IamPolicyDocumentStatement s -> TF.Attr s [TF.Attr s (StatementCondition s)])
               (\s a -> s { _condition = a } :: IamPolicyDocumentStatement s)

instance P.HasEffect (IamPolicyDocumentStatement s) (TF.Attr s P.Text) where
    effect =
        P.lens (_effect :: IamPolicyDocumentStatement s -> TF.Attr s P.Text)
               (\s a -> s { _effect = a } :: IamPolicyDocumentStatement s)

instance P.HasNotActions (IamPolicyDocumentStatement s) (TF.Attr s [TF.Attr s P.Text]) where
    notActions =
        P.lens (_notActions :: IamPolicyDocumentStatement s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _notActions = a } :: IamPolicyDocumentStatement s)

instance P.HasNotPrincipals (IamPolicyDocumentStatement s) (TF.Attr s [TF.Attr s (StatementNotPrincipals s)]) where
    notPrincipals =
        P.lens (_notPrincipals :: IamPolicyDocumentStatement s -> TF.Attr s [TF.Attr s (StatementNotPrincipals s)])
               (\s a -> s { _notPrincipals = a } :: IamPolicyDocumentStatement s)

instance P.HasNotResources (IamPolicyDocumentStatement s) (TF.Attr s [TF.Attr s P.Text]) where
    notResources =
        P.lens (_notResources :: IamPolicyDocumentStatement s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _notResources = a } :: IamPolicyDocumentStatement s)

instance P.HasPrincipals (IamPolicyDocumentStatement s) (TF.Attr s [TF.Attr s (StatementPrincipals s)]) where
    principals =
        P.lens (_principals :: IamPolicyDocumentStatement s -> TF.Attr s [TF.Attr s (StatementPrincipals s)])
               (\s a -> s { _principals = a } :: IamPolicyDocumentStatement s)

instance P.HasResources (IamPolicyDocumentStatement s) (TF.Attr s [TF.Attr s P.Text]) where
    resources =
        P.lens (_resources :: IamPolicyDocumentStatement s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _resources = a } :: IamPolicyDocumentStatement s)

instance P.HasSid (IamPolicyDocumentStatement s) (TF.Attr s P.Text) where
    sid =
        P.lens (_sid :: IamPolicyDocumentStatement s -> TF.Attr s P.Text)
               (\s a -> s { _sid = a } :: IamPolicyDocumentStatement s)

-- | @spot_instance_request_credit_specification@ nested settings.
data SpotInstanceRequestCreditSpecification s = SpotInstanceRequestCreditSpecification'
    { _cpuCredits :: TF.Attr s P.Text
    -- ^ @cpu_credits@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSpotInstanceRequestCreditSpecification
    :: SpotInstanceRequestCreditSpecification s
newSpotInstanceRequestCreditSpecification =
    SpotInstanceRequestCreditSpecification'
        { _cpuCredits = TF.value "standard"
        }

instance P.Hashable  (SpotInstanceRequestCreditSpecification s)
instance TF.IsValue  (SpotInstanceRequestCreditSpecification s)
instance TF.IsObject (SpotInstanceRequestCreditSpecification s) where
    toObject SpotInstanceRequestCreditSpecification'{..} = P.catMaybes
        [ TF.assign "cpu_credits" <$> TF.attribute _cpuCredits
        ]

instance TF.IsValid (SpotInstanceRequestCreditSpecification s) where
    validator = P.mempty

instance P.HasCpuCredits (SpotInstanceRequestCreditSpecification s) (TF.Attr s P.Text) where
    cpuCredits =
        P.lens (_cpuCredits :: SpotInstanceRequestCreditSpecification s -> TF.Attr s P.Text)
               (\s a -> s { _cpuCredits = a } :: SpotInstanceRequestCreditSpecification s)

-- | @origin_custom_header@ nested settings.
data OriginCustomHeader s = OriginCustomHeader'
    { _name  :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _value :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newOriginCustomHeader
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> OriginCustomHeader s
newOriginCustomHeader _name _value =
    OriginCustomHeader'
        { _name = _name
        , _value = _value
        }

instance P.Hashable  (OriginCustomHeader s)
instance TF.IsValue  (OriginCustomHeader s)
instance TF.IsObject (OriginCustomHeader s) where
    toObject OriginCustomHeader'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (OriginCustomHeader s) where
    validator = P.mempty

instance P.HasName (OriginCustomHeader s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: OriginCustomHeader s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: OriginCustomHeader s)

instance P.HasValue (OriginCustomHeader s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: OriginCustomHeader s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: OriginCustomHeader s)

-- | @vpc_peering_connection_requester@ nested settings.
data VpcPeeringConnectionRequester s = VpcPeeringConnectionRequester'
    { _allowClassicLinkToRemoteVpc :: TF.Attr s P.Bool
    -- ^ @allow_classic_link_to_remote_vpc@ - (Optional)
    --
    , _allowRemoteVpcDnsResolution :: TF.Attr s P.Bool
    -- ^ @allow_remote_vpc_dns_resolution@ - (Optional)
    --
    , _allowVpcToRemoteClassicLink :: TF.Attr s P.Bool
    -- ^ @allow_vpc_to_remote_classic_link@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newVpcPeeringConnectionRequester
    :: VpcPeeringConnectionRequester s
newVpcPeeringConnectionRequester =
    VpcPeeringConnectionRequester'
        { _allowClassicLinkToRemoteVpc = TF.value P.False
        , _allowRemoteVpcDnsResolution = TF.value P.False
        , _allowVpcToRemoteClassicLink = TF.value P.False
        }

instance P.Hashable  (VpcPeeringConnectionRequester s)
instance TF.IsValue  (VpcPeeringConnectionRequester s)
instance TF.IsObject (VpcPeeringConnectionRequester s) where
    toObject VpcPeeringConnectionRequester'{..} = P.catMaybes
        [ TF.assign "allow_classic_link_to_remote_vpc" <$> TF.attribute _allowClassicLinkToRemoteVpc
        , TF.assign "allow_remote_vpc_dns_resolution" <$> TF.attribute _allowRemoteVpcDnsResolution
        , TF.assign "allow_vpc_to_remote_classic_link" <$> TF.attribute _allowVpcToRemoteClassicLink
        ]

instance TF.IsValid (VpcPeeringConnectionRequester s) where
    validator = P.mempty

instance P.HasAllowClassicLinkToRemoteVpc (VpcPeeringConnectionRequester s) (TF.Attr s P.Bool) where
    allowClassicLinkToRemoteVpc =
        P.lens (_allowClassicLinkToRemoteVpc :: VpcPeeringConnectionRequester s -> TF.Attr s P.Bool)
               (\s a -> s { _allowClassicLinkToRemoteVpc = a } :: VpcPeeringConnectionRequester s)

instance P.HasAllowRemoteVpcDnsResolution (VpcPeeringConnectionRequester s) (TF.Attr s P.Bool) where
    allowRemoteVpcDnsResolution =
        P.lens (_allowRemoteVpcDnsResolution :: VpcPeeringConnectionRequester s -> TF.Attr s P.Bool)
               (\s a -> s { _allowRemoteVpcDnsResolution = a } :: VpcPeeringConnectionRequester s)

instance P.HasAllowVpcToRemoteClassicLink (VpcPeeringConnectionRequester s) (TF.Attr s P.Bool) where
    allowVpcToRemoteClassicLink =
        P.lens (_allowVpcToRemoteClassicLink :: VpcPeeringConnectionRequester s -> TF.Attr s P.Bool)
               (\s a -> s { _allowVpcToRemoteClassicLink = a } :: VpcPeeringConnectionRequester s)

-- | @lambda_function_environment@ nested settings.
data LambdaFunctionEnvironment s = LambdaFunctionEnvironment'
    { _variables :: TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))
    -- ^ @variables@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLambdaFunctionEnvironment
    :: LambdaFunctionEnvironment s
newLambdaFunctionEnvironment =
    LambdaFunctionEnvironment'
        { _variables = TF.Nil
        }

instance P.Hashable  (LambdaFunctionEnvironment s)
instance TF.IsValue  (LambdaFunctionEnvironment s)
instance TF.IsObject (LambdaFunctionEnvironment s) where
    toObject LambdaFunctionEnvironment'{..} = P.catMaybes
        [ TF.assign "variables" <$> TF.attribute _variables
        ]

instance TF.IsValid (LambdaFunctionEnvironment s) where
    validator = P.mempty

instance P.HasVariables (LambdaFunctionEnvironment s) (TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))) where
    variables =
        P.lens (_variables :: LambdaFunctionEnvironment s -> TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text)))
               (\s a -> s { _variables = a } :: LambdaFunctionEnvironment s)

instance s ~ s' => P.HasComputedVariables (TF.Ref s' (LambdaFunctionEnvironment s)) (TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))) where
    computedVariables x = TF.compute (TF.refKey x) "variables"

-- | @serializer_parquet_ser_de@ nested settings.
data SerializerParquetSerDe s = SerializerParquetSerDe'
    { _blockSizeBytes              :: TF.Attr s P.Integer
    -- ^ @block_size_bytes@ - (Optional)
    --
    , _compression                 :: TF.Attr s P.Text
    -- ^ @compression@ - (Optional)
    --
    , _enableDictionaryCompression :: TF.Attr s P.Bool
    -- ^ @enable_dictionary_compression@ - (Optional)
    --
    , _maxPaddingBytes             :: TF.Attr s P.Integer
    -- ^ @max_padding_bytes@ - (Optional)
    --
    , _pageSizeBytes               :: TF.Attr s P.Integer
    -- ^ @page_size_bytes@ - (Optional)
    --
    , _writerVersion               :: TF.Attr s P.Text
    -- ^ @writer_version@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSerializerParquetSerDe
    :: SerializerParquetSerDe s
newSerializerParquetSerDe =
    SerializerParquetSerDe'
        { _blockSizeBytes = TF.value 268435456
        , _compression = TF.value "SNAPPY"
        , _enableDictionaryCompression = TF.value P.False
        , _maxPaddingBytes = TF.value 0
        , _pageSizeBytes = TF.value 1048576
        , _writerVersion = TF.value "V1"
        }

instance P.Hashable  (SerializerParquetSerDe s)
instance TF.IsValue  (SerializerParquetSerDe s)
instance TF.IsObject (SerializerParquetSerDe s) where
    toObject SerializerParquetSerDe'{..} = P.catMaybes
        [ TF.assign "block_size_bytes" <$> TF.attribute _blockSizeBytes
        , TF.assign "compression" <$> TF.attribute _compression
        , TF.assign "enable_dictionary_compression" <$> TF.attribute _enableDictionaryCompression
        , TF.assign "max_padding_bytes" <$> TF.attribute _maxPaddingBytes
        , TF.assign "page_size_bytes" <$> TF.attribute _pageSizeBytes
        , TF.assign "writer_version" <$> TF.attribute _writerVersion
        ]

instance TF.IsValid (SerializerParquetSerDe s) where
    validator = P.mempty

instance P.HasBlockSizeBytes (SerializerParquetSerDe s) (TF.Attr s P.Integer) where
    blockSizeBytes =
        P.lens (_blockSizeBytes :: SerializerParquetSerDe s -> TF.Attr s P.Integer)
               (\s a -> s { _blockSizeBytes = a } :: SerializerParquetSerDe s)

instance P.HasCompression (SerializerParquetSerDe s) (TF.Attr s P.Text) where
    compression =
        P.lens (_compression :: SerializerParquetSerDe s -> TF.Attr s P.Text)
               (\s a -> s { _compression = a } :: SerializerParquetSerDe s)

instance P.HasEnableDictionaryCompression (SerializerParquetSerDe s) (TF.Attr s P.Bool) where
    enableDictionaryCompression =
        P.lens (_enableDictionaryCompression :: SerializerParquetSerDe s -> TF.Attr s P.Bool)
               (\s a -> s { _enableDictionaryCompression = a } :: SerializerParquetSerDe s)

instance P.HasMaxPaddingBytes (SerializerParquetSerDe s) (TF.Attr s P.Integer) where
    maxPaddingBytes =
        P.lens (_maxPaddingBytes :: SerializerParquetSerDe s -> TF.Attr s P.Integer)
               (\s a -> s { _maxPaddingBytes = a } :: SerializerParquetSerDe s)

instance P.HasPageSizeBytes (SerializerParquetSerDe s) (TF.Attr s P.Integer) where
    pageSizeBytes =
        P.lens (_pageSizeBytes :: SerializerParquetSerDe s -> TF.Attr s P.Integer)
               (\s a -> s { _pageSizeBytes = a } :: SerializerParquetSerDe s)

instance P.HasWriterVersion (SerializerParquetSerDe s) (TF.Attr s P.Text) where
    writerVersion =
        P.lens (_writerVersion :: SerializerParquetSerDe s -> TF.Attr s P.Text)
               (\s a -> s { _writerVersion = a } :: SerializerParquetSerDe s)

-- | @elasticsearch_domain_ebs_options@ nested settings.
data ElasticsearchDomainEbsOptions s = ElasticsearchDomainEbsOptions'
    { _ebsEnabled :: TF.Attr s P.Bool
    -- ^ @ebs_enabled@ - (Required)
    --
    , _iops       :: TF.Attr s P.Integer
    -- ^ @iops@ - (Optional)
    --
    , _volumeSize :: TF.Attr s P.Integer
    -- ^ @volume_size@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElasticsearchDomainEbsOptions
    :: TF.Attr s P.Bool -- ^ @ebs_enabled@ - 'P.ebsEnabled'
    -> ElasticsearchDomainEbsOptions s
newElasticsearchDomainEbsOptions _ebsEnabled =
    ElasticsearchDomainEbsOptions'
        { _ebsEnabled = _ebsEnabled
        , _iops = TF.Nil
        , _volumeSize = TF.Nil
        }

instance P.Hashable  (ElasticsearchDomainEbsOptions s)
instance TF.IsValue  (ElasticsearchDomainEbsOptions s)
instance TF.IsObject (ElasticsearchDomainEbsOptions s) where
    toObject ElasticsearchDomainEbsOptions'{..} = P.catMaybes
        [ TF.assign "ebs_enabled" <$> TF.attribute _ebsEnabled
        , TF.assign "iops" <$> TF.attribute _iops
        , TF.assign "volume_size" <$> TF.attribute _volumeSize
        ]

instance TF.IsValid (ElasticsearchDomainEbsOptions s) where
    validator = P.mempty

instance P.HasEbsEnabled (ElasticsearchDomainEbsOptions s) (TF.Attr s P.Bool) where
    ebsEnabled =
        P.lens (_ebsEnabled :: ElasticsearchDomainEbsOptions s -> TF.Attr s P.Bool)
               (\s a -> s { _ebsEnabled = a } :: ElasticsearchDomainEbsOptions s)

instance P.HasIops (ElasticsearchDomainEbsOptions s) (TF.Attr s P.Integer) where
    iops =
        P.lens (_iops :: ElasticsearchDomainEbsOptions s -> TF.Attr s P.Integer)
               (\s a -> s { _iops = a } :: ElasticsearchDomainEbsOptions s)

instance P.HasVolumeSize (ElasticsearchDomainEbsOptions s) (TF.Attr s P.Integer) where
    volumeSize =
        P.lens (_volumeSize :: ElasticsearchDomainEbsOptions s -> TF.Attr s P.Integer)
               (\s a -> s { _volumeSize = a } :: ElasticsearchDomainEbsOptions s)

instance s ~ s' => P.HasComputedVolumeType (TF.Ref s' (ElasticsearchDomainEbsOptions s)) (TF.Attr s P.Text) where
    computedVolumeType x = TF.compute (TF.refKey x) "volume_type"

-- | @iot_thing_type_properties@ nested settings.
data IotThingTypeProperties s = IotThingTypeProperties'
    { _description :: TF.Attr s P.Text
    -- ^ @description@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newIotThingTypeProperties
    :: IotThingTypeProperties s
newIotThingTypeProperties =
    IotThingTypeProperties'
        { _description = TF.Nil
        }

instance P.Hashable  (IotThingTypeProperties s)
instance TF.IsValue  (IotThingTypeProperties s)
instance TF.IsObject (IotThingTypeProperties s) where
    toObject IotThingTypeProperties'{..} = P.catMaybes
        [ TF.assign "description" <$> TF.attribute _description
        ]

instance TF.IsValid (IotThingTypeProperties s) where
    validator = P.mempty

instance P.HasDescription (IotThingTypeProperties s) (TF.Attr s P.Text) where
    description =
        P.lens (_description :: IotThingTypeProperties s -> TF.Attr s P.Text)
               (\s a -> s { _description = a } :: IotThingTypeProperties s)

instance s ~ s' => P.HasComputedSearchableAttributes (TF.Ref s' (IotThingTypeProperties s)) (TF.Attr s [TF.Attr s P.Text]) where
    computedSearchableAttributes x = TF.compute (TF.refKey x) "searchable_attributes"

-- | @dms_endpoint_s3_settings@ nested settings.
data DmsEndpointS3Settings s = DmsEndpointS3Settings'
    { _bucketFolder            :: TF.Attr s P.Text
    -- ^ @bucket_folder@ - (Optional)
    --
    , _bucketName              :: TF.Attr s P.Text
    -- ^ @bucket_name@ - (Optional)
    --
    , _compressionType         :: TF.Attr s P.Text
    -- ^ @compression_type@ - (Optional)
    --
    , _csvDelimiter            :: TF.Attr s P.Text
    -- ^ @csv_delimiter@ - (Optional)
    --
    , _csvRowDelimiter         :: TF.Attr s P.Text
    -- ^ @csv_row_delimiter@ - (Optional)
    --
    , _externalTableDefinition :: TF.Attr s P.Text
    -- ^ @external_table_definition@ - (Optional)
    --
    , _serviceAccessRoleArn    :: TF.Attr s P.Text
    -- ^ @service_access_role_arn@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDmsEndpointS3Settings
    :: DmsEndpointS3Settings s
newDmsEndpointS3Settings =
    DmsEndpointS3Settings'
        { _bucketFolder = TF.Nil
        , _bucketName = TF.Nil
        , _compressionType = TF.value "NONE"
        , _csvDelimiter = TF.value ","
        , _csvRowDelimiter = TF.value "\n"
        , _externalTableDefinition = TF.Nil
        , _serviceAccessRoleArn = TF.Nil
        }

instance P.Hashable  (DmsEndpointS3Settings s)
instance TF.IsValue  (DmsEndpointS3Settings s)
instance TF.IsObject (DmsEndpointS3Settings s) where
    toObject DmsEndpointS3Settings'{..} = P.catMaybes
        [ TF.assign "bucket_folder" <$> TF.attribute _bucketFolder
        , TF.assign "bucket_name" <$> TF.attribute _bucketName
        , TF.assign "compression_type" <$> TF.attribute _compressionType
        , TF.assign "csv_delimiter" <$> TF.attribute _csvDelimiter
        , TF.assign "csv_row_delimiter" <$> TF.attribute _csvRowDelimiter
        , TF.assign "external_table_definition" <$> TF.attribute _externalTableDefinition
        , TF.assign "service_access_role_arn" <$> TF.attribute _serviceAccessRoleArn
        ]

instance TF.IsValid (DmsEndpointS3Settings s) where
    validator = P.mempty

instance P.HasBucketFolder (DmsEndpointS3Settings s) (TF.Attr s P.Text) where
    bucketFolder =
        P.lens (_bucketFolder :: DmsEndpointS3Settings s -> TF.Attr s P.Text)
               (\s a -> s { _bucketFolder = a } :: DmsEndpointS3Settings s)

instance P.HasBucketName (DmsEndpointS3Settings s) (TF.Attr s P.Text) where
    bucketName =
        P.lens (_bucketName :: DmsEndpointS3Settings s -> TF.Attr s P.Text)
               (\s a -> s { _bucketName = a } :: DmsEndpointS3Settings s)

instance P.HasCompressionType (DmsEndpointS3Settings s) (TF.Attr s P.Text) where
    compressionType =
        P.lens (_compressionType :: DmsEndpointS3Settings s -> TF.Attr s P.Text)
               (\s a -> s { _compressionType = a } :: DmsEndpointS3Settings s)

instance P.HasCsvDelimiter (DmsEndpointS3Settings s) (TF.Attr s P.Text) where
    csvDelimiter =
        P.lens (_csvDelimiter :: DmsEndpointS3Settings s -> TF.Attr s P.Text)
               (\s a -> s { _csvDelimiter = a } :: DmsEndpointS3Settings s)

instance P.HasCsvRowDelimiter (DmsEndpointS3Settings s) (TF.Attr s P.Text) where
    csvRowDelimiter =
        P.lens (_csvRowDelimiter :: DmsEndpointS3Settings s -> TF.Attr s P.Text)
               (\s a -> s { _csvRowDelimiter = a } :: DmsEndpointS3Settings s)

instance P.HasExternalTableDefinition (DmsEndpointS3Settings s) (TF.Attr s P.Text) where
    externalTableDefinition =
        P.lens (_externalTableDefinition :: DmsEndpointS3Settings s -> TF.Attr s P.Text)
               (\s a -> s { _externalTableDefinition = a } :: DmsEndpointS3Settings s)

instance P.HasServiceAccessRoleArn (DmsEndpointS3Settings s) (TF.Attr s P.Text) where
    serviceAccessRoleArn =
        P.lens (_serviceAccessRoleArn :: DmsEndpointS3Settings s -> TF.Attr s P.Text)
               (\s a -> s { _serviceAccessRoleArn = a } :: DmsEndpointS3Settings s)

-- | @extended_s3_configuration_cloudwatch_logging_options@ nested settings.
data ExtendedS3ConfigurationCloudwatchLoggingOptions s = ExtendedS3ConfigurationCloudwatchLoggingOptions'
    { _enabled       :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Optional)
    --
    , _logGroupName  :: TF.Attr s P.Text
    -- ^ @log_group_name@ - (Optional)
    --
    , _logStreamName :: TF.Attr s P.Text
    -- ^ @log_stream_name@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newExtendedS3ConfigurationCloudwatchLoggingOptions
    :: ExtendedS3ConfigurationCloudwatchLoggingOptions s
newExtendedS3ConfigurationCloudwatchLoggingOptions =
    ExtendedS3ConfigurationCloudwatchLoggingOptions'
        { _enabled = TF.value P.False
        , _logGroupName = TF.Nil
        , _logStreamName = TF.Nil
        }

instance P.Hashable  (ExtendedS3ConfigurationCloudwatchLoggingOptions s)
instance TF.IsValue  (ExtendedS3ConfigurationCloudwatchLoggingOptions s)
instance TF.IsObject (ExtendedS3ConfigurationCloudwatchLoggingOptions s) where
    toObject ExtendedS3ConfigurationCloudwatchLoggingOptions'{..} = P.catMaybes
        [ TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "log_group_name" <$> TF.attribute _logGroupName
        , TF.assign "log_stream_name" <$> TF.attribute _logStreamName
        ]

instance TF.IsValid (ExtendedS3ConfigurationCloudwatchLoggingOptions s) where
    validator = P.mempty

instance P.HasEnabled (ExtendedS3ConfigurationCloudwatchLoggingOptions s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: ExtendedS3ConfigurationCloudwatchLoggingOptions s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: ExtendedS3ConfigurationCloudwatchLoggingOptions s)

instance P.HasLogGroupName (ExtendedS3ConfigurationCloudwatchLoggingOptions s) (TF.Attr s P.Text) where
    logGroupName =
        P.lens (_logGroupName :: ExtendedS3ConfigurationCloudwatchLoggingOptions s -> TF.Attr s P.Text)
               (\s a -> s { _logGroupName = a } :: ExtendedS3ConfigurationCloudwatchLoggingOptions s)

instance P.HasLogStreamName (ExtendedS3ConfigurationCloudwatchLoggingOptions s) (TF.Attr s P.Text) where
    logStreamName =
        P.lens (_logStreamName :: ExtendedS3ConfigurationCloudwatchLoggingOptions s -> TF.Attr s P.Text)
               (\s a -> s { _logStreamName = a } :: ExtendedS3ConfigurationCloudwatchLoggingOptions s)

-- | @config_config_rule_scope@ nested settings.
data ConfigConfigRuleScope s = ConfigConfigRuleScope'
    { _complianceResourceId    :: TF.Attr s P.Text
    -- ^ @compliance_resource_id@ - (Optional)
    --
    , _complianceResourceTypes :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @compliance_resource_types@ - (Optional)
    --
    , _tagKey                  :: TF.Attr s P.Text
    -- ^ @tag_key@ - (Optional)
    --
    , _tagValue                :: TF.Attr s P.Text
    -- ^ @tag_value@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newConfigConfigRuleScope
    :: ConfigConfigRuleScope s
newConfigConfigRuleScope =
    ConfigConfigRuleScope'
        { _complianceResourceId = TF.Nil
        , _complianceResourceTypes = TF.Nil
        , _tagKey = TF.Nil
        , _tagValue = TF.Nil
        }

instance P.Hashable  (ConfigConfigRuleScope s)
instance TF.IsValue  (ConfigConfigRuleScope s)
instance TF.IsObject (ConfigConfigRuleScope s) where
    toObject ConfigConfigRuleScope'{..} = P.catMaybes
        [ TF.assign "compliance_resource_id" <$> TF.attribute _complianceResourceId
        , TF.assign "compliance_resource_types" <$> TF.attribute _complianceResourceTypes
        , TF.assign "tag_key" <$> TF.attribute _tagKey
        , TF.assign "tag_value" <$> TF.attribute _tagValue
        ]

instance TF.IsValid (ConfigConfigRuleScope s) where
    validator = P.mempty

instance P.HasComplianceResourceId (ConfigConfigRuleScope s) (TF.Attr s P.Text) where
    complianceResourceId =
        P.lens (_complianceResourceId :: ConfigConfigRuleScope s -> TF.Attr s P.Text)
               (\s a -> s { _complianceResourceId = a } :: ConfigConfigRuleScope s)

instance P.HasComplianceResourceTypes (ConfigConfigRuleScope s) (TF.Attr s [TF.Attr s P.Text]) where
    complianceResourceTypes =
        P.lens (_complianceResourceTypes :: ConfigConfigRuleScope s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _complianceResourceTypes = a } :: ConfigConfigRuleScope s)

instance P.HasTagKey (ConfigConfigRuleScope s) (TF.Attr s P.Text) where
    tagKey =
        P.lens (_tagKey :: ConfigConfigRuleScope s -> TF.Attr s P.Text)
               (\s a -> s { _tagKey = a } :: ConfigConfigRuleScope s)

instance P.HasTagValue (ConfigConfigRuleScope s) (TF.Attr s P.Text) where
    tagValue =
        P.lens (_tagValue :: ConfigConfigRuleScope s -> TF.Attr s P.Text)
               (\s a -> s { _tagValue = a } :: ConfigConfigRuleScope s)

-- | @deserializer_open_x_json_ser_de@ nested settings.
data DeserializerOpenXJsonSerDe s = DeserializerOpenXJsonSerDe'
    { _caseInsensitive :: TF.Attr s P.Bool
    -- ^ @case_insensitive@ - (Optional)
    --
    , _columnToJsonKeyMappings :: TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))
    -- ^ @column_to_json_key_mappings@ - (Optional)
    --
    , _convertDotsInJsonKeysToUnderscores :: TF.Attr s P.Bool
    -- ^ @convert_dots_in_json_keys_to_underscores@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDeserializerOpenXJsonSerDe
    :: DeserializerOpenXJsonSerDe s
newDeserializerOpenXJsonSerDe =
    DeserializerOpenXJsonSerDe'
        { _caseInsensitive = TF.value P.True
        , _columnToJsonKeyMappings = TF.Nil
        , _convertDotsInJsonKeysToUnderscores = TF.value P.False
        }

instance P.Hashable  (DeserializerOpenXJsonSerDe s)
instance TF.IsValue  (DeserializerOpenXJsonSerDe s)
instance TF.IsObject (DeserializerOpenXJsonSerDe s) where
    toObject DeserializerOpenXJsonSerDe'{..} = P.catMaybes
        [ TF.assign "case_insensitive" <$> TF.attribute _caseInsensitive
        , TF.assign "column_to_json_key_mappings" <$> TF.attribute _columnToJsonKeyMappings
        , TF.assign "convert_dots_in_json_keys_to_underscores" <$> TF.attribute _convertDotsInJsonKeysToUnderscores
        ]

instance TF.IsValid (DeserializerOpenXJsonSerDe s) where
    validator = P.mempty

instance P.HasCaseInsensitive (DeserializerOpenXJsonSerDe s) (TF.Attr s P.Bool) where
    caseInsensitive =
        P.lens (_caseInsensitive :: DeserializerOpenXJsonSerDe s -> TF.Attr s P.Bool)
               (\s a -> s { _caseInsensitive = a } :: DeserializerOpenXJsonSerDe s)

instance P.HasColumnToJsonKeyMappings (DeserializerOpenXJsonSerDe s) (TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))) where
    columnToJsonKeyMappings =
        P.lens (_columnToJsonKeyMappings :: DeserializerOpenXJsonSerDe s -> TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text)))
               (\s a -> s { _columnToJsonKeyMappings = a } :: DeserializerOpenXJsonSerDe s)

instance P.HasConvertDotsInJsonKeysToUnderscores (DeserializerOpenXJsonSerDe s) (TF.Attr s P.Bool) where
    convertDotsInJsonKeysToUnderscores =
        P.lens (_convertDotsInJsonKeysToUnderscores :: DeserializerOpenXJsonSerDe s -> TF.Attr s P.Bool)
               (\s a -> s { _convertDotsInJsonKeysToUnderscores = a } :: DeserializerOpenXJsonSerDe s)

-- | @codedeploy_deployment_group_on_premises_instance_tag_filter@ nested settings.
data CodedeployDeploymentGroupOnPremisesInstanceTagFilter s = CodedeployDeploymentGroupOnPremisesInstanceTagFilter'
    { _key   :: TF.Attr s P.Text
    -- ^ @key@ - (Optional)
    --
    , _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Optional)
    --
    , _value :: TF.Attr s P.Text
    -- ^ @value@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCodedeployDeploymentGroupOnPremisesInstanceTagFilter
    :: CodedeployDeploymentGroupOnPremisesInstanceTagFilter s
newCodedeployDeploymentGroupOnPremisesInstanceTagFilter =
    CodedeployDeploymentGroupOnPremisesInstanceTagFilter'
        { _key = TF.Nil
        , _type' = TF.Nil
        , _value = TF.Nil
        }

instance P.Hashable  (CodedeployDeploymentGroupOnPremisesInstanceTagFilter s)
instance TF.IsValue  (CodedeployDeploymentGroupOnPremisesInstanceTagFilter s)
instance TF.IsObject (CodedeployDeploymentGroupOnPremisesInstanceTagFilter s) where
    toObject CodedeployDeploymentGroupOnPremisesInstanceTagFilter'{..} = P.catMaybes
        [ TF.assign "key" <$> TF.attribute _key
        , TF.assign "type" <$> TF.attribute _type'
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (CodedeployDeploymentGroupOnPremisesInstanceTagFilter s) where
    validator = P.mempty

instance P.HasKey (CodedeployDeploymentGroupOnPremisesInstanceTagFilter s) (TF.Attr s P.Text) where
    key =
        P.lens (_key :: CodedeployDeploymentGroupOnPremisesInstanceTagFilter s -> TF.Attr s P.Text)
               (\s a -> s { _key = a } :: CodedeployDeploymentGroupOnPremisesInstanceTagFilter s)

instance P.HasType' (CodedeployDeploymentGroupOnPremisesInstanceTagFilter s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: CodedeployDeploymentGroupOnPremisesInstanceTagFilter s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: CodedeployDeploymentGroupOnPremisesInstanceTagFilter s)

instance P.HasValue (CodedeployDeploymentGroupOnPremisesInstanceTagFilter s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: CodedeployDeploymentGroupOnPremisesInstanceTagFilter s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: CodedeployDeploymentGroupOnPremisesInstanceTagFilter s)

-- | @cognito_identity_pool_roles_attachment_role_mapping@ nested settings.
data CognitoIdentityPoolRolesAttachmentRoleMapping s = CognitoIdentityPoolRolesAttachmentRoleMapping'
    { _ambiguousRoleResolution :: TF.Attr s P.Text
    -- ^ @ambiguous_role_resolution@ - (Optional)
    --
    , _identityProvider :: TF.Attr s P.Text
    -- ^ @identity_provider@ - (Required)
    --
    , _mappingRule :: TF.Attr s [TF.Attr s (RoleMappingMappingRule s)]
    -- ^ @mapping_rule@ - (Optional)
    --
    , _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCognitoIdentityPoolRolesAttachmentRoleMapping
    :: TF.Attr s P.Text -- ^ @identity_provider@ - 'P.identityProvider'
    -> TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> CognitoIdentityPoolRolesAttachmentRoleMapping s
newCognitoIdentityPoolRolesAttachmentRoleMapping _identityProvider _type' =
    CognitoIdentityPoolRolesAttachmentRoleMapping'
        { _ambiguousRoleResolution = TF.Nil
        , _identityProvider = _identityProvider
        , _mappingRule = TF.Nil
        , _type' = _type'
        }

instance P.Hashable  (CognitoIdentityPoolRolesAttachmentRoleMapping s)
instance TF.IsValue  (CognitoIdentityPoolRolesAttachmentRoleMapping s)
instance TF.IsObject (CognitoIdentityPoolRolesAttachmentRoleMapping s) where
    toObject CognitoIdentityPoolRolesAttachmentRoleMapping'{..} = P.catMaybes
        [ TF.assign "ambiguous_role_resolution" <$> TF.attribute _ambiguousRoleResolution
        , TF.assign "identity_provider" <$> TF.attribute _identityProvider
        , TF.assign "mapping_rule" <$> TF.attribute _mappingRule
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (CognitoIdentityPoolRolesAttachmentRoleMapping s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_mappingRule"
                  (_mappingRule
                      :: CognitoIdentityPoolRolesAttachmentRoleMapping s -> TF.Attr s [TF.Attr s (RoleMappingMappingRule s)])
                  TF.validator

instance P.HasAmbiguousRoleResolution (CognitoIdentityPoolRolesAttachmentRoleMapping s) (TF.Attr s P.Text) where
    ambiguousRoleResolution =
        P.lens (_ambiguousRoleResolution :: CognitoIdentityPoolRolesAttachmentRoleMapping s -> TF.Attr s P.Text)
               (\s a -> s { _ambiguousRoleResolution = a } :: CognitoIdentityPoolRolesAttachmentRoleMapping s)

instance P.HasIdentityProvider (CognitoIdentityPoolRolesAttachmentRoleMapping s) (TF.Attr s P.Text) where
    identityProvider =
        P.lens (_identityProvider :: CognitoIdentityPoolRolesAttachmentRoleMapping s -> TF.Attr s P.Text)
               (\s a -> s { _identityProvider = a } :: CognitoIdentityPoolRolesAttachmentRoleMapping s)

instance P.HasMappingRule (CognitoIdentityPoolRolesAttachmentRoleMapping s) (TF.Attr s [TF.Attr s (RoleMappingMappingRule s)]) where
    mappingRule =
        P.lens (_mappingRule :: CognitoIdentityPoolRolesAttachmentRoleMapping s -> TF.Attr s [TF.Attr s (RoleMappingMappingRule s)])
               (\s a -> s { _mappingRule = a } :: CognitoIdentityPoolRolesAttachmentRoleMapping s)

instance P.HasType' (CognitoIdentityPoolRolesAttachmentRoleMapping s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: CognitoIdentityPoolRolesAttachmentRoleMapping s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: CognitoIdentityPoolRolesAttachmentRoleMapping s)

-- | @ssm_document_parameter@ nested settings.
data SsmDocumentParameter s = SsmDocumentParameter'
    { _defaultValue :: TF.Attr s P.Text
    -- ^ @default_value@ - (Optional)
    --
    , _description  :: TF.Attr s P.Text
    -- ^ @description@ - (Optional)
    --
    , _name         :: TF.Attr s P.Text
    -- ^ @name@ - (Optional)
    --
    , _type'        :: TF.Attr s P.Text
    -- ^ @type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSsmDocumentParameter
    :: SsmDocumentParameter s
newSsmDocumentParameter =
    SsmDocumentParameter'
        { _defaultValue = TF.Nil
        , _description = TF.Nil
        , _name = TF.Nil
        , _type' = TF.Nil
        }

instance P.Hashable  (SsmDocumentParameter s)
instance TF.IsValue  (SsmDocumentParameter s)
instance TF.IsObject (SsmDocumentParameter s) where
    toObject SsmDocumentParameter'{..} = P.catMaybes
        [ TF.assign "default_value" <$> TF.attribute _defaultValue
        , TF.assign "description" <$> TF.attribute _description
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (SsmDocumentParameter s) where
    validator = P.mempty

instance P.HasDefaultValue (SsmDocumentParameter s) (TF.Attr s P.Text) where
    defaultValue =
        P.lens (_defaultValue :: SsmDocumentParameter s -> TF.Attr s P.Text)
               (\s a -> s { _defaultValue = a } :: SsmDocumentParameter s)

instance P.HasDescription (SsmDocumentParameter s) (TF.Attr s P.Text) where
    description =
        P.lens (_description :: SsmDocumentParameter s -> TF.Attr s P.Text)
               (\s a -> s { _description = a } :: SsmDocumentParameter s)

instance P.HasName (SsmDocumentParameter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: SsmDocumentParameter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: SsmDocumentParameter s)

instance P.HasType' (SsmDocumentParameter s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: SsmDocumentParameter s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: SsmDocumentParameter s)

-- | @opsworks_java_app_layer_ebs_volume@ nested settings.
data OpsworksJavaAppLayerEbsVolume s = OpsworksJavaAppLayerEbsVolume'
    { _iops          :: TF.Attr s P.Integer
    -- ^ @iops@ - (Optional)
    --
    , _mountPoint    :: TF.Attr s P.Text
    -- ^ @mount_point@ - (Required)
    --
    , _numberOfDisks :: TF.Attr s P.Integer
    -- ^ @number_of_disks@ - (Required)
    --
    , _raidLevel     :: TF.Attr s P.Text
    -- ^ @raid_level@ - (Optional)
    --
    , _size          :: TF.Attr s P.Integer
    -- ^ @size@ - (Required)
    --
    , _type'         :: TF.Attr s P.Text
    -- ^ @type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newOpsworksJavaAppLayerEbsVolume
    :: TF.Attr s P.Text -- ^ @mount_point@ - 'P.mountPoint'
    -> TF.Attr s P.Integer -- ^ @number_of_disks@ - 'P.numberOfDisks'
    -> TF.Attr s P.Integer -- ^ @size@ - 'P.size'
    -> OpsworksJavaAppLayerEbsVolume s
newOpsworksJavaAppLayerEbsVolume _mountPoint _numberOfDisks _size =
    OpsworksJavaAppLayerEbsVolume'
        { _iops = TF.value 0
        , _mountPoint = _mountPoint
        , _numberOfDisks = _numberOfDisks
        , _raidLevel = TF.Nil
        , _size = _size
        , _type' = TF.value "standard"
        }

instance P.Hashable  (OpsworksJavaAppLayerEbsVolume s)
instance TF.IsValue  (OpsworksJavaAppLayerEbsVolume s)
instance TF.IsObject (OpsworksJavaAppLayerEbsVolume s) where
    toObject OpsworksJavaAppLayerEbsVolume'{..} = P.catMaybes
        [ TF.assign "iops" <$> TF.attribute _iops
        , TF.assign "mount_point" <$> TF.attribute _mountPoint
        , TF.assign "number_of_disks" <$> TF.attribute _numberOfDisks
        , TF.assign "raid_level" <$> TF.attribute _raidLevel
        , TF.assign "size" <$> TF.attribute _size
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (OpsworksJavaAppLayerEbsVolume s) where
    validator = P.mempty

instance P.HasIops (OpsworksJavaAppLayerEbsVolume s) (TF.Attr s P.Integer) where
    iops =
        P.lens (_iops :: OpsworksJavaAppLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _iops = a } :: OpsworksJavaAppLayerEbsVolume s)

instance P.HasMountPoint (OpsworksJavaAppLayerEbsVolume s) (TF.Attr s P.Text) where
    mountPoint =
        P.lens (_mountPoint :: OpsworksJavaAppLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _mountPoint = a } :: OpsworksJavaAppLayerEbsVolume s)

instance P.HasNumberOfDisks (OpsworksJavaAppLayerEbsVolume s) (TF.Attr s P.Integer) where
    numberOfDisks =
        P.lens (_numberOfDisks :: OpsworksJavaAppLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _numberOfDisks = a } :: OpsworksJavaAppLayerEbsVolume s)

instance P.HasRaidLevel (OpsworksJavaAppLayerEbsVolume s) (TF.Attr s P.Text) where
    raidLevel =
        P.lens (_raidLevel :: OpsworksJavaAppLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _raidLevel = a } :: OpsworksJavaAppLayerEbsVolume s)

instance P.HasSize (OpsworksJavaAppLayerEbsVolume s) (TF.Attr s P.Integer) where
    size =
        P.lens (_size :: OpsworksJavaAppLayerEbsVolume s -> TF.Attr s P.Integer)
               (\s a -> s { _size = a } :: OpsworksJavaAppLayerEbsVolume s)

instance P.HasType' (OpsworksJavaAppLayerEbsVolume s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: OpsworksJavaAppLayerEbsVolume s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: OpsworksJavaAppLayerEbsVolume s)

-- | @instance_ebs_block_device@ nested settings.
data InstanceEbsBlockDevice s = InstanceEbsBlockDevice'
    { _deleteOnTermination :: TF.Attr s P.Bool
    -- ^ @delete_on_termination@ - (Optional, Forces New)
    --
    , _deviceName          :: TF.Attr s P.Text
    -- ^ @device_name@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newInstanceEbsBlockDevice
    :: TF.Attr s P.Text -- ^ @device_name@ - 'P.deviceName'
    -> InstanceEbsBlockDevice s
newInstanceEbsBlockDevice _deviceName =
    InstanceEbsBlockDevice'
        { _deleteOnTermination = TF.value P.True
        , _deviceName = _deviceName
        }

instance P.Hashable  (InstanceEbsBlockDevice s)
instance TF.IsValue  (InstanceEbsBlockDevice s)
instance TF.IsObject (InstanceEbsBlockDevice s) where
    toObject InstanceEbsBlockDevice'{..} = P.catMaybes
        [ TF.assign "delete_on_termination" <$> TF.attribute _deleteOnTermination
        , TF.assign "device_name" <$> TF.attribute _deviceName
        ]

instance TF.IsValid (InstanceEbsBlockDevice s) where
    validator = P.mempty

instance P.HasDeleteOnTermination (InstanceEbsBlockDevice s) (TF.Attr s P.Bool) where
    deleteOnTermination =
        P.lens (_deleteOnTermination :: InstanceEbsBlockDevice s -> TF.Attr s P.Bool)
               (\s a -> s { _deleteOnTermination = a } :: InstanceEbsBlockDevice s)

instance P.HasDeviceName (InstanceEbsBlockDevice s) (TF.Attr s P.Text) where
    deviceName =
        P.lens (_deviceName :: InstanceEbsBlockDevice s -> TF.Attr s P.Text)
               (\s a -> s { _deviceName = a } :: InstanceEbsBlockDevice s)

instance s ~ s' => P.HasComputedEncrypted (TF.Ref s' (InstanceEbsBlockDevice s)) (TF.Attr s P.Bool) where
    computedEncrypted x = TF.compute (TF.refKey x) "encrypted"

instance s ~ s' => P.HasComputedIops (TF.Ref s' (InstanceEbsBlockDevice s)) (TF.Attr s P.Integer) where
    computedIops x = TF.compute (TF.refKey x) "iops"

instance s ~ s' => P.HasComputedSnapshotId (TF.Ref s' (InstanceEbsBlockDevice s)) (TF.Attr s P.Text) where
    computedSnapshotId x = TF.compute (TF.refKey x) "snapshot_id"

instance s ~ s' => P.HasComputedVolumeId (TF.Ref s' (InstanceEbsBlockDevice s)) (TF.Attr s P.Text) where
    computedVolumeId x = TF.compute (TF.refKey x) "volume_id"

instance s ~ s' => P.HasComputedVolumeSize (TF.Ref s' (InstanceEbsBlockDevice s)) (TF.Attr s P.Integer) where
    computedVolumeSize x = TF.compute (TF.refKey x) "volume_size"

instance s ~ s' => P.HasComputedVolumeType (TF.Ref s' (InstanceEbsBlockDevice s)) (TF.Attr s P.Text) where
    computedVolumeType x = TF.compute (TF.refKey x) "volume_type"

instance s ~ s' => P.HasComputedDeleteOnTermination (TF.Ref s' (InstanceEbsBlockDevice s)) (TF.Attr s P.Bool) where
    computedDeleteOnTermination x = TF.compute (TF.refKey x) "delete_on_termination"

instance s ~ s' => P.HasComputedDeviceName (TF.Ref s' (InstanceEbsBlockDevice s)) (TF.Attr s P.Text) where
    computedDeviceName x = TF.compute (TF.refKey x) "device_name"

-- | @cognito_identity_pool_roles_attachment_roles@ nested settings.
data CognitoIdentityPoolRolesAttachmentRoles s = CognitoIdentityPoolRolesAttachmentRoles'
    { _authenticated   :: TF.Attr s P.Text
    -- ^ @authenticated@ - (Optional)
    --
    , _unauthenticated :: TF.Attr s P.Text
    -- ^ @unauthenticated@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCognitoIdentityPoolRolesAttachmentRoles
    :: CognitoIdentityPoolRolesAttachmentRoles s
newCognitoIdentityPoolRolesAttachmentRoles =
    CognitoIdentityPoolRolesAttachmentRoles'
        { _authenticated = TF.Nil
        , _unauthenticated = TF.Nil
        }

instance P.Hashable  (CognitoIdentityPoolRolesAttachmentRoles s)
instance TF.IsValue  (CognitoIdentityPoolRolesAttachmentRoles s)
instance TF.IsObject (CognitoIdentityPoolRolesAttachmentRoles s) where
    toObject CognitoIdentityPoolRolesAttachmentRoles'{..} = P.catMaybes
        [ TF.assign "authenticated" <$> TF.attribute _authenticated
        , TF.assign "unauthenticated" <$> TF.attribute _unauthenticated
        ]

instance TF.IsValid (CognitoIdentityPoolRolesAttachmentRoles s) where
    validator = P.mempty

instance P.HasAuthenticated (CognitoIdentityPoolRolesAttachmentRoles s) (TF.Attr s P.Text) where
    authenticated =
        P.lens (_authenticated :: CognitoIdentityPoolRolesAttachmentRoles s -> TF.Attr s P.Text)
               (\s a -> s { _authenticated = a } :: CognitoIdentityPoolRolesAttachmentRoles s)

instance P.HasUnauthenticated (CognitoIdentityPoolRolesAttachmentRoles s) (TF.Attr s P.Text) where
    unauthenticated =
        P.lens (_unauthenticated :: CognitoIdentityPoolRolesAttachmentRoles s -> TF.Attr s P.Text)
               (\s a -> s { _unauthenticated = a } :: CognitoIdentityPoolRolesAttachmentRoles s)

-- | @rule_apply_server_side_encryption_by_default@ nested settings.
data RuleApplyServerSideEncryptionByDefault s = RuleApplyServerSideEncryptionByDefault'
    { _kmsMasterKeyId :: TF.Attr s P.Text
    -- ^ @kms_master_key_id@ - (Optional)
    --
    , _sseAlgorithm   :: TF.Attr s P.Text
    -- ^ @sse_algorithm@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRuleApplyServerSideEncryptionByDefault
    :: TF.Attr s P.Text -- ^ @sse_algorithm@ - 'P.sseAlgorithm'
    -> RuleApplyServerSideEncryptionByDefault s
newRuleApplyServerSideEncryptionByDefault _sseAlgorithm =
    RuleApplyServerSideEncryptionByDefault'
        { _kmsMasterKeyId = TF.Nil
        , _sseAlgorithm = _sseAlgorithm
        }

instance P.Hashable  (RuleApplyServerSideEncryptionByDefault s)
instance TF.IsValue  (RuleApplyServerSideEncryptionByDefault s)
instance TF.IsObject (RuleApplyServerSideEncryptionByDefault s) where
    toObject RuleApplyServerSideEncryptionByDefault'{..} = P.catMaybes
        [ TF.assign "kms_master_key_id" <$> TF.attribute _kmsMasterKeyId
        , TF.assign "sse_algorithm" <$> TF.attribute _sseAlgorithm
        ]

instance TF.IsValid (RuleApplyServerSideEncryptionByDefault s) where
    validator = P.mempty

instance P.HasKmsMasterKeyId (RuleApplyServerSideEncryptionByDefault s) (TF.Attr s P.Text) where
    kmsMasterKeyId =
        P.lens (_kmsMasterKeyId :: RuleApplyServerSideEncryptionByDefault s -> TF.Attr s P.Text)
               (\s a -> s { _kmsMasterKeyId = a } :: RuleApplyServerSideEncryptionByDefault s)

instance P.HasSseAlgorithm (RuleApplyServerSideEncryptionByDefault s) (TF.Attr s P.Text) where
    sseAlgorithm =
        P.lens (_sseAlgorithm :: RuleApplyServerSideEncryptionByDefault s -> TF.Attr s P.Text)
               (\s a -> s { _sseAlgorithm = a } :: RuleApplyServerSideEncryptionByDefault s)

-- | @step_hadoop_jar_step@ nested settings.
data StepHadoopJarStep s = StepHadoopJarStep'
    { _args       :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @args@ - (Optional, Forces New)
    --
    , _jar        :: TF.Attr s P.Text
    -- ^ @jar@ - (Required, Forces New)
    --
    , _mainClass  :: TF.Attr s P.Text
    -- ^ @main_class@ - (Optional, Forces New)
    --
    , _properties :: TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))
    -- ^ @properties@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newStepHadoopJarStep
    :: TF.Attr s P.Text -- ^ @jar@ - 'P.jar'
    -> StepHadoopJarStep s
newStepHadoopJarStep _jar =
    StepHadoopJarStep'
        { _args = TF.Nil
        , _jar = _jar
        , _mainClass = TF.Nil
        , _properties = TF.Nil
        }

instance P.Hashable  (StepHadoopJarStep s)
instance TF.IsValue  (StepHadoopJarStep s)
instance TF.IsObject (StepHadoopJarStep s) where
    toObject StepHadoopJarStep'{..} = P.catMaybes
        [ TF.assign "args" <$> TF.attribute _args
        , TF.assign "jar" <$> TF.attribute _jar
        , TF.assign "main_class" <$> TF.attribute _mainClass
        , TF.assign "properties" <$> TF.attribute _properties
        ]

instance TF.IsValid (StepHadoopJarStep s) where
    validator = P.mempty

instance P.HasArgs (StepHadoopJarStep s) (TF.Attr s [TF.Attr s P.Text]) where
    args =
        P.lens (_args :: StepHadoopJarStep s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _args = a } :: StepHadoopJarStep s)

instance P.HasJar (StepHadoopJarStep s) (TF.Attr s P.Text) where
    jar =
        P.lens (_jar :: StepHadoopJarStep s -> TF.Attr s P.Text)
               (\s a -> s { _jar = a } :: StepHadoopJarStep s)

instance P.HasMainClass (StepHadoopJarStep s) (TF.Attr s P.Text) where
    mainClass =
        P.lens (_mainClass :: StepHadoopJarStep s -> TF.Attr s P.Text)
               (\s a -> s { _mainClass = a } :: StepHadoopJarStep s)

instance P.HasProperties (StepHadoopJarStep s) (TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))) where
    properties =
        P.lens (_properties :: StepHadoopJarStep s -> TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text)))
               (\s a -> s { _properties = a } :: StepHadoopJarStep s)

-- | @lifecycle_rule_noncurrent_version_transition@ nested settings.
data LifecycleRuleNoncurrentVersionTransition s = LifecycleRuleNoncurrentVersionTransition'
    { _days         :: TF.Attr s P.Integer
    -- ^ @days@ - (Optional)
    --
    , _storageClass :: TF.Attr s P.Text
    -- ^ @storage_class@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLifecycleRuleNoncurrentVersionTransition
    :: TF.Attr s P.Text -- ^ @storage_class@ - 'P.storageClass'
    -> LifecycleRuleNoncurrentVersionTransition s
newLifecycleRuleNoncurrentVersionTransition _storageClass =
    LifecycleRuleNoncurrentVersionTransition'
        { _days = TF.Nil
        , _storageClass = _storageClass
        }

instance P.Hashable  (LifecycleRuleNoncurrentVersionTransition s)
instance TF.IsValue  (LifecycleRuleNoncurrentVersionTransition s)
instance TF.IsObject (LifecycleRuleNoncurrentVersionTransition s) where
    toObject LifecycleRuleNoncurrentVersionTransition'{..} = P.catMaybes
        [ TF.assign "days" <$> TF.attribute _days
        , TF.assign "storage_class" <$> TF.attribute _storageClass
        ]

instance TF.IsValid (LifecycleRuleNoncurrentVersionTransition s) where
    validator = P.mempty

instance P.HasDays (LifecycleRuleNoncurrentVersionTransition s) (TF.Attr s P.Integer) where
    days =
        P.lens (_days :: LifecycleRuleNoncurrentVersionTransition s -> TF.Attr s P.Integer)
               (\s a -> s { _days = a } :: LifecycleRuleNoncurrentVersionTransition s)

instance P.HasStorageClass (LifecycleRuleNoncurrentVersionTransition s) (TF.Attr s P.Text) where
    storageClass =
        P.lens (_storageClass :: LifecycleRuleNoncurrentVersionTransition s -> TF.Attr s P.Text)
               (\s a -> s { _storageClass = a } :: LifecycleRuleNoncurrentVersionTransition s)

-- | @ssm_resource_data_sync_s3_destination@ nested settings.
data SsmResourceDataSyncS3Destination s = SsmResourceDataSyncS3Destination'
    { _bucketName :: TF.Attr s P.Text
    -- ^ @bucket_name@ - (Required)
    --
    , _kmsKeyArn  :: TF.Attr s P.Text
    -- ^ @kms_key_arn@ - (Optional)
    --
    , _prefix     :: TF.Attr s P.Text
    -- ^ @prefix@ - (Optional)
    --
    , _region     :: TF.Attr s P.Text
    -- ^ @region@ - (Required)
    --
    , _syncFormat :: TF.Attr s P.Text
    -- ^ @sync_format@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSsmResourceDataSyncS3Destination
    :: TF.Attr s P.Text -- ^ @bucket_name@ - 'P.bucketName'
    -> TF.Attr s P.Text -- ^ @region@ - 'P.region'
    -> SsmResourceDataSyncS3Destination s
newSsmResourceDataSyncS3Destination _bucketName _region =
    SsmResourceDataSyncS3Destination'
        { _bucketName = _bucketName
        , _kmsKeyArn = TF.Nil
        , _prefix = TF.Nil
        , _region = _region
        , _syncFormat = TF.value "JsonSerDe"
        }

instance P.Hashable  (SsmResourceDataSyncS3Destination s)
instance TF.IsValue  (SsmResourceDataSyncS3Destination s)
instance TF.IsObject (SsmResourceDataSyncS3Destination s) where
    toObject SsmResourceDataSyncS3Destination'{..} = P.catMaybes
        [ TF.assign "bucket_name" <$> TF.attribute _bucketName
        , TF.assign "kms_key_arn" <$> TF.attribute _kmsKeyArn
        , TF.assign "prefix" <$> TF.attribute _prefix
        , TF.assign "region" <$> TF.attribute _region
        , TF.assign "sync_format" <$> TF.attribute _syncFormat
        ]

instance TF.IsValid (SsmResourceDataSyncS3Destination s) where
    validator = P.mempty

instance P.HasBucketName (SsmResourceDataSyncS3Destination s) (TF.Attr s P.Text) where
    bucketName =
        P.lens (_bucketName :: SsmResourceDataSyncS3Destination s -> TF.Attr s P.Text)
               (\s a -> s { _bucketName = a } :: SsmResourceDataSyncS3Destination s)

instance P.HasKmsKeyArn (SsmResourceDataSyncS3Destination s) (TF.Attr s P.Text) where
    kmsKeyArn =
        P.lens (_kmsKeyArn :: SsmResourceDataSyncS3Destination s -> TF.Attr s P.Text)
               (\s a -> s { _kmsKeyArn = a } :: SsmResourceDataSyncS3Destination s)

instance P.HasPrefix (SsmResourceDataSyncS3Destination s) (TF.Attr s P.Text) where
    prefix =
        P.lens (_prefix :: SsmResourceDataSyncS3Destination s -> TF.Attr s P.Text)
               (\s a -> s { _prefix = a } :: SsmResourceDataSyncS3Destination s)

instance P.HasRegion (SsmResourceDataSyncS3Destination s) (TF.Attr s P.Text) where
    region =
        P.lens (_region :: SsmResourceDataSyncS3Destination s -> TF.Attr s P.Text)
               (\s a -> s { _region = a } :: SsmResourceDataSyncS3Destination s)

instance P.HasSyncFormat (SsmResourceDataSyncS3Destination s) (TF.Attr s P.Text) where
    syncFormat =
        P.lens (_syncFormat :: SsmResourceDataSyncS3Destination s -> TF.Attr s P.Text)
               (\s a -> s { _syncFormat = a } :: SsmResourceDataSyncS3Destination s)

-- | @appautoscaling_policy_step_scaling_policy_configuration@ nested settings.
data AppautoscalingPolicyStepScalingPolicyConfiguration s = AppautoscalingPolicyStepScalingPolicyConfiguration'
    { _adjustmentType :: TF.Attr s P.Text
    -- ^ @adjustment_type@ - (Optional)
    --
    , _cooldown :: TF.Attr s P.Integer
    -- ^ @cooldown@ - (Optional)
    --
    , _metricAggregationType :: TF.Attr s P.Text
    -- ^ @metric_aggregation_type@ - (Optional)
    --
    , _minAdjustmentMagnitude :: TF.Attr s P.Integer
    -- ^ @min_adjustment_magnitude@ - (Optional)
    --
    , _stepAdjustment :: TF.Attr s [TF.Attr s (StepScalingPolicyConfigurationStepAdjustment s)]
    -- ^ @step_adjustment@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAppautoscalingPolicyStepScalingPolicyConfiguration
    :: AppautoscalingPolicyStepScalingPolicyConfiguration s
newAppautoscalingPolicyStepScalingPolicyConfiguration =
    AppautoscalingPolicyStepScalingPolicyConfiguration'
        { _adjustmentType = TF.Nil
        , _cooldown = TF.Nil
        , _metricAggregationType = TF.Nil
        , _minAdjustmentMagnitude = TF.Nil
        , _stepAdjustment = TF.Nil
        }

instance P.Hashable  (AppautoscalingPolicyStepScalingPolicyConfiguration s)
instance TF.IsValue  (AppautoscalingPolicyStepScalingPolicyConfiguration s)
instance TF.IsObject (AppautoscalingPolicyStepScalingPolicyConfiguration s) where
    toObject AppautoscalingPolicyStepScalingPolicyConfiguration'{..} = P.catMaybes
        [ TF.assign "adjustment_type" <$> TF.attribute _adjustmentType
        , TF.assign "cooldown" <$> TF.attribute _cooldown
        , TF.assign "metric_aggregation_type" <$> TF.attribute _metricAggregationType
        , TF.assign "min_adjustment_magnitude" <$> TF.attribute _minAdjustmentMagnitude
        , TF.assign "step_adjustment" <$> TF.attribute _stepAdjustment
        ]

instance TF.IsValid (AppautoscalingPolicyStepScalingPolicyConfiguration s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_stepAdjustment"
                  (_stepAdjustment
                      :: AppautoscalingPolicyStepScalingPolicyConfiguration s -> TF.Attr s [TF.Attr s (StepScalingPolicyConfigurationStepAdjustment s)])
                  TF.validator

instance P.HasAdjustmentType (AppautoscalingPolicyStepScalingPolicyConfiguration s) (TF.Attr s P.Text) where
    adjustmentType =
        P.lens (_adjustmentType :: AppautoscalingPolicyStepScalingPolicyConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _adjustmentType = a } :: AppautoscalingPolicyStepScalingPolicyConfiguration s)

instance P.HasCooldown (AppautoscalingPolicyStepScalingPolicyConfiguration s) (TF.Attr s P.Integer) where
    cooldown =
        P.lens (_cooldown :: AppautoscalingPolicyStepScalingPolicyConfiguration s -> TF.Attr s P.Integer)
               (\s a -> s { _cooldown = a } :: AppautoscalingPolicyStepScalingPolicyConfiguration s)

instance P.HasMetricAggregationType (AppautoscalingPolicyStepScalingPolicyConfiguration s) (TF.Attr s P.Text) where
    metricAggregationType =
        P.lens (_metricAggregationType :: AppautoscalingPolicyStepScalingPolicyConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _metricAggregationType = a } :: AppautoscalingPolicyStepScalingPolicyConfiguration s)

instance P.HasMinAdjustmentMagnitude (AppautoscalingPolicyStepScalingPolicyConfiguration s) (TF.Attr s P.Integer) where
    minAdjustmentMagnitude =
        P.lens (_minAdjustmentMagnitude :: AppautoscalingPolicyStepScalingPolicyConfiguration s -> TF.Attr s P.Integer)
               (\s a -> s { _minAdjustmentMagnitude = a } :: AppautoscalingPolicyStepScalingPolicyConfiguration s)

instance P.HasStepAdjustment (AppautoscalingPolicyStepScalingPolicyConfiguration s) (TF.Attr s [TF.Attr s (StepScalingPolicyConfigurationStepAdjustment s)]) where
    stepAdjustment =
        P.lens (_stepAdjustment :: AppautoscalingPolicyStepScalingPolicyConfiguration s -> TF.Attr s [TF.Attr s (StepScalingPolicyConfigurationStepAdjustment s)])
               (\s a -> s { _stepAdjustment = a } :: AppautoscalingPolicyStepScalingPolicyConfiguration s)

-- | @alb_listener_default_action@ nested settings.
data AlbListenerDefaultAction s = AlbListenerDefaultAction'
    { _targetGroupArn :: TF.Attr s P.Text
    -- ^ @target_group_arn@ - (Required)
    --
    , _type'          :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAlbListenerDefaultAction
    :: TF.Attr s P.Text -- ^ @target_group_arn@ - 'P.targetGroupArn'
    -> TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> AlbListenerDefaultAction s
newAlbListenerDefaultAction _targetGroupArn _type' =
    AlbListenerDefaultAction'
        { _targetGroupArn = _targetGroupArn
        , _type' = _type'
        }

instance P.Hashable  (AlbListenerDefaultAction s)
instance TF.IsValue  (AlbListenerDefaultAction s)
instance TF.IsObject (AlbListenerDefaultAction s) where
    toObject AlbListenerDefaultAction'{..} = P.catMaybes
        [ TF.assign "target_group_arn" <$> TF.attribute _targetGroupArn
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (AlbListenerDefaultAction s) where
    validator = P.mempty

instance P.HasTargetGroupArn (AlbListenerDefaultAction s) (TF.Attr s P.Text) where
    targetGroupArn =
        P.lens (_targetGroupArn :: AlbListenerDefaultAction s -> TF.Attr s P.Text)
               (\s a -> s { _targetGroupArn = a } :: AlbListenerDefaultAction s)

instance P.HasType' (AlbListenerDefaultAction s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: AlbListenerDefaultAction s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: AlbListenerDefaultAction s)

instance s ~ s' => P.HasComputedTargetGroupArn (TF.Ref s' (AlbListenerDefaultAction s)) (TF.Attr s P.Text) where
    computedTargetGroupArn x = TF.compute (TF.refKey x) "target_group_arn"

instance s ~ s' => P.HasComputedType (TF.Ref s' (AlbListenerDefaultAction s)) (TF.Attr s P.Text) where
    computedType x = TF.compute (TF.refKey x) "type"

-- | @elasticsearch_domain_cognito_options@ nested settings.
data ElasticsearchDomainCognitoOptions s = ElasticsearchDomainCognitoOptions'
    { _enabled        :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Optional)
    --
    , _identityPoolId :: TF.Attr s P.Text
    -- ^ @identity_pool_id@ - (Required)
    --
    , _roleArn        :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Required)
    --
    , _userPoolId     :: TF.Attr s P.Text
    -- ^ @user_pool_id@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElasticsearchDomainCognitoOptions
    :: TF.Attr s P.Text -- ^ @identity_pool_id@ - 'P.identityPoolId'
    -> TF.Attr s P.Text -- ^ @role_arn@ - 'P.roleArn'
    -> TF.Attr s P.Text -- ^ @user_pool_id@ - 'P.userPoolId'
    -> ElasticsearchDomainCognitoOptions s
newElasticsearchDomainCognitoOptions _identityPoolId _roleArn _userPoolId =
    ElasticsearchDomainCognitoOptions'
        { _enabled = TF.value P.False
        , _identityPoolId = _identityPoolId
        , _roleArn = _roleArn
        , _userPoolId = _userPoolId
        }

instance P.Hashable  (ElasticsearchDomainCognitoOptions s)
instance TF.IsValue  (ElasticsearchDomainCognitoOptions s)
instance TF.IsObject (ElasticsearchDomainCognitoOptions s) where
    toObject ElasticsearchDomainCognitoOptions'{..} = P.catMaybes
        [ TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "identity_pool_id" <$> TF.attribute _identityPoolId
        , TF.assign "role_arn" <$> TF.attribute _roleArn
        , TF.assign "user_pool_id" <$> TF.attribute _userPoolId
        ]

instance TF.IsValid (ElasticsearchDomainCognitoOptions s) where
    validator = P.mempty

instance P.HasEnabled (ElasticsearchDomainCognitoOptions s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: ElasticsearchDomainCognitoOptions s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: ElasticsearchDomainCognitoOptions s)

instance P.HasIdentityPoolId (ElasticsearchDomainCognitoOptions s) (TF.Attr s P.Text) where
    identityPoolId =
        P.lens (_identityPoolId :: ElasticsearchDomainCognitoOptions s -> TF.Attr s P.Text)
               (\s a -> s { _identityPoolId = a } :: ElasticsearchDomainCognitoOptions s)

instance P.HasRoleArn (ElasticsearchDomainCognitoOptions s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: ElasticsearchDomainCognitoOptions s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: ElasticsearchDomainCognitoOptions s)

instance P.HasUserPoolId (ElasticsearchDomainCognitoOptions s) (TF.Attr s P.Text) where
    userPoolId =
        P.lens (_userPoolId :: ElasticsearchDomainCognitoOptions s -> TF.Attr s P.Text)
               (\s a -> s { _userPoolId = a } :: ElasticsearchDomainCognitoOptions s)

-- | @lb_target_group_stickiness@ nested settings.
data LbTargetGroupStickiness s = LbTargetGroupStickiness'
    { _cookieDuration :: TF.Attr s P.Integer
    -- ^ @cookie_duration@ - (Optional)
    --
    , _enabled        :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Optional)
    --
    , _type'          :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLbTargetGroupStickiness
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> LbTargetGroupStickiness s
newLbTargetGroupStickiness _type' =
    LbTargetGroupStickiness'
        { _cookieDuration = TF.value 86400
        , _enabled = TF.value P.True
        , _type' = _type'
        }

instance P.Hashable  (LbTargetGroupStickiness s)
instance TF.IsValue  (LbTargetGroupStickiness s)
instance TF.IsObject (LbTargetGroupStickiness s) where
    toObject LbTargetGroupStickiness'{..} = P.catMaybes
        [ TF.assign "cookie_duration" <$> TF.attribute _cookieDuration
        , TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (LbTargetGroupStickiness s) where
    validator = P.mempty

instance P.HasCookieDuration (LbTargetGroupStickiness s) (TF.Attr s P.Integer) where
    cookieDuration =
        P.lens (_cookieDuration :: LbTargetGroupStickiness s -> TF.Attr s P.Integer)
               (\s a -> s { _cookieDuration = a } :: LbTargetGroupStickiness s)

instance P.HasEnabled (LbTargetGroupStickiness s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: LbTargetGroupStickiness s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: LbTargetGroupStickiness s)

instance P.HasType' (LbTargetGroupStickiness s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: LbTargetGroupStickiness s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: LbTargetGroupStickiness s)

instance s ~ s' => P.HasComputedCookieDuration (TF.Ref s' (LbTargetGroupStickiness s)) (TF.Attr s P.Integer) where
    computedCookieDuration x = TF.compute (TF.refKey x) "cookie_duration"

instance s ~ s' => P.HasComputedEnabled (TF.Ref s' (LbTargetGroupStickiness s)) (TF.Attr s P.Bool) where
    computedEnabled x = TF.compute (TF.refKey x) "enabled"

instance s ~ s' => P.HasComputedType (TF.Ref s' (LbTargetGroupStickiness s)) (TF.Attr s P.Text) where
    computedType x = TF.compute (TF.refKey x) "type"

-- | @codebuild_project_environment@ nested settings.
data CodebuildProjectEnvironment s = CodebuildProjectEnvironment'
    { _computeType    :: TF.Attr s P.Text
    -- ^ @compute_type@ - (Required)
    --
    , _image          :: TF.Attr s P.Text
    -- ^ @image@ - (Required)
    --
    , _privilegedMode :: TF.Attr s P.Bool
    -- ^ @privileged_mode@ - (Optional)
    --
    , _type'          :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCodebuildProjectEnvironment
    :: TF.Attr s P.Text -- ^ @compute_type@ - 'P.computeType'
    -> TF.Attr s P.Text -- ^ @image@ - 'P.image'
    -> TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> CodebuildProjectEnvironment s
newCodebuildProjectEnvironment _computeType _image _type' =
    CodebuildProjectEnvironment'
        { _computeType = _computeType
        , _image = _image
        , _privilegedMode = TF.value P.False
        , _type' = _type'
        }

instance P.Hashable  (CodebuildProjectEnvironment s)
instance TF.IsValue  (CodebuildProjectEnvironment s)
instance TF.IsObject (CodebuildProjectEnvironment s) where
    toObject CodebuildProjectEnvironment'{..} = P.catMaybes
        [ TF.assign "compute_type" <$> TF.attribute _computeType
        , TF.assign "image" <$> TF.attribute _image
        , TF.assign "privileged_mode" <$> TF.attribute _privilegedMode
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (CodebuildProjectEnvironment s) where
    validator = P.mempty

instance P.HasComputeType (CodebuildProjectEnvironment s) (TF.Attr s P.Text) where
    computeType =
        P.lens (_computeType :: CodebuildProjectEnvironment s -> TF.Attr s P.Text)
               (\s a -> s { _computeType = a } :: CodebuildProjectEnvironment s)

instance P.HasImage (CodebuildProjectEnvironment s) (TF.Attr s P.Text) where
    image =
        P.lens (_image :: CodebuildProjectEnvironment s -> TF.Attr s P.Text)
               (\s a -> s { _image = a } :: CodebuildProjectEnvironment s)

instance P.HasPrivilegedMode (CodebuildProjectEnvironment s) (TF.Attr s P.Bool) where
    privilegedMode =
        P.lens (_privilegedMode :: CodebuildProjectEnvironment s -> TF.Attr s P.Bool)
               (\s a -> s { _privilegedMode = a } :: CodebuildProjectEnvironment s)

instance P.HasType' (CodebuildProjectEnvironment s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: CodebuildProjectEnvironment s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: CodebuildProjectEnvironment s)

instance s ~ s' => P.HasComputedEnvironmentVariable (TF.Ref s' (CodebuildProjectEnvironment s)) (TF.Attr s [TF.Attr s (EnvironmentEnvironmentVariable s)]) where
    computedEnvironmentVariable x = TF.compute (TF.refKey x) "environment_variable"

-- | @ssm_maintenance_window_task_logging_info@ nested settings.
data SsmMaintenanceWindowTaskLoggingInfo s = SsmMaintenanceWindowTaskLoggingInfo'
    { _s3BucketName   :: TF.Attr s P.Text
    -- ^ @s3_bucket_name@ - (Required)
    --
    , _s3BucketPrefix :: TF.Attr s P.Text
    -- ^ @s3_bucket_prefix@ - (Optional)
    --
    , _s3Region       :: TF.Attr s P.Text
    -- ^ @s3_region@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSsmMaintenanceWindowTaskLoggingInfo
    :: TF.Attr s P.Text -- ^ @s3_bucket_name@ - 'P.s3BucketName'
    -> TF.Attr s P.Text -- ^ @s3_region@ - 'P.s3Region'
    -> SsmMaintenanceWindowTaskLoggingInfo s
newSsmMaintenanceWindowTaskLoggingInfo _s3BucketName _s3Region =
    SsmMaintenanceWindowTaskLoggingInfo'
        { _s3BucketName = _s3BucketName
        , _s3BucketPrefix = TF.Nil
        , _s3Region = _s3Region
        }

instance P.Hashable  (SsmMaintenanceWindowTaskLoggingInfo s)
instance TF.IsValue  (SsmMaintenanceWindowTaskLoggingInfo s)
instance TF.IsObject (SsmMaintenanceWindowTaskLoggingInfo s) where
    toObject SsmMaintenanceWindowTaskLoggingInfo'{..} = P.catMaybes
        [ TF.assign "s3_bucket_name" <$> TF.attribute _s3BucketName
        , TF.assign "s3_bucket_prefix" <$> TF.attribute _s3BucketPrefix
        , TF.assign "s3_region" <$> TF.attribute _s3Region
        ]

instance TF.IsValid (SsmMaintenanceWindowTaskLoggingInfo s) where
    validator = P.mempty

instance P.HasS3BucketName (SsmMaintenanceWindowTaskLoggingInfo s) (TF.Attr s P.Text) where
    s3BucketName =
        P.lens (_s3BucketName :: SsmMaintenanceWindowTaskLoggingInfo s -> TF.Attr s P.Text)
               (\s a -> s { _s3BucketName = a } :: SsmMaintenanceWindowTaskLoggingInfo s)

instance P.HasS3BucketPrefix (SsmMaintenanceWindowTaskLoggingInfo s) (TF.Attr s P.Text) where
    s3BucketPrefix =
        P.lens (_s3BucketPrefix :: SsmMaintenanceWindowTaskLoggingInfo s -> TF.Attr s P.Text)
               (\s a -> s { _s3BucketPrefix = a } :: SsmMaintenanceWindowTaskLoggingInfo s)

instance P.HasS3Region (SsmMaintenanceWindowTaskLoggingInfo s) (TF.Attr s P.Text) where
    s3Region =
        P.lens (_s3Region :: SsmMaintenanceWindowTaskLoggingInfo s -> TF.Attr s P.Text)
               (\s a -> s { _s3Region = a } :: SsmMaintenanceWindowTaskLoggingInfo s)

-- | @config_delivery_channel_snapshot_delivery_properties@ nested settings.
data ConfigDeliveryChannelSnapshotDeliveryProperties s = ConfigDeliveryChannelSnapshotDeliveryProperties'
    { _deliveryFrequency :: TF.Attr s P.Text
    -- ^ @delivery_frequency@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newConfigDeliveryChannelSnapshotDeliveryProperties
    :: ConfigDeliveryChannelSnapshotDeliveryProperties s
newConfigDeliveryChannelSnapshotDeliveryProperties =
    ConfigDeliveryChannelSnapshotDeliveryProperties'
        { _deliveryFrequency = TF.Nil
        }

instance P.Hashable  (ConfigDeliveryChannelSnapshotDeliveryProperties s)
instance TF.IsValue  (ConfigDeliveryChannelSnapshotDeliveryProperties s)
instance TF.IsObject (ConfigDeliveryChannelSnapshotDeliveryProperties s) where
    toObject ConfigDeliveryChannelSnapshotDeliveryProperties'{..} = P.catMaybes
        [ TF.assign "delivery_frequency" <$> TF.attribute _deliveryFrequency
        ]

instance TF.IsValid (ConfigDeliveryChannelSnapshotDeliveryProperties s) where
    validator = P.mempty

instance P.HasDeliveryFrequency (ConfigDeliveryChannelSnapshotDeliveryProperties s) (TF.Attr s P.Text) where
    deliveryFrequency =
        P.lens (_deliveryFrequency :: ConfigDeliveryChannelSnapshotDeliveryProperties s -> TF.Attr s P.Text)
               (\s a -> s { _deliveryFrequency = a } :: ConfigDeliveryChannelSnapshotDeliveryProperties s)

-- | @elastictranscoder_pipeline_thumbnail_config@ nested settings.
data ElastictranscoderPipelineThumbnailConfig s = ElastictranscoderPipelineThumbnailConfig'
    { _storageClass :: TF.Attr s P.Text
    -- ^ @storage_class@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElastictranscoderPipelineThumbnailConfig
    :: ElastictranscoderPipelineThumbnailConfig s
newElastictranscoderPipelineThumbnailConfig =
    ElastictranscoderPipelineThumbnailConfig'
        { _storageClass = TF.Nil
        }

instance P.Hashable  (ElastictranscoderPipelineThumbnailConfig s)
instance TF.IsValue  (ElastictranscoderPipelineThumbnailConfig s)
instance TF.IsObject (ElastictranscoderPipelineThumbnailConfig s) where
    toObject ElastictranscoderPipelineThumbnailConfig'{..} = P.catMaybes
        [ TF.assign "storage_class" <$> TF.attribute _storageClass
        ]

instance TF.IsValid (ElastictranscoderPipelineThumbnailConfig s) where
    validator = P.mempty

instance P.HasStorageClass (ElastictranscoderPipelineThumbnailConfig s) (TF.Attr s P.Text) where
    storageClass =
        P.lens (_storageClass :: ElastictranscoderPipelineThumbnailConfig s -> TF.Attr s P.Text)
               (\s a -> s { _storageClass = a } :: ElastictranscoderPipelineThumbnailConfig s)

instance s ~ s' => P.HasComputedBucket (TF.Ref s' (ElastictranscoderPipelineThumbnailConfig s)) (TF.Attr s P.Text) where
    computedBucket x = TF.compute (TF.refKey x) "bucket"

-- | @ami_ids_filter@ nested settings.
data AmiIdsFilter s = AmiIdsFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAmiIdsFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> AmiIdsFilter s
newAmiIdsFilter _name _values =
    AmiIdsFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (AmiIdsFilter s)
instance TF.IsValue  (AmiIdsFilter s)
instance TF.IsObject (AmiIdsFilter s) where
    toObject AmiIdsFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (AmiIdsFilter s) where
    validator = P.mempty

instance P.HasName (AmiIdsFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: AmiIdsFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: AmiIdsFilter s)

instance P.HasValues (AmiIdsFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: AmiIdsFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: AmiIdsFilter s)

-- | @codedeploy_deployment_group_load_balancer_info@ nested settings.
data CodedeployDeploymentGroupLoadBalancerInfo s = CodedeployDeploymentGroupLoadBalancerInfo'
    { _elbInfo :: TF.Attr s [TF.Attr s (LoadBalancerInfoElbInfo s)]
    -- ^ @elb_info@ - (Optional)
    --
    , _targetGroupInfo :: TF.Attr s [TF.Attr s (LoadBalancerInfoTargetGroupInfo s)]
    -- ^ @target_group_info@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCodedeployDeploymentGroupLoadBalancerInfo
    :: CodedeployDeploymentGroupLoadBalancerInfo s
newCodedeployDeploymentGroupLoadBalancerInfo =
    CodedeployDeploymentGroupLoadBalancerInfo'
        { _elbInfo = TF.Nil
        , _targetGroupInfo = TF.Nil
        }

instance P.Hashable  (CodedeployDeploymentGroupLoadBalancerInfo s)
instance TF.IsValue  (CodedeployDeploymentGroupLoadBalancerInfo s)
instance TF.IsObject (CodedeployDeploymentGroupLoadBalancerInfo s) where
    toObject CodedeployDeploymentGroupLoadBalancerInfo'{..} = P.catMaybes
        [ TF.assign "elb_info" <$> TF.attribute _elbInfo
        , TF.assign "target_group_info" <$> TF.attribute _targetGroupInfo
        ]

instance TF.IsValid (CodedeployDeploymentGroupLoadBalancerInfo s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_elbInfo"
                  (_elbInfo
                      :: CodedeployDeploymentGroupLoadBalancerInfo s -> TF.Attr s [TF.Attr s (LoadBalancerInfoElbInfo s)])
                  TF.validator
           P.<> TF.settingsValidator "_targetGroupInfo"
                  (_targetGroupInfo
                      :: CodedeployDeploymentGroupLoadBalancerInfo s -> TF.Attr s [TF.Attr s (LoadBalancerInfoTargetGroupInfo s)])
                  TF.validator

instance P.HasElbInfo (CodedeployDeploymentGroupLoadBalancerInfo s) (TF.Attr s [TF.Attr s (LoadBalancerInfoElbInfo s)]) where
    elbInfo =
        P.lens (_elbInfo :: CodedeployDeploymentGroupLoadBalancerInfo s -> TF.Attr s [TF.Attr s (LoadBalancerInfoElbInfo s)])
               (\s a -> s { _elbInfo = a } :: CodedeployDeploymentGroupLoadBalancerInfo s)

instance P.HasTargetGroupInfo (CodedeployDeploymentGroupLoadBalancerInfo s) (TF.Attr s [TF.Attr s (LoadBalancerInfoTargetGroupInfo s)]) where
    targetGroupInfo =
        P.lens (_targetGroupInfo :: CodedeployDeploymentGroupLoadBalancerInfo s -> TF.Attr s [TF.Attr s (LoadBalancerInfoTargetGroupInfo s)])
               (\s a -> s { _targetGroupInfo = a } :: CodedeployDeploymentGroupLoadBalancerInfo s)

-- | @iot_topic_rule_sqs@ nested settings.
data IotTopicRuleSqs s = IotTopicRuleSqs'
    { _queueUrl  :: TF.Attr s P.Text
    -- ^ @queue_url@ - (Required)
    --
    , _roleArn   :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Required)
    --
    , _useBase64 :: TF.Attr s P.Bool
    -- ^ @use_base64@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newIotTopicRuleSqs
    :: TF.Attr s P.Text -- ^ @queue_url@ - 'P.queueUrl'
    -> TF.Attr s P.Text -- ^ @role_arn@ - 'P.roleArn'
    -> TF.Attr s P.Bool -- ^ @use_base64@ - 'P.useBase64'
    -> IotTopicRuleSqs s
newIotTopicRuleSqs _queueUrl _roleArn _useBase64 =
    IotTopicRuleSqs'
        { _queueUrl = _queueUrl
        , _roleArn = _roleArn
        , _useBase64 = _useBase64
        }

instance P.Hashable  (IotTopicRuleSqs s)
instance TF.IsValue  (IotTopicRuleSqs s)
instance TF.IsObject (IotTopicRuleSqs s) where
    toObject IotTopicRuleSqs'{..} = P.catMaybes
        [ TF.assign "queue_url" <$> TF.attribute _queueUrl
        , TF.assign "role_arn" <$> TF.attribute _roleArn
        , TF.assign "use_base64" <$> TF.attribute _useBase64
        ]

instance TF.IsValid (IotTopicRuleSqs s) where
    validator = P.mempty

instance P.HasQueueUrl (IotTopicRuleSqs s) (TF.Attr s P.Text) where
    queueUrl =
        P.lens (_queueUrl :: IotTopicRuleSqs s -> TF.Attr s P.Text)
               (\s a -> s { _queueUrl = a } :: IotTopicRuleSqs s)

instance P.HasRoleArn (IotTopicRuleSqs s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: IotTopicRuleSqs s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: IotTopicRuleSqs s)

instance P.HasUseBase64 (IotTopicRuleSqs s) (TF.Attr s P.Bool) where
    useBase64 =
        P.lens (_useBase64 :: IotTopicRuleSqs s -> TF.Attr s P.Bool)
               (\s a -> s { _useBase64 = a } :: IotTopicRuleSqs s)

-- | @redshift_parameter_group_parameter@ nested settings.
data RedshiftParameterGroupParameter s = RedshiftParameterGroupParameter'
    { _name  :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _value :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRedshiftParameterGroupParameter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> RedshiftParameterGroupParameter s
newRedshiftParameterGroupParameter _name _value =
    RedshiftParameterGroupParameter'
        { _name = _name
        , _value = _value
        }

instance P.Hashable  (RedshiftParameterGroupParameter s)
instance TF.IsValue  (RedshiftParameterGroupParameter s)
instance TF.IsObject (RedshiftParameterGroupParameter s) where
    toObject RedshiftParameterGroupParameter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (RedshiftParameterGroupParameter s) where
    validator = P.mempty

instance P.HasName (RedshiftParameterGroupParameter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: RedshiftParameterGroupParameter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: RedshiftParameterGroupParameter s)

instance P.HasValue (RedshiftParameterGroupParameter s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: RedshiftParameterGroupParameter s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: RedshiftParameterGroupParameter s)

-- | @lifecycle_rule_expiration@ nested settings.
data LifecycleRuleExpiration s = LifecycleRuleExpiration'
    { _date                      :: TF.Attr s P.Text
    -- ^ @date@ - (Optional)
    --
    , _days                      :: TF.Attr s P.Integer
    -- ^ @days@ - (Optional)
    --
    , _expiredObjectDeleteMarker :: TF.Attr s P.Bool
    -- ^ @expired_object_delete_marker@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLifecycleRuleExpiration
    :: LifecycleRuleExpiration s
newLifecycleRuleExpiration =
    LifecycleRuleExpiration'
        { _date = TF.Nil
        , _days = TF.Nil
        , _expiredObjectDeleteMarker = TF.Nil
        }

instance P.Hashable  (LifecycleRuleExpiration s)
instance TF.IsValue  (LifecycleRuleExpiration s)
instance TF.IsObject (LifecycleRuleExpiration s) where
    toObject LifecycleRuleExpiration'{..} = P.catMaybes
        [ TF.assign "date" <$> TF.attribute _date
        , TF.assign "days" <$> TF.attribute _days
        , TF.assign "expired_object_delete_marker" <$> TF.attribute _expiredObjectDeleteMarker
        ]

instance TF.IsValid (LifecycleRuleExpiration s) where
    validator = P.mempty

instance P.HasDate (LifecycleRuleExpiration s) (TF.Attr s P.Text) where
    date =
        P.lens (_date :: LifecycleRuleExpiration s -> TF.Attr s P.Text)
               (\s a -> s { _date = a } :: LifecycleRuleExpiration s)

instance P.HasDays (LifecycleRuleExpiration s) (TF.Attr s P.Integer) where
    days =
        P.lens (_days :: LifecycleRuleExpiration s -> TF.Attr s P.Integer)
               (\s a -> s { _days = a } :: LifecycleRuleExpiration s)

instance P.HasExpiredObjectDeleteMarker (LifecycleRuleExpiration s) (TF.Attr s P.Bool) where
    expiredObjectDeleteMarker =
        P.lens (_expiredObjectDeleteMarker :: LifecycleRuleExpiration s -> TF.Attr s P.Bool)
               (\s a -> s { _expiredObjectDeleteMarker = a } :: LifecycleRuleExpiration s)

-- | @batch_job_queue_compute_environment_order@ nested settings.
data BatchJobQueueComputeEnvironmentOrder s = BatchJobQueueComputeEnvironmentOrder'
    deriving (P.Show, P.Eq, P.Generic)

newBatchJobQueueComputeEnvironmentOrder
    :: BatchJobQueueComputeEnvironmentOrder s
newBatchJobQueueComputeEnvironmentOrder =
    BatchJobQueueComputeEnvironmentOrder'

instance P.Hashable  (BatchJobQueueComputeEnvironmentOrder s)
instance TF.IsValue  (BatchJobQueueComputeEnvironmentOrder s)
instance TF.IsObject (BatchJobQueueComputeEnvironmentOrder s) where
    toObject BatchJobQueueComputeEnvironmentOrder' = []

instance TF.IsValid (BatchJobQueueComputeEnvironmentOrder s) where
    validator = P.mempty

instance s ~ s' => P.HasComputedComputeEnvironment (TF.Ref s' (BatchJobQueueComputeEnvironmentOrder s)) (TF.Attr s P.Text) where
    computedComputeEnvironment x = TF.compute (TF.refKey x) "compute_environment"

instance s ~ s' => P.HasComputedOrder (TF.Ref s' (BatchJobQueueComputeEnvironmentOrder s)) (TF.Attr s P.Integer) where
    computedOrder x = TF.compute (TF.refKey x) "order"

-- | @load_balancer_info_target_group_info@ nested settings.
data LoadBalancerInfoTargetGroupInfo s = LoadBalancerInfoTargetGroupInfo'
    { _name :: TF.Attr s P.Text
    -- ^ @name@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLoadBalancerInfoTargetGroupInfo
    :: LoadBalancerInfoTargetGroupInfo s
newLoadBalancerInfoTargetGroupInfo =
    LoadBalancerInfoTargetGroupInfo'
        { _name = TF.Nil
        }

instance P.Hashable  (LoadBalancerInfoTargetGroupInfo s)
instance TF.IsValue  (LoadBalancerInfoTargetGroupInfo s)
instance TF.IsObject (LoadBalancerInfoTargetGroupInfo s) where
    toObject LoadBalancerInfoTargetGroupInfo'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        ]

instance TF.IsValid (LoadBalancerInfoTargetGroupInfo s) where
    validator = P.mempty

instance P.HasName (LoadBalancerInfoTargetGroupInfo s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: LoadBalancerInfoTargetGroupInfo s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: LoadBalancerInfoTargetGroupInfo s)

-- | @elastic_beanstalk_application_appversion_lifecycle@ nested settings.
data ElasticBeanstalkApplicationAppversionLifecycle s = ElasticBeanstalkApplicationAppversionLifecycle'
    { _deleteSourceFromS3 :: TF.Attr s P.Bool
    -- ^ @delete_source_from_s3@ - (Optional)
    --
    , _maxAgeInDays       :: TF.Attr s P.Integer
    -- ^ @max_age_in_days@ - (Optional)
    --
    , _maxCount           :: TF.Attr s P.Integer
    -- ^ @max_count@ - (Optional)
    --
    , _serviceRole        :: TF.Attr s P.Text
    -- ^ @service_role@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElasticBeanstalkApplicationAppversionLifecycle
    :: TF.Attr s P.Text -- ^ @service_role@ - 'P.serviceRole'
    -> ElasticBeanstalkApplicationAppversionLifecycle s
newElasticBeanstalkApplicationAppversionLifecycle _serviceRole =
    ElasticBeanstalkApplicationAppversionLifecycle'
        { _deleteSourceFromS3 = TF.Nil
        , _maxAgeInDays = TF.Nil
        , _maxCount = TF.Nil
        , _serviceRole = _serviceRole
        }

instance P.Hashable  (ElasticBeanstalkApplicationAppversionLifecycle s)
instance TF.IsValue  (ElasticBeanstalkApplicationAppversionLifecycle s)
instance TF.IsObject (ElasticBeanstalkApplicationAppversionLifecycle s) where
    toObject ElasticBeanstalkApplicationAppversionLifecycle'{..} = P.catMaybes
        [ TF.assign "delete_source_from_s3" <$> TF.attribute _deleteSourceFromS3
        , TF.assign "max_age_in_days" <$> TF.attribute _maxAgeInDays
        , TF.assign "max_count" <$> TF.attribute _maxCount
        , TF.assign "service_role" <$> TF.attribute _serviceRole
        ]

instance TF.IsValid (ElasticBeanstalkApplicationAppversionLifecycle s) where
    validator = P.mempty

instance P.HasDeleteSourceFromS3 (ElasticBeanstalkApplicationAppversionLifecycle s) (TF.Attr s P.Bool) where
    deleteSourceFromS3 =
        P.lens (_deleteSourceFromS3 :: ElasticBeanstalkApplicationAppversionLifecycle s -> TF.Attr s P.Bool)
               (\s a -> s { _deleteSourceFromS3 = a } :: ElasticBeanstalkApplicationAppversionLifecycle s)

instance P.HasMaxAgeInDays (ElasticBeanstalkApplicationAppversionLifecycle s) (TF.Attr s P.Integer) where
    maxAgeInDays =
        P.lens (_maxAgeInDays :: ElasticBeanstalkApplicationAppversionLifecycle s -> TF.Attr s P.Integer)
               (\s a -> s { _maxAgeInDays = a } :: ElasticBeanstalkApplicationAppversionLifecycle s)

instance P.HasMaxCount (ElasticBeanstalkApplicationAppversionLifecycle s) (TF.Attr s P.Integer) where
    maxCount =
        P.lens (_maxCount :: ElasticBeanstalkApplicationAppversionLifecycle s -> TF.Attr s P.Integer)
               (\s a -> s { _maxCount = a } :: ElasticBeanstalkApplicationAppversionLifecycle s)

instance P.HasServiceRole (ElasticBeanstalkApplicationAppversionLifecycle s) (TF.Attr s P.Text) where
    serviceRole =
        P.lens (_serviceRole :: ElasticBeanstalkApplicationAppversionLifecycle s -> TF.Attr s P.Text)
               (\s a -> s { _serviceRole = a } :: ElasticBeanstalkApplicationAppversionLifecycle s)

-- | @glue_job_command@ nested settings.
data GlueJobCommand s = GlueJobCommand'
    { _name           :: TF.Attr s P.Text
    -- ^ @name@ - (Optional)
    --
    , _scriptLocation :: TF.Attr s P.Text
    -- ^ @script_location@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newGlueJobCommand
    :: TF.Attr s P.Text -- ^ @script_location@ - 'P.scriptLocation'
    -> GlueJobCommand s
newGlueJobCommand _scriptLocation =
    GlueJobCommand'
        { _name = TF.value "glueetl"
        , _scriptLocation = _scriptLocation
        }

instance P.Hashable  (GlueJobCommand s)
instance TF.IsValue  (GlueJobCommand s)
instance TF.IsObject (GlueJobCommand s) where
    toObject GlueJobCommand'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "script_location" <$> TF.attribute _scriptLocation
        ]

instance TF.IsValid (GlueJobCommand s) where
    validator = P.mempty

instance P.HasName (GlueJobCommand s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: GlueJobCommand s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: GlueJobCommand s)

instance P.HasScriptLocation (GlueJobCommand s) (TF.Attr s P.Text) where
    scriptLocation =
        P.lens (_scriptLocation :: GlueJobCommand s -> TF.Attr s P.Text)
               (\s a -> s { _scriptLocation = a } :: GlueJobCommand s)

-- | @dns_config_dns_records@ nested settings.
data DnsConfigDnsRecords s = DnsConfigDnsRecords'
    { _ttl   :: TF.Attr s P.Integer
    -- ^ @ttl@ - (Required)
    --
    , _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDnsConfigDnsRecords
    :: TF.Attr s P.Integer -- ^ @ttl@ - 'P.ttl'
    -> TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> DnsConfigDnsRecords s
newDnsConfigDnsRecords _ttl _type' =
    DnsConfigDnsRecords'
        { _ttl = _ttl
        , _type' = _type'
        }

instance P.Hashable  (DnsConfigDnsRecords s)
instance TF.IsValue  (DnsConfigDnsRecords s)
instance TF.IsObject (DnsConfigDnsRecords s) where
    toObject DnsConfigDnsRecords'{..} = P.catMaybes
        [ TF.assign "ttl" <$> TF.attribute _ttl
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (DnsConfigDnsRecords s) where
    validator = P.mempty

instance P.HasTtl (DnsConfigDnsRecords s) (TF.Attr s P.Integer) where
    ttl =
        P.lens (_ttl :: DnsConfigDnsRecords s -> TF.Attr s P.Integer)
               (\s a -> s { _ttl = a } :: DnsConfigDnsRecords s)

instance P.HasType' (DnsConfigDnsRecords s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: DnsConfigDnsRecords s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: DnsConfigDnsRecords s)

-- | @nat_gateway_filter@ nested settings.
data NatGatewayFilter s = NatGatewayFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newNatGatewayFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> NatGatewayFilter s
newNatGatewayFilter _name _values =
    NatGatewayFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (NatGatewayFilter s)
instance TF.IsValue  (NatGatewayFilter s)
instance TF.IsObject (NatGatewayFilter s) where
    toObject NatGatewayFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (NatGatewayFilter s) where
    validator = P.mempty

instance P.HasName (NatGatewayFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: NatGatewayFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: NatGatewayFilter s)

instance P.HasValues (NatGatewayFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: NatGatewayFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: NatGatewayFilter s)

-- | @codebuild_project_artifacts@ nested settings.
data CodebuildProjectArtifacts s = CodebuildProjectArtifacts'
    { _location      :: TF.Attr s P.Text
    -- ^ @location@ - (Optional)
    --
    , _name          :: TF.Attr s P.Text
    -- ^ @name@ - (Optional)
    --
    , _namespaceType :: TF.Attr s P.Text
    -- ^ @namespace_type@ - (Optional)
    --
    , _packaging     :: TF.Attr s P.Text
    -- ^ @packaging@ - (Optional)
    --
    , _path          :: TF.Attr s P.Text
    -- ^ @path@ - (Optional)
    --
    , _type'         :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCodebuildProjectArtifacts
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> CodebuildProjectArtifacts s
newCodebuildProjectArtifacts _type' =
    CodebuildProjectArtifacts'
        { _location = TF.Nil
        , _name = TF.Nil
        , _namespaceType = TF.Nil
        , _packaging = TF.Nil
        , _path = TF.Nil
        , _type' = _type'
        }

instance P.Hashable  (CodebuildProjectArtifacts s)
instance TF.IsValue  (CodebuildProjectArtifacts s)
instance TF.IsObject (CodebuildProjectArtifacts s) where
    toObject CodebuildProjectArtifacts'{..} = P.catMaybes
        [ TF.assign "location" <$> TF.attribute _location
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "namespace_type" <$> TF.attribute _namespaceType
        , TF.assign "packaging" <$> TF.attribute _packaging
        , TF.assign "path" <$> TF.attribute _path
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (CodebuildProjectArtifacts s) where
    validator = P.mempty

instance P.HasLocation (CodebuildProjectArtifacts s) (TF.Attr s P.Text) where
    location =
        P.lens (_location :: CodebuildProjectArtifacts s -> TF.Attr s P.Text)
               (\s a -> s { _location = a } :: CodebuildProjectArtifacts s)

instance P.HasName (CodebuildProjectArtifacts s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: CodebuildProjectArtifacts s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: CodebuildProjectArtifacts s)

instance P.HasNamespaceType (CodebuildProjectArtifacts s) (TF.Attr s P.Text) where
    namespaceType =
        P.lens (_namespaceType :: CodebuildProjectArtifacts s -> TF.Attr s P.Text)
               (\s a -> s { _namespaceType = a } :: CodebuildProjectArtifacts s)

instance P.HasPackaging (CodebuildProjectArtifacts s) (TF.Attr s P.Text) where
    packaging =
        P.lens (_packaging :: CodebuildProjectArtifacts s -> TF.Attr s P.Text)
               (\s a -> s { _packaging = a } :: CodebuildProjectArtifacts s)

instance P.HasPath (CodebuildProjectArtifacts s) (TF.Attr s P.Text) where
    path =
        P.lens (_path :: CodebuildProjectArtifacts s -> TF.Attr s P.Text)
               (\s a -> s { _path = a } :: CodebuildProjectArtifacts s)

instance P.HasType' (CodebuildProjectArtifacts s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: CodebuildProjectArtifacts s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: CodebuildProjectArtifacts s)

-- | @s3_configuration_cloudwatch_logging_options@ nested settings.
data S3ConfigurationCloudwatchLoggingOptions s = S3ConfigurationCloudwatchLoggingOptions'
    { _enabled       :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Optional)
    --
    , _logGroupName  :: TF.Attr s P.Text
    -- ^ @log_group_name@ - (Optional)
    --
    , _logStreamName :: TF.Attr s P.Text
    -- ^ @log_stream_name@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newS3ConfigurationCloudwatchLoggingOptions
    :: S3ConfigurationCloudwatchLoggingOptions s
newS3ConfigurationCloudwatchLoggingOptions =
    S3ConfigurationCloudwatchLoggingOptions'
        { _enabled = TF.value P.False
        , _logGroupName = TF.Nil
        , _logStreamName = TF.Nil
        }

instance P.Hashable  (S3ConfigurationCloudwatchLoggingOptions s)
instance TF.IsValue  (S3ConfigurationCloudwatchLoggingOptions s)
instance TF.IsObject (S3ConfigurationCloudwatchLoggingOptions s) where
    toObject S3ConfigurationCloudwatchLoggingOptions'{..} = P.catMaybes
        [ TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "log_group_name" <$> TF.attribute _logGroupName
        , TF.assign "log_stream_name" <$> TF.attribute _logStreamName
        ]

instance TF.IsValid (S3ConfigurationCloudwatchLoggingOptions s) where
    validator = P.mempty

instance P.HasEnabled (S3ConfigurationCloudwatchLoggingOptions s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: S3ConfigurationCloudwatchLoggingOptions s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: S3ConfigurationCloudwatchLoggingOptions s)

instance P.HasLogGroupName (S3ConfigurationCloudwatchLoggingOptions s) (TF.Attr s P.Text) where
    logGroupName =
        P.lens (_logGroupName :: S3ConfigurationCloudwatchLoggingOptions s -> TF.Attr s P.Text)
               (\s a -> s { _logGroupName = a } :: S3ConfigurationCloudwatchLoggingOptions s)

instance P.HasLogStreamName (S3ConfigurationCloudwatchLoggingOptions s) (TF.Attr s P.Text) where
    logStreamName =
        P.lens (_logStreamName :: S3ConfigurationCloudwatchLoggingOptions s -> TF.Attr s P.Text)
               (\s a -> s { _logStreamName = a } :: S3ConfigurationCloudwatchLoggingOptions s)

-- | @network_acls_filter@ nested settings.
data NetworkAclsFilter s = NetworkAclsFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newNetworkAclsFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> NetworkAclsFilter s
newNetworkAclsFilter _name _values =
    NetworkAclsFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (NetworkAclsFilter s)
instance TF.IsValue  (NetworkAclsFilter s)
instance TF.IsObject (NetworkAclsFilter s) where
    toObject NetworkAclsFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (NetworkAclsFilter s) where
    validator = P.mempty

instance P.HasName (NetworkAclsFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: NetworkAclsFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: NetworkAclsFilter s)

instance P.HasValues (NetworkAclsFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: NetworkAclsFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: NetworkAclsFilter s)

-- | @extended_s3_configuration_s3_backup_configuration@ nested settings.
data ExtendedS3ConfigurationS3BackupConfiguration s = ExtendedS3ConfigurationS3BackupConfiguration'
    { _bucketArn         :: TF.Attr s P.Text
    -- ^ @bucket_arn@ - (Required)
    --
    , _bufferInterval    :: TF.Attr s P.Integer
    -- ^ @buffer_interval@ - (Optional)
    --
    , _bufferSize        :: TF.Attr s P.Integer
    -- ^ @buffer_size@ - (Optional)
    --
    , _compressionFormat :: TF.Attr s P.Text
    -- ^ @compression_format@ - (Optional)
    --
    , _kmsKeyArn         :: TF.Attr s P.Text
    -- ^ @kms_key_arn@ - (Optional)
    --
    , _prefix            :: TF.Attr s P.Text
    -- ^ @prefix@ - (Optional)
    --
    , _roleArn           :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newExtendedS3ConfigurationS3BackupConfiguration
    :: TF.Attr s P.Text -- ^ @bucket_arn@ - 'P.bucketArn'
    -> TF.Attr s P.Text -- ^ @role_arn@ - 'P.roleArn'
    -> ExtendedS3ConfigurationS3BackupConfiguration s
newExtendedS3ConfigurationS3BackupConfiguration _bucketArn _roleArn =
    ExtendedS3ConfigurationS3BackupConfiguration'
        { _bucketArn = _bucketArn
        , _bufferInterval = TF.value 300
        , _bufferSize = TF.value 5
        , _compressionFormat = TF.value "UNCOMPRESSED"
        , _kmsKeyArn = TF.Nil
        , _prefix = TF.Nil
        , _roleArn = _roleArn
        }

instance P.Hashable  (ExtendedS3ConfigurationS3BackupConfiguration s)
instance TF.IsValue  (ExtendedS3ConfigurationS3BackupConfiguration s)
instance TF.IsObject (ExtendedS3ConfigurationS3BackupConfiguration s) where
    toObject ExtendedS3ConfigurationS3BackupConfiguration'{..} = P.catMaybes
        [ TF.assign "bucket_arn" <$> TF.attribute _bucketArn
        , TF.assign "buffer_interval" <$> TF.attribute _bufferInterval
        , TF.assign "buffer_size" <$> TF.attribute _bufferSize
        , TF.assign "compression_format" <$> TF.attribute _compressionFormat
        , TF.assign "kms_key_arn" <$> TF.attribute _kmsKeyArn
        , TF.assign "prefix" <$> TF.attribute _prefix
        , TF.assign "role_arn" <$> TF.attribute _roleArn
        ]

instance TF.IsValid (ExtendedS3ConfigurationS3BackupConfiguration s) where
    validator = P.mempty

instance P.HasBucketArn (ExtendedS3ConfigurationS3BackupConfiguration s) (TF.Attr s P.Text) where
    bucketArn =
        P.lens (_bucketArn :: ExtendedS3ConfigurationS3BackupConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _bucketArn = a } :: ExtendedS3ConfigurationS3BackupConfiguration s)

instance P.HasBufferInterval (ExtendedS3ConfigurationS3BackupConfiguration s) (TF.Attr s P.Integer) where
    bufferInterval =
        P.lens (_bufferInterval :: ExtendedS3ConfigurationS3BackupConfiguration s -> TF.Attr s P.Integer)
               (\s a -> s { _bufferInterval = a } :: ExtendedS3ConfigurationS3BackupConfiguration s)

instance P.HasBufferSize (ExtendedS3ConfigurationS3BackupConfiguration s) (TF.Attr s P.Integer) where
    bufferSize =
        P.lens (_bufferSize :: ExtendedS3ConfigurationS3BackupConfiguration s -> TF.Attr s P.Integer)
               (\s a -> s { _bufferSize = a } :: ExtendedS3ConfigurationS3BackupConfiguration s)

instance P.HasCompressionFormat (ExtendedS3ConfigurationS3BackupConfiguration s) (TF.Attr s P.Text) where
    compressionFormat =
        P.lens (_compressionFormat :: ExtendedS3ConfigurationS3BackupConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _compressionFormat = a } :: ExtendedS3ConfigurationS3BackupConfiguration s)

instance P.HasKmsKeyArn (ExtendedS3ConfigurationS3BackupConfiguration s) (TF.Attr s P.Text) where
    kmsKeyArn =
        P.lens (_kmsKeyArn :: ExtendedS3ConfigurationS3BackupConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _kmsKeyArn = a } :: ExtendedS3ConfigurationS3BackupConfiguration s)

instance P.HasPrefix (ExtendedS3ConfigurationS3BackupConfiguration s) (TF.Attr s P.Text) where
    prefix =
        P.lens (_prefix :: ExtendedS3ConfigurationS3BackupConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _prefix = a } :: ExtendedS3ConfigurationS3BackupConfiguration s)

instance P.HasRoleArn (ExtendedS3ConfigurationS3BackupConfiguration s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: ExtendedS3ConfigurationS3BackupConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: ExtendedS3ConfigurationS3BackupConfiguration s)

instance s ~ s' => P.HasComputedCloudwatchLoggingOptions (TF.Ref s' (ExtendedS3ConfigurationS3BackupConfiguration s)) (TF.Attr s (S3BackupConfigurationCloudwatchLoggingOptions s)) where
    computedCloudwatchLoggingOptions x = TF.compute (TF.refKey x) "cloudwatch_logging_options"

-- | @target_tracking_configuration_predefined_metric_specification@ nested settings.
data TargetTrackingConfigurationPredefinedMetricSpecification s = TargetTrackingConfigurationPredefinedMetricSpecification'
    { _predefinedMetricType :: TF.Attr s P.Text
    -- ^ @predefined_metric_type@ - (Required)
    --
    , _resourceLabel        :: TF.Attr s P.Text
    -- ^ @resource_label@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newTargetTrackingConfigurationPredefinedMetricSpecification
    :: TF.Attr s P.Text -- ^ @predefined_metric_type@ - 'P.predefinedMetricType'
    -> TargetTrackingConfigurationPredefinedMetricSpecification s
newTargetTrackingConfigurationPredefinedMetricSpecification _predefinedMetricType =
    TargetTrackingConfigurationPredefinedMetricSpecification'
        { _predefinedMetricType = _predefinedMetricType
        , _resourceLabel = TF.Nil
        }

instance P.Hashable  (TargetTrackingConfigurationPredefinedMetricSpecification s)
instance TF.IsValue  (TargetTrackingConfigurationPredefinedMetricSpecification s)
instance TF.IsObject (TargetTrackingConfigurationPredefinedMetricSpecification s) where
    toObject TargetTrackingConfigurationPredefinedMetricSpecification'{..} = P.catMaybes
        [ TF.assign "predefined_metric_type" <$> TF.attribute _predefinedMetricType
        , TF.assign "resource_label" <$> TF.attribute _resourceLabel
        ]

instance TF.IsValid (TargetTrackingConfigurationPredefinedMetricSpecification s) where
    validator = P.mempty

instance P.HasPredefinedMetricType (TargetTrackingConfigurationPredefinedMetricSpecification s) (TF.Attr s P.Text) where
    predefinedMetricType =
        P.lens (_predefinedMetricType :: TargetTrackingConfigurationPredefinedMetricSpecification s -> TF.Attr s P.Text)
               (\s a -> s { _predefinedMetricType = a } :: TargetTrackingConfigurationPredefinedMetricSpecification s)

instance P.HasResourceLabel (TargetTrackingConfigurationPredefinedMetricSpecification s) (TF.Attr s P.Text) where
    resourceLabel =
        P.lens (_resourceLabel :: TargetTrackingConfigurationPredefinedMetricSpecification s -> TF.Attr s P.Text)
               (\s a -> s { _resourceLabel = a } :: TargetTrackingConfigurationPredefinedMetricSpecification s)

-- | @codepipeline_artifact_store@ nested settings.
data CodepipelineArtifactStore s = CodepipelineArtifactStore'
    { _encryptionKey :: TF.Attr s (ArtifactStoreEncryptionKey s)
    -- ^ @encryption_key@ - (Optional)
    --
    , _location      :: TF.Attr s P.Text
    -- ^ @location@ - (Required)
    --
    , _type'         :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCodepipelineArtifactStore
    :: TF.Attr s P.Text -- ^ @location@ - 'P.location'
    -> TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> CodepipelineArtifactStore s
newCodepipelineArtifactStore _location _type' =
    CodepipelineArtifactStore'
        { _encryptionKey = TF.Nil
        , _location = _location
        , _type' = _type'
        }

instance P.Hashable  (CodepipelineArtifactStore s)
instance TF.IsValue  (CodepipelineArtifactStore s)
instance TF.IsObject (CodepipelineArtifactStore s) where
    toObject CodepipelineArtifactStore'{..} = P.catMaybes
        [ TF.assign "encryption_key" <$> TF.attribute _encryptionKey
        , TF.assign "location" <$> TF.attribute _location
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (CodepipelineArtifactStore s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_encryptionKey"
                  (_encryptionKey
                      :: CodepipelineArtifactStore s -> TF.Attr s (ArtifactStoreEncryptionKey s))
                  TF.validator

instance P.HasEncryptionKey (CodepipelineArtifactStore s) (TF.Attr s (ArtifactStoreEncryptionKey s)) where
    encryptionKey =
        P.lens (_encryptionKey :: CodepipelineArtifactStore s -> TF.Attr s (ArtifactStoreEncryptionKey s))
               (\s a -> s { _encryptionKey = a } :: CodepipelineArtifactStore s)

instance P.HasLocation (CodepipelineArtifactStore s) (TF.Attr s P.Text) where
    location =
        P.lens (_location :: CodepipelineArtifactStore s -> TF.Attr s P.Text)
               (\s a -> s { _location = a } :: CodepipelineArtifactStore s)

instance P.HasType' (CodepipelineArtifactStore s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: CodepipelineArtifactStore s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: CodepipelineArtifactStore s)

-- | @ses_receipt_rule_lambda_action@ nested settings.
data SesReceiptRuleLambdaAction s = SesReceiptRuleLambdaAction'
    { _functionArn :: TF.Attr s P.Text
    -- ^ @function_arn@ - (Required)
    --
    , _position    :: TF.Attr s P.Integer
    -- ^ @position@ - (Required)
    --
    , _topicArn    :: TF.Attr s P.Text
    -- ^ @topic_arn@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSesReceiptRuleLambdaAction
    :: TF.Attr s P.Text -- ^ @function_arn@ - 'P.functionArn'
    -> TF.Attr s P.Integer -- ^ @position@ - 'P.position'
    -> SesReceiptRuleLambdaAction s
newSesReceiptRuleLambdaAction _functionArn _position =
    SesReceiptRuleLambdaAction'
        { _functionArn = _functionArn
        , _position = _position
        , _topicArn = TF.Nil
        }

instance P.Hashable  (SesReceiptRuleLambdaAction s)
instance TF.IsValue  (SesReceiptRuleLambdaAction s)
instance TF.IsObject (SesReceiptRuleLambdaAction s) where
    toObject SesReceiptRuleLambdaAction'{..} = P.catMaybes
        [ TF.assign "function_arn" <$> TF.attribute _functionArn
        , TF.assign "position" <$> TF.attribute _position
        , TF.assign "topic_arn" <$> TF.attribute _topicArn
        ]

instance TF.IsValid (SesReceiptRuleLambdaAction s) where
    validator = P.mempty

instance P.HasFunctionArn (SesReceiptRuleLambdaAction s) (TF.Attr s P.Text) where
    functionArn =
        P.lens (_functionArn :: SesReceiptRuleLambdaAction s -> TF.Attr s P.Text)
               (\s a -> s { _functionArn = a } :: SesReceiptRuleLambdaAction s)

instance P.HasPosition (SesReceiptRuleLambdaAction s) (TF.Attr s P.Integer) where
    position =
        P.lens (_position :: SesReceiptRuleLambdaAction s -> TF.Attr s P.Integer)
               (\s a -> s { _position = a } :: SesReceiptRuleLambdaAction s)

instance P.HasTopicArn (SesReceiptRuleLambdaAction s) (TF.Attr s P.Text) where
    topicArn =
        P.lens (_topicArn :: SesReceiptRuleLambdaAction s -> TF.Attr s P.Text)
               (\s a -> s { _topicArn = a } :: SesReceiptRuleLambdaAction s)

instance s ~ s' => P.HasComputedInvocationType (TF.Ref s' (SesReceiptRuleLambdaAction s)) (TF.Attr s P.Text) where
    computedInvocationType x = TF.compute (TF.refKey x) "invocation_type"

-- | @rules_destination@ nested settings.
data RulesDestination s = RulesDestination'
    { _bucket          :: TF.Attr s P.Text
    -- ^ @bucket@ - (Required)
    --
    , _replicaKmsKeyId :: TF.Attr s P.Text
    -- ^ @replica_kms_key_id@ - (Optional)
    --
    , _storageClass    :: TF.Attr s P.Text
    -- ^ @storage_class@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRulesDestination
    :: TF.Attr s P.Text -- ^ @bucket@ - 'P.bucket'
    -> RulesDestination s
newRulesDestination _bucket =
    RulesDestination'
        { _bucket = _bucket
        , _replicaKmsKeyId = TF.Nil
        , _storageClass = TF.Nil
        }

instance P.Hashable  (RulesDestination s)
instance TF.IsValue  (RulesDestination s)
instance TF.IsObject (RulesDestination s) where
    toObject RulesDestination'{..} = P.catMaybes
        [ TF.assign "bucket" <$> TF.attribute _bucket
        , TF.assign "replica_kms_key_id" <$> TF.attribute _replicaKmsKeyId
        , TF.assign "storage_class" <$> TF.attribute _storageClass
        ]

instance TF.IsValid (RulesDestination s) where
    validator = P.mempty

instance P.HasBucket (RulesDestination s) (TF.Attr s P.Text) where
    bucket =
        P.lens (_bucket :: RulesDestination s -> TF.Attr s P.Text)
               (\s a -> s { _bucket = a } :: RulesDestination s)

instance P.HasReplicaKmsKeyId (RulesDestination s) (TF.Attr s P.Text) where
    replicaKmsKeyId =
        P.lens (_replicaKmsKeyId :: RulesDestination s -> TF.Attr s P.Text)
               (\s a -> s { _replicaKmsKeyId = a } :: RulesDestination s)

instance P.HasStorageClass (RulesDestination s) (TF.Attr s P.Text) where
    storageClass =
        P.lens (_storageClass :: RulesDestination s -> TF.Attr s P.Text)
               (\s a -> s { _storageClass = a } :: RulesDestination s)

-- | @origin_custom_origin_config@ nested settings.
data OriginCustomOriginConfig s = OriginCustomOriginConfig'
    { _httpPort               :: TF.Attr s P.Integer
    -- ^ @http_port@ - (Required)
    --
    , _httpsPort              :: TF.Attr s P.Integer
    -- ^ @https_port@ - (Required)
    --
    , _originKeepaliveTimeout :: TF.Attr s P.Integer
    -- ^ @origin_keepalive_timeout@ - (Optional)
    --
    , _originProtocolPolicy   :: TF.Attr s P.Text
    -- ^ @origin_protocol_policy@ - (Required)
    --
    , _originReadTimeout      :: TF.Attr s P.Integer
    -- ^ @origin_read_timeout@ - (Optional)
    --
    , _originSslProtocols     :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @origin_ssl_protocols@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newOriginCustomOriginConfig
    :: TF.Attr s P.Integer -- ^ @http_port@ - 'P.httpPort'
    -> TF.Attr s P.Integer -- ^ @https_port@ - 'P.httpsPort'
    -> TF.Attr s P.Text -- ^ @origin_protocol_policy@ - 'P.originProtocolPolicy'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @origin_ssl_protocols@ - 'P.originSslProtocols'
    -> OriginCustomOriginConfig s
newOriginCustomOriginConfig _httpPort _httpsPort _originProtocolPolicy _originSslProtocols =
    OriginCustomOriginConfig'
        { _httpPort = _httpPort
        , _httpsPort = _httpsPort
        , _originKeepaliveTimeout = TF.value 5
        , _originProtocolPolicy = _originProtocolPolicy
        , _originReadTimeout = TF.value 30
        , _originSslProtocols = _originSslProtocols
        }

instance P.Hashable  (OriginCustomOriginConfig s)
instance TF.IsValue  (OriginCustomOriginConfig s)
instance TF.IsObject (OriginCustomOriginConfig s) where
    toObject OriginCustomOriginConfig'{..} = P.catMaybes
        [ TF.assign "http_port" <$> TF.attribute _httpPort
        , TF.assign "https_port" <$> TF.attribute _httpsPort
        , TF.assign "origin_keepalive_timeout" <$> TF.attribute _originKeepaliveTimeout
        , TF.assign "origin_protocol_policy" <$> TF.attribute _originProtocolPolicy
        , TF.assign "origin_read_timeout" <$> TF.attribute _originReadTimeout
        , TF.assign "origin_ssl_protocols" <$> TF.attribute _originSslProtocols
        ]

instance TF.IsValid (OriginCustomOriginConfig s) where
    validator = P.mempty

instance P.HasHttpPort (OriginCustomOriginConfig s) (TF.Attr s P.Integer) where
    httpPort =
        P.lens (_httpPort :: OriginCustomOriginConfig s -> TF.Attr s P.Integer)
               (\s a -> s { _httpPort = a } :: OriginCustomOriginConfig s)

instance P.HasHttpsPort (OriginCustomOriginConfig s) (TF.Attr s P.Integer) where
    httpsPort =
        P.lens (_httpsPort :: OriginCustomOriginConfig s -> TF.Attr s P.Integer)
               (\s a -> s { _httpsPort = a } :: OriginCustomOriginConfig s)

instance P.HasOriginKeepaliveTimeout (OriginCustomOriginConfig s) (TF.Attr s P.Integer) where
    originKeepaliveTimeout =
        P.lens (_originKeepaliveTimeout :: OriginCustomOriginConfig s -> TF.Attr s P.Integer)
               (\s a -> s { _originKeepaliveTimeout = a } :: OriginCustomOriginConfig s)

instance P.HasOriginProtocolPolicy (OriginCustomOriginConfig s) (TF.Attr s P.Text) where
    originProtocolPolicy =
        P.lens (_originProtocolPolicy :: OriginCustomOriginConfig s -> TF.Attr s P.Text)
               (\s a -> s { _originProtocolPolicy = a } :: OriginCustomOriginConfig s)

instance P.HasOriginReadTimeout (OriginCustomOriginConfig s) (TF.Attr s P.Integer) where
    originReadTimeout =
        P.lens (_originReadTimeout :: OriginCustomOriginConfig s -> TF.Attr s P.Integer)
               (\s a -> s { _originReadTimeout = a } :: OriginCustomOriginConfig s)

instance P.HasOriginSslProtocols (OriginCustomOriginConfig s) (TF.Attr s [TF.Attr s P.Text]) where
    originSslProtocols =
        P.lens (_originSslProtocols :: OriginCustomOriginConfig s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _originSslProtocols = a } :: OriginCustomOriginConfig s)

-- | @glue_crawler_jdbc_target@ nested settings.
data GlueCrawlerJdbcTarget s = GlueCrawlerJdbcTarget'
    { _connectionName :: TF.Attr s P.Text
    -- ^ @connection_name@ - (Required)
    --
    , _exclusions     :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @exclusions@ - (Optional)
    --
    , _path           :: TF.Attr s P.Text
    -- ^ @path@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newGlueCrawlerJdbcTarget
    :: TF.Attr s P.Text -- ^ @connection_name@ - 'P.connectionName'
    -> TF.Attr s P.Text -- ^ @path@ - 'P.path'
    -> GlueCrawlerJdbcTarget s
newGlueCrawlerJdbcTarget _connectionName _path =
    GlueCrawlerJdbcTarget'
        { _connectionName = _connectionName
        , _exclusions = TF.Nil
        , _path = _path
        }

instance P.Hashable  (GlueCrawlerJdbcTarget s)
instance TF.IsValue  (GlueCrawlerJdbcTarget s)
instance TF.IsObject (GlueCrawlerJdbcTarget s) where
    toObject GlueCrawlerJdbcTarget'{..} = P.catMaybes
        [ TF.assign "connection_name" <$> TF.attribute _connectionName
        , TF.assign "exclusions" <$> TF.attribute _exclusions
        , TF.assign "path" <$> TF.attribute _path
        ]

instance TF.IsValid (GlueCrawlerJdbcTarget s) where
    validator = P.mempty

instance P.HasConnectionName (GlueCrawlerJdbcTarget s) (TF.Attr s P.Text) where
    connectionName =
        P.lens (_connectionName :: GlueCrawlerJdbcTarget s -> TF.Attr s P.Text)
               (\s a -> s { _connectionName = a } :: GlueCrawlerJdbcTarget s)

instance P.HasExclusions (GlueCrawlerJdbcTarget s) (TF.Attr s [TF.Attr s P.Text]) where
    exclusions =
        P.lens (_exclusions :: GlueCrawlerJdbcTarget s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _exclusions = a } :: GlueCrawlerJdbcTarget s)

instance P.HasPath (GlueCrawlerJdbcTarget s) (TF.Attr s P.Text) where
    path =
        P.lens (_path :: GlueCrawlerJdbcTarget s -> TF.Attr s P.Text)
               (\s a -> s { _path = a } :: GlueCrawlerJdbcTarget s)

-- | @alb_listener_rule_action@ nested settings.
data AlbListenerRuleAction s = AlbListenerRuleAction'
    { _targetGroupArn :: TF.Attr s P.Text
    -- ^ @target_group_arn@ - (Required)
    --
    , _type'          :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAlbListenerRuleAction
    :: TF.Attr s P.Text -- ^ @target_group_arn@ - 'P.targetGroupArn'
    -> TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> AlbListenerRuleAction s
newAlbListenerRuleAction _targetGroupArn _type' =
    AlbListenerRuleAction'
        { _targetGroupArn = _targetGroupArn
        , _type' = _type'
        }

instance P.Hashable  (AlbListenerRuleAction s)
instance TF.IsValue  (AlbListenerRuleAction s)
instance TF.IsObject (AlbListenerRuleAction s) where
    toObject AlbListenerRuleAction'{..} = P.catMaybes
        [ TF.assign "target_group_arn" <$> TF.attribute _targetGroupArn
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (AlbListenerRuleAction s) where
    validator = P.mempty

instance P.HasTargetGroupArn (AlbListenerRuleAction s) (TF.Attr s P.Text) where
    targetGroupArn =
        P.lens (_targetGroupArn :: AlbListenerRuleAction s -> TF.Attr s P.Text)
               (\s a -> s { _targetGroupArn = a } :: AlbListenerRuleAction s)

instance P.HasType' (AlbListenerRuleAction s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: AlbListenerRuleAction s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: AlbListenerRuleAction s)

-- | @directory_service_directory_connect_settings@ nested settings.
data DirectoryServiceDirectoryConnectSettings s = DirectoryServiceDirectoryConnectSettings'
    { _customerDnsIps   :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @customer_dns_ips@ - (Required, Forces New)
    --
    , _customerUsername :: TF.Attr s P.Text
    -- ^ @customer_username@ - (Required, Forces New)
    --
    , _subnetIds        :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @subnet_ids@ - (Required, Forces New)
    --
    , _vpcId            :: TF.Attr s P.Text
    -- ^ @vpc_id@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDirectoryServiceDirectoryConnectSettings
    :: TF.Attr s [TF.Attr s P.Text] -- ^ @customer_dns_ips@ - 'P.customerDnsIps'
    -> TF.Attr s P.Text -- ^ @customer_username@ - 'P.customerUsername'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @subnet_ids@ - 'P.subnetIds'
    -> TF.Attr s P.Text -- ^ @vpc_id@ - 'P.vpcId'
    -> DirectoryServiceDirectoryConnectSettings s
newDirectoryServiceDirectoryConnectSettings _customerDnsIps _customerUsername _subnetIds _vpcId =
    DirectoryServiceDirectoryConnectSettings'
        { _customerDnsIps = _customerDnsIps
        , _customerUsername = _customerUsername
        , _subnetIds = _subnetIds
        , _vpcId = _vpcId
        }

instance P.Hashable  (DirectoryServiceDirectoryConnectSettings s)
instance TF.IsValue  (DirectoryServiceDirectoryConnectSettings s)
instance TF.IsObject (DirectoryServiceDirectoryConnectSettings s) where
    toObject DirectoryServiceDirectoryConnectSettings'{..} = P.catMaybes
        [ TF.assign "customer_dns_ips" <$> TF.attribute _customerDnsIps
        , TF.assign "customer_username" <$> TF.attribute _customerUsername
        , TF.assign "subnet_ids" <$> TF.attribute _subnetIds
        , TF.assign "vpc_id" <$> TF.attribute _vpcId
        ]

instance TF.IsValid (DirectoryServiceDirectoryConnectSettings s) where
    validator = P.mempty

instance P.HasCustomerDnsIps (DirectoryServiceDirectoryConnectSettings s) (TF.Attr s [TF.Attr s P.Text]) where
    customerDnsIps =
        P.lens (_customerDnsIps :: DirectoryServiceDirectoryConnectSettings s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _customerDnsIps = a } :: DirectoryServiceDirectoryConnectSettings s)

instance P.HasCustomerUsername (DirectoryServiceDirectoryConnectSettings s) (TF.Attr s P.Text) where
    customerUsername =
        P.lens (_customerUsername :: DirectoryServiceDirectoryConnectSettings s -> TF.Attr s P.Text)
               (\s a -> s { _customerUsername = a } :: DirectoryServiceDirectoryConnectSettings s)

instance P.HasSubnetIds (DirectoryServiceDirectoryConnectSettings s) (TF.Attr s [TF.Attr s P.Text]) where
    subnetIds =
        P.lens (_subnetIds :: DirectoryServiceDirectoryConnectSettings s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _subnetIds = a } :: DirectoryServiceDirectoryConnectSettings s)

instance P.HasVpcId (DirectoryServiceDirectoryConnectSettings s) (TF.Attr s P.Text) where
    vpcId =
        P.lens (_vpcId :: DirectoryServiceDirectoryConnectSettings s -> TF.Attr s P.Text)
               (\s a -> s { _vpcId = a } :: DirectoryServiceDirectoryConnectSettings s)

-- | @blue_green_deployment_config_green_fleet_provisioning_option@ nested settings.
data BlueGreenDeploymentConfigGreenFleetProvisioningOption s = BlueGreenDeploymentConfigGreenFleetProvisioningOption'
    { _action :: TF.Attr s P.Text
    -- ^ @action@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newBlueGreenDeploymentConfigGreenFleetProvisioningOption
    :: BlueGreenDeploymentConfigGreenFleetProvisioningOption s
newBlueGreenDeploymentConfigGreenFleetProvisioningOption =
    BlueGreenDeploymentConfigGreenFleetProvisioningOption'
        { _action = TF.Nil
        }

instance P.Hashable  (BlueGreenDeploymentConfigGreenFleetProvisioningOption s)
instance TF.IsValue  (BlueGreenDeploymentConfigGreenFleetProvisioningOption s)
instance TF.IsObject (BlueGreenDeploymentConfigGreenFleetProvisioningOption s) where
    toObject BlueGreenDeploymentConfigGreenFleetProvisioningOption'{..} = P.catMaybes
        [ TF.assign "action" <$> TF.attribute _action
        ]

instance TF.IsValid (BlueGreenDeploymentConfigGreenFleetProvisioningOption s) where
    validator = P.mempty

instance P.HasAction (BlueGreenDeploymentConfigGreenFleetProvisioningOption s) (TF.Attr s P.Text) where
    action =
        P.lens (_action :: BlueGreenDeploymentConfigGreenFleetProvisioningOption s -> TF.Attr s P.Text)
               (\s a -> s { _action = a } :: BlueGreenDeploymentConfigGreenFleetProvisioningOption s)

-- | @db_parameter_group_parameter@ nested settings.
data DbParameterGroupParameter s = DbParameterGroupParameter'
    { _applyMethod :: TF.Attr s P.Text
    -- ^ @apply_method@ - (Optional)
    --
    , _name        :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _value       :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDbParameterGroupParameter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> DbParameterGroupParameter s
newDbParameterGroupParameter _name _value =
    DbParameterGroupParameter'
        { _applyMethod = TF.value "immediate"
        , _name = _name
        , _value = _value
        }

instance P.Hashable  (DbParameterGroupParameter s)
instance TF.IsValue  (DbParameterGroupParameter s)
instance TF.IsObject (DbParameterGroupParameter s) where
    toObject DbParameterGroupParameter'{..} = P.catMaybes
        [ TF.assign "apply_method" <$> TF.attribute _applyMethod
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (DbParameterGroupParameter s) where
    validator = P.mempty

instance P.HasApplyMethod (DbParameterGroupParameter s) (TF.Attr s P.Text) where
    applyMethod =
        P.lens (_applyMethod :: DbParameterGroupParameter s -> TF.Attr s P.Text)
               (\s a -> s { _applyMethod = a } :: DbParameterGroupParameter s)

instance P.HasName (DbParameterGroupParameter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: DbParameterGroupParameter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: DbParameterGroupParameter s)

instance P.HasValue (DbParameterGroupParameter s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: DbParameterGroupParameter s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: DbParameterGroupParameter s)

-- | @wafregional_ipset_ip_set_descriptor@ nested settings.
data WafregionalIpsetIpSetDescriptor s = WafregionalIpsetIpSetDescriptor'
    { _type' :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    , _value :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newWafregionalIpsetIpSetDescriptor
    :: TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> WafregionalIpsetIpSetDescriptor s
newWafregionalIpsetIpSetDescriptor _type' _value =
    WafregionalIpsetIpSetDescriptor'
        { _type' = _type'
        , _value = _value
        }

instance P.Hashable  (WafregionalIpsetIpSetDescriptor s)
instance TF.IsValue  (WafregionalIpsetIpSetDescriptor s)
instance TF.IsObject (WafregionalIpsetIpSetDescriptor s) where
    toObject WafregionalIpsetIpSetDescriptor'{..} = P.catMaybes
        [ TF.assign "type" <$> TF.attribute _type'
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (WafregionalIpsetIpSetDescriptor s) where
    validator = P.mempty

instance P.HasType' (WafregionalIpsetIpSetDescriptor s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: WafregionalIpsetIpSetDescriptor s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: WafregionalIpsetIpSetDescriptor s)

instance P.HasValue (WafregionalIpsetIpSetDescriptor s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: WafregionalIpsetIpSetDescriptor s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: WafregionalIpsetIpSetDescriptor s)

-- | @codedeploy_deployment_group_auto_rollback_configuration@ nested settings.
data CodedeployDeploymentGroupAutoRollbackConfiguration s = CodedeployDeploymentGroupAutoRollbackConfiguration'
    { _enabled :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Optional)
    --
    , _events  :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @events@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCodedeployDeploymentGroupAutoRollbackConfiguration
    :: CodedeployDeploymentGroupAutoRollbackConfiguration s
newCodedeployDeploymentGroupAutoRollbackConfiguration =
    CodedeployDeploymentGroupAutoRollbackConfiguration'
        { _enabled = TF.Nil
        , _events = TF.Nil
        }

instance P.Hashable  (CodedeployDeploymentGroupAutoRollbackConfiguration s)
instance TF.IsValue  (CodedeployDeploymentGroupAutoRollbackConfiguration s)
instance TF.IsObject (CodedeployDeploymentGroupAutoRollbackConfiguration s) where
    toObject CodedeployDeploymentGroupAutoRollbackConfiguration'{..} = P.catMaybes
        [ TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "events" <$> TF.attribute _events
        ]

instance TF.IsValid (CodedeployDeploymentGroupAutoRollbackConfiguration s) where
    validator = P.mempty

instance P.HasEnabled (CodedeployDeploymentGroupAutoRollbackConfiguration s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: CodedeployDeploymentGroupAutoRollbackConfiguration s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: CodedeployDeploymentGroupAutoRollbackConfiguration s)

instance P.HasEvents (CodedeployDeploymentGroupAutoRollbackConfiguration s) (TF.Attr s [TF.Attr s P.Text]) where
    events =
        P.lens (_events :: CodedeployDeploymentGroupAutoRollbackConfiguration s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _events = a } :: CodedeployDeploymentGroupAutoRollbackConfiguration s)

-- | @codebuild_project_vpc_config@ nested settings.
data CodebuildProjectVpcConfig s = CodebuildProjectVpcConfig'
    { _securityGroupIds :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @security_group_ids@ - (Required)
    --
    , _subnets          :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @subnets@ - (Required)
    --
    , _vpcId            :: TF.Attr s P.Text
    -- ^ @vpc_id@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCodebuildProjectVpcConfig
    :: TF.Attr s [TF.Attr s P.Text] -- ^ @security_group_ids@ - 'P.securityGroupIds'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @subnets@ - 'P.subnets'
    -> TF.Attr s P.Text -- ^ @vpc_id@ - 'P.vpcId'
    -> CodebuildProjectVpcConfig s
newCodebuildProjectVpcConfig _securityGroupIds _subnets _vpcId =
    CodebuildProjectVpcConfig'
        { _securityGroupIds = _securityGroupIds
        , _subnets = _subnets
        , _vpcId = _vpcId
        }

instance P.Hashable  (CodebuildProjectVpcConfig s)
instance TF.IsValue  (CodebuildProjectVpcConfig s)
instance TF.IsObject (CodebuildProjectVpcConfig s) where
    toObject CodebuildProjectVpcConfig'{..} = P.catMaybes
        [ TF.assign "security_group_ids" <$> TF.attribute _securityGroupIds
        , TF.assign "subnets" <$> TF.attribute _subnets
        , TF.assign "vpc_id" <$> TF.attribute _vpcId
        ]

instance TF.IsValid (CodebuildProjectVpcConfig s) where
    validator = P.mempty

instance P.HasSecurityGroupIds (CodebuildProjectVpcConfig s) (TF.Attr s [TF.Attr s P.Text]) where
    securityGroupIds =
        P.lens (_securityGroupIds :: CodebuildProjectVpcConfig s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _securityGroupIds = a } :: CodebuildProjectVpcConfig s)

instance P.HasSubnets (CodebuildProjectVpcConfig s) (TF.Attr s [TF.Attr s P.Text]) where
    subnets =
        P.lens (_subnets :: CodebuildProjectVpcConfig s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _subnets = a } :: CodebuildProjectVpcConfig s)

instance P.HasVpcId (CodebuildProjectVpcConfig s) (TF.Attr s P.Text) where
    vpcId =
        P.lens (_vpcId :: CodebuildProjectVpcConfig s -> TF.Attr s P.Text)
               (\s a -> s { _vpcId = a } :: CodebuildProjectVpcConfig s)

-- | @autoscaling_groups_filter@ nested settings.
data AutoscalingGroupsFilter s = AutoscalingGroupsFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAutoscalingGroupsFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> AutoscalingGroupsFilter s
newAutoscalingGroupsFilter _name _values =
    AutoscalingGroupsFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (AutoscalingGroupsFilter s)
instance TF.IsValue  (AutoscalingGroupsFilter s)
instance TF.IsObject (AutoscalingGroupsFilter s) where
    toObject AutoscalingGroupsFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (AutoscalingGroupsFilter s) where
    validator = P.mempty

instance P.HasName (AutoscalingGroupsFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: AutoscalingGroupsFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: AutoscalingGroupsFilter s)

instance P.HasValues (AutoscalingGroupsFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: AutoscalingGroupsFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: AutoscalingGroupsFilter s)

-- | @mq_broker_user@ nested settings.
data MqBrokerUser s = MqBrokerUser'
    { _consoleAccess :: TF.Attr s P.Bool
    -- ^ @console_access@ - (Optional)
    --
    , _groups        :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @groups@ - (Optional)
    --
    , _password      :: TF.Attr s P.Text
    -- ^ @password@ - (Required)
    --
    , _username      :: TF.Attr s P.Text
    -- ^ @username@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newMqBrokerUser
    :: TF.Attr s P.Text -- ^ @password@ - 'P.password'
    -> TF.Attr s P.Text -- ^ @username@ - 'P.username'
    -> MqBrokerUser s
newMqBrokerUser _password _username =
    MqBrokerUser'
        { _consoleAccess = TF.value P.False
        , _groups = TF.Nil
        , _password = _password
        , _username = _username
        }

instance P.Hashable  (MqBrokerUser s)
instance TF.IsValue  (MqBrokerUser s)
instance TF.IsObject (MqBrokerUser s) where
    toObject MqBrokerUser'{..} = P.catMaybes
        [ TF.assign "console_access" <$> TF.attribute _consoleAccess
        , TF.assign "groups" <$> TF.attribute _groups
        , TF.assign "password" <$> TF.attribute _password
        , TF.assign "username" <$> TF.attribute _username
        ]

instance TF.IsValid (MqBrokerUser s) where
    validator = P.mempty

instance P.HasConsoleAccess (MqBrokerUser s) (TF.Attr s P.Bool) where
    consoleAccess =
        P.lens (_consoleAccess :: MqBrokerUser s -> TF.Attr s P.Bool)
               (\s a -> s { _consoleAccess = a } :: MqBrokerUser s)

instance P.HasGroups (MqBrokerUser s) (TF.Attr s [TF.Attr s P.Text]) where
    groups =
        P.lens (_groups :: MqBrokerUser s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _groups = a } :: MqBrokerUser s)

instance P.HasPassword (MqBrokerUser s) (TF.Attr s P.Text) where
    password =
        P.lens (_password :: MqBrokerUser s -> TF.Attr s P.Text)
               (\s a -> s { _password = a } :: MqBrokerUser s)

instance P.HasUsername (MqBrokerUser s) (TF.Attr s P.Text) where
    username =
        P.lens (_username :: MqBrokerUser s -> TF.Attr s P.Text)
               (\s a -> s { _username = a } :: MqBrokerUser s)

instance s ~ s' => P.HasComputedConsoleAccess (TF.Ref s' (MqBrokerUser s)) (TF.Attr s P.Bool) where
    computedConsoleAccess x = TF.compute (TF.refKey x) "console_access"

instance s ~ s' => P.HasComputedGroups (TF.Ref s' (MqBrokerUser s)) (TF.Attr s [TF.Attr s P.Text]) where
    computedGroups x = TF.compute (TF.refKey x) "groups"

-- | @data_format_conversion_configuration_input_format_configuration@ nested settings.
data DataFormatConversionConfigurationInputFormatConfiguration s = DataFormatConversionConfigurationInputFormatConfiguration'
    { _deserializer :: TF.Attr s (InputFormatConfigurationDeserializer s)
    -- ^ @deserializer@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDataFormatConversionConfigurationInputFormatConfiguration
    :: TF.Attr s (InputFormatConfigurationDeserializer s) -- ^ @deserializer@ - 'P.deserializer'
    -> DataFormatConversionConfigurationInputFormatConfiguration s
newDataFormatConversionConfigurationInputFormatConfiguration _deserializer =
    DataFormatConversionConfigurationInputFormatConfiguration'
        { _deserializer = _deserializer
        }

instance P.Hashable  (DataFormatConversionConfigurationInputFormatConfiguration s)
instance TF.IsValue  (DataFormatConversionConfigurationInputFormatConfiguration s)
instance TF.IsObject (DataFormatConversionConfigurationInputFormatConfiguration s) where
    toObject DataFormatConversionConfigurationInputFormatConfiguration'{..} = P.catMaybes
        [ TF.assign "deserializer" <$> TF.attribute _deserializer
        ]

instance TF.IsValid (DataFormatConversionConfigurationInputFormatConfiguration s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_deserializer"
                  (_deserializer
                      :: DataFormatConversionConfigurationInputFormatConfiguration s -> TF.Attr s (InputFormatConfigurationDeserializer s))
                  TF.validator

instance P.HasDeserializer (DataFormatConversionConfigurationInputFormatConfiguration s) (TF.Attr s (InputFormatConfigurationDeserializer s)) where
    deserializer =
        P.lens (_deserializer :: DataFormatConversionConfigurationInputFormatConfiguration s -> TF.Attr s (InputFormatConfigurationDeserializer s))
               (\s a -> s { _deserializer = a } :: DataFormatConversionConfigurationInputFormatConfiguration s)

-- | @ami_copy_ephemeral_block_device@ nested settings.
data AmiCopyEphemeralBlockDevice s = AmiCopyEphemeralBlockDevice'
    deriving (P.Show, P.Eq, P.Generic)

newAmiCopyEphemeralBlockDevice
    :: AmiCopyEphemeralBlockDevice s
newAmiCopyEphemeralBlockDevice =
    AmiCopyEphemeralBlockDevice'

instance P.Hashable  (AmiCopyEphemeralBlockDevice s)
instance TF.IsValue  (AmiCopyEphemeralBlockDevice s)
instance TF.IsObject (AmiCopyEphemeralBlockDevice s) where
    toObject AmiCopyEphemeralBlockDevice' = []

instance TF.IsValid (AmiCopyEphemeralBlockDevice s) where
    validator = P.mempty

instance s ~ s' => P.HasComputedDeviceName (TF.Ref s' (AmiCopyEphemeralBlockDevice s)) (TF.Attr s P.Text) where
    computedDeviceName x = TF.compute (TF.refKey x) "device_name"

instance s ~ s' => P.HasComputedVirtualName (TF.Ref s' (AmiCopyEphemeralBlockDevice s)) (TF.Attr s P.Text) where
    computedVirtualName x = TF.compute (TF.refKey x) "virtual_name"

-- | @elastictranscoder_pipeline_content_config@ nested settings.
data ElastictranscoderPipelineContentConfig s = ElastictranscoderPipelineContentConfig'
    { _storageClass :: TF.Attr s P.Text
    -- ^ @storage_class@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElastictranscoderPipelineContentConfig
    :: ElastictranscoderPipelineContentConfig s
newElastictranscoderPipelineContentConfig =
    ElastictranscoderPipelineContentConfig'
        { _storageClass = TF.Nil
        }

instance P.Hashable  (ElastictranscoderPipelineContentConfig s)
instance TF.IsValue  (ElastictranscoderPipelineContentConfig s)
instance TF.IsObject (ElastictranscoderPipelineContentConfig s) where
    toObject ElastictranscoderPipelineContentConfig'{..} = P.catMaybes
        [ TF.assign "storage_class" <$> TF.attribute _storageClass
        ]

instance TF.IsValid (ElastictranscoderPipelineContentConfig s) where
    validator = P.mempty

instance P.HasStorageClass (ElastictranscoderPipelineContentConfig s) (TF.Attr s P.Text) where
    storageClass =
        P.lens (_storageClass :: ElastictranscoderPipelineContentConfig s -> TF.Attr s P.Text)
               (\s a -> s { _storageClass = a } :: ElastictranscoderPipelineContentConfig s)

instance s ~ s' => P.HasComputedBucket (TF.Ref s' (ElastictranscoderPipelineContentConfig s)) (TF.Attr s P.Text) where
    computedBucket x = TF.compute (TF.refKey x) "bucket"

-- | @storagegateway_nfs_file_share_nfs_file_share_defaults@ nested settings.
data StoragegatewayNfsFileShareNfsFileShareDefaults s = StoragegatewayNfsFileShareNfsFileShareDefaults'
    { _directoryMode :: TF.Attr s P.Text
    -- ^ @directory_mode@ - (Optional)
    --
    , _fileMode      :: TF.Attr s P.Text
    -- ^ @file_mode@ - (Optional)
    --
    , _groupId       :: TF.Attr s P.Integer
    -- ^ @group_id@ - (Optional)
    --
    , _ownerId       :: TF.Attr s P.Integer
    -- ^ @owner_id@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newStoragegatewayNfsFileShareNfsFileShareDefaults
    :: StoragegatewayNfsFileShareNfsFileShareDefaults s
newStoragegatewayNfsFileShareNfsFileShareDefaults =
    StoragegatewayNfsFileShareNfsFileShareDefaults'
        { _directoryMode = TF.value "0777"
        , _fileMode = TF.value "0666"
        , _groupId = TF.value 65534
        , _ownerId = TF.value 65534
        }

instance P.Hashable  (StoragegatewayNfsFileShareNfsFileShareDefaults s)
instance TF.IsValue  (StoragegatewayNfsFileShareNfsFileShareDefaults s)
instance TF.IsObject (StoragegatewayNfsFileShareNfsFileShareDefaults s) where
    toObject StoragegatewayNfsFileShareNfsFileShareDefaults'{..} = P.catMaybes
        [ TF.assign "directory_mode" <$> TF.attribute _directoryMode
        , TF.assign "file_mode" <$> TF.attribute _fileMode
        , TF.assign "group_id" <$> TF.attribute _groupId
        , TF.assign "owner_id" <$> TF.attribute _ownerId
        ]

instance TF.IsValid (StoragegatewayNfsFileShareNfsFileShareDefaults s) where
    validator = P.mempty

instance P.HasDirectoryMode (StoragegatewayNfsFileShareNfsFileShareDefaults s) (TF.Attr s P.Text) where
    directoryMode =
        P.lens (_directoryMode :: StoragegatewayNfsFileShareNfsFileShareDefaults s -> TF.Attr s P.Text)
               (\s a -> s { _directoryMode = a } :: StoragegatewayNfsFileShareNfsFileShareDefaults s)

instance P.HasFileMode (StoragegatewayNfsFileShareNfsFileShareDefaults s) (TF.Attr s P.Text) where
    fileMode =
        P.lens (_fileMode :: StoragegatewayNfsFileShareNfsFileShareDefaults s -> TF.Attr s P.Text)
               (\s a -> s { _fileMode = a } :: StoragegatewayNfsFileShareNfsFileShareDefaults s)

instance P.HasGroupId (StoragegatewayNfsFileShareNfsFileShareDefaults s) (TF.Attr s P.Integer) where
    groupId =
        P.lens (_groupId :: StoragegatewayNfsFileShareNfsFileShareDefaults s -> TF.Attr s P.Integer)
               (\s a -> s { _groupId = a } :: StoragegatewayNfsFileShareNfsFileShareDefaults s)

instance P.HasOwnerId (StoragegatewayNfsFileShareNfsFileShareDefaults s) (TF.Attr s P.Integer) where
    ownerId =
        P.lens (_ownerId :: StoragegatewayNfsFileShareNfsFileShareDefaults s -> TF.Attr s P.Integer)
               (\s a -> s { _ownerId = a } :: StoragegatewayNfsFileShareNfsFileShareDefaults s)

-- | @iot_topic_rule_cloudwatch_alarm@ nested settings.
data IotTopicRuleCloudwatchAlarm s = IotTopicRuleCloudwatchAlarm'
    { _alarmName   :: TF.Attr s P.Text
    -- ^ @alarm_name@ - (Required)
    --
    , _roleArn     :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Required)
    --
    , _stateReason :: TF.Attr s P.Text
    -- ^ @state_reason@ - (Required)
    --
    , _stateValue  :: TF.Attr s P.Text
    -- ^ @state_value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newIotTopicRuleCloudwatchAlarm
    :: TF.Attr s P.Text -- ^ @alarm_name@ - 'P.alarmName'
    -> TF.Attr s P.Text -- ^ @role_arn@ - 'P.roleArn'
    -> TF.Attr s P.Text -- ^ @state_reason@ - 'P.stateReason'
    -> TF.Attr s P.Text -- ^ @state_value@ - 'P.stateValue'
    -> IotTopicRuleCloudwatchAlarm s
newIotTopicRuleCloudwatchAlarm _alarmName _roleArn _stateReason _stateValue =
    IotTopicRuleCloudwatchAlarm'
        { _alarmName = _alarmName
        , _roleArn = _roleArn
        , _stateReason = _stateReason
        , _stateValue = _stateValue
        }

instance P.Hashable  (IotTopicRuleCloudwatchAlarm s)
instance TF.IsValue  (IotTopicRuleCloudwatchAlarm s)
instance TF.IsObject (IotTopicRuleCloudwatchAlarm s) where
    toObject IotTopicRuleCloudwatchAlarm'{..} = P.catMaybes
        [ TF.assign "alarm_name" <$> TF.attribute _alarmName
        , TF.assign "role_arn" <$> TF.attribute _roleArn
        , TF.assign "state_reason" <$> TF.attribute _stateReason
        , TF.assign "state_value" <$> TF.attribute _stateValue
        ]

instance TF.IsValid (IotTopicRuleCloudwatchAlarm s) where
    validator = P.mempty

instance P.HasAlarmName (IotTopicRuleCloudwatchAlarm s) (TF.Attr s P.Text) where
    alarmName =
        P.lens (_alarmName :: IotTopicRuleCloudwatchAlarm s -> TF.Attr s P.Text)
               (\s a -> s { _alarmName = a } :: IotTopicRuleCloudwatchAlarm s)

instance P.HasRoleArn (IotTopicRuleCloudwatchAlarm s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: IotTopicRuleCloudwatchAlarm s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: IotTopicRuleCloudwatchAlarm s)

instance P.HasStateReason (IotTopicRuleCloudwatchAlarm s) (TF.Attr s P.Text) where
    stateReason =
        P.lens (_stateReason :: IotTopicRuleCloudwatchAlarm s -> TF.Attr s P.Text)
               (\s a -> s { _stateReason = a } :: IotTopicRuleCloudwatchAlarm s)

instance P.HasStateValue (IotTopicRuleCloudwatchAlarm s) (TF.Attr s P.Text) where
    stateValue =
        P.lens (_stateValue :: IotTopicRuleCloudwatchAlarm s -> TF.Attr s P.Text)
               (\s a -> s { _stateValue = a } :: IotTopicRuleCloudwatchAlarm s)

-- | @kinesis_firehose_delivery_stream_s3_configuration@ nested settings.
data KinesisFirehoseDeliveryStreamS3Configuration s = KinesisFirehoseDeliveryStreamS3Configuration'
    { _bucketArn         :: TF.Attr s P.Text
    -- ^ @bucket_arn@ - (Required)
    --
    , _bufferInterval    :: TF.Attr s P.Integer
    -- ^ @buffer_interval@ - (Optional)
    --
    , _bufferSize        :: TF.Attr s P.Integer
    -- ^ @buffer_size@ - (Optional)
    --
    , _compressionFormat :: TF.Attr s P.Text
    -- ^ @compression_format@ - (Optional)
    --
    , _kmsKeyArn         :: TF.Attr s P.Text
    -- ^ @kms_key_arn@ - (Optional)
    --
    , _prefix            :: TF.Attr s P.Text
    -- ^ @prefix@ - (Optional)
    --
    , _roleArn           :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newKinesisFirehoseDeliveryStreamS3Configuration
    :: TF.Attr s P.Text -- ^ @bucket_arn@ - 'P.bucketArn'
    -> TF.Attr s P.Text -- ^ @role_arn@ - 'P.roleArn'
    -> KinesisFirehoseDeliveryStreamS3Configuration s
newKinesisFirehoseDeliveryStreamS3Configuration _bucketArn _roleArn =
    KinesisFirehoseDeliveryStreamS3Configuration'
        { _bucketArn = _bucketArn
        , _bufferInterval = TF.value 300
        , _bufferSize = TF.value 5
        , _compressionFormat = TF.value "UNCOMPRESSED"
        , _kmsKeyArn = TF.Nil
        , _prefix = TF.Nil
        , _roleArn = _roleArn
        }

instance P.Hashable  (KinesisFirehoseDeliveryStreamS3Configuration s)
instance TF.IsValue  (KinesisFirehoseDeliveryStreamS3Configuration s)
instance TF.IsObject (KinesisFirehoseDeliveryStreamS3Configuration s) where
    toObject KinesisFirehoseDeliveryStreamS3Configuration'{..} = P.catMaybes
        [ TF.assign "bucket_arn" <$> TF.attribute _bucketArn
        , TF.assign "buffer_interval" <$> TF.attribute _bufferInterval
        , TF.assign "buffer_size" <$> TF.attribute _bufferSize
        , TF.assign "compression_format" <$> TF.attribute _compressionFormat
        , TF.assign "kms_key_arn" <$> TF.attribute _kmsKeyArn
        , TF.assign "prefix" <$> TF.attribute _prefix
        , TF.assign "role_arn" <$> TF.attribute _roleArn
        ]

instance TF.IsValid (KinesisFirehoseDeliveryStreamS3Configuration s) where
    validator = P.mempty

instance P.HasBucketArn (KinesisFirehoseDeliveryStreamS3Configuration s) (TF.Attr s P.Text) where
    bucketArn =
        P.lens (_bucketArn :: KinesisFirehoseDeliveryStreamS3Configuration s -> TF.Attr s P.Text)
               (\s a -> s { _bucketArn = a } :: KinesisFirehoseDeliveryStreamS3Configuration s)

instance P.HasBufferInterval (KinesisFirehoseDeliveryStreamS3Configuration s) (TF.Attr s P.Integer) where
    bufferInterval =
        P.lens (_bufferInterval :: KinesisFirehoseDeliveryStreamS3Configuration s -> TF.Attr s P.Integer)
               (\s a -> s { _bufferInterval = a } :: KinesisFirehoseDeliveryStreamS3Configuration s)

instance P.HasBufferSize (KinesisFirehoseDeliveryStreamS3Configuration s) (TF.Attr s P.Integer) where
    bufferSize =
        P.lens (_bufferSize :: KinesisFirehoseDeliveryStreamS3Configuration s -> TF.Attr s P.Integer)
               (\s a -> s { _bufferSize = a } :: KinesisFirehoseDeliveryStreamS3Configuration s)

instance P.HasCompressionFormat (KinesisFirehoseDeliveryStreamS3Configuration s) (TF.Attr s P.Text) where
    compressionFormat =
        P.lens (_compressionFormat :: KinesisFirehoseDeliveryStreamS3Configuration s -> TF.Attr s P.Text)
               (\s a -> s { _compressionFormat = a } :: KinesisFirehoseDeliveryStreamS3Configuration s)

instance P.HasKmsKeyArn (KinesisFirehoseDeliveryStreamS3Configuration s) (TF.Attr s P.Text) where
    kmsKeyArn =
        P.lens (_kmsKeyArn :: KinesisFirehoseDeliveryStreamS3Configuration s -> TF.Attr s P.Text)
               (\s a -> s { _kmsKeyArn = a } :: KinesisFirehoseDeliveryStreamS3Configuration s)

instance P.HasPrefix (KinesisFirehoseDeliveryStreamS3Configuration s) (TF.Attr s P.Text) where
    prefix =
        P.lens (_prefix :: KinesisFirehoseDeliveryStreamS3Configuration s -> TF.Attr s P.Text)
               (\s a -> s { _prefix = a } :: KinesisFirehoseDeliveryStreamS3Configuration s)

instance P.HasRoleArn (KinesisFirehoseDeliveryStreamS3Configuration s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: KinesisFirehoseDeliveryStreamS3Configuration s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: KinesisFirehoseDeliveryStreamS3Configuration s)

instance s ~ s' => P.HasComputedCloudwatchLoggingOptions (TF.Ref s' (KinesisFirehoseDeliveryStreamS3Configuration s)) (TF.Attr s (S3ConfigurationCloudwatchLoggingOptions s)) where
    computedCloudwatchLoggingOptions x = TF.compute (TF.refKey x) "cloudwatch_logging_options"

-- | @launch_template_tag_specifications@ nested settings.
data LaunchTemplateTagSpecifications s = LaunchTemplateTagSpecifications'
    { _resourceType :: TF.Attr s P.Text
    -- ^ @resource_type@ - (Optional)
    --
    , _tags         :: TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))
    -- ^ @tags@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLaunchTemplateTagSpecifications
    :: LaunchTemplateTagSpecifications s
newLaunchTemplateTagSpecifications =
    LaunchTemplateTagSpecifications'
        { _resourceType = TF.Nil
        , _tags = TF.Nil
        }

instance P.Hashable  (LaunchTemplateTagSpecifications s)
instance TF.IsValue  (LaunchTemplateTagSpecifications s)
instance TF.IsObject (LaunchTemplateTagSpecifications s) where
    toObject LaunchTemplateTagSpecifications'{..} = P.catMaybes
        [ TF.assign "resource_type" <$> TF.attribute _resourceType
        , TF.assign "tags" <$> TF.attribute _tags
        ]

instance TF.IsValid (LaunchTemplateTagSpecifications s) where
    validator = P.mempty

instance P.HasResourceType (LaunchTemplateTagSpecifications s) (TF.Attr s P.Text) where
    resourceType =
        P.lens (_resourceType :: LaunchTemplateTagSpecifications s -> TF.Attr s P.Text)
               (\s a -> s { _resourceType = a } :: LaunchTemplateTagSpecifications s)

instance P.HasTags (LaunchTemplateTagSpecifications s) (TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))) where
    tags =
        P.lens (_tags :: LaunchTemplateTagSpecifications s -> TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text)))
               (\s a -> s { _tags = a } :: LaunchTemplateTagSpecifications s)

-- | @restrictions_geo_restriction@ nested settings.
data RestrictionsGeoRestriction s = RestrictionsGeoRestriction'
    { _locations       :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @locations@ - (Optional)
    --
    , _restrictionType :: TF.Attr s P.Text
    -- ^ @restriction_type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRestrictionsGeoRestriction
    :: TF.Attr s P.Text -- ^ @restriction_type@ - 'P.restrictionType'
    -> RestrictionsGeoRestriction s
newRestrictionsGeoRestriction _restrictionType =
    RestrictionsGeoRestriction'
        { _locations = TF.Nil
        , _restrictionType = _restrictionType
        }

instance P.Hashable  (RestrictionsGeoRestriction s)
instance TF.IsValue  (RestrictionsGeoRestriction s)
instance TF.IsObject (RestrictionsGeoRestriction s) where
    toObject RestrictionsGeoRestriction'{..} = P.catMaybes
        [ TF.assign "locations" <$> TF.attribute _locations
        , TF.assign "restriction_type" <$> TF.attribute _restrictionType
        ]

instance TF.IsValid (RestrictionsGeoRestriction s) where
    validator = P.mempty

instance P.HasLocations (RestrictionsGeoRestriction s) (TF.Attr s [TF.Attr s P.Text]) where
    locations =
        P.lens (_locations :: RestrictionsGeoRestriction s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _locations = a } :: RestrictionsGeoRestriction s)

instance P.HasRestrictionType (RestrictionsGeoRestriction s) (TF.Attr s P.Text) where
    restrictionType =
        P.lens (_restrictionType :: RestrictionsGeoRestriction s -> TF.Attr s P.Text)
               (\s a -> s { _restrictionType = a } :: RestrictionsGeoRestriction s)

-- | @vpc_peering_connection_filter@ nested settings.
data VpcPeeringConnectionFilter s = VpcPeeringConnectionFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newVpcPeeringConnectionFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> VpcPeeringConnectionFilter s
newVpcPeeringConnectionFilter _name _values =
    VpcPeeringConnectionFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (VpcPeeringConnectionFilter s)
instance TF.IsValue  (VpcPeeringConnectionFilter s)
instance TF.IsObject (VpcPeeringConnectionFilter s) where
    toObject VpcPeeringConnectionFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (VpcPeeringConnectionFilter s) where
    validator = P.mempty

instance P.HasName (VpcPeeringConnectionFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: VpcPeeringConnectionFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: VpcPeeringConnectionFilter s)

instance P.HasValues (VpcPeeringConnectionFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: VpcPeeringConnectionFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: VpcPeeringConnectionFilter s)

-- | @db_option_group_option@ nested settings.
data DbOptionGroupOption s = DbOptionGroupOption'
    { _dbSecurityGroupMemberships :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @db_security_group_memberships@ - (Optional)
    --
    , _optionName :: TF.Attr s P.Text
    -- ^ @option_name@ - (Required)
    --
    , _optionSettings :: TF.Attr s [TF.Attr s (OptionOptionSettings s)]
    -- ^ @option_settings@ - (Optional)
    --
    , _port :: TF.Attr s P.Integer
    -- ^ @port@ - (Optional)
    --
    , _version :: TF.Attr s P.Text
    -- ^ @version@ - (Optional)
    --
    , _vpcSecurityGroupMemberships :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @vpc_security_group_memberships@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDbOptionGroupOption
    :: TF.Attr s P.Text -- ^ @option_name@ - 'P.optionName'
    -> DbOptionGroupOption s
newDbOptionGroupOption _optionName =
    DbOptionGroupOption'
        { _dbSecurityGroupMemberships = TF.Nil
        , _optionName = _optionName
        , _optionSettings = TF.Nil
        , _port = TF.Nil
        , _version = TF.Nil
        , _vpcSecurityGroupMemberships = TF.Nil
        }

instance P.Hashable  (DbOptionGroupOption s)
instance TF.IsValue  (DbOptionGroupOption s)
instance TF.IsObject (DbOptionGroupOption s) where
    toObject DbOptionGroupOption'{..} = P.catMaybes
        [ TF.assign "db_security_group_memberships" <$> TF.attribute _dbSecurityGroupMemberships
        , TF.assign "option_name" <$> TF.attribute _optionName
        , TF.assign "option_settings" <$> TF.attribute _optionSettings
        , TF.assign "port" <$> TF.attribute _port
        , TF.assign "version" <$> TF.attribute _version
        , TF.assign "vpc_security_group_memberships" <$> TF.attribute _vpcSecurityGroupMemberships
        ]

instance TF.IsValid (DbOptionGroupOption s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_optionSettings"
                  (_optionSettings
                      :: DbOptionGroupOption s -> TF.Attr s [TF.Attr s (OptionOptionSettings s)])
                  TF.validator

instance P.HasDbSecurityGroupMemberships (DbOptionGroupOption s) (TF.Attr s [TF.Attr s P.Text]) where
    dbSecurityGroupMemberships =
        P.lens (_dbSecurityGroupMemberships :: DbOptionGroupOption s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _dbSecurityGroupMemberships = a } :: DbOptionGroupOption s)

instance P.HasOptionName (DbOptionGroupOption s) (TF.Attr s P.Text) where
    optionName =
        P.lens (_optionName :: DbOptionGroupOption s -> TF.Attr s P.Text)
               (\s a -> s { _optionName = a } :: DbOptionGroupOption s)

instance P.HasOptionSettings (DbOptionGroupOption s) (TF.Attr s [TF.Attr s (OptionOptionSettings s)]) where
    optionSettings =
        P.lens (_optionSettings :: DbOptionGroupOption s -> TF.Attr s [TF.Attr s (OptionOptionSettings s)])
               (\s a -> s { _optionSettings = a } :: DbOptionGroupOption s)

instance P.HasPort (DbOptionGroupOption s) (TF.Attr s P.Integer) where
    port =
        P.lens (_port :: DbOptionGroupOption s -> TF.Attr s P.Integer)
               (\s a -> s { _port = a } :: DbOptionGroupOption s)

instance P.HasVersion (DbOptionGroupOption s) (TF.Attr s P.Text) where
    version =
        P.lens (_version :: DbOptionGroupOption s -> TF.Attr s P.Text)
               (\s a -> s { _version = a } :: DbOptionGroupOption s)

instance P.HasVpcSecurityGroupMemberships (DbOptionGroupOption s) (TF.Attr s [TF.Attr s P.Text]) where
    vpcSecurityGroupMemberships =
        P.lens (_vpcSecurityGroupMemberships :: DbOptionGroupOption s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _vpcSecurityGroupMemberships = a } :: DbOptionGroupOption s)

-- | @route53_record_latency_routing_policy@ nested settings.
data Route53RecordLatencyRoutingPolicy s = Route53RecordLatencyRoutingPolicy'
    { _region :: TF.Attr s P.Text
    -- ^ @region@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRoute53RecordLatencyRoutingPolicy
    :: TF.Attr s P.Text -- ^ @region@ - 'P.region'
    -> Route53RecordLatencyRoutingPolicy s
newRoute53RecordLatencyRoutingPolicy _region =
    Route53RecordLatencyRoutingPolicy'
        { _region = _region
        }

instance P.Hashable  (Route53RecordLatencyRoutingPolicy s)
instance TF.IsValue  (Route53RecordLatencyRoutingPolicy s)
instance TF.IsObject (Route53RecordLatencyRoutingPolicy s) where
    toObject Route53RecordLatencyRoutingPolicy'{..} = P.catMaybes
        [ TF.assign "region" <$> TF.attribute _region
        ]

instance TF.IsValid (Route53RecordLatencyRoutingPolicy s) where
    validator = P.mempty

instance P.HasRegion (Route53RecordLatencyRoutingPolicy s) (TF.Attr s P.Text) where
    region =
        P.lens (_region :: Route53RecordLatencyRoutingPolicy s -> TF.Attr s P.Text)
               (\s a -> s { _region = a } :: Route53RecordLatencyRoutingPolicy s)

-- | @elasticsearch_domain_log_publishing_options@ nested settings.
data ElasticsearchDomainLogPublishingOptions s = ElasticsearchDomainLogPublishingOptions'
    { _cloudwatchLogGroupArn :: TF.Attr s P.Text
    -- ^ @cloudwatch_log_group_arn@ - (Required)
    --
    , _enabled               :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Optional)
    --
    , _logType               :: TF.Attr s P.Text
    -- ^ @log_type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElasticsearchDomainLogPublishingOptions
    :: TF.Attr s P.Text -- ^ @cloudwatch_log_group_arn@ - 'P.cloudwatchLogGroupArn'
    -> TF.Attr s P.Text -- ^ @log_type@ - 'P.logType'
    -> ElasticsearchDomainLogPublishingOptions s
newElasticsearchDomainLogPublishingOptions _cloudwatchLogGroupArn _logType =
    ElasticsearchDomainLogPublishingOptions'
        { _cloudwatchLogGroupArn = _cloudwatchLogGroupArn
        , _enabled = TF.value P.True
        , _logType = _logType
        }

instance P.Hashable  (ElasticsearchDomainLogPublishingOptions s)
instance TF.IsValue  (ElasticsearchDomainLogPublishingOptions s)
instance TF.IsObject (ElasticsearchDomainLogPublishingOptions s) where
    toObject ElasticsearchDomainLogPublishingOptions'{..} = P.catMaybes
        [ TF.assign "cloudwatch_log_group_arn" <$> TF.attribute _cloudwatchLogGroupArn
        , TF.assign "enabled" <$> TF.attribute _enabled
        , TF.assign "log_type" <$> TF.attribute _logType
        ]

instance TF.IsValid (ElasticsearchDomainLogPublishingOptions s) where
    validator = P.mempty

instance P.HasCloudwatchLogGroupArn (ElasticsearchDomainLogPublishingOptions s) (TF.Attr s P.Text) where
    cloudwatchLogGroupArn =
        P.lens (_cloudwatchLogGroupArn :: ElasticsearchDomainLogPublishingOptions s -> TF.Attr s P.Text)
               (\s a -> s { _cloudwatchLogGroupArn = a } :: ElasticsearchDomainLogPublishingOptions s)

instance P.HasEnabled (ElasticsearchDomainLogPublishingOptions s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: ElasticsearchDomainLogPublishingOptions s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: ElasticsearchDomainLogPublishingOptions s)

instance P.HasLogType (ElasticsearchDomainLogPublishingOptions s) (TF.Attr s P.Text) where
    logType =
        P.lens (_logType :: ElasticsearchDomainLogPublishingOptions s -> TF.Attr s P.Text)
               (\s a -> s { _logType = a } :: ElasticsearchDomainLogPublishingOptions s)

-- | @codedeploy_deployment_group_deployment_style@ nested settings.
data CodedeployDeploymentGroupDeploymentStyle s = CodedeployDeploymentGroupDeploymentStyle'
    { _deploymentOption :: TF.Attr s P.Text
    -- ^ @deployment_option@ - (Optional)
    --
    , _deploymentType   :: TF.Attr s P.Text
    -- ^ @deployment_type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCodedeployDeploymentGroupDeploymentStyle
    :: CodedeployDeploymentGroupDeploymentStyle s
newCodedeployDeploymentGroupDeploymentStyle =
    CodedeployDeploymentGroupDeploymentStyle'
        { _deploymentOption = TF.Nil
        , _deploymentType = TF.Nil
        }

instance P.Hashable  (CodedeployDeploymentGroupDeploymentStyle s)
instance TF.IsValue  (CodedeployDeploymentGroupDeploymentStyle s)
instance TF.IsObject (CodedeployDeploymentGroupDeploymentStyle s) where
    toObject CodedeployDeploymentGroupDeploymentStyle'{..} = P.catMaybes
        [ TF.assign "deployment_option" <$> TF.attribute _deploymentOption
        , TF.assign "deployment_type" <$> TF.attribute _deploymentType
        ]

instance TF.IsValid (CodedeployDeploymentGroupDeploymentStyle s) where
    validator = P.mempty

instance P.HasDeploymentOption (CodedeployDeploymentGroupDeploymentStyle s) (TF.Attr s P.Text) where
    deploymentOption =
        P.lens (_deploymentOption :: CodedeployDeploymentGroupDeploymentStyle s -> TF.Attr s P.Text)
               (\s a -> s { _deploymentOption = a } :: CodedeployDeploymentGroupDeploymentStyle s)

instance P.HasDeploymentType (CodedeployDeploymentGroupDeploymentStyle s) (TF.Attr s P.Text) where
    deploymentType =
        P.lens (_deploymentType :: CodedeployDeploymentGroupDeploymentStyle s -> TF.Attr s P.Text)
               (\s a -> s { _deploymentType = a } :: CodedeployDeploymentGroupDeploymentStyle s)

-- | @autoscaling_group_initial_lifecycle_hook@ nested settings.
data AutoscalingGroupInitialLifecycleHook s = AutoscalingGroupInitialLifecycleHook'
    { _heartbeatTimeout      :: TF.Attr s P.Integer
    -- ^ @heartbeat_timeout@ - (Optional)
    --
    , _lifecycleTransition   :: TF.Attr s P.Text
    -- ^ @lifecycle_transition@ - (Required)
    --
    , _name                  :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _notificationMetadata  :: TF.Attr s P.Text
    -- ^ @notification_metadata@ - (Optional)
    --
    , _notificationTargetArn :: TF.Attr s P.Text
    -- ^ @notification_target_arn@ - (Optional)
    --
    , _roleArn               :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newAutoscalingGroupInitialLifecycleHook
    :: TF.Attr s P.Text -- ^ @lifecycle_transition@ - 'P.lifecycleTransition'
    -> TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> AutoscalingGroupInitialLifecycleHook s
newAutoscalingGroupInitialLifecycleHook _lifecycleTransition _name =
    AutoscalingGroupInitialLifecycleHook'
        { _heartbeatTimeout = TF.Nil
        , _lifecycleTransition = _lifecycleTransition
        , _name = _name
        , _notificationMetadata = TF.Nil
        , _notificationTargetArn = TF.Nil
        , _roleArn = TF.Nil
        }

instance P.Hashable  (AutoscalingGroupInitialLifecycleHook s)
instance TF.IsValue  (AutoscalingGroupInitialLifecycleHook s)
instance TF.IsObject (AutoscalingGroupInitialLifecycleHook s) where
    toObject AutoscalingGroupInitialLifecycleHook'{..} = P.catMaybes
        [ TF.assign "heartbeat_timeout" <$> TF.attribute _heartbeatTimeout
        , TF.assign "lifecycle_transition" <$> TF.attribute _lifecycleTransition
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "notification_metadata" <$> TF.attribute _notificationMetadata
        , TF.assign "notification_target_arn" <$> TF.attribute _notificationTargetArn
        , TF.assign "role_arn" <$> TF.attribute _roleArn
        ]

instance TF.IsValid (AutoscalingGroupInitialLifecycleHook s) where
    validator = P.mempty

instance P.HasHeartbeatTimeout (AutoscalingGroupInitialLifecycleHook s) (TF.Attr s P.Integer) where
    heartbeatTimeout =
        P.lens (_heartbeatTimeout :: AutoscalingGroupInitialLifecycleHook s -> TF.Attr s P.Integer)
               (\s a -> s { _heartbeatTimeout = a } :: AutoscalingGroupInitialLifecycleHook s)

instance P.HasLifecycleTransition (AutoscalingGroupInitialLifecycleHook s) (TF.Attr s P.Text) where
    lifecycleTransition =
        P.lens (_lifecycleTransition :: AutoscalingGroupInitialLifecycleHook s -> TF.Attr s P.Text)
               (\s a -> s { _lifecycleTransition = a } :: AutoscalingGroupInitialLifecycleHook s)

instance P.HasName (AutoscalingGroupInitialLifecycleHook s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: AutoscalingGroupInitialLifecycleHook s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: AutoscalingGroupInitialLifecycleHook s)

instance P.HasNotificationMetadata (AutoscalingGroupInitialLifecycleHook s) (TF.Attr s P.Text) where
    notificationMetadata =
        P.lens (_notificationMetadata :: AutoscalingGroupInitialLifecycleHook s -> TF.Attr s P.Text)
               (\s a -> s { _notificationMetadata = a } :: AutoscalingGroupInitialLifecycleHook s)

instance P.HasNotificationTargetArn (AutoscalingGroupInitialLifecycleHook s) (TF.Attr s P.Text) where
    notificationTargetArn =
        P.lens (_notificationTargetArn :: AutoscalingGroupInitialLifecycleHook s -> TF.Attr s P.Text)
               (\s a -> s { _notificationTargetArn = a } :: AutoscalingGroupInitialLifecycleHook s)

instance P.HasRoleArn (AutoscalingGroupInitialLifecycleHook s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: AutoscalingGroupInitialLifecycleHook s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: AutoscalingGroupInitialLifecycleHook s)

instance s ~ s' => P.HasComputedDefaultResult (TF.Ref s' (AutoscalingGroupInitialLifecycleHook s)) (TF.Attr s P.Text) where
    computedDefaultResult x = TF.compute (TF.refKey x) "default_result"

-- | @s3_bucket_notification_lambda_function@ nested settings.
data S3BucketNotificationLambdaFunction s = S3BucketNotificationLambdaFunction'
    { _events            :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @events@ - (Required)
    --
    , _filterPrefix      :: TF.Attr s P.Text
    -- ^ @filter_prefix@ - (Optional)
    --
    , _filterSuffix      :: TF.Attr s P.Text
    -- ^ @filter_suffix@ - (Optional)
    --
    , _lambdaFunctionArn :: TF.Attr s P.Text
    -- ^ @lambda_function_arn@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newS3BucketNotificationLambdaFunction
    :: TF.Attr s [TF.Attr s P.Text] -- ^ @events@ - 'P.events'
    -> S3BucketNotificationLambdaFunction s
newS3BucketNotificationLambdaFunction _events =
    S3BucketNotificationLambdaFunction'
        { _events = _events
        , _filterPrefix = TF.Nil
        , _filterSuffix = TF.Nil
        , _lambdaFunctionArn = TF.Nil
        }

instance P.Hashable  (S3BucketNotificationLambdaFunction s)
instance TF.IsValue  (S3BucketNotificationLambdaFunction s)
instance TF.IsObject (S3BucketNotificationLambdaFunction s) where
    toObject S3BucketNotificationLambdaFunction'{..} = P.catMaybes
        [ TF.assign "events" <$> TF.attribute _events
        , TF.assign "filter_prefix" <$> TF.attribute _filterPrefix
        , TF.assign "filter_suffix" <$> TF.attribute _filterSuffix
        , TF.assign "lambda_function_arn" <$> TF.attribute _lambdaFunctionArn
        ]

instance TF.IsValid (S3BucketNotificationLambdaFunction s) where
    validator = P.mempty

instance P.HasEvents (S3BucketNotificationLambdaFunction s) (TF.Attr s [TF.Attr s P.Text]) where
    events =
        P.lens (_events :: S3BucketNotificationLambdaFunction s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _events = a } :: S3BucketNotificationLambdaFunction s)

instance P.HasFilterPrefix (S3BucketNotificationLambdaFunction s) (TF.Attr s P.Text) where
    filterPrefix =
        P.lens (_filterPrefix :: S3BucketNotificationLambdaFunction s -> TF.Attr s P.Text)
               (\s a -> s { _filterPrefix = a } :: S3BucketNotificationLambdaFunction s)

instance P.HasFilterSuffix (S3BucketNotificationLambdaFunction s) (TF.Attr s P.Text) where
    filterSuffix =
        P.lens (_filterSuffix :: S3BucketNotificationLambdaFunction s -> TF.Attr s P.Text)
               (\s a -> s { _filterSuffix = a } :: S3BucketNotificationLambdaFunction s)

instance P.HasLambdaFunctionArn (S3BucketNotificationLambdaFunction s) (TF.Attr s P.Text) where
    lambdaFunctionArn =
        P.lens (_lambdaFunctionArn :: S3BucketNotificationLambdaFunction s -> TF.Attr s P.Text)
               (\s a -> s { _lambdaFunctionArn = a } :: S3BucketNotificationLambdaFunction s)

instance s ~ s' => P.HasComputedId (TF.Ref s' (S3BucketNotificationLambdaFunction s)) (TF.Attr s P.Text) where
    computedId x = TF.compute (TF.refKey x) "id"

-- | @source_selection_criteria_sse_kms_encrypted_objects@ nested settings.
data SourceSelectionCriteriaSseKmsEncryptedObjects s = SourceSelectionCriteriaSseKmsEncryptedObjects'
    { _enabled :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSourceSelectionCriteriaSseKmsEncryptedObjects
    :: TF.Attr s P.Bool -- ^ @enabled@ - 'P.enabled'
    -> SourceSelectionCriteriaSseKmsEncryptedObjects s
newSourceSelectionCriteriaSseKmsEncryptedObjects _enabled =
    SourceSelectionCriteriaSseKmsEncryptedObjects'
        { _enabled = _enabled
        }

instance P.Hashable  (SourceSelectionCriteriaSseKmsEncryptedObjects s)
instance TF.IsValue  (SourceSelectionCriteriaSseKmsEncryptedObjects s)
instance TF.IsObject (SourceSelectionCriteriaSseKmsEncryptedObjects s) where
    toObject SourceSelectionCriteriaSseKmsEncryptedObjects'{..} = P.catMaybes
        [ TF.assign "enabled" <$> TF.attribute _enabled
        ]

instance TF.IsValid (SourceSelectionCriteriaSseKmsEncryptedObjects s) where
    validator = P.mempty

instance P.HasEnabled (SourceSelectionCriteriaSseKmsEncryptedObjects s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: SourceSelectionCriteriaSseKmsEncryptedObjects s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: SourceSelectionCriteriaSseKmsEncryptedObjects s)

-- | @route_table_route@ nested settings.
data RouteTableRoute s = RouteTableRoute'
    { _cidrBlock              :: TF.Attr s P.Text
    -- ^ @cidr_block@ - (Optional)
    --
    , _egressOnlyGatewayId    :: TF.Attr s P.Text
    -- ^ @egress_only_gateway_id@ - (Optional)
    --
    , _gatewayId              :: TF.Attr s P.Text
    -- ^ @gateway_id@ - (Optional)
    --
    , _instanceId             :: TF.Attr s P.Text
    -- ^ @instance_id@ - (Optional)
    --
    , _ipv6CidrBlock          :: TF.Attr s P.Text
    -- ^ @ipv6_cidr_block@ - (Optional)
    --
    , _natGatewayId           :: TF.Attr s P.Text
    -- ^ @nat_gateway_id@ - (Optional)
    --
    , _networkInterfaceId     :: TF.Attr s P.Text
    -- ^ @network_interface_id@ - (Optional)
    --
    , _vpcPeeringConnectionId :: TF.Attr s P.Text
    -- ^ @vpc_peering_connection_id@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newRouteTableRoute
    :: RouteTableRoute s
newRouteTableRoute =
    RouteTableRoute'
        { _cidrBlock = TF.Nil
        , _egressOnlyGatewayId = TF.Nil
        , _gatewayId = TF.Nil
        , _instanceId = TF.Nil
        , _ipv6CidrBlock = TF.Nil
        , _natGatewayId = TF.Nil
        , _networkInterfaceId = TF.Nil
        , _vpcPeeringConnectionId = TF.Nil
        }

instance P.Hashable  (RouteTableRoute s)
instance TF.IsValue  (RouteTableRoute s)
instance TF.IsObject (RouteTableRoute s) where
    toObject RouteTableRoute'{..} = P.catMaybes
        [ TF.assign "cidr_block" <$> TF.attribute _cidrBlock
        , TF.assign "egress_only_gateway_id" <$> TF.attribute _egressOnlyGatewayId
        , TF.assign "gateway_id" <$> TF.attribute _gatewayId
        , TF.assign "instance_id" <$> TF.attribute _instanceId
        , TF.assign "ipv6_cidr_block" <$> TF.attribute _ipv6CidrBlock
        , TF.assign "nat_gateway_id" <$> TF.attribute _natGatewayId
        , TF.assign "network_interface_id" <$> TF.attribute _networkInterfaceId
        , TF.assign "vpc_peering_connection_id" <$> TF.attribute _vpcPeeringConnectionId
        ]

instance TF.IsValid (RouteTableRoute s) where
    validator = P.mempty

instance P.HasCidrBlock (RouteTableRoute s) (TF.Attr s P.Text) where
    cidrBlock =
        P.lens (_cidrBlock :: RouteTableRoute s -> TF.Attr s P.Text)
               (\s a -> s { _cidrBlock = a } :: RouteTableRoute s)

instance P.HasEgressOnlyGatewayId (RouteTableRoute s) (TF.Attr s P.Text) where
    egressOnlyGatewayId =
        P.lens (_egressOnlyGatewayId :: RouteTableRoute s -> TF.Attr s P.Text)
               (\s a -> s { _egressOnlyGatewayId = a } :: RouteTableRoute s)

instance P.HasGatewayId (RouteTableRoute s) (TF.Attr s P.Text) where
    gatewayId =
        P.lens (_gatewayId :: RouteTableRoute s -> TF.Attr s P.Text)
               (\s a -> s { _gatewayId = a } :: RouteTableRoute s)

instance P.HasInstanceId (RouteTableRoute s) (TF.Attr s P.Text) where
    instanceId =
        P.lens (_instanceId :: RouteTableRoute s -> TF.Attr s P.Text)
               (\s a -> s { _instanceId = a } :: RouteTableRoute s)

instance P.HasIpv6CidrBlock (RouteTableRoute s) (TF.Attr s P.Text) where
    ipv6CidrBlock =
        P.lens (_ipv6CidrBlock :: RouteTableRoute s -> TF.Attr s P.Text)
               (\s a -> s { _ipv6CidrBlock = a } :: RouteTableRoute s)

instance P.HasNatGatewayId (RouteTableRoute s) (TF.Attr s P.Text) where
    natGatewayId =
        P.lens (_natGatewayId :: RouteTableRoute s -> TF.Attr s P.Text)
               (\s a -> s { _natGatewayId = a } :: RouteTableRoute s)

instance P.HasNetworkInterfaceId (RouteTableRoute s) (TF.Attr s P.Text) where
    networkInterfaceId =
        P.lens (_networkInterfaceId :: RouteTableRoute s -> TF.Attr s P.Text)
               (\s a -> s { _networkInterfaceId = a } :: RouteTableRoute s)

instance P.HasVpcPeeringConnectionId (RouteTableRoute s) (TF.Attr s P.Text) where
    vpcPeeringConnectionId =
        P.lens (_vpcPeeringConnectionId :: RouteTableRoute s -> TF.Attr s P.Text)
               (\s a -> s { _vpcPeeringConnectionId = a } :: RouteTableRoute s)

-- | @instance_filter@ nested settings.
data InstanceFilter s = InstanceFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newInstanceFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> InstanceFilter s
newInstanceFilter _name _values =
    InstanceFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (InstanceFilter s)
instance TF.IsValue  (InstanceFilter s)
instance TF.IsObject (InstanceFilter s) where
    toObject InstanceFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (InstanceFilter s) where
    validator = P.mempty

instance P.HasName (InstanceFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: InstanceFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: InstanceFilter s)

instance P.HasValues (InstanceFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: InstanceFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: InstanceFilter s)

-- | @vpc_peering_connection_options_accepter@ nested settings.
data VpcPeeringConnectionOptionsAccepter s = VpcPeeringConnectionOptionsAccepter'
    { _allowClassicLinkToRemoteVpc :: TF.Attr s P.Bool
    -- ^ @allow_classic_link_to_remote_vpc@ - (Optional)
    --
    , _allowRemoteVpcDnsResolution :: TF.Attr s P.Bool
    -- ^ @allow_remote_vpc_dns_resolution@ - (Optional)
    --
    , _allowVpcToRemoteClassicLink :: TF.Attr s P.Bool
    -- ^ @allow_vpc_to_remote_classic_link@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newVpcPeeringConnectionOptionsAccepter
    :: VpcPeeringConnectionOptionsAccepter s
newVpcPeeringConnectionOptionsAccepter =
    VpcPeeringConnectionOptionsAccepter'
        { _allowClassicLinkToRemoteVpc = TF.value P.False
        , _allowRemoteVpcDnsResolution = TF.value P.False
        , _allowVpcToRemoteClassicLink = TF.value P.False
        }

instance P.Hashable  (VpcPeeringConnectionOptionsAccepter s)
instance TF.IsValue  (VpcPeeringConnectionOptionsAccepter s)
instance TF.IsObject (VpcPeeringConnectionOptionsAccepter s) where
    toObject VpcPeeringConnectionOptionsAccepter'{..} = P.catMaybes
        [ TF.assign "allow_classic_link_to_remote_vpc" <$> TF.attribute _allowClassicLinkToRemoteVpc
        , TF.assign "allow_remote_vpc_dns_resolution" <$> TF.attribute _allowRemoteVpcDnsResolution
        , TF.assign "allow_vpc_to_remote_classic_link" <$> TF.attribute _allowVpcToRemoteClassicLink
        ]

instance TF.IsValid (VpcPeeringConnectionOptionsAccepter s) where
    validator = P.mempty

instance P.HasAllowClassicLinkToRemoteVpc (VpcPeeringConnectionOptionsAccepter s) (TF.Attr s P.Bool) where
    allowClassicLinkToRemoteVpc =
        P.lens (_allowClassicLinkToRemoteVpc :: VpcPeeringConnectionOptionsAccepter s -> TF.Attr s P.Bool)
               (\s a -> s { _allowClassicLinkToRemoteVpc = a } :: VpcPeeringConnectionOptionsAccepter s)

instance P.HasAllowRemoteVpcDnsResolution (VpcPeeringConnectionOptionsAccepter s) (TF.Attr s P.Bool) where
    allowRemoteVpcDnsResolution =
        P.lens (_allowRemoteVpcDnsResolution :: VpcPeeringConnectionOptionsAccepter s -> TF.Attr s P.Bool)
               (\s a -> s { _allowRemoteVpcDnsResolution = a } :: VpcPeeringConnectionOptionsAccepter s)

instance P.HasAllowVpcToRemoteClassicLink (VpcPeeringConnectionOptionsAccepter s) (TF.Attr s P.Bool) where
    allowVpcToRemoteClassicLink =
        P.lens (_allowVpcToRemoteClassicLink :: VpcPeeringConnectionOptionsAccepter s -> TF.Attr s P.Bool)
               (\s a -> s { _allowVpcToRemoteClassicLink = a } :: VpcPeeringConnectionOptionsAccepter s)

-- | @iot_topic_rule_elasticsearch@ nested settings.
data IotTopicRuleElasticsearch s = IotTopicRuleElasticsearch'
    { _endpoint :: TF.Attr s P.Text
    -- ^ @endpoint@ - (Required)
    --
    , _id       :: TF.Attr s P.Text
    -- ^ @id@ - (Required)
    --
    , _index    :: TF.Attr s P.Text
    -- ^ @index@ - (Required)
    --
    , _roleArn  :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Required)
    --
    , _type'    :: TF.Attr s P.Text
    -- ^ @type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newIotTopicRuleElasticsearch
    :: TF.Attr s P.Text -- ^ @endpoint@ - 'P.endpoint'
    -> TF.Attr s P.Text -- ^ @id@ - 'P.id'
    -> TF.Attr s P.Text -- ^ @index@ - 'P.index'
    -> TF.Attr s P.Text -- ^ @role_arn@ - 'P.roleArn'
    -> TF.Attr s P.Text -- ^ @type@ - 'P.type''
    -> IotTopicRuleElasticsearch s
newIotTopicRuleElasticsearch _endpoint _id _index _roleArn _type' =
    IotTopicRuleElasticsearch'
        { _endpoint = _endpoint
        , _id = _id
        , _index = _index
        , _roleArn = _roleArn
        , _type' = _type'
        }

instance P.Hashable  (IotTopicRuleElasticsearch s)
instance TF.IsValue  (IotTopicRuleElasticsearch s)
instance TF.IsObject (IotTopicRuleElasticsearch s) where
    toObject IotTopicRuleElasticsearch'{..} = P.catMaybes
        [ TF.assign "endpoint" <$> TF.attribute _endpoint
        , TF.assign "id" <$> TF.attribute _id
        , TF.assign "index" <$> TF.attribute _index
        , TF.assign "role_arn" <$> TF.attribute _roleArn
        , TF.assign "type" <$> TF.attribute _type'
        ]

instance TF.IsValid (IotTopicRuleElasticsearch s) where
    validator = P.mempty

instance P.HasEndpoint (IotTopicRuleElasticsearch s) (TF.Attr s P.Text) where
    endpoint =
        P.lens (_endpoint :: IotTopicRuleElasticsearch s -> TF.Attr s P.Text)
               (\s a -> s { _endpoint = a } :: IotTopicRuleElasticsearch s)

instance P.HasId (IotTopicRuleElasticsearch s) (TF.Attr s P.Text) where
    id =
        P.lens (_id :: IotTopicRuleElasticsearch s -> TF.Attr s P.Text)
               (\s a -> s { _id = a } :: IotTopicRuleElasticsearch s)

instance P.HasIndex (IotTopicRuleElasticsearch s) (TF.Attr s P.Text) where
    index =
        P.lens (_index :: IotTopicRuleElasticsearch s -> TF.Attr s P.Text)
               (\s a -> s { _index = a } :: IotTopicRuleElasticsearch s)

instance P.HasRoleArn (IotTopicRuleElasticsearch s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: IotTopicRuleElasticsearch s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: IotTopicRuleElasticsearch s)

instance P.HasType' (IotTopicRuleElasticsearch s) (TF.Attr s P.Text) where
    type' =
        P.lens (_type' :: IotTopicRuleElasticsearch s -> TF.Attr s P.Text)
               (\s a -> s { _type' = a } :: IotTopicRuleElasticsearch s)

-- | @instance_root_block_device@ nested settings.
data InstanceRootBlockDevice s = InstanceRootBlockDevice'
    { _deleteOnTermination :: TF.Attr s P.Bool
    -- ^ @delete_on_termination@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newInstanceRootBlockDevice
    :: InstanceRootBlockDevice s
newInstanceRootBlockDevice =
    InstanceRootBlockDevice'
        { _deleteOnTermination = TF.value P.True
        }

instance P.Hashable  (InstanceRootBlockDevice s)
instance TF.IsValue  (InstanceRootBlockDevice s)
instance TF.IsObject (InstanceRootBlockDevice s) where
    toObject InstanceRootBlockDevice'{..} = P.catMaybes
        [ TF.assign "delete_on_termination" <$> TF.attribute _deleteOnTermination
        ]

instance TF.IsValid (InstanceRootBlockDevice s) where
    validator = P.mempty

instance P.HasDeleteOnTermination (InstanceRootBlockDevice s) (TF.Attr s P.Bool) where
    deleteOnTermination =
        P.lens (_deleteOnTermination :: InstanceRootBlockDevice s -> TF.Attr s P.Bool)
               (\s a -> s { _deleteOnTermination = a } :: InstanceRootBlockDevice s)

instance s ~ s' => P.HasComputedIops (TF.Ref s' (InstanceRootBlockDevice s)) (TF.Attr s P.Integer) where
    computedIops x = TF.compute (TF.refKey x) "iops"

instance s ~ s' => P.HasComputedVolumeId (TF.Ref s' (InstanceRootBlockDevice s)) (TF.Attr s P.Text) where
    computedVolumeId x = TF.compute (TF.refKey x) "volume_id"

instance s ~ s' => P.HasComputedVolumeSize (TF.Ref s' (InstanceRootBlockDevice s)) (TF.Attr s P.Integer) where
    computedVolumeSize x = TF.compute (TF.refKey x) "volume_size"

instance s ~ s' => P.HasComputedVolumeType (TF.Ref s' (InstanceRootBlockDevice s)) (TF.Attr s P.Text) where
    computedVolumeType x = TF.compute (TF.refKey x) "volume_type"

instance s ~ s' => P.HasComputedDeleteOnTermination (TF.Ref s' (InstanceRootBlockDevice s)) (TF.Attr s P.Bool) where
    computedDeleteOnTermination x = TF.compute (TF.refKey x) "delete_on_termination"

-- | @kinesis_firehose_delivery_stream_splunk_configuration@ nested settings.
data KinesisFirehoseDeliveryStreamSplunkConfiguration s = KinesisFirehoseDeliveryStreamSplunkConfiguration'
    { _hecAcknowledgmentTimeout :: TF.Attr s P.Integer
    -- ^ @hec_acknowledgment_timeout@ - (Optional)
    --
    , _hecEndpoint :: TF.Attr s P.Text
    -- ^ @hec_endpoint@ - (Required)
    --
    , _hecEndpointType :: TF.Attr s P.Text
    -- ^ @hec_endpoint_type@ - (Optional)
    --
    , _hecToken :: TF.Attr s P.Text
    -- ^ @hec_token@ - (Required)
    --
    , _processingConfiguration :: TF.Attr s (SplunkConfigurationProcessingConfiguration s)
    -- ^ @processing_configuration@ - (Optional)
    --
    , _retryDuration :: TF.Attr s P.Integer
    -- ^ @retry_duration@ - (Optional)
    --
    , _s3BackupMode :: TF.Attr s P.Text
    -- ^ @s3_backup_mode@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newKinesisFirehoseDeliveryStreamSplunkConfiguration
    :: TF.Attr s P.Text -- ^ @hec_endpoint@ - 'P.hecEndpoint'
    -> TF.Attr s P.Text -- ^ @hec_token@ - 'P.hecToken'
    -> KinesisFirehoseDeliveryStreamSplunkConfiguration s
newKinesisFirehoseDeliveryStreamSplunkConfiguration _hecEndpoint _hecToken =
    KinesisFirehoseDeliveryStreamSplunkConfiguration'
        { _hecAcknowledgmentTimeout = TF.value 180
        , _hecEndpoint = _hecEndpoint
        , _hecEndpointType = TF.value "Raw"
        , _hecToken = _hecToken
        , _processingConfiguration = TF.Nil
        , _retryDuration = TF.value 3600
        , _s3BackupMode = TF.value "FailedEventsOnly"
        }

instance P.Hashable  (KinesisFirehoseDeliveryStreamSplunkConfiguration s)
instance TF.IsValue  (KinesisFirehoseDeliveryStreamSplunkConfiguration s)
instance TF.IsObject (KinesisFirehoseDeliveryStreamSplunkConfiguration s) where
    toObject KinesisFirehoseDeliveryStreamSplunkConfiguration'{..} = P.catMaybes
        [ TF.assign "hec_acknowledgment_timeout" <$> TF.attribute _hecAcknowledgmentTimeout
        , TF.assign "hec_endpoint" <$> TF.attribute _hecEndpoint
        , TF.assign "hec_endpoint_type" <$> TF.attribute _hecEndpointType
        , TF.assign "hec_token" <$> TF.attribute _hecToken
        , TF.assign "processing_configuration" <$> TF.attribute _processingConfiguration
        , TF.assign "retry_duration" <$> TF.attribute _retryDuration
        , TF.assign "s3_backup_mode" <$> TF.attribute _s3BackupMode
        ]

instance TF.IsValid (KinesisFirehoseDeliveryStreamSplunkConfiguration s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_processingConfiguration"
                  (_processingConfiguration
                      :: KinesisFirehoseDeliveryStreamSplunkConfiguration s -> TF.Attr s (SplunkConfigurationProcessingConfiguration s))
                  TF.validator

instance P.HasHecAcknowledgmentTimeout (KinesisFirehoseDeliveryStreamSplunkConfiguration s) (TF.Attr s P.Integer) where
    hecAcknowledgmentTimeout =
        P.lens (_hecAcknowledgmentTimeout :: KinesisFirehoseDeliveryStreamSplunkConfiguration s -> TF.Attr s P.Integer)
               (\s a -> s { _hecAcknowledgmentTimeout = a } :: KinesisFirehoseDeliveryStreamSplunkConfiguration s)

instance P.HasHecEndpoint (KinesisFirehoseDeliveryStreamSplunkConfiguration s) (TF.Attr s P.Text) where
    hecEndpoint =
        P.lens (_hecEndpoint :: KinesisFirehoseDeliveryStreamSplunkConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _hecEndpoint = a } :: KinesisFirehoseDeliveryStreamSplunkConfiguration s)

instance P.HasHecEndpointType (KinesisFirehoseDeliveryStreamSplunkConfiguration s) (TF.Attr s P.Text) where
    hecEndpointType =
        P.lens (_hecEndpointType :: KinesisFirehoseDeliveryStreamSplunkConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _hecEndpointType = a } :: KinesisFirehoseDeliveryStreamSplunkConfiguration s)

instance P.HasHecToken (KinesisFirehoseDeliveryStreamSplunkConfiguration s) (TF.Attr s P.Text) where
    hecToken =
        P.lens (_hecToken :: KinesisFirehoseDeliveryStreamSplunkConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _hecToken = a } :: KinesisFirehoseDeliveryStreamSplunkConfiguration s)

instance P.HasProcessingConfiguration (KinesisFirehoseDeliveryStreamSplunkConfiguration s) (TF.Attr s (SplunkConfigurationProcessingConfiguration s)) where
    processingConfiguration =
        P.lens (_processingConfiguration :: KinesisFirehoseDeliveryStreamSplunkConfiguration s -> TF.Attr s (SplunkConfigurationProcessingConfiguration s))
               (\s a -> s { _processingConfiguration = a } :: KinesisFirehoseDeliveryStreamSplunkConfiguration s)

instance P.HasRetryDuration (KinesisFirehoseDeliveryStreamSplunkConfiguration s) (TF.Attr s P.Integer) where
    retryDuration =
        P.lens (_retryDuration :: KinesisFirehoseDeliveryStreamSplunkConfiguration s -> TF.Attr s P.Integer)
               (\s a -> s { _retryDuration = a } :: KinesisFirehoseDeliveryStreamSplunkConfiguration s)

instance P.HasS3BackupMode (KinesisFirehoseDeliveryStreamSplunkConfiguration s) (TF.Attr s P.Text) where
    s3BackupMode =
        P.lens (_s3BackupMode :: KinesisFirehoseDeliveryStreamSplunkConfiguration s -> TF.Attr s P.Text)
               (\s a -> s { _s3BackupMode = a } :: KinesisFirehoseDeliveryStreamSplunkConfiguration s)

instance s ~ s' => P.HasComputedCloudwatchLoggingOptions (TF.Ref s' (KinesisFirehoseDeliveryStreamSplunkConfiguration s)) (TF.Attr s (SplunkConfigurationCloudwatchLoggingOptions s)) where
    computedCloudwatchLoggingOptions x = TF.compute (TF.refKey x) "cloudwatch_logging_options"

-- | @opsworks_application_environment@ nested settings.
data OpsworksApplicationEnvironment s = OpsworksApplicationEnvironment'
    { _key    :: TF.Attr s P.Text
    -- ^ @key@ - (Required)
    --
    , _secure :: TF.Attr s P.Bool
    -- ^ @secure@ - (Optional)
    --
    , _value  :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newOpsworksApplicationEnvironment
    :: TF.Attr s P.Text -- ^ @key@ - 'P.key'
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> OpsworksApplicationEnvironment s
newOpsworksApplicationEnvironment _key _value =
    OpsworksApplicationEnvironment'
        { _key = _key
        , _secure = TF.value P.True
        , _value = _value
        }

instance P.Hashable  (OpsworksApplicationEnvironment s)
instance TF.IsValue  (OpsworksApplicationEnvironment s)
instance TF.IsObject (OpsworksApplicationEnvironment s) where
    toObject OpsworksApplicationEnvironment'{..} = P.catMaybes
        [ TF.assign "key" <$> TF.attribute _key
        , TF.assign "secure" <$> TF.attribute _secure
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (OpsworksApplicationEnvironment s) where
    validator = P.mempty

instance P.HasKey (OpsworksApplicationEnvironment s) (TF.Attr s P.Text) where
    key =
        P.lens (_key :: OpsworksApplicationEnvironment s -> TF.Attr s P.Text)
               (\s a -> s { _key = a } :: OpsworksApplicationEnvironment s)

instance P.HasSecure (OpsworksApplicationEnvironment s) (TF.Attr s P.Bool) where
    secure =
        P.lens (_secure :: OpsworksApplicationEnvironment s -> TF.Attr s P.Bool)
               (\s a -> s { _secure = a } :: OpsworksApplicationEnvironment s)

instance P.HasValue (OpsworksApplicationEnvironment s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: OpsworksApplicationEnvironment s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: OpsworksApplicationEnvironment s)

-- | @glue_script_dag_node@ nested settings.
data GlueScriptDagNode s = GlueScriptDagNode'
    { _args       :: TF.Attr s (P.NonEmpty (TF.Attr s (DagNodeArgs s)))
    -- ^ @args@ - (Required)
    --
    , _id         :: TF.Attr s P.Text
    -- ^ @id@ - (Required)
    --
    , _lineNumber :: TF.Attr s P.Integer
    -- ^ @line_number@ - (Optional)
    --
    , _nodeType   :: TF.Attr s P.Text
    -- ^ @node_type@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newGlueScriptDagNode
    :: TF.Attr s (P.NonEmpty (TF.Attr s (DagNodeArgs s))) -- ^ @args@ - 'P.args'
    -> TF.Attr s P.Text -- ^ @id@ - 'P.id'
    -> TF.Attr s P.Text -- ^ @node_type@ - 'P.nodeType'
    -> GlueScriptDagNode s
newGlueScriptDagNode _args _id _nodeType =
    GlueScriptDagNode'
        { _args = _args
        , _id = _id
        , _lineNumber = TF.Nil
        , _nodeType = _nodeType
        }

instance P.Hashable  (GlueScriptDagNode s)
instance TF.IsValue  (GlueScriptDagNode s)
instance TF.IsObject (GlueScriptDagNode s) where
    toObject GlueScriptDagNode'{..} = P.catMaybes
        [ TF.assign "args" <$> TF.attribute _args
        , TF.assign "id" <$> TF.attribute _id
        , TF.assign "line_number" <$> TF.attribute _lineNumber
        , TF.assign "node_type" <$> TF.attribute _nodeType
        ]

instance TF.IsValid (GlueScriptDagNode s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_args"
                  (_args
                      :: GlueScriptDagNode s -> TF.Attr s (P.NonEmpty (TF.Attr s (DagNodeArgs s))))
                  TF.validator

instance P.HasArgs (GlueScriptDagNode s) (TF.Attr s (P.NonEmpty (TF.Attr s (DagNodeArgs s)))) where
    args =
        P.lens (_args :: GlueScriptDagNode s -> TF.Attr s (P.NonEmpty (TF.Attr s (DagNodeArgs s))))
               (\s a -> s { _args = a } :: GlueScriptDagNode s)

instance P.HasId (GlueScriptDagNode s) (TF.Attr s P.Text) where
    id =
        P.lens (_id :: GlueScriptDagNode s -> TF.Attr s P.Text)
               (\s a -> s { _id = a } :: GlueScriptDagNode s)

instance P.HasLineNumber (GlueScriptDagNode s) (TF.Attr s P.Integer) where
    lineNumber =
        P.lens (_lineNumber :: GlueScriptDagNode s -> TF.Attr s P.Integer)
               (\s a -> s { _lineNumber = a } :: GlueScriptDagNode s)

instance P.HasNodeType (GlueScriptDagNode s) (TF.Attr s P.Text) where
    nodeType =
        P.lens (_nodeType :: GlueScriptDagNode s -> TF.Attr s P.Text)
               (\s a -> s { _nodeType = a } :: GlueScriptDagNode s)

-- | @ses_event_destination_cloudwatch_destination@ nested settings.
data SesEventDestinationCloudwatchDestination s = SesEventDestinationCloudwatchDestination'
    { _defaultValue  :: TF.Attr s P.Text
    -- ^ @default_value@ - (Required)
    --
    , _dimensionName :: TF.Attr s P.Text
    -- ^ @dimension_name@ - (Required)
    --
    , _valueSource   :: TF.Attr s P.Text
    -- ^ @value_source@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSesEventDestinationCloudwatchDestination
    :: TF.Attr s P.Text -- ^ @default_value@ - 'P.defaultValue'
    -> TF.Attr s P.Text -- ^ @dimension_name@ - 'P.dimensionName'
    -> TF.Attr s P.Text -- ^ @value_source@ - 'P.valueSource'
    -> SesEventDestinationCloudwatchDestination s
newSesEventDestinationCloudwatchDestination _defaultValue _dimensionName _valueSource =
    SesEventDestinationCloudwatchDestination'
        { _defaultValue = _defaultValue
        , _dimensionName = _dimensionName
        , _valueSource = _valueSource
        }

instance P.Hashable  (SesEventDestinationCloudwatchDestination s)
instance TF.IsValue  (SesEventDestinationCloudwatchDestination s)
instance TF.IsObject (SesEventDestinationCloudwatchDestination s) where
    toObject SesEventDestinationCloudwatchDestination'{..} = P.catMaybes
        [ TF.assign "default_value" <$> TF.attribute _defaultValue
        , TF.assign "dimension_name" <$> TF.attribute _dimensionName
        , TF.assign "value_source" <$> TF.attribute _valueSource
        ]

instance TF.IsValid (SesEventDestinationCloudwatchDestination s) where
    validator = P.mempty

instance P.HasDefaultValue (SesEventDestinationCloudwatchDestination s) (TF.Attr s P.Text) where
    defaultValue =
        P.lens (_defaultValue :: SesEventDestinationCloudwatchDestination s -> TF.Attr s P.Text)
               (\s a -> s { _defaultValue = a } :: SesEventDestinationCloudwatchDestination s)

instance P.HasDimensionName (SesEventDestinationCloudwatchDestination s) (TF.Attr s P.Text) where
    dimensionName =
        P.lens (_dimensionName :: SesEventDestinationCloudwatchDestination s -> TF.Attr s P.Text)
               (\s a -> s { _dimensionName = a } :: SesEventDestinationCloudwatchDestination s)

instance P.HasValueSource (SesEventDestinationCloudwatchDestination s) (TF.Attr s P.Text) where
    valueSource =
        P.lens (_valueSource :: SesEventDestinationCloudwatchDestination s -> TF.Attr s P.Text)
               (\s a -> s { _valueSource = a } :: SesEventDestinationCloudwatchDestination s)

-- | @elastictranscoder_pipeline_content_config_permissions@ nested settings.
data ElastictranscoderPipelineContentConfigPermissions s = ElastictranscoderPipelineContentConfigPermissions'
    { _access      :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @access@ - (Optional)
    --
    , _grantee     :: TF.Attr s P.Text
    -- ^ @grantee@ - (Optional)
    --
    , _granteeType :: TF.Attr s P.Text
    -- ^ @grantee_type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElastictranscoderPipelineContentConfigPermissions
    :: ElastictranscoderPipelineContentConfigPermissions s
newElastictranscoderPipelineContentConfigPermissions =
    ElastictranscoderPipelineContentConfigPermissions'
        { _access = TF.Nil
        , _grantee = TF.Nil
        , _granteeType = TF.Nil
        }

instance P.Hashable  (ElastictranscoderPipelineContentConfigPermissions s)
instance TF.IsValue  (ElastictranscoderPipelineContentConfigPermissions s)
instance TF.IsObject (ElastictranscoderPipelineContentConfigPermissions s) where
    toObject ElastictranscoderPipelineContentConfigPermissions'{..} = P.catMaybes
        [ TF.assign "access" <$> TF.attribute _access
        , TF.assign "grantee" <$> TF.attribute _grantee
        , TF.assign "grantee_type" <$> TF.attribute _granteeType
        ]

instance TF.IsValid (ElastictranscoderPipelineContentConfigPermissions s) where
    validator = P.mempty

instance P.HasAccess (ElastictranscoderPipelineContentConfigPermissions s) (TF.Attr s [TF.Attr s P.Text]) where
    access =
        P.lens (_access :: ElastictranscoderPipelineContentConfigPermissions s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _access = a } :: ElastictranscoderPipelineContentConfigPermissions s)

instance P.HasGrantee (ElastictranscoderPipelineContentConfigPermissions s) (TF.Attr s P.Text) where
    grantee =
        P.lens (_grantee :: ElastictranscoderPipelineContentConfigPermissions s -> TF.Attr s P.Text)
               (\s a -> s { _grantee = a } :: ElastictranscoderPipelineContentConfigPermissions s)

instance P.HasGranteeType (ElastictranscoderPipelineContentConfigPermissions s) (TF.Attr s P.Text) where
    granteeType =
        P.lens (_granteeType :: ElastictranscoderPipelineContentConfigPermissions s -> TF.Attr s P.Text)
               (\s a -> s { _granteeType = a } :: ElastictranscoderPipelineContentConfigPermissions s)

-- | @lb_subnet_mapping@ nested settings.
data LbSubnetMapping s = LbSubnetMapping'
    { _allocationId :: TF.Attr s P.Text
    -- ^ @allocation_id@ - (Optional, Forces New)
    --
    , _subnetId     :: TF.Attr s P.Text
    -- ^ @subnet_id@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLbSubnetMapping
    :: TF.Attr s P.Text -- ^ @subnet_id@ - 'P.subnetId'
    -> LbSubnetMapping s
newLbSubnetMapping _subnetId =
    LbSubnetMapping'
        { _allocationId = TF.Nil
        , _subnetId = _subnetId
        }

instance P.Hashable  (LbSubnetMapping s)
instance TF.IsValue  (LbSubnetMapping s)
instance TF.IsObject (LbSubnetMapping s) where
    toObject LbSubnetMapping'{..} = P.catMaybes
        [ TF.assign "allocation_id" <$> TF.attribute _allocationId
        , TF.assign "subnet_id" <$> TF.attribute _subnetId
        ]

instance TF.IsValid (LbSubnetMapping s) where
    validator = P.mempty

instance P.HasAllocationId (LbSubnetMapping s) (TF.Attr s P.Text) where
    allocationId =
        P.lens (_allocationId :: LbSubnetMapping s -> TF.Attr s P.Text)
               (\s a -> s { _allocationId = a } :: LbSubnetMapping s)

instance P.HasSubnetId (LbSubnetMapping s) (TF.Attr s P.Text) where
    subnetId =
        P.lens (_subnetId :: LbSubnetMapping s -> TF.Attr s P.Text)
               (\s a -> s { _subnetId = a } :: LbSubnetMapping s)

-- | @ses_event_destination_kinesis_destination@ nested settings.
data SesEventDestinationKinesisDestination s = SesEventDestinationKinesisDestination'
    { _roleArn   :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Required)
    --
    , _streamArn :: TF.Attr s P.Text
    -- ^ @stream_arn@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSesEventDestinationKinesisDestination
    :: TF.Attr s P.Text -- ^ @role_arn@ - 'P.roleArn'
    -> TF.Attr s P.Text -- ^ @stream_arn@ - 'P.streamArn'
    -> SesEventDestinationKinesisDestination s
newSesEventDestinationKinesisDestination _roleArn _streamArn =
    SesEventDestinationKinesisDestination'
        { _roleArn = _roleArn
        , _streamArn = _streamArn
        }

instance P.Hashable  (SesEventDestinationKinesisDestination s)
instance TF.IsValue  (SesEventDestinationKinesisDestination s)
instance TF.IsObject (SesEventDestinationKinesisDestination s) where
    toObject SesEventDestinationKinesisDestination'{..} = P.catMaybes
        [ TF.assign "role_arn" <$> TF.attribute _roleArn
        , TF.assign "stream_arn" <$> TF.attribute _streamArn
        ]

instance TF.IsValid (SesEventDestinationKinesisDestination s) where
    validator = P.mempty

instance P.HasRoleArn (SesEventDestinationKinesisDestination s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: SesEventDestinationKinesisDestination s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: SesEventDestinationKinesisDestination s)

instance P.HasStreamArn (SesEventDestinationKinesisDestination s) (TF.Attr s P.Text) where
    streamArn =
        P.lens (_streamArn :: SesEventDestinationKinesisDestination s -> TF.Attr s P.Text)
               (\s a -> s { _streamArn = a } :: SesEventDestinationKinesisDestination s)

-- | @ses_receipt_rule_stop_action@ nested settings.
data SesReceiptRuleStopAction s = SesReceiptRuleStopAction'
    { _position :: TF.Attr s P.Integer
    -- ^ @position@ - (Required)
    --
    , _scope    :: TF.Attr s P.Text
    -- ^ @scope@ - (Required)
    --
    , _topicArn :: TF.Attr s P.Text
    -- ^ @topic_arn@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSesReceiptRuleStopAction
    :: TF.Attr s P.Integer -- ^ @position@ - 'P.position'
    -> TF.Attr s P.Text -- ^ @scope@ - 'P.scope'
    -> SesReceiptRuleStopAction s
newSesReceiptRuleStopAction _position _scope =
    SesReceiptRuleStopAction'
        { _position = _position
        , _scope = _scope
        , _topicArn = TF.Nil
        }

instance P.Hashable  (SesReceiptRuleStopAction s)
instance TF.IsValue  (SesReceiptRuleStopAction s)
instance TF.IsObject (SesReceiptRuleStopAction s) where
    toObject SesReceiptRuleStopAction'{..} = P.catMaybes
        [ TF.assign "position" <$> TF.attribute _position
        , TF.assign "scope" <$> TF.attribute _scope
        , TF.assign "topic_arn" <$> TF.attribute _topicArn
        ]

instance TF.IsValid (SesReceiptRuleStopAction s) where
    validator = P.mempty

instance P.HasPosition (SesReceiptRuleStopAction s) (TF.Attr s P.Integer) where
    position =
        P.lens (_position :: SesReceiptRuleStopAction s -> TF.Attr s P.Integer)
               (\s a -> s { _position = a } :: SesReceiptRuleStopAction s)

instance P.HasScope (SesReceiptRuleStopAction s) (TF.Attr s P.Text) where
    scope =
        P.lens (_scope :: SesReceiptRuleStopAction s -> TF.Attr s P.Text)
               (\s a -> s { _scope = a } :: SesReceiptRuleStopAction s)

instance P.HasTopicArn (SesReceiptRuleStopAction s) (TF.Attr s P.Text) where
    topicArn =
        P.lens (_topicArn :: SesReceiptRuleStopAction s -> TF.Attr s P.Text)
               (\s a -> s { _topicArn = a } :: SesReceiptRuleStopAction s)

-- | @statement_condition@ nested settings.
data StatementCondition s = StatementCondition'
    { _test     :: TF.Attr s P.Text
    -- ^ @test@ - (Required)
    --
    , _values   :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    , _variable :: TF.Attr s P.Text
    -- ^ @variable@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newStatementCondition
    :: TF.Attr s P.Text -- ^ @test@ - 'P.test'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> TF.Attr s P.Text -- ^ @variable@ - 'P.variable'
    -> StatementCondition s
newStatementCondition _test _values _variable =
    StatementCondition'
        { _test = _test
        , _values = _values
        , _variable = _variable
        }

instance P.Hashable  (StatementCondition s)
instance TF.IsValue  (StatementCondition s)
instance TF.IsObject (StatementCondition s) where
    toObject StatementCondition'{..} = P.catMaybes
        [ TF.assign "test" <$> TF.attribute _test
        , TF.assign "values" <$> TF.attribute _values
        , TF.assign "variable" <$> TF.attribute _variable
        ]

instance TF.IsValid (StatementCondition s) where
    validator = P.mempty

instance P.HasTest (StatementCondition s) (TF.Attr s P.Text) where
    test =
        P.lens (_test :: StatementCondition s -> TF.Attr s P.Text)
               (\s a -> s { _test = a } :: StatementCondition s)

instance P.HasValues (StatementCondition s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: StatementCondition s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: StatementCondition s)

instance P.HasVariable (StatementCondition s) (TF.Attr s P.Text) where
    variable =
        P.lens (_variable :: StatementCondition s -> TF.Attr s P.Text)
               (\s a -> s { _variable = a } :: StatementCondition s)

-- | @ebs_snapshot_ids_filter@ nested settings.
data EbsSnapshotIdsFilter s = EbsSnapshotIdsFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newEbsSnapshotIdsFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> EbsSnapshotIdsFilter s
newEbsSnapshotIdsFilter _name _values =
    EbsSnapshotIdsFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (EbsSnapshotIdsFilter s)
instance TF.IsValue  (EbsSnapshotIdsFilter s)
instance TF.IsObject (EbsSnapshotIdsFilter s) where
    toObject EbsSnapshotIdsFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (EbsSnapshotIdsFilter s) where
    validator = P.mempty

instance P.HasName (EbsSnapshotIdsFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: EbsSnapshotIdsFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: EbsSnapshotIdsFilter s)

instance P.HasValues (EbsSnapshotIdsFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: EbsSnapshotIdsFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: EbsSnapshotIdsFilter s)

-- | @cloudwatch_event_target_ecs_target@ nested settings.
data CloudwatchEventTargetEcsTarget s = CloudwatchEventTargetEcsTarget'
    { _taskCount         :: TF.Attr s P.Integer
    -- ^ @task_count@ - (Optional)
    --
    , _taskDefinitionArn :: TF.Attr s P.Text
    -- ^ @task_definition_arn@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCloudwatchEventTargetEcsTarget
    :: TF.Attr s P.Text -- ^ @task_definition_arn@ - 'P.taskDefinitionArn'
    -> CloudwatchEventTargetEcsTarget s
newCloudwatchEventTargetEcsTarget _taskDefinitionArn =
    CloudwatchEventTargetEcsTarget'
        { _taskCount = TF.Nil
        , _taskDefinitionArn = _taskDefinitionArn
        }

instance P.Hashable  (CloudwatchEventTargetEcsTarget s)
instance TF.IsValue  (CloudwatchEventTargetEcsTarget s)
instance TF.IsObject (CloudwatchEventTargetEcsTarget s) where
    toObject CloudwatchEventTargetEcsTarget'{..} = P.catMaybes
        [ TF.assign "task_count" <$> TF.attribute _taskCount
        , TF.assign "task_definition_arn" <$> TF.attribute _taskDefinitionArn
        ]

instance TF.IsValid (CloudwatchEventTargetEcsTarget s) where
    validator = P.mempty

instance P.HasTaskCount (CloudwatchEventTargetEcsTarget s) (TF.Attr s P.Integer) where
    taskCount =
        P.lens (_taskCount :: CloudwatchEventTargetEcsTarget s -> TF.Attr s P.Integer)
               (\s a -> s { _taskCount = a } :: CloudwatchEventTargetEcsTarget s)

instance P.HasTaskDefinitionArn (CloudwatchEventTargetEcsTarget s) (TF.Attr s P.Text) where
    taskDefinitionArn =
        P.lens (_taskDefinitionArn :: CloudwatchEventTargetEcsTarget s -> TF.Attr s P.Text)
               (\s a -> s { _taskDefinitionArn = a } :: CloudwatchEventTargetEcsTarget s)

-- | @source_source_detail@ nested settings.
data SourceSourceDetail s = SourceSourceDetail'
    { _eventSource               :: TF.Attr s P.Text
    -- ^ @event_source@ - (Optional)
    --
    , _maximumExecutionFrequency :: TF.Attr s P.Text
    -- ^ @maximum_execution_frequency@ - (Optional)
    --
    , _messageType               :: TF.Attr s P.Text
    -- ^ @message_type@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSourceSourceDetail
    :: SourceSourceDetail s
newSourceSourceDetail =
    SourceSourceDetail'
        { _eventSource = TF.value "aws.config"
        , _maximumExecutionFrequency = TF.Nil
        , _messageType = TF.Nil
        }

instance P.Hashable  (SourceSourceDetail s)
instance TF.IsValue  (SourceSourceDetail s)
instance TF.IsObject (SourceSourceDetail s) where
    toObject SourceSourceDetail'{..} = P.catMaybes
        [ TF.assign "event_source" <$> TF.attribute _eventSource
        , TF.assign "maximum_execution_frequency" <$> TF.attribute _maximumExecutionFrequency
        , TF.assign "message_type" <$> TF.attribute _messageType
        ]

instance TF.IsValid (SourceSourceDetail s) where
    validator = P.mempty

instance P.HasEventSource (SourceSourceDetail s) (TF.Attr s P.Text) where
    eventSource =
        P.lens (_eventSource :: SourceSourceDetail s -> TF.Attr s P.Text)
               (\s a -> s { _eventSource = a } :: SourceSourceDetail s)

instance P.HasMaximumExecutionFrequency (SourceSourceDetail s) (TF.Attr s P.Text) where
    maximumExecutionFrequency =
        P.lens (_maximumExecutionFrequency :: SourceSourceDetail s -> TF.Attr s P.Text)
               (\s a -> s { _maximumExecutionFrequency = a } :: SourceSourceDetail s)

instance P.HasMessageType (SourceSourceDetail s) (TF.Attr s P.Text) where
    messageType =
        P.lens (_messageType :: SourceSourceDetail s -> TF.Attr s P.Text)
               (\s a -> s { _messageType = a } :: SourceSourceDetail s)

-- | @ssm_association_output_location@ nested settings.
data SsmAssociationOutputLocation s = SsmAssociationOutputLocation'
    { _s3BucketName :: TF.Attr s P.Text
    -- ^ @s3_bucket_name@ - (Required)
    --
    , _s3KeyPrefix  :: TF.Attr s P.Text
    -- ^ @s3_key_prefix@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSsmAssociationOutputLocation
    :: TF.Attr s P.Text -- ^ @s3_bucket_name@ - 'P.s3BucketName'
    -> SsmAssociationOutputLocation s
newSsmAssociationOutputLocation _s3BucketName =
    SsmAssociationOutputLocation'
        { _s3BucketName = _s3BucketName
        , _s3KeyPrefix = TF.Nil
        }

instance P.Hashable  (SsmAssociationOutputLocation s)
instance TF.IsValue  (SsmAssociationOutputLocation s)
instance TF.IsObject (SsmAssociationOutputLocation s) where
    toObject SsmAssociationOutputLocation'{..} = P.catMaybes
        [ TF.assign "s3_bucket_name" <$> TF.attribute _s3BucketName
        , TF.assign "s3_key_prefix" <$> TF.attribute _s3KeyPrefix
        ]

instance TF.IsValid (SsmAssociationOutputLocation s) where
    validator = P.mempty

instance P.HasS3BucketName (SsmAssociationOutputLocation s) (TF.Attr s P.Text) where
    s3BucketName =
        P.lens (_s3BucketName :: SsmAssociationOutputLocation s -> TF.Attr s P.Text)
               (\s a -> s { _s3BucketName = a } :: SsmAssociationOutputLocation s)

instance P.HasS3KeyPrefix (SsmAssociationOutputLocation s) (TF.Attr s P.Text) where
    s3KeyPrefix =
        P.lens (_s3KeyPrefix :: SsmAssociationOutputLocation s -> TF.Attr s P.Text)
               (\s a -> s { _s3KeyPrefix = a } :: SsmAssociationOutputLocation s)

-- | @service_discovery_service_health_check_custom_config@ nested settings.
data ServiceDiscoveryServiceHealthCheckCustomConfig s = ServiceDiscoveryServiceHealthCheckCustomConfig'
    { _failureThreshold :: TF.Attr s P.Integer
    -- ^ @failure_threshold@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newServiceDiscoveryServiceHealthCheckCustomConfig
    :: ServiceDiscoveryServiceHealthCheckCustomConfig s
newServiceDiscoveryServiceHealthCheckCustomConfig =
    ServiceDiscoveryServiceHealthCheckCustomConfig'
        { _failureThreshold = TF.Nil
        }

instance P.Hashable  (ServiceDiscoveryServiceHealthCheckCustomConfig s)
instance TF.IsValue  (ServiceDiscoveryServiceHealthCheckCustomConfig s)
instance TF.IsObject (ServiceDiscoveryServiceHealthCheckCustomConfig s) where
    toObject ServiceDiscoveryServiceHealthCheckCustomConfig'{..} = P.catMaybes
        [ TF.assign "failure_threshold" <$> TF.attribute _failureThreshold
        ]

instance TF.IsValid (ServiceDiscoveryServiceHealthCheckCustomConfig s) where
    validator = P.mempty

instance P.HasFailureThreshold (ServiceDiscoveryServiceHealthCheckCustomConfig s) (TF.Attr s P.Integer) where
    failureThreshold =
        P.lens (_failureThreshold :: ServiceDiscoveryServiceHealthCheckCustomConfig s -> TF.Attr s P.Integer)
               (\s a -> s { _failureThreshold = a } :: ServiceDiscoveryServiceHealthCheckCustomConfig s)

-- | @default_cache_behavior_forwarded_values@ nested settings.
data DefaultCacheBehaviorForwardedValues s = DefaultCacheBehaviorForwardedValues'
    { _cookies              :: TF.Attr s (ForwardedValuesCookies s)
    -- ^ @cookies@ - (Required)
    --
    , _headers              :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @headers@ - (Optional)
    --
    , _queryString          :: TF.Attr s P.Bool
    -- ^ @query_string@ - (Required)
    --
    , _queryStringCacheKeys :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @query_string_cache_keys@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDefaultCacheBehaviorForwardedValues
    :: TF.Attr s (ForwardedValuesCookies s) -- ^ @cookies@ - 'P.cookies'
    -> TF.Attr s P.Bool -- ^ @query_string@ - 'P.queryString'
    -> DefaultCacheBehaviorForwardedValues s
newDefaultCacheBehaviorForwardedValues _cookies _queryString =
    DefaultCacheBehaviorForwardedValues'
        { _cookies = _cookies
        , _headers = TF.Nil
        , _queryString = _queryString
        , _queryStringCacheKeys = TF.Nil
        }

instance P.Hashable  (DefaultCacheBehaviorForwardedValues s)
instance TF.IsValue  (DefaultCacheBehaviorForwardedValues s)
instance TF.IsObject (DefaultCacheBehaviorForwardedValues s) where
    toObject DefaultCacheBehaviorForwardedValues'{..} = P.catMaybes
        [ TF.assign "cookies" <$> TF.attribute _cookies
        , TF.assign "headers" <$> TF.attribute _headers
        , TF.assign "query_string" <$> TF.attribute _queryString
        , TF.assign "query_string_cache_keys" <$> TF.attribute _queryStringCacheKeys
        ]

instance TF.IsValid (DefaultCacheBehaviorForwardedValues s) where
    validator = P.mempty
           P.<> TF.settingsValidator "_cookies"
                  (_cookies
                      :: DefaultCacheBehaviorForwardedValues s -> TF.Attr s (ForwardedValuesCookies s))
                  TF.validator

instance P.HasCookies (DefaultCacheBehaviorForwardedValues s) (TF.Attr s (ForwardedValuesCookies s)) where
    cookies =
        P.lens (_cookies :: DefaultCacheBehaviorForwardedValues s -> TF.Attr s (ForwardedValuesCookies s))
               (\s a -> s { _cookies = a } :: DefaultCacheBehaviorForwardedValues s)

instance P.HasHeaders (DefaultCacheBehaviorForwardedValues s) (TF.Attr s [TF.Attr s P.Text]) where
    headers =
        P.lens (_headers :: DefaultCacheBehaviorForwardedValues s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _headers = a } :: DefaultCacheBehaviorForwardedValues s)

instance P.HasQueryString (DefaultCacheBehaviorForwardedValues s) (TF.Attr s P.Bool) where
    queryString =
        P.lens (_queryString :: DefaultCacheBehaviorForwardedValues s -> TF.Attr s P.Bool)
               (\s a -> s { _queryString = a } :: DefaultCacheBehaviorForwardedValues s)

instance P.HasQueryStringCacheKeys (DefaultCacheBehaviorForwardedValues s) (TF.Attr s [TF.Attr s P.Text]) where
    queryStringCacheKeys =
        P.lens (_queryStringCacheKeys :: DefaultCacheBehaviorForwardedValues s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _queryStringCacheKeys = a } :: DefaultCacheBehaviorForwardedValues s)

-- | @vpcs_filter@ nested settings.
data VpcsFilter s = VpcsFilter'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newVpcsFilter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> VpcsFilter s
newVpcsFilter _name _values =
    VpcsFilter'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (VpcsFilter s)
instance TF.IsValue  (VpcsFilter s)
instance TF.IsObject (VpcsFilter s) where
    toObject VpcsFilter'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (VpcsFilter s) where
    validator = P.mempty

instance P.HasName (VpcsFilter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: VpcsFilter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: VpcsFilter s)

instance P.HasValues (VpcsFilter s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: VpcsFilter s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: VpcsFilter s)

-- | @ses_receipt_rule_s3_action@ nested settings.
data SesReceiptRuleS3Action s = SesReceiptRuleS3Action'
    { _bucketName      :: TF.Attr s P.Text
    -- ^ @bucket_name@ - (Required)
    --
    , _kmsKeyArn       :: TF.Attr s P.Text
    -- ^ @kms_key_arn@ - (Optional)
    --
    , _objectKeyPrefix :: TF.Attr s P.Text
    -- ^ @object_key_prefix@ - (Optional)
    --
    , _position        :: TF.Attr s P.Integer
    -- ^ @position@ - (Required)
    --
    , _topicArn        :: TF.Attr s P.Text
    -- ^ @topic_arn@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSesReceiptRuleS3Action
    :: TF.Attr s P.Text -- ^ @bucket_name@ - 'P.bucketName'
    -> TF.Attr s P.Integer -- ^ @position@ - 'P.position'
    -> SesReceiptRuleS3Action s
newSesReceiptRuleS3Action _bucketName _position =
    SesReceiptRuleS3Action'
        { _bucketName = _bucketName
        , _kmsKeyArn = TF.Nil
        , _objectKeyPrefix = TF.Nil
        , _position = _position
        , _topicArn = TF.Nil
        }

instance P.Hashable  (SesReceiptRuleS3Action s)
instance TF.IsValue  (SesReceiptRuleS3Action s)
instance TF.IsObject (SesReceiptRuleS3Action s) where
    toObject SesReceiptRuleS3Action'{..} = P.catMaybes
        [ TF.assign "bucket_name" <$> TF.attribute _bucketName
        , TF.assign "kms_key_arn" <$> TF.attribute _kmsKeyArn
        , TF.assign "object_key_prefix" <$> TF.attribute _objectKeyPrefix
        , TF.assign "position" <$> TF.attribute _position
        , TF.assign "topic_arn" <$> TF.attribute _topicArn
        ]

instance TF.IsValid (SesReceiptRuleS3Action s) where
    validator = P.mempty

instance P.HasBucketName (SesReceiptRuleS3Action s) (TF.Attr s P.Text) where
    bucketName =
        P.lens (_bucketName :: SesReceiptRuleS3Action s -> TF.Attr s P.Text)
               (\s a -> s { _bucketName = a } :: SesReceiptRuleS3Action s)

instance P.HasKmsKeyArn (SesReceiptRuleS3Action s) (TF.Attr s P.Text) where
    kmsKeyArn =
        P.lens (_kmsKeyArn :: SesReceiptRuleS3Action s -> TF.Attr s P.Text)
               (\s a -> s { _kmsKeyArn = a } :: SesReceiptRuleS3Action s)

instance P.HasObjectKeyPrefix (SesReceiptRuleS3Action s) (TF.Attr s P.Text) where
    objectKeyPrefix =
        P.lens (_objectKeyPrefix :: SesReceiptRuleS3Action s -> TF.Attr s P.Text)
               (\s a -> s { _objectKeyPrefix = a } :: SesReceiptRuleS3Action s)

instance P.HasPosition (SesReceiptRuleS3Action s) (TF.Attr s P.Integer) where
    position =
        P.lens (_position :: SesReceiptRuleS3Action s -> TF.Attr s P.Integer)
               (\s a -> s { _position = a } :: SesReceiptRuleS3Action s)

instance P.HasTopicArn (SesReceiptRuleS3Action s) (TF.Attr s P.Text) where
    topicArn =
        P.lens (_topicArn :: SesReceiptRuleS3Action s -> TF.Attr s P.Text)
               (\s a -> s { _topicArn = a } :: SesReceiptRuleS3Action s)

-- | @instance_credit_specification@ nested settings.
data InstanceCreditSpecification s = InstanceCreditSpecification'
    { _cpuCredits :: TF.Attr s P.Text
    -- ^ @cpu_credits@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newInstanceCreditSpecification
    :: InstanceCreditSpecification s
newInstanceCreditSpecification =
    InstanceCreditSpecification'
        { _cpuCredits = TF.value "standard"
        }

instance P.Hashable  (InstanceCreditSpecification s)
instance TF.IsValue  (InstanceCreditSpecification s)
instance TF.IsObject (InstanceCreditSpecification s) where
    toObject InstanceCreditSpecification'{..} = P.catMaybes
        [ TF.assign "cpu_credits" <$> TF.attribute _cpuCredits
        ]

instance TF.IsValid (InstanceCreditSpecification s) where
    validator = P.mempty

instance P.HasCpuCredits (InstanceCreditSpecification s) (TF.Attr s P.Text) where
    cpuCredits =
        P.lens (_cpuCredits :: InstanceCreditSpecification s -> TF.Attr s P.Text)
               (\s a -> s { _cpuCredits = a } :: InstanceCreditSpecification s)

instance s ~ s' => P.HasComputedCpuCredits (TF.Ref s' (InstanceCreditSpecification s)) (TF.Attr s P.Text) where
    computedCpuCredits x = TF.compute (TF.refKey x) "cpu_credits"

-- | @neptune_parameter_group_parameter@ nested settings.
data NeptuneParameterGroupParameter s = NeptuneParameterGroupParameter'
    { _applyMethod :: TF.Attr s P.Text
    -- ^ @apply_method@ - (Optional)
    --
    , _name        :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _value       :: TF.Attr s P.Text
    -- ^ @value@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newNeptuneParameterGroupParameter
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @value@ - 'P.value'
    -> NeptuneParameterGroupParameter s
newNeptuneParameterGroupParameter _name _value =
    NeptuneParameterGroupParameter'
        { _applyMethod = TF.value "pending-reboot"
        , _name = _name
        , _value = _value
        }

instance P.Hashable  (NeptuneParameterGroupParameter s)
instance TF.IsValue  (NeptuneParameterGroupParameter s)
instance TF.IsObject (NeptuneParameterGroupParameter s) where
    toObject NeptuneParameterGroupParameter'{..} = P.catMaybes
        [ TF.assign "apply_method" <$> TF.attribute _applyMethod
        , TF.assign "name" <$> TF.attribute _name
        , TF.assign "value" <$> TF.attribute _value
        ]

instance TF.IsValid (NeptuneParameterGroupParameter s) where
    validator = P.mempty

instance P.HasApplyMethod (NeptuneParameterGroupParameter s) (TF.Attr s P.Text) where
    applyMethod =
        P.lens (_applyMethod :: NeptuneParameterGroupParameter s -> TF.Attr s P.Text)
               (\s a -> s { _applyMethod = a } :: NeptuneParameterGroupParameter s)

instance P.HasName (NeptuneParameterGroupParameter s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: NeptuneParameterGroupParameter s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: NeptuneParameterGroupParameter s)

instance P.HasValue (NeptuneParameterGroupParameter s) (TF.Attr s P.Text) where
    value =
        P.lens (_value :: NeptuneParameterGroupParameter s -> TF.Attr s P.Text)
               (\s a -> s { _value = a } :: NeptuneParameterGroupParameter s)

-- | @ssm_maintenance_window_task_task_parameters@ nested settings.
data SsmMaintenanceWindowTaskTaskParameters s = SsmMaintenanceWindowTaskTaskParameters'
    { _name   :: TF.Attr s P.Text
    -- ^ @name@ - (Required, Forces New)
    --
    , _values :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @values@ - (Required, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSsmMaintenanceWindowTaskTaskParameters
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s [TF.Attr s P.Text] -- ^ @values@ - 'P.values'
    -> SsmMaintenanceWindowTaskTaskParameters s
newSsmMaintenanceWindowTaskTaskParameters _name _values =
    SsmMaintenanceWindowTaskTaskParameters'
        { _name = _name
        , _values = _values
        }

instance P.Hashable  (SsmMaintenanceWindowTaskTaskParameters s)
instance TF.IsValue  (SsmMaintenanceWindowTaskTaskParameters s)
instance TF.IsObject (SsmMaintenanceWindowTaskTaskParameters s) where
    toObject SsmMaintenanceWindowTaskTaskParameters'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "values" <$> TF.attribute _values
        ]

instance TF.IsValid (SsmMaintenanceWindowTaskTaskParameters s) where
    validator = P.mempty

instance P.HasName (SsmMaintenanceWindowTaskTaskParameters s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: SsmMaintenanceWindowTaskTaskParameters s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: SsmMaintenanceWindowTaskTaskParameters s)

instance P.HasValues (SsmMaintenanceWindowTaskTaskParameters s) (TF.Attr s [TF.Attr s P.Text]) where
    values =
        P.lens (_values :: SsmMaintenanceWindowTaskTaskParameters s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _values = a } :: SsmMaintenanceWindowTaskTaskParameters s)

-- | @elasticsearch_domain_vpc_options@ nested settings.
data ElasticsearchDomainVpcOptions s = ElasticsearchDomainVpcOptions'
    { _securityGroupIds :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @security_group_ids@ - (Optional)
    --
    , _subnetIds        :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @subnet_ids@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newElasticsearchDomainVpcOptions
    :: ElasticsearchDomainVpcOptions s
newElasticsearchDomainVpcOptions =
    ElasticsearchDomainVpcOptions'
        { _securityGroupIds = TF.Nil
        , _subnetIds = TF.Nil
        }

instance P.Hashable  (ElasticsearchDomainVpcOptions s)
instance TF.IsValue  (ElasticsearchDomainVpcOptions s)
instance TF.IsObject (ElasticsearchDomainVpcOptions s) where
    toObject ElasticsearchDomainVpcOptions'{..} = P.catMaybes
        [ TF.assign "security_group_ids" <$> TF.attribute _securityGroupIds
        , TF.assign "subnet_ids" <$> TF.attribute _subnetIds
        ]

instance TF.IsValid (ElasticsearchDomainVpcOptions s) where
    validator = P.mempty

instance P.HasSecurityGroupIds (ElasticsearchDomainVpcOptions s) (TF.Attr s [TF.Attr s P.Text]) where
    securityGroupIds =
        P.lens (_securityGroupIds :: ElasticsearchDomainVpcOptions s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _securityGroupIds = a } :: ElasticsearchDomainVpcOptions s)

instance P.HasSubnetIds (ElasticsearchDomainVpcOptions s) (TF.Attr s [TF.Attr s P.Text]) where
    subnetIds =
        P.lens (_subnetIds :: ElasticsearchDomainVpcOptions s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _subnetIds = a } :: ElasticsearchDomainVpcOptions s)

instance s ~ s' => P.HasComputedAvailabilityZones (TF.Ref s' (ElasticsearchDomainVpcOptions s)) (TF.Attr s [TF.Attr s P.Text]) where
    computedAvailabilityZones x = TF.compute (TF.refKey x) "availability_zones"

instance s ~ s' => P.HasComputedVpcId (TF.Ref s' (ElasticsearchDomainVpcOptions s)) (TF.Attr s P.Text) where
    computedVpcId x = TF.compute (TF.refKey x) "vpc_id"

-- | @dynamodb_table_local_secondary_index@ nested settings.
data DynamodbTableLocalSecondaryIndex s = DynamodbTableLocalSecondaryIndex'
    { _name             :: TF.Attr s P.Text
    -- ^ @name@ - (Required)
    --
    , _nonKeyAttributes :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @non_key_attributes@ - (Optional)
    --
    , _projectionType   :: TF.Attr s P.Text
    -- ^ @projection_type@ - (Required)
    --
    , _rangeKey         :: TF.Attr s P.Text
    -- ^ @range_key@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newDynamodbTableLocalSecondaryIndex
    :: TF.Attr s P.Text -- ^ @name@ - 'P.name'
    -> TF.Attr s P.Text -- ^ @projection_type@ - 'P.projectionType'
    -> TF.Attr s P.Text -- ^ @range_key@ - 'P.rangeKey'
    -> DynamodbTableLocalSecondaryIndex s
newDynamodbTableLocalSecondaryIndex _name _projectionType _rangeKey =
    DynamodbTableLocalSecondaryIndex'
        { _name = _name
        , _nonKeyAttributes = TF.Nil
        , _projectionType = _projectionType
        , _rangeKey = _rangeKey
        }

instance P.Hashable  (DynamodbTableLocalSecondaryIndex s)
instance TF.IsValue  (DynamodbTableLocalSecondaryIndex s)
instance TF.IsObject (DynamodbTableLocalSecondaryIndex s) where
    toObject DynamodbTableLocalSecondaryIndex'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "non_key_attributes" <$> TF.attribute _nonKeyAttributes
        , TF.assign "projection_type" <$> TF.attribute _projectionType
        , TF.assign "range_key" <$> TF.attribute _rangeKey
        ]

instance TF.IsValid (DynamodbTableLocalSecondaryIndex s) where
    validator = P.mempty

instance P.HasName (DynamodbTableLocalSecondaryIndex s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: DynamodbTableLocalSecondaryIndex s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: DynamodbTableLocalSecondaryIndex s)

instance P.HasNonKeyAttributes (DynamodbTableLocalSecondaryIndex s) (TF.Attr s [TF.Attr s P.Text]) where
    nonKeyAttributes =
        P.lens (_nonKeyAttributes :: DynamodbTableLocalSecondaryIndex s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _nonKeyAttributes = a } :: DynamodbTableLocalSecondaryIndex s)

instance P.HasProjectionType (DynamodbTableLocalSecondaryIndex s) (TF.Attr s P.Text) where
    projectionType =
        P.lens (_projectionType :: DynamodbTableLocalSecondaryIndex s -> TF.Attr s P.Text)
               (\s a -> s { _projectionType = a } :: DynamodbTableLocalSecondaryIndex s)

instance P.HasRangeKey (DynamodbTableLocalSecondaryIndex s) (TF.Attr s P.Text) where
    rangeKey =
        P.lens (_rangeKey :: DynamodbTableLocalSecondaryIndex s -> TF.Attr s P.Text)
               (\s a -> s { _rangeKey = a } :: DynamodbTableLocalSecondaryIndex s)

instance s ~ s' => P.HasComputedName (TF.Ref s' (DynamodbTableLocalSecondaryIndex s)) (TF.Attr s P.Text) where
    computedName x = TF.compute (TF.refKey x) "name"

instance s ~ s' => P.HasComputedNonKeyAttributes (TF.Ref s' (DynamodbTableLocalSecondaryIndex s)) (TF.Attr s [TF.Attr s P.Text]) where
    computedNonKeyAttributes x = TF.compute (TF.refKey x) "non_key_attributes"

instance s ~ s' => P.HasComputedProjectionType (TF.Ref s' (DynamodbTableLocalSecondaryIndex s)) (TF.Attr s P.Text) where
    computedProjectionType x = TF.compute (TF.refKey x) "projection_type"

instance s ~ s' => P.HasComputedRangeKey (TF.Ref s' (DynamodbTableLocalSecondaryIndex s)) (TF.Attr s P.Text) where
    computedRangeKey x = TF.compute (TF.refKey x) "range_key"

-- | @load_balancer_info_elb_info@ nested settings.
data LoadBalancerInfoElbInfo s = LoadBalancerInfoElbInfo'
    { _name :: TF.Attr s P.Text
    -- ^ @name@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLoadBalancerInfoElbInfo
    :: LoadBalancerInfoElbInfo s
newLoadBalancerInfoElbInfo =
    LoadBalancerInfoElbInfo'
        { _name = TF.Nil
        }

instance P.Hashable  (LoadBalancerInfoElbInfo s)
instance TF.IsValue  (LoadBalancerInfoElbInfo s)
instance TF.IsObject (LoadBalancerInfoElbInfo s) where
    toObject LoadBalancerInfoElbInfo'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        ]

instance TF.IsValid (LoadBalancerInfoElbInfo s) where
    validator = P.mempty

instance P.HasName (LoadBalancerInfoElbInfo s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: LoadBalancerInfoElbInfo s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: LoadBalancerInfoElbInfo s)

-- | @glue_crawler_s3_target@ nested settings.
data GlueCrawlerS3Target s = GlueCrawlerS3Target'
    { _exclusions :: TF.Attr s [TF.Attr s P.Text]
    -- ^ @exclusions@ - (Optional)
    --
    , _path       :: TF.Attr s P.Text
    -- ^ @path@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newGlueCrawlerS3Target
    :: TF.Attr s P.Text -- ^ @path@ - 'P.path'
    -> GlueCrawlerS3Target s
newGlueCrawlerS3Target _path =
    GlueCrawlerS3Target'
        { _exclusions = TF.Nil
        , _path = _path
        }

instance P.Hashable  (GlueCrawlerS3Target s)
instance TF.IsValue  (GlueCrawlerS3Target s)
instance TF.IsObject (GlueCrawlerS3Target s) where
    toObject GlueCrawlerS3Target'{..} = P.catMaybes
        [ TF.assign "exclusions" <$> TF.attribute _exclusions
        , TF.assign "path" <$> TF.attribute _path
        ]

instance TF.IsValid (GlueCrawlerS3Target s) where
    validator = P.mempty

instance P.HasExclusions (GlueCrawlerS3Target s) (TF.Attr s [TF.Attr s P.Text]) where
    exclusions =
        P.lens (_exclusions :: GlueCrawlerS3Target s -> TF.Attr s [TF.Attr s P.Text])
               (\s a -> s { _exclusions = a } :: GlueCrawlerS3Target s)

instance P.HasPath (GlueCrawlerS3Target s) (TF.Attr s P.Text) where
    path =
        P.lens (_path :: GlueCrawlerS3Target s -> TF.Attr s P.Text)
               (\s a -> s { _path = a } :: GlueCrawlerS3Target s)

-- | @iot_topic_rule_cloudwatch_metric@ nested settings.
data IotTopicRuleCloudwatchMetric s = IotTopicRuleCloudwatchMetric'
    { _metricName      :: TF.Attr s P.Text
    -- ^ @metric_name@ - (Required)
    --
    , _metricNamespace :: TF.Attr s P.Text
    -- ^ @metric_namespace@ - (Required)
    --
    , _metricTimestamp :: TF.Attr s P.Text
    -- ^ @metric_timestamp@ - (Optional)
    --
    , _metricUnit      :: TF.Attr s P.Text
    -- ^ @metric_unit@ - (Required)
    --
    , _metricValue     :: TF.Attr s P.Text
    -- ^ @metric_value@ - (Required)
    --
    , _roleArn         :: TF.Attr s P.Text
    -- ^ @role_arn@ - (Required)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newIotTopicRuleCloudwatchMetric
    :: TF.Attr s P.Text -- ^ @metric_name@ - 'P.metricName'
    -> TF.Attr s P.Text -- ^ @metric_namespace@ - 'P.metricNamespace'
    -> TF.Attr s P.Text -- ^ @metric_unit@ - 'P.metricUnit'
    -> TF.Attr s P.Text -- ^ @metric_value@ - 'P.metricValue'
    -> TF.Attr s P.Text -- ^ @role_arn@ - 'P.roleArn'
    -> IotTopicRuleCloudwatchMetric s
newIotTopicRuleCloudwatchMetric _metricName _metricNamespace _metricUnit _metricValue _roleArn =
    IotTopicRuleCloudwatchMetric'
        { _metricName = _metricName
        , _metricNamespace = _metricNamespace
        , _metricTimestamp = TF.Nil
        , _metricUnit = _metricUnit
        , _metricValue = _metricValue
        , _roleArn = _roleArn
        }

instance P.Hashable  (IotTopicRuleCloudwatchMetric s)
instance TF.IsValue  (IotTopicRuleCloudwatchMetric s)
instance TF.IsObject (IotTopicRuleCloudwatchMetric s) where
    toObject IotTopicRuleCloudwatchMetric'{..} = P.catMaybes
        [ TF.assign "metric_name" <$> TF.attribute _metricName
        , TF.assign "metric_namespace" <$> TF.attribute _metricNamespace
        , TF.assign "metric_timestamp" <$> TF.attribute _metricTimestamp
        , TF.assign "metric_unit" <$> TF.attribute _metricUnit
        , TF.assign "metric_value" <$> TF.attribute _metricValue
        , TF.assign "role_arn" <$> TF.attribute _roleArn
        ]

instance TF.IsValid (IotTopicRuleCloudwatchMetric s) where
    validator = P.mempty

instance P.HasMetricName (IotTopicRuleCloudwatchMetric s) (TF.Attr s P.Text) where
    metricName =
        P.lens (_metricName :: IotTopicRuleCloudwatchMetric s -> TF.Attr s P.Text)
               (\s a -> s { _metricName = a } :: IotTopicRuleCloudwatchMetric s)

instance P.HasMetricNamespace (IotTopicRuleCloudwatchMetric s) (TF.Attr s P.Text) where
    metricNamespace =
        P.lens (_metricNamespace :: IotTopicRuleCloudwatchMetric s -> TF.Attr s P.Text)
               (\s a -> s { _metricNamespace = a } :: IotTopicRuleCloudwatchMetric s)

instance P.HasMetricTimestamp (IotTopicRuleCloudwatchMetric s) (TF.Attr s P.Text) where
    metricTimestamp =
        P.lens (_metricTimestamp :: IotTopicRuleCloudwatchMetric s -> TF.Attr s P.Text)
               (\s a -> s { _metricTimestamp = a } :: IotTopicRuleCloudwatchMetric s)

instance P.HasMetricUnit (IotTopicRuleCloudwatchMetric s) (TF.Attr s P.Text) where
    metricUnit =
        P.lens (_metricUnit :: IotTopicRuleCloudwatchMetric s -> TF.Attr s P.Text)
               (\s a -> s { _metricUnit = a } :: IotTopicRuleCloudwatchMetric s)

instance P.HasMetricValue (IotTopicRuleCloudwatchMetric s) (TF.Attr s P.Text) where
    metricValue =
        P.lens (_metricValue :: IotTopicRuleCloudwatchMetric s -> TF.Attr s P.Text)
               (\s a -> s { _metricValue = a } :: IotTopicRuleCloudwatchMetric s)

instance P.HasRoleArn (IotTopicRuleCloudwatchMetric s) (TF.Attr s P.Text) where
    roleArn =
        P.lens (_roleArn :: IotTopicRuleCloudwatchMetric s -> TF.Attr s P.Text)
               (\s a -> s { _roleArn = a } :: IotTopicRuleCloudwatchMetric s)

-- | @launch_template_monitoring@ nested settings.
data LaunchTemplateMonitoring s = LaunchTemplateMonitoring'
    { _enabled :: TF.Attr s P.Bool
    -- ^ @enabled@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newLaunchTemplateMonitoring
    :: LaunchTemplateMonitoring s
newLaunchTemplateMonitoring =
    LaunchTemplateMonitoring'
        { _enabled = TF.Nil
        }

instance P.Hashable  (LaunchTemplateMonitoring s)
instance TF.IsValue  (LaunchTemplateMonitoring s)
instance TF.IsObject (LaunchTemplateMonitoring s) where
    toObject LaunchTemplateMonitoring'{..} = P.catMaybes
        [ TF.assign "enabled" <$> TF.attribute _enabled
        ]

instance TF.IsValid (LaunchTemplateMonitoring s) where
    validator = P.mempty

instance P.HasEnabled (LaunchTemplateMonitoring s) (TF.Attr s P.Bool) where
    enabled =
        P.lens (_enabled :: LaunchTemplateMonitoring s -> TF.Attr s P.Bool)
               (\s a -> s { _enabled = a } :: LaunchTemplateMonitoring s)

-- | @storage_descriptor_ser_de_info@ nested settings.
data StorageDescriptorSerDeInfo s = StorageDescriptorSerDeInfo'
    { _name                 :: TF.Attr s P.Text
    -- ^ @name@ - (Optional)
    --
    , _parameters           :: TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))
    -- ^ @parameters@ - (Optional)
    --
    , _serializationLibrary :: TF.Attr s P.Text
    -- ^ @serialization_library@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newStorageDescriptorSerDeInfo
    :: StorageDescriptorSerDeInfo s
newStorageDescriptorSerDeInfo =
    StorageDescriptorSerDeInfo'
        { _name = TF.Nil
        , _parameters = TF.Nil
        , _serializationLibrary = TF.Nil
        }

instance P.Hashable  (StorageDescriptorSerDeInfo s)
instance TF.IsValue  (StorageDescriptorSerDeInfo s)
instance TF.IsObject (StorageDescriptorSerDeInfo s) where
    toObject StorageDescriptorSerDeInfo'{..} = P.catMaybes
        [ TF.assign "name" <$> TF.attribute _name
        , TF.assign "parameters" <$> TF.attribute _parameters
        , TF.assign "serialization_library" <$> TF.attribute _serializationLibrary
        ]

instance TF.IsValid (StorageDescriptorSerDeInfo s) where
    validator = P.mempty

instance P.HasName (StorageDescriptorSerDeInfo s) (TF.Attr s P.Text) where
    name =
        P.lens (_name :: StorageDescriptorSerDeInfo s -> TF.Attr s P.Text)
               (\s a -> s { _name = a } :: StorageDescriptorSerDeInfo s)

instance P.HasParameters (StorageDescriptorSerDeInfo s) (TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text))) where
    parameters =
        P.lens (_parameters :: StorageDescriptorSerDeInfo s -> TF.Attr s (P.HashMap P.Text (TF.Attr s P.Text)))
               (\s a -> s { _parameters = a } :: StorageDescriptorSerDeInfo s)

instance P.HasSerializationLibrary (StorageDescriptorSerDeInfo s) (TF.Attr s P.Text) where
    serializationLibrary =
        P.lens (_serializationLibrary :: StorageDescriptorSerDeInfo s -> TF.Attr s P.Text)
               (\s a -> s { _serializationLibrary = a } :: StorageDescriptorSerDeInfo s)

-- | @schema_string_attribute_constraints@ nested settings.
data SchemaStringAttributeConstraints s = SchemaStringAttributeConstraints'
    { _maxLength :: TF.Attr s P.Text
    -- ^ @max_length@ - (Optional, Forces New)
    --
    , _minLength :: TF.Attr s P.Text
    -- ^ @min_length@ - (Optional, Forces New)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSchemaStringAttributeConstraints
    :: SchemaStringAttributeConstraints s
newSchemaStringAttributeConstraints =
    SchemaStringAttributeConstraints'
        { _maxLength = TF.Nil
        , _minLength = TF.Nil
        }

instance P.Hashable  (SchemaStringAttributeConstraints s)
instance TF.IsValue  (SchemaStringAttributeConstraints s)
instance TF.IsObject (SchemaStringAttributeConstraints s) where
    toObject SchemaStringAttributeConstraints'{..} = P.catMaybes
        [ TF.assign "max_length" <$> TF.attribute _maxLength
        , TF.assign "min_length" <$> TF.attribute _minLength
        ]

instance TF.IsValid (SchemaStringAttributeConstraints s) where
    validator = P.mempty

instance P.HasMaxLength (SchemaStringAttributeConstraints s) (TF.Attr s P.Text) where
    maxLength =
        P.lens (_maxLength :: SchemaStringAttributeConstraints s -> TF.Attr s P.Text)
               (\s a -> s { _maxLength = a } :: SchemaStringAttributeConstraints s)

instance P.HasMinLength (SchemaStringAttributeConstraints s) (TF.Attr s P.Text) where
    minLength =
        P.lens (_minLength :: SchemaStringAttributeConstraints s -> TF.Attr s P.Text)
               (\s a -> s { _minLength = a } :: SchemaStringAttributeConstraints s)

-- | @cognito_identity_pool_cognito_identity_providers@ nested settings.
data CognitoIdentityPoolCognitoIdentityProviders s = CognitoIdentityPoolCognitoIdentityProviders'
    { _clientId             :: TF.Attr s P.Text
    -- ^ @client_id@ - (Optional)
    --
    , _providerName         :: TF.Attr s P.Text
    -- ^ @provider_name@ - (Optional)
    --
    , _serverSideTokenCheck :: TF.Attr s P.Bool
    -- ^ @server_side_token_check@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newCognitoIdentityPoolCognitoIdentityProviders
    :: CognitoIdentityPoolCognitoIdentityProviders s
newCognitoIdentityPoolCognitoIdentityProviders =
    CognitoIdentityPoolCognitoIdentityProviders'
        { _clientId = TF.Nil
        , _providerName = TF.Nil
        , _serverSideTokenCheck = TF.value P.False
        }

instance P.Hashable  (CognitoIdentityPoolCognitoIdentityProviders s)
instance TF.IsValue  (CognitoIdentityPoolCognitoIdentityProviders s)
instance TF.IsObject (CognitoIdentityPoolCognitoIdentityProviders s) where
    toObject CognitoIdentityPoolCognitoIdentityProviders'{..} = P.catMaybes
        [ TF.assign "client_id" <$> TF.attribute _clientId
        , TF.assign "provider_name" <$> TF.attribute _providerName
        , TF.assign "server_side_token_check" <$> TF.attribute _serverSideTokenCheck
        ]

instance TF.IsValid (CognitoIdentityPoolCognitoIdentityProviders s) where
    validator = P.mempty

instance P.HasClientId (CognitoIdentityPoolCognitoIdentityProviders s) (TF.Attr s P.Text) where
    clientId =
        P.lens (_clientId :: CognitoIdentityPoolCognitoIdentityProviders s -> TF.Attr s P.Text)
               (\s a -> s { _clientId = a } :: CognitoIdentityPoolCognitoIdentityProviders s)

instance P.HasProviderName (CognitoIdentityPoolCognitoIdentityProviders s) (TF.Attr s P.Text) where
    providerName =
        P.lens (_providerName :: CognitoIdentityPoolCognitoIdentityProviders s -> TF.Attr s P.Text)
               (\s a -> s { _providerName = a } :: CognitoIdentityPoolCognitoIdentityProviders s)

instance P.HasServerSideTokenCheck (CognitoIdentityPoolCognitoIdentityProviders s) (TF.Attr s P.Bool) where
    serverSideTokenCheck =
        P.lens (_serverSideTokenCheck :: CognitoIdentityPoolCognitoIdentityProviders s -> TF.Attr s P.Bool)
               (\s a -> s { _serverSideTokenCheck = a } :: CognitoIdentityPoolCognitoIdentityProviders s)

-- | @spot_instance_request_ephemeral_block_device@ nested settings.
data SpotInstanceRequestEphemeralBlockDevice s = SpotInstanceRequestEphemeralBlockDevice'
    { _deviceName  :: TF.Attr s P.Text
    -- ^ @device_name@ - (Required)
    --
    , _noDevice    :: TF.Attr s P.Bool
    -- ^ @no_device@ - (Optional)
    --
    , _virtualName :: TF.Attr s P.Text
    -- ^ @virtual_name@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newSpotInstanceRequestEphemeralBlockDevice
    :: TF.Attr s P.Text -- ^ @device_name@ - 'P.deviceName'
    -> SpotInstanceRequestEphemeralBlockDevice s
newSpotInstanceRequestEphemeralBlockDevice _deviceName =
    SpotInstanceRequestEphemeralBlockDevice'
        { _deviceName = _deviceName
        , _noDevice = TF.Nil
        , _virtualName = TF.Nil
        }

instance P.Hashable  (SpotInstanceRequestEphemeralBlockDevice s)
instance TF.IsValue  (SpotInstanceRequestEphemeralBlockDevice s)
instance TF.IsObject (SpotInstanceRequestEphemeralBlockDevice s) where
    toObject SpotInstanceRequestEphemeralBlockDevice'{..} = P.catMaybes
        [ TF.assign "device_name" <$> TF.attribute _deviceName
        , TF.assign "no_device" <$> TF.attribute _noDevice
        , TF.assign "virtual_name" <$> TF.attribute _virtualName
        ]

instance TF.IsValid (SpotInstanceRequestEphemeralBlockDevice s) where
    validator = P.mempty

instance P.HasDeviceName (SpotInstanceRequestEphemeralBlockDevice s) (TF.Attr s P.Text) where
    deviceName =
        P.lens (_deviceName :: SpotInstanceRequestEphemeralBlockDevice s -> TF.Attr s P.Text)
               (\s a -> s { _deviceName = a } :: SpotInstanceRequestEphemeralBlockDevice s)

instance P.HasNoDevice (SpotInstanceRequestEphemeralBlockDevice s) (TF.Attr s P.Bool) where
    noDevice =
        P.lens (_noDevice :: SpotInstanceRequestEphemeralBlockDevice s -> TF.Attr s P.Bool)
               (\s a -> s { _noDevice = a } :: SpotInstanceRequestEphemeralBlockDevice s)

instance P.HasVirtualName (SpotInstanceRequestEphemeralBlockDevice s) (TF.Attr s P.Text) where
    virtualName =
        P.lens (_virtualName :: SpotInstanceRequestEphemeralBlockDevice s -> TF.Attr s P.Text)
               (\s a -> s { _virtualName = a } :: SpotInstanceRequestEphemeralBlockDevice s)

-- | @vpc_peering_connection_accepter_accepter@ nested settings.
data VpcPeeringConnectionAccepterAccepter s = VpcPeeringConnectionAccepterAccepter'
    { _allowClassicLinkToRemoteVpc :: TF.Attr s P.Bool
    -- ^ @allow_classic_link_to_remote_vpc@ - (Optional)
    --
    , _allowRemoteVpcDnsResolution :: TF.Attr s P.Bool
    -- ^ @allow_remote_vpc_dns_resolution@ - (Optional)
    --
    , _allowVpcToRemoteClassicLink :: TF.Attr s P.Bool
    -- ^ @allow_vpc_to_remote_classic_link@ - (Optional)
    --
    } deriving (P.Show, P.Eq, P.Generic)

newVpcPeeringConnectionAccepterAccepter
    :: VpcPeeringConnectionAccepterAccepter s
newVpcPeeringConnectionAccepterAccepter =
    VpcPeeringConnectionAccepterAccepter'
        { _allowClassicLinkToRemoteVpc = TF.value P.False
        , _allowRemoteVpcDnsResolution = TF.value P.False
        , _allowVpcToRemoteClassicLink = TF.value P.False
        }

instance P.Hashable  (VpcPeeringConnectionAccepterAccepter s)
instance TF.IsValue  (VpcPeeringConnectionAccepterAccepter s)
instance TF.IsObject (VpcPeeringConnectionAccepterAccepter s) where
    toObject VpcPeeringConnectionAccepterAccepter'{..} = P.catMaybes
        [ TF.assign "allow_classic_link_to_remote_vpc" <$> TF.attribute _allowClassicLinkToRemoteVpc
        , TF.assign "allow_remote_vpc_dns_resolution" <$> TF.attribute _allowRemoteVpcDnsResolution
        , TF.assign "allow_vpc_to_remote_classic_link" <$> TF.attribute _allowVpcToRemoteClassicLink
        ]

instance TF.IsValid (VpcPeeringConnectionAccepterAccepter s) where
    validator = P.mempty

instance P.HasAllowClassicLinkToRemoteVpc (VpcPeeringConnectionAccepterAccepter s) (TF.Attr s P.Bool) where
    allowClassicLinkToRemoteVpc =
        P.lens (_allowClassicLinkToRemoteVpc :: VpcPeeringConnectionAccepterAccepter s -> TF.Attr s P.Bool)
               (\s a -> s { _allowClassicLinkToRemoteVpc = a } :: VpcPeeringConnectionAccepterAccepter s)

instance P.HasAllowRemoteVpcDnsResolution (VpcPeeringConnectionAccepterAccepter s) (TF.Attr s P.Bool) where
    allowRemoteVpcDnsResolution =
        P.lens (_allowRemoteVpcDnsResolution :: VpcPeeringConnectionAccepterAccepter s -> TF.Attr s P.Bool)
               (\s a -> s { _allowRemoteVpcDnsResolution = a } :: VpcPeeringConnectionAccepterAccepter s)

instance P.HasAllowVpcToRemoteClassicLink (VpcPeeringConnectionAccepterAccepter s) (TF.Attr s P.Bool) where
    allowVpcToRemoteClassicLink =
        P.lens (_allowVpcToRemoteClassicLink :: VpcPeeringConnectionAccepterAccepter s -> TF.Attr s P.Bool)
               (\s a -> s { _allowVpcToRemoteClassicLink = a } :: VpcPeeringConnectionAccepterAccepter s)
